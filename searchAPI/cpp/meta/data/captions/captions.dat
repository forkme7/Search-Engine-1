good ok I have some questions I can ask while we are waiting for the system to start. Alright. I don't have mic either, coz we are waiting for the system to start. Okay, I have a question for you. So it has been my standard protocol for the last several years to print out handouts that are copies of my lecture slides for you I wanna know if I bring these paper handouts to you, how many of you will actually, just rise your hand, just give me a rough estimate how many of you will actually annotate them with a pen, if I bring these handouts? Maybe, maybe the better question is how many of you do not see yourself actually applying a pen to a piece of paper to take notes. rise your hand if you think you're just gonna do things via pdf.  Ok,  I will continue to print them out. I saw, I did see a few hands doing this. you guys didn't see any hands but I saw a few those. so it's ok to do this. we are not alright you are gonna put it into so there's one first last thing of teaching the first last thing of teaching is never never never try new technologies the first day of class. we are breaking rules around here. that looks like a that looks like a different input. that looks like maybe one of the HDMI that looks like a document camera or something. a hidden document camera center, laptop HDMI to the center and apply, do you have to apply it then? ok laptop HDMI go, and then should just work but it looks like, there is like I think it seems I am projecting. ok it's going oh no ok I am reconnecting. Don't touch anything. I am reconnecting. do we know each other? like middle school maybe? what's your last name? oh... ok so my thing is connected i believe I gotta work ok give me BGA so now it just disconnected ok you can connect. alright   Alright. Let's start. 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
Yes, we're working out kinks, but guess what? It is 190% better this semester than it was last semester in this room at this time. Umm, there are some hidden problems you don't even know about. For example, guess what color that ink is? Red. It is red ink. So we'll figure all this out. And we're not wireless so I cannot play frisbee with my laptop, that's the dream we'll be working toward that. Umm, and it's a whole new ecosystem for me so patience is good. Alright so any good parties start off with introductions. SoÂ I'm Cinda, I'm not doing this alone this semester. Well I never ever do it alone but this time I actually have a co-teacher, he's actually new to campus sort of, his name is Mattox Beckman. I'm going to introduce him right now, and it turns out that Mattox and I should have been friends decades ago because our time working on our PhD coincided almost exactly on this campus but we only knew of each other by reputation, we didn't actually know each other. He's the new lecturer in this department, and he's going to bring a lot of new energy and ideas. The next introductions I want to do are not for details but purely for magnitude. I want you to see the sheer magnitude of the course staff we have available to you. So I invited all of course staff to come introduce themselves at the start of the hour and about a fourth of them showed up. So, here's my challenge to you. Do better at class attendance than course staff did at coming to introduce themselves. This is fun when almost all the seats are full. Alright so anyway, I want them to tell you who they are very quickly, because I want you to hear the variety of places they come from and years that they are in school. So tell me your name, your year in school and your major. Hi, I'm Bol, I'm a first year grad student, I did my undergrad in civil but now I'm starting CS. Wow, that's exciting, nice to meet you too. I'm also meeting some of these people for the first time. Hi, I'm George, I'm a second year in CS. George, I knew you when you were this tall. Hi, I'm Laura, I'm a senior in CS. Hi, I'm Andrew, I'm a sophomore in CS. Hi, I'm Mosa, I'm a junior in computer engineering. That means this building is his home. We're visitors here. Some of the rest of us are visitors here. I'm Shi-shen, I'm a junior in CS. I'm Flora, I'm a junior in CS. How long have you been a computer scientist, Flora? A computer scientist, since high school but... A computer science major? A computer science major since last Thursday. And we're very happy about it. We got her!. Hi, I'm Adya, I'm a junior in CS. Hi, I'm Justin, I'm a junior in CE. Oh, another one. (laughter) I'm Chase, first year grad and CS. I'm Rohan and I'm a junior in CS. I'm Terry, I'm an english PhD and now just won't be teaching you. I'll be helping Beckman. He's actually going to read all your emails before I do. So, when you compose something to me, you're going to send it some place Terry sees first, so if you're mean to me, he's going to change all the wording. Because that's what he does. And you know, you can be as mean as - no way. That's wrong. Hi guys, I'm Asma, second year PhD in CS. I TA'd 125 last semester. I can see some of my students here so, really exciting! Hi guys, I'm Chaitanya, second year grad student in CS. Again, I TA'd with Asma, and I can see couple of people here. We get all the good ones, eventually! I'm Roy, I'm a first year grad in CS. Where you an undergrad here? Yes, okay. So, one thing we really like - did everybody get to introduce themselves? - one thing I really like is that our undergrads tend to stay for grad school. Chase was an undergrad here too. So they know the course, they know what's going on. Okay, so that's us. You guys can do whatever - oh, I have a task already. Could you pass somebody - volunteer to pass out handouts? The printer died halfway thru so, maybe divvy those up and kinda do them by rows. First official task. Okay, but we're not done with introductions because there is that awkward moment where you know us but we don't know you. So, first of all, I'm always curious about majors. So raise your hand if you're  a CS major. Okay, so everybody see that? So what we're doing here is building histograms over the room. You can tell density of things by looking around the room, we do this all the time. Raise your hand if you're a Comp E. Look at that, about half and half! About half and half for this semester. How about EE?
Oh, a third a third, a third.  Ok. Raise your hand if your major is none of the above. Ok. A fourth, a fourth, a fourth. Raise your hand if it is not the above and you would like to be a cs minor or you're intending to be a cs minor. Ok. Alright. So somebody who is uh..one of the not of the aboves volunteer to have a little conversation with me. So raise your hand if you are willing to have a public conversation with me about your major.  Anybody willing to do that? Ok. Ohh...we're in this huge room. Oh,  Tim you are gonna save me. Thank you. Ok.  So, what's your major? Economics. Ok. So how are you using computer science and economics? What's your intention? I have no idea. Ok. That's perfectly fair. Now. What I really..so that was all superficial right? That's what you'd..exactly. What dorm do you live in kind of stuff. But here is the meaningful thing. Ok. Tim, did it hurt you to speak into my microphone to all these people?  Oh no. Not all all, right? Ok! So my challenge for each one of you is to do that sometime during this semester, to have a little bit of dialogue with me or with whoever who happens to be teaching cuz it's a little bit weird to talk in this room for the first time for most people. But is there somebody else over here who is willing to have a conversation? Okay. What's your major?  I am a jazz studies. Is it music?  Yea. Ok. Are you? So are you a performer? Well it could be dance? Come on.. it could be dance? Are you performer? Uh..I guess I am, but I cannot dance. Ok. And did this experience hurt? No, it did not. I mean, a little bit. But.. It hurt a little bit? Alright. So we are not going to spend any more time getting you used to the feel of the room, but I would really really like for you to make it a personal goal to be brave enough to like.. raise your hand, offer an answer, its..its..we need it. Alright. So. Moving beyond that. Ok. So what I want to know are, is your year in school approximately.  Ok. So if you are a freshmen or sophomore, raise your hand. Ok.  I'm thinking two-thirds. We'll give that a guess. If you are a junior or senior, raise your hand.  Yea, ok. About a third. And what if you're..how about a grad student? Anybody a grad student?  here..a few grad students. Ok. Alright. Let's see. Anybody else have a question? I have a puzzle for you. Somebody think of a question that you believe will divide the room in half. Divide the room.. Hang on.. Divide the room in half. Yes? You have a question you think will divide the room in half? Ok. I should have traveling mics. Yes? Are you male? Oh..that is wishful thinking on your part. On my part too.. I can riff on inclusivity and diversity for a really long time. And probably throughout the semester, some issues will come up. You know I think it doesn't divide the room in half. Should we try it? Yea..Ok. So raise your hand if you identify as male? This is putting people on the spot, huh..sorry. You don't have to answer this one. Raise your hand if you happen to identify as female. Yea ok. Let's fix this. Ok? Let's work together to fix it. It's no one person's issue. Computing is cool and it's a shame when it's only few people doing it. Ok. Another question that divides the room in half. Yea? Can you yell? Just yell, so I don't have to run. I'm getting tired. In the what? the what? the thursday lab discussion.. Thursday? Thursday lab discussion? People with lab discussions on Thursdays? This is a good one because...ok. Fine. Friday lab discussions? And yea that pretty much divides it in half? Wednesday night lab discussions? How cute. They're doing this. They're doing this thing. Ok. There are few. Ok. How about this? Cubs or Cardinals?  Cubs? Cardinals? I haven't been to the zoo lately? I don't know what you're talking about?  Ok.  Among people in central Illinois, the issue of Cubs and Cardinals divides neighborhoods. Ok. Baseball to Baseball thing.  Umm.. Ok. Do you know that we are effectively at the geographic center of Indianapolis, St. Louis, and Chicago? Which make means that everybody in town should be a Packers fan instead of a Bears, Colts, or Rams fan, but you know unfortunately those are few and far between. Ok. Um..Anything anybody else wants to tell me  about you guys Oh I know one.  Late night versus early morning? Hi, Sylvia. Late night versus early morning? Ok. I consider myself a night owl.
I love the early mornings Okay Alright, nice, we will have o, we will have office hours early in the morning. You can tell how they will be populated versus the evening one. Its wise to rise with the birds, carninals haha. Okay. Alright, we need to get rolling cause I actually intend to talk about c++ today rather than just riffing on the joy of college. So, we should work. Anybody wanna tell me anything else? Okay So, all you need to know. Okay this is gonna be the thing. Will be. Here I haven't actually our site to the official site yet. But, all of the logistic details of the course will be at the course website. Including all information on this stuff. We haven't connected the pieces together, but that should be your first stop for questions that you have about course infrastructure. And that's pretty much all I am gonna say about it. I am not gonna talk about the details of grading at this point. I am not gonna talk about the details of MPs, Machine Problems. The only thing I am going to tell you is that lab sections meet this week. So, when you registered for this course, you registered for lab section. This first week I request that you please go to the one for which you are registered. In subsequent semester, or in subsequent weeks, you may be able to flip around if you need to. But for this first week, while we are getting a grip on who's actually in the class. Please go to the one to which you are registered for. Okay, any questions about that? Okay. So, everyday, so you can almost think of this moment as the first moment of lecture Everyday, we will start the lecture with the series of announcements. Those announcements will tell you uh oh don't know what I did. Where did the magic guy go. I didn't do anything. Ian save me. Okay. So, these announcements will tell you what is going on with the course in terms of due dates. I.. I don't know Yeah Okay I'm gonna keep going Oh good see. Okay So the announcements today are we are gonna give you your first assignment later this afternoon. Also your first programming assignment later this afternoon So you want me to hurry up, so we get c++ Classes are cancelled on Monday because of Labor day. And that's this Monday right? the Next monday Is that right? the first Monday? Oh brother. That's actually this noon nifty font. This is this new nifty font that makes 7s look like 1s Thats all. Okay So we have class on Monday. Okay, fine we are good. I think we are good We'll see. I'll figure this out. I need a calendar in front of my face. Mattox you helping me here? Labor day is
Yes No it isn't. Because this is the magic of that fun You gotta gonna flip a coin. And decide which one it is everytime Here is what we are gonna do for our debug you brain As long as I try, not everything in the lecture is clear.  So what we are going to do is after every lecture out there for now  will probably do it right out side this room until it is too crowded find a conference room We are going to hold follow up or debugs your brain or debug your lecture exprience right out side that room for now  right after this lecture will mostly be Mattix doing that I will do the one after the next lecture that's gonna a little bit of flux say when you get out of class there will be resources available and those constitute our open office hours even if you don't come to class Â  Â who will do that you have access to us in that lobby kind of meat day on Monday Wedesdat Friday Ok go to section this week they talk about the they  specifically talk about the protocol  the infrastructure of this course and the way you check out do and checking for your homework assignment so so that session make the rest of the semester a lot smoother have another announcement  for which I do not yet have a room  but on Wednesday will have a room  if you are not comfortable using Linux or Unix system in general  then we have a tutorial  available to you from 8/27 or 8/28 you sure Monday...oh it's August Linux tutorials 7-9pm that's being run by the ACM we just don't have a room yet so far before we even announce  the Facebook event actually have 245 tanbes We are looking for a big room Alright oh look it looks red sorry When do that happen let's make it look blue Alright any question about announcements  we don't know what room it is yet We will be all announced it on Wendnesday We don't have a room yet, it might be here We don't know Alright so what's this course about I have some metaphors  for you there is the stadium that's our stadium raise your hand if you have not yet been to a ILLINI football game you have a another goal for you this semester because the pageant tree is kind of cool  Umm go to a ILLINI football game it's kind of fun it's like a phenomenon  I will be going on October thirteenth because I grew up in Nebraska go big red sorry alright so I count you to go because it is just fun Now here is my question what you have is this stedium and I wanna know Where is Tom Bogue what are your idea for finding Tom Bogue there is the stadium  is filled with tens of thousands of People How I am gonna find my friend Tom Bogue who is a course staff for since who wasn't here I am actually looking for him
Where's Tom? He's kind of unlikely to be in the stadium.Â  Darnit. Where's Tom Bogue? How are you going to find him in the stadium? How are you going to find him? You can raise your hand, and I'll talk to you. Yes, what's your idea to speak very loudly. Get on the loudspeaker. And ask him to meet you where you are right? Share your location with your iPhone right? Say come here right now. Okay, so get on the loudspeaker, so this is a technology that allows for simultaneous broadcast to everybody in the stadium.  Well guess what, what happens if the loudspeaker is broken? How are you going to find Tom Bogue? Can you yell loud enough from over there so I can hear you. Oh, call him or text him on his phone right? Yo Tom, meet me at the... Alright, so there's technology there that makes that possible, what's that? What is the detail that makes that possible? His cell number, that's right. So you have a unique identifier you can use to find him directly, not unlike a hash table I'd say. Alright, now guess what, Tom doesn't have a phone. How are you going to find Tom Bogue? Oh, so you're going to trust that Tom has not scalped for his ticket, and that the official ticket sales office, has connected Tom to a particular seat yes? Yes, that's one way of maybe doing it.  So there's some potential for fault in the system there. In an ideal world, that should work perfectly, good idea. Of course, you'd need to have access to that proprietary data, but you know, we're optimistic here. Okay, anything else? So we don't have access to the proprietary data, and Tom scalped his tickets. Yeah?  I could go look for him. That would be my favorite thing. Okay so let's pretend you guys are the stadium and I'm going to look for him. Are you Tom Bogue? No, oh okay. Are you Tom Bogue? Are you Tom Bogue? You guys should stop me. Are you Tom Bogue? Are you Tom Bogue? You guys should collectively stop this. Yeah, yeah okay. Why? Why? Why stop it? It's inefficient. That's right. You're sitting there going, She's an idiot." Right? That's dangerous to do, but okay. Yeah, because look, the amount of time it was going to take to go all the way through this room, and find out that Tom wasn't here, was proportional to the amount of time it took me to talk to each one of you. That's no good. Especially if we have a complete conversation right? So what else could we do in that scenario? Yeah? Yeah, yeah, yeah, that's like broadcasting right? Yeah? I could, oh, oh that's kind of cool, that broadens the bandwith of things. He said to ask individual people if they had seen him. So I could ask, that person right there if they'd seen him, and they would go, oh I didn't seem him.  I could ask that person over there, and so instead of talking to every last person, I could maybe talk to every ten perhaps? Okay, fine. Yeah? Okay, very good, okay. Look at this. So, are you Tom Bogue? Okay, so what I would really appreciate is if you would everybody around you if they are Tom Bogue, and repeat this process with them. Okay? Alright, so do you have a mental image of what would happen if we did that? What does it resemble? Don't tell me a tree, we're in a football stadium. It resembles.., you can get this, see this is why you guys need to go to a football game. It resembles a wave, that's right, we could do this.  That's right, okay. So that kind of connects the story back and forth. And it turns out, it's not quite right, but it's close, it turns out that effectively we could examine the whole room in approximately the amount of time it would take me to talk to just a few people. You can imagine it spreading diagonally here. Now, the actual way that it would spread, well that's what we're gonna talk about later in the semester. Actually quantifying the difference between the two algorithms or techniques for investigating the data, that's what this course is about. In fact, we're going to have arguments about which approach would be better. I might not trust that somebody else can ask the question. I might need to rely on this me asking every last person, that would be being a control freak. Alright, so in any case we're  going to have those arguments and discussions. That's what this course is about. Any questions about it? Or comments? Alright, beat that one to death. Here's yet another metaphor. Here's yet another metaphor for what this class is about. And yet another question that helps me get to know you. Raise your hand if your closet looks more like the upper left. 
Raise your hand if your closet looks more like the lower right. I assert that there's actually a lot of correlation between night owls and upper left. and morning person and lower right but we won't investigate that. That's a question for another time. Alright, let's do it again. Upper left? Lower right? Ok. Raise your hand if you didn't raise your hand in the last minute. Why? Why didn't your choose between them? It's about half and half. Ah, ok so there's a grey area between the two and that probably where most people are. How about it I asked you which one you'd like it to be? Not the left. Ok. Alright. Did that hurt? And you weren't ready for that at all. We didn't talk about that ahead of time. I don't even know your name. Alright. Ok so the metaphor here, in case you're missing it, is that not only can we be clever with the mechanism we use to search our data. We can be clever with the mechanism we use to arrange our data in the first place. Now the real question is if you're looking for your purple long sleeve button down. Would you rather look for it in this closet or in this closet? Yeah, obviously. Alright, all you do is go the the button downs and it's right there. Right? Where this one you do your back linear search. Alright so, our algorithms and our arrangement of data in memory are two things. And it's the whole course. Any questions or comments? Ok what's it like? Eh, you can read that later. It's a puzzle solving course. My goal every day is to have you go Oh, that's cool" once. Just once during the day. That's what I want from you. I want you to go Oh, cool!" just one time. And that's the thinking part of it. Where you're thinking broadenings. Has that happened yet today? Eh, ok. I don't want to know. Alright. Where did you come from? So I think that many of you can raise your hand if your introductory course, your prerequisite course is 125.  That corresponds a lot to the CS majors a probably minors. Raise your hand--ah this is so hard. I cannot remember what the prerequisite course is for ECE. Which one is it? Did that hurt? To talk to me? Ok. Alright. And what's your name? Matt, ok. Thank you. Alright. So it is 220. Good alright. That's the prerequisite course. Now the amazing thing is that you guys in 220. You people in 220 learn everything you need to know about C. And that means things like pointers and memory and being responsible with your memory. And if you came from CS 125 it means that you know everything that there is to know about objects. Well guess what, in this course we seek to unify. And so we're going to use C++. And the dated version for a very deliberate reason. We're gunna use C++ and the cool thing about it is that there is a little something in for everybody. C++ has pointers, that is we control our memory at a lower level. But it's also object oriented. 
Now, if you know everything there is to know about pointers, I'd still suggest that you use that as a springboard to learn, perhaps a little bit new, how C++ deals with memory a little differently, at least syntactically, from C. So you will still not want to disengage, you will still want to be disengaged with the idiosyncratic differences between C and C++.  And now, in the previous sentences replace pointers with objects and the same is true for those of you who came from 125.  Even if you already know about objects, you will find new idiosyncratic things in C++ that you should learn about. So, these two things even though parts of them are familiar, as a whole they will be slightly different.  My take will be, my emphasis will be to differentiate C++ from your previous experiences.  So I'm going to assume that you know for loops, variable assignment, function calling, I really am going to assume that you have had the introductory course, cruise right on past that basic stuff (conditionals, what) cruise right on past that basic stuff and into the ways that it differs, and the ways that it will serve us in learning about data structures.  Any questions?  Alright.  Let's work.  So, the first c++ - and I have 15 minutes - can we find - 13 minutes - we're going to get a ton of stuff done. Because you already know a lot of what I'm about to tell you.  You already know it.  You already know that when you declare and define a variable in your prerequisite language that it has the following characteristics.  You might not have thought about it explicitly before.  But I'm pretty sure it won't surprise you when I tell you every variable has a name, and a value, and in our languages of choice, it has a type, and they have memory locations.  That is the value of this variable is stored someplace.  Okay?  Any of that surprise you?  Alright.  So, uh, like these other languages C++ has some primitive types.  These are things that you can look up.  We make a declaration in c++- for completeness you can look them up.  We make a declaration in c++ in a way that won't surprise you.  If I want a boolean I'm gonna call it a bool.  Cat.  Like this.  Okay?  So I declare the variable - what's the variable name?  Cat.  What's it's type?  Boolean.  What's its value?  This is tricky.  What's its value?  Okay.  Anytime you ask what's its value and there isn't an automatic known everybody answers the same thing we're all sure we're all on the same page, then what you have to think is it is garbage.  It absolutely has no value.  Now, it's true, that some c++ compilers will stick in, you know, a default value for you.  But, we're never going to rely on that.  We're always going to assume it is garbage until we give it, until we explicitly give it the value that we want it to have. so, oftentimes, these primitive types will be accompanied by an assignment statement much like this.  So that statement is equivalent char rating; rating = 'E';.  We can do them both in one go.  Any question about it?  Okay, fine.
so bad it's, uhh. So bad... It's good. Okay, The key thing to notice there is sometimes if you don't include your decimal to reinforce the fact that you're not dealing with integers, the compiler will yell at you. So, you know, that is the shortcutting a ton of ridiculous debugging time right there.  All right, any questions about that? No. Here is what I think. I think you should be sleeping. Kuhh, we had known about variable declaration for at least a semester now.  So, here is where things get a little bit more interesting.  It turns out that the set of primitive types of things we can use to declare variables is not enough.  In many many almost all circumstances, in fact, we want to define our own types to use as the bases for declaring variables. Okay? In C that was structs; in JAVA it was classes and in C++ it is classes. Alright, so here's what we gonna talk about next. User defined types in C++, those are classes. Okay? And I will show you the syntax for defining a class in just a minute because I wanna start with how do you use a class once it is defined and available to you. Well, you use it. This is different. This is different than in JAVA. You use it just like you do a primitive type and, in fact, a software engineering principle says that when you write a class, you create a type that can be used just as if it is a primitive type. It is sort of one of the standards for completeness. Okay? Alright, so if it's just like a primtive type and if my class name is sphere, then I declare a variable of type sphere" using this statement. Any question about it?  So now I have a sphere.  We don't yet know what a sphere is. We gonna define the class later on. For now, I just want you to see how to declare one.  Okay, so, a class is a group of two things... It is a group of a variables and functions. Now, these two words, which I will refer to as variables and functions, in other languages may have different ways being refer to. So, we may have fields, here sometimes instead of variables. We might call them member variables and I will always do that actually, almost always do that if I rememering that they are called member variables. Uh,  and functions, functions are always refered to as... methods, very good. And for those of you who came from C, the classes is not very different from a struct except for this part. Okay? a class is not very different from a struct except for this part. Any questions? And I will show you how to use that part very soon. Not quite yet, I don't think One of the things that ran wrong this morning was that the printer was broken and so, I don't have my class notes. So we are a kind of winging it. you've probably noticed. Alright, so here we go. Let's define a class. Okay? Now, here is the skeleton, here is the skeleton. Uh, we simply define class sphere" [use] opening and close brackets to declare a block of code and what is different from what you've seen before is that we do have to include a semicolon in this case after the class definition. And the reason for that is because there is a field right there that we don't use. Okay? But it exists in the language definition and so we have to end that statement. There's like this ghost"  statement here. Okay? So, another common mistake to make is to forget that semicolon because it feels redundant. Feels like I put a closed bracket there and it must think I'm done with my class definition but you are not. Okay, so, well, uh, here we go.
The members are the collection of both variables and functions. And in the class definition itself, we declare our intent to define. Now, what that means is that we won't actually see any function definitions inside the class definition. So this is already different from Java, because in Java your class definitions are that long sometimes, right? In C++ not so much because we just make a list of the things we intend to define, rather than explicitly defining all of them. So now, in this class definition, we allow for our little control freakiness stuff to come out. There are two regions inside the class definitions that we use to control access to the members. And those regions are specified by a public keyword and a private keyword. Public keyword and a private keyword. And public is anything you want the user of the class to see. Now who's the user of the class, it's whoever did this, it's whoever made the declaration. Private, though, is what you want to control. Two purposes to private. One, you want to control access because you don't want a calling function, you want to control the calling function changes your data associated with the thing.  That's one reason. And two, actually, I can think of another reason, two, you don't want to expose to the calling function the way you have implemented something. And three, you want some special place that you can put your utility code that nobody can mess with, that nobody needs to see. So these are usually the following things: the data of associated with the class object, and those are the variables that I referred to on the other page. But also, functionality that only the class itself needs. And we won't worry about that for a while. Okay, so I made a big stink out of the fact that the class definition includes only declarations for all of the members. And then the question is, well where does the actual implementation go, where does the code go? And the answer is, in a separate file. We actually implement all the functions in a separate place. That allows us to kinda keep the value of our implementations, to not show the world how clever we are, because we're going to bank on it. We're going to make bank on it. So, often times, we would define a class like this. We will put the declarations in a file called sphere.h and we will refer to it as the header file. And we'll actually put the member function definitions in another file called sphere.cpp. And I'll show you later how to compile those together. Actually the lab might show you how to compile them together. Alright, next time we will start exactly right here. That is, wait, stop, freeze. Everybody freeze. Freeze. You're just not doing it, are you?  We're going to start with the design component of the class definition. We're going to start talking about: What is a sphere? What kinds of things should it be able to do? What data do we need to keep about it? At the very start of next time. Alright, bye.
hello there! hi hi hi
Hello? There we go. Ok I had to turn it on. So, RP is Reflections|Projections. It's like a conference where we have speakers come in and there's a job fair. And there's also something called Mechmania which is a coding competition from friday to sunday. And every year they make up an entirely new game that you kinda work your way through. Every year we have a Mockmania before the event where people try out the game and make sure there aren't any bugs Trying to get it ready for the actual thing. So if you're interested in being in Mockmania you should come and be a part of that. You can sign up at acm.uiuc.edu/mockmania And if you come there might be prizes if you find some really good bugs. And there might be food. There probably will be food. Yeah, Mechmania is the actual event and the Mockmania is just the trial. We'll probably have it in the next week or so. Ok. My turn. I didn't have bug free slides last time and probably the most critical piece of information I have for you is just plain flat out wrong. I believe with 99% certainty that that is actually the course website. So everything you need should be there. I am aware that the lecture slides are not yet uploaded, they will be. That's like highest on my priority list to do after I get back to my office. It's a process. If you have general questions, even if they are one-to-one questions between you and course staff, please post to Piazza with those questions. You can post privately. Right now all of our email boxes are way too full. And I think I have about a 50% hit rate on actually seeing all of the email that's coming to me. If you post to Piazza you have at least 40 sets of staff eyes on your message. I was asked a question right before class. Gosh I've already forgotten what it was. I suggested to be posted to Piazza so this is the perfect example. Does anybody have any questions? What is your question? If we're currently taking CS 173 will we get the math from that in time for use in this course? Ok, so I think that the consern came out of Homework zero. And sort of assess how much time we should spend on Homework zero. We've pretty much settled into the fact that 173 teaches you stuff in time for you to use it in this class.  There's like one day where it's kinda switched. One day when we're talking about induction it's kinda switched. But in the end it ends up being ok. So taking CS173 concurrently with this class is not bad. Now how much time should you spend on Homework zero if you're concurrently taking 173? I think Homework zero, at least parts of it, are kind of fun. And so use Google. Try to do it. Don't spend all week on it. If you kind of give your best effort and it doesn't flow but you are currently enrolled in 173 then you're ok. If you give your best effort and it doesn't flow, and you are not in 173 then you may consider adjusting your schedule for this semester. Does that make sense? Does that cover all the issues? Yes ok. Alright so more details for that discussion could happen on Piazza. I think lots of people are interested in that issue.
Due date ... right there and proficiency  exam sign up instructions so if you have had a data structures class and you did well in it and you don't want to be in this room, you're welcome to take the proficiency exam, and I'll tell you that the pass rate is pretty low Umm... and that uh, in fact very few people even take the CS225 proficiency exam. Some people take it and still enroll. Some people pass it and still enroll in the class, so I don't know what the deal is. The information for signing up if you think you'd like to take is that I certainly don't intend to discourage anyone from taking it. You are all welcome to take the exam. Alright. Any other questions, any questions about the announcements? Okay, so I left you hanging in the middle of last lecture; completely hanging.  In fact, we had started to define our first class.  In our first class We were defining class sphere. The reason why we wanted to define a new class is because we wanted to declare things of type sphere, and low and behold, sphere is not a primitive type in C++. So my objective and my goal is, mmm, I'm not going to be fluent with this tablet yet, and I apologize, but I'm working on it. My goal is to be able to make a declaration of type sphere of a variable whos variable whose name is beach ball. For example, okay? Now the question is how do we make that happen? The answer is to define a class whose name is sphere. The details of defining a class are like this You understand that there is this public access system, but you don't necessarily know what that means And a private area in the class definition You don't know yet what that implies, and that's okay. Then you go to the drawing board and you think, okay, what kind of functionality do you want from a sphere and how do you represent a sphere. That is, what data do we need to umm keep about a sphere. So when we talk about the representation. What we're really talking about is what data will characterize anything of class sphere. So ... raise your hand if you have an idea of data that will characterize a sphere. Yeah? Whether it is round or not. Guess what? We're going to implement it so that it is round Okay? Sphere will be round Okay? That is just... we'll make that happen Yes, so if I tell you something is a sphere and I give you its radius You know what that sphere is, right? There is only one sphere that has that radius... well, sorta We're going to use ... uhhh ... radius ... oh wait Could I use diameter instead? Yes, could I use surface area instead? That would be crazy, but yeah, because you'd have to take square root. How about volume? Could I use volume instead of radius to characterize my sphere? Is there only one sphere with volume ... whatever? Now, again, we are in a design discussion. Why wouldn't I use those? Why wouldn't I use those other things? Yeah? Yeah, they induce time to evaluate, right? Like if the only thing I care about about a sphere is its volume, then I might use its volume But probably, for a general purpose sphere, I can most quickly get to what I want by keeping its radius, and doing simple arithmetic Simple arithmetic in every direction to get the data, or the information that I want from it. So I'm not going to keep... you're going to have to forgive all the slide switching. That is my fist on the ... thing. I'm going to keep the radius. Okay? That's going to be my representative.  Now, the reason why we keep the radius instead of the volume, say, is taking cube roots is expensive computationally. Okay? So that's the piece of it...that is... that's the piece of it that's hard. That's why we decide on radius Whereas cubing something ... not expensive at all. Who knew? You thought they were uhhh you thought they were inverses of each other. You didn't care. We care. Okay, so now we know how to represent this beach ball. We're just going to keep its radius. Do we need any other kind of representation?  Yes? Yeah, its location You are absolutely right. We would probably want to keep where this sphere is to but the real truth is what we're designing is a stupid sphere. We're only going to represent it via its radius. We're not going to try to keep track of where it is, but we could. We're just gonna keep things extremely simple So what I'm going to say here is plus more... probably.
So, alright. We are going to keep sphere and denote it by its radius. What do we want to do with the spheres? So, once I have beach ball here, what do I need to be able to do with it? yeah? I might want to get the diameter from it. That's right. I might want to get information about it. I might want to get information about sphere. Anything else? I might want to do? yeah? I might want to change it. That's right. I might want to change information about it. I might want to change the radius. ugh, change it. OK? And, the last one is kinda implicit, and I already done it. We might want to create a new one. If you are coming from Java, this basically constitutes a collection of geters and seters right? We need to get information and change information. In C++, we do that ourselves explicitly. We don't just get ask for them. So, we are going to write the code to do it. Now, before we write the code to actually implement it, these things, we declare them. Now, here is the story, for the representation in practice, we are always going to put the declaration of the member variable, that's what those are, in the private section, cause we want to controll the access. Talk about that more in a second. So, in the private section of our class defination, I am going to write double theRadius. And now, I am going to use my functionality list, as essentially a checklist for the declarations of the functions I am going to implement. To declare the class defination. So, one two and three there are my checklist, and I am going to go through there, and start to declaring functions, achieve that functionality. OK? alright. So, the first thing I want to do is get information. If I am getting information from the thing, then I better have a return type. Better have a way to accepting the information. Ugh, what I am going to do is, oh, sorry, erasing, hmm. oh, no.. What I am going to do is, to have a function, with return type is double, whose name is get, probably one of these for radius,  diameter, volume and surface area. But the one I am going to use for an example is get diameter. There are no parameters to that function, and the declaration, ends with semicolon. And I will show you how to use that function that has no parameters in just a sec. Now, we are done with get information. Now, what does it look like when we want to chage one of these things? Well, we don't expect a return type, we might have a boolean in there to see weather we have been successful. The name of it might be setRadius(), and this time, we do want a parameter. We are going to pass setRadius, a double, whose name is newRadius. Hey, again, it is a declaration, and it ends with a semicolon. It is just a statement of my intend to imple ment.  A statement of intend to implement. Ok, and now finally, we are going to talk later in the day, about creating new objects.  I am going to show the declaration of the functions will be deployed, so as to create objects, you are going to tell me what's weird about them. One of them that I am going to use, is simply this. and another one I am going to use to create new objects  is simply this
I don't know what i called it I don't know what letter that is. I think it's supposed to be a T bubububububu trahhh there Okay what surprises you about the function declaration right now already two thing i should think should surprise you yes? It's this same they have the same name they are not the same function and i can tell because they have the different parameter list so you should yes if two funcitons have the same name but different parameter list, they are different functions. It's almost like you should look at that function sign and use it as part of the characterization of a function so good point same same different parameterization anything else surprise you by those two function declaration? yes? no return type that's right and the reason for that is because these are functions called contructors that the system deploys for you. you dont deploy them so you do not expect the return type. you are not writing code that's going to handle the return type so no function no return type in these function declarations theres one more thing that's a little bit weird about this. Yes? Exactly, it has exactly the same name as the class right? here's the same and there's the same and moreover woah yeah right there woah woah woah hmmm no... this is new haha he no problem moreover right here ohhh when we use the class when we use the class there is the same name again so this is all consisted with our idea of user defined type  okay any question about this? alright so now at this point at this point we have we have shown what a sphere implementation is going to look like we have not yet made it happen right? there is no assignment statement that actually changes he radius here so this can not be it and it isn't it But, i wanna point out that right now  if this is all we know about a sphere in fact it is. In fact all we know that we can already do stuff to sphere right? I can take my bball my beachball and I can do this so for those of you who have not worked with ooj language before this will feel new i'm going to invoke my member function on my object of type sphere simply by using a dot and a function name let's see I'm going to set radius  to whatever you like how big are beachballs they are like 11 inches in diameters something like 11inches in radius that would be nice sized one right? I would be a such a better teacher if right now if at this moment a beachball started its rounds in the room shoot you know if the big darn it next semester will be better I tell you maybe next hour where's madix I was you walking where is matt is there beach ball? oh you have a beach ball in your office? shoooot remind me  what ahhahahahaha that would have to change up everything okay sorry for the distraction
has shown us, that we have a function called setRadius that takes a parameter that's a double. Okay? Any question about that? And now I can do things like, I can do things like cout". cout<<bball.getDiameter()" No parameters. And I'm gonna send an endl". Now, new stuff! This is new!;)  Right here. This is like in C, printout. This is C++'s mechanism for allowing you to send output to standard out or send data to standard out. Okay?  And, there are some other little things you have to do. You have to tell. You have to state your intention to do so in your code, but we'll talk about that in more data later. So, you're gonna see this. All it means is hey print this stuff for me". So what would happen if I invoke this command, compile the code and ran it? What would the results be here? This would result in --- twenty - two, gotcha! Yes you would get 22. Okay? If we implemented this. Okay! Now the kicker is here is what I can't do. Hold on just a second I wanna answer your question, but I wanna see if I can answer it without via esp okay?  Alright. Here's what I wanna know if I can do. Can I do this? Can I do that? Wow, really? Okay. So speculate to yourself a little bit. No, I can't do it.  Why?  Yes! This is what private means. Anything in this private sections is not accessible via the object itself. So this thing is not allowed. Because the radius is private Alright I have a little piece of vocabulary to give you and that is the following. This code in the blue box is called client code. Anything that uses a class definition is referred to as a client. It doesn't mean that you could expect payment or anything. It just means, users". So this is sphere class client code. And so now I can say the sentence: private members are inaccessible to client code. Private members are inaccessible to client code. Clients cannot use anything declared in the private session. Similarly the reason I can use these two is because they're public. We've laid them out there, right? Like this is permission. This is not friends, or family, or U of I. This is everybody. Everybody can use this. Okay. Use these functions. Any questions about this? Yes? Yes, exactly. We're gonna talk about that in just a second. So his question was can we access the radius via functions?". Of course we can cause we have a function that allows us. setRadius", right? So we have to go through setRadius to change the radius. Alright. Yes You don't need a constructor to create the object. The system will provide one for you, but it's a really really stupid one. So you probably want to create your own. Okay? Alright. Anything else? Okay. Here we go. Alright. So I've sort of replicated what I did before, because I was lying to you of course. The code on the previous page actually won't do anything because we have not created the implementation of each of those member functions So that's what we're gonna do on this page. And so I replicated the code from the previous page here so I can talk about how we actually make those functions work.  But, even at this point, something should surprise you. So when you look at what I've replicated here, two things should surprise you about this code. What are they? What do you see here that shocks you? Shocks I mean. Yes?
Okay, so the comment is, I believe, you'll have to correct me if I am wrong, that that name matches this name. And that is absolutely germane. It's probably the most important point because what I am really doing here is creating the code that will make that declaration on the left work. Okay, it's creating the code that will say what happens when that function is invoked. Okay fine, I am not too surprised about that. Anything else here? Yes, okay look at, this wasn't here. You can look back - I didn't do that when I declared this here. So that's different, I'm gonna talk about it in a minute. Okay, what else looks weird here? What else looks unfamiliar? What the heck is the double colon about? Okay, that's called a scope resolution operator. And here's what that says. That says that this setRadius is the setRadius declared in the sphere class. It's not the one declared in the circle class. It's not the one declared in the arm class. You get it? Doesn't your arm have a radius? Yes, okay. Like if you have a broken arm, you set the radius, right? Fine. Tough crowd. Okay fine, so this setRadius is the one associated with the sphere class. So if you saw something here that was attached via the scope resolution operator to another class, it's not the one you are interested in. Okay. I am not going to talk about const yet, I'll talk about it in a minute. Suffice to say that the scope resolution operator attaches, or associates, a function to a class. Alright, so let's set the radius. What code do you think we would have to do if somebody tells you here's a new radius". How would I set the radius to be that value? That's it, that's the code! It can be, it can be. It can be but they are not inside the same code block. By convention, not because we have to, but by convention, we stick these implementations into a different file. Remind me to talk about that again before I advance the slide. Alright. Yes? Yeah, I might want to because what this allows right now is I can say bball.setRadius(-4.7). Right? And so this is our chance, our opportunity to do some error handling here. So maybe I might want to say If newRad is greater than zero do this, otherwise theRadius - what should be a default radius? Yeah? Yeah maybe one Or just leave it. Don't make a change, but then you'd want to tell somebody you are doing that. In any case, this is not exactly how you handle errors. Alright, so I want to make a comment here. In this class, we are not going to talk a lot about exception handling. Okay? We have too much to do, and so, we are not a software engineering class, so. C++ has mechanisms for exception handling. You can Google them.  You'll be better at Googling them after you go through these first four weeks of the course. So, wait, let us handle exceptions in kind of a novice way for now and if you have questions about it later, we can discuss it. Okay
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
I can't hear, you have to yell. Oh yeah, look at this, look at this. I just said 5 minutes ago, don't touch that, you cannot change the radius.  And yeah, here we are doing it, here is gonna allows it.  The fact that this says here allows me access This is a sphere class member function I have access and I need access to these private members OK? That's what we were doing here Yes? No, you cannot do this in a client code You don't want to do this in the client code This is all part of the sphere class definition OK, let's do getDiameter() I am gonna do this one for you because there is absolutely nothing about this code that will surprise you You can raise me if you want return 2 times the radius OK? Alright, Any question about that implementation? Yes? Yea, you don't in C++ yeah You never have to be object itself if you are coming from java  The object there talking about is implicit. There is a this if it's a pointer to the current object But we are not talking about pointers yet OK, one last thing What the heck is that const OK, so, noticed that, getDiameter() has no reason at all to change the radius Putting a const in that place is a promise that it will not change that radius So const placed at the end of the function signature is a promise that the private members will not be changed by the function And the reason that's good is now I can hand you the getDiameter() signature and I can ask you to implement.  And if you try to be in the furious. I am gonna change her radius to 52 every time. You can't. The complier will not allowed you to do that So it promises if I am asking for information nothing will be changed about the value of the object Alright, any questions about it, good? Did we cover everything there? Why do I wanna make , excuse me? OK, so the question is why would you wanna do that The short answer is you want to ask the compiler to help you to control access every time you can't.  Because the compiler put the code together before the client every uses it before every excecuted Before your code is ever executed. So every time you can bring control at compile time you want to do this Now, you do not want get diameter to change the diameter, that would be a bug. So we are trying to increase our integrity of our code enforced by the compiler, just to make it easier to maintain. To eliminate the potential bugs. 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
What would you like to have happen when we declare a sphere? Yeah? I dont have to. So the suggestion was a great one This is a moment where I get ot go oh, we love C++ He said you have to allocate memory and I'm gonna go, its youre lucky day! Was that you? That said that? Its your lucky day! You do not have to explicitly allocate youre own memory. You can just declare one ok. Its fine, its there for you on the stack. Yes? Yes! It should have a default radius. Thats right Lets set up the default radius I'm giong to assert that a good one is the unit radius. Ok? Is that alright with you? Ok Alright, fine. Uhh, there is alternative syntax for this in C++ and the reason I'm telling you this is becuse you will see it. People use it. It isn't quite as clear, its's a little bit weird becuase it really teaches you something new about the language. Alright, here is an alternative syntax for declaring a default sphere. or a no argument sphere. I'm either gonna do the first one or this one. I'm going to use what's called the initialization line to declare  the value of my member variable And thenm this is  an empty code block. Nothing to see here. Move one. It does not have semicolon Its not a class definition. It as a implementation and thats the code block. The only place you have to have the semicolon is here or at the end of a line. That's a good point. Yeah? Yesh, no. Its like a parameter. Ok? So this is correct syntax What is there to observe about this syatax. There is a colon. It's the name of the private member as if it is a function. as if it is a function kind of and then you sort of pass the value that you want to that variable. OK? There is a really good question. Yes. There you go, that's it. That's exactly what I wanted you to ask. Ok. Have I been doing this class a long time or what? What if you have more than one member variable that you want yo initialize. And the answer is the folliwong. if this thing also has a color associated with it, you delimit them by a comma. which is also unusual in our context I dont know what r is Oh, and there is no semicolon. dont let me put a semicolon there, there is nothing there Ok. So I show you this contruct. For two reasons One is because you will see other people use it and two is because when we talk about inheritance in C++ this actiually becomes important there are cases where we explicity call member functions of super classes. Alright, any qustions about this? Yes?
Are we or could we explicitly call? Okay so any time anybody ever asks a question in c++ that starts with 'can we', the answer if it fits the specification of the language is yes. But the more important question is because you can do crazy things with c++, you can hack to your heart's content. But the more appropriate question is should we? And so I'm gonna rephrase your question as 'should we explicitly call the constructor' and my answer is in most cases no. We should notÂ explicitly call the constructor we have define it for the system to use we're going to let it use it, okay?  Yes Okay so I'm gonna get there for just a second.  So that him asking that question is really saying alright move on and I will do so. So let's move on. Because we have this other constructor and I've just been kind of obfuscating it right, moving past it. Here's what it allows you to do. And you can tell me at the end if I don't really answer your question, okay? Umm here is what it allows you to do. It allows you to declare a I don't know what aball is, apple ball? I don't know how big are they, 4.7 something? It allows you to upon declaration give a value to the radius and the only reason that this constructor exist is because we declared it because we said it should. Now what does the code look like here? It looks like theRadius equals r. And we could say if r is grater than 0 do that, else theRadius equals 1.0, say. Okay? Alright any questions about that? Yes Very good question. The question is can we use the initializer list for this constructor the answer is yes and that syntax looks exactly looks like you would expect. That syntax, I'm gonna put it in a different color ink because it's alternative code, OHHHH, would look like theRadius and have an r in it. Okay you can refer to the parameters in that initialization list. Why wouldn't you wanna do that? You cant error correct it. That's right. You still have a question? Yeah okay. Errrrrr I don't know the answer to that. I think not. I haven't see it. Is it time to go is that why you're restless. It's not I have two minutes left! Okay so here's what I'm gonna say in those last two minutes. If you don't declare any of these, declare or define any of these constructors, the system will give you one. Okay? So that is point one about constructors. If you do not provide a constructor, the system will give you a no argument constructor so you can't do this little trick of instantiating the variable without defining yourself. A no arg, okay? Now if you give one, if you give one constructor, the system will give you none. So if we just defined that constructor then and not any other ones we would not be allowed to that declaration, okay? So ahhhhhhhh, if you define any constructor, the system gives none. Okay? And then the last important about constructor I've already made and that is to reinforce the idea that the constructor is a function that you write for the system to use. And you should think very carefully about why you're explicitly invoking it if you are ever tempted to do so. So the ctor is written for the system to use upon declaration. You should not call it.Â  It is not called by client code. Okay that's it how far did I get in the slides? Look at that. Oh um.  Okay and that's it how far do I get in the slide. Oh look at that. Whooo, er. [interesting noises]
Let's work. Let's work. Now you can hear me. Let's work. Did you groan when I said let's work? Ah, all right, my watch says 11 o'clock.Ok, so ah, let us see, so ,good friendships are built on shared experiences, yes? Good friendship on build on shared experiences, so, I wanted to step out this slides a little bit and create a shared experience for all of us. Now, i m a little nervous about it because i m the person with microphone. Um and so, and so um, i want, you guys are welcome to bring your own microphones if you like. Then we can , wait. That 's a distraction we do. HI,  i m sorry. Ok ,so i am yes im controlling the keyboard and yes i have the microphone clearly not controlling this screen at this point, Um but, i WOULD like input from you on how this go. Now, this experience is simply called review of what we've known so far, ok? the review of what we've known so far, Cauchy title huh? It's gonna be a 89 of rotten tomatoes, all right, so, here I am, here I am at my command prompt,  on my macbook, ok? So. I 've done nothing especially in stole your (simmity)? or while ago.  It s not even really my macbook. im kind of borrowing it from somebody else.And moreover it is like 3 years and a half years old.  So, there is really nothing special about the particular setup this going on here i dont even think i ve been installed the developer tools, now. The situation that we are in right now in this terminal winde could be replicated easily on any engineering work station machine. Either by ssh, that is  remote access to those machines or by sitting in the lab directly. Now the reason im not doing that is i actually prefer not be dependent on the network ,on the wireless network. And so , i'm doing it just locally on my machine so as to diminish the probability that something goes horribly wrong. Ok, so, uh i  am in my uh, fall 15 working directory i found that out and typing present working direcoty and im gonna list this contents of this, all right, the file that were going to be working on is demo.cpp would you like to see it ? are you dying to know what's in demo.cpp. All right, there it is, ohhhhhh. It is intended i have said it is going to be c++ files by it's extension. Ok, and clang likes that it didn't like it when i had txt. Uh, all right, so fine, im going to try i've said this is in c++ file , let's see if clang likes it. ok,um, to escape from this is the unique thing that will be convinient. To excape from the current processes into the calling process. I did control+z and i'm going to bring it back that one that editing back to the four ground with fg, for four ground. So, ill be swapping back and forth with key strokes that my fingers learn decades ago. So, if it looks a little, um im not fast. OK? so , if it looks like, what the hack did she do there? Number 1, feel free to ask. Number 2, assume that it is  something simple All right, now ,  i have demo.cpp. It's being edited in the background but i've saved it, it has no content. And im going to ask our c++ compiler to make it into executable code for us. OK? we are gonna ask the c++ compiler to compile it. Oh, oh, doesn't like it .
Hmmm. What do you think it doesn't like? What doesn't it like? Yeah? [student answers] Yeah, it doesn't have anything to do with the architecture it turns out. It turns out it doesn't have anything to do with the architecture, even though the error message says all of this stuff that I don't even know about my own machine. Ok What doesn't it like, yeah? That I have no curly braces at all and in fact, it doesn't like that I have no main function. So the C++ compiler wants something to compile and the thing it wants to compile is a function whose name is main. Ok, so let's fix that. I'm gonna type 'fg' here. It brings my previous process into the foreground again. And I'm going to go ahead and define a function whose name is main. Ok. And that's it. Now, uhh, is it gonna be happy? Well, cross your fingers, so clang requires an incantation before you invoke it. You have to cross your fingers, nod your head three times, and [gasp] yay, nothing yelled at us. Ok, alright, now how do we execute things? So clang took that C++ file, hold on, just, it was a rhetorical question that time. Usually I want an answer, but is it a question? Alright, hold on just a sec So the question I'm answering is... how... what has... what just happened there? clang took this C++ code, compiled it into, uhh, an exectuable, something that we could execute and, by default, it put it into a file called Now, the reason we saw that previously was because I had already been playing inside this umm inside this directory, otherwise that a.out would not have been there prior to this compilation. So, a.out was just created, or in this case updated, for us by the compiler. Any question about that? And then I'm promising you that it is an executable. Now, if it's an executable,  I should be able to execute it, right? [typing as well] a.out Hmm, darn it. Ok, everybody trips on this. Here's the thing. The system needs to know explicitly which a.out you're talking about. In fact, it didn't even bother to look in the current subdirectory because I haven't set... I have the paths setup to look in a whole bunch of other places. Ok, so, umm, and there are lots of a.out's so I have to tell the system which, explictly, which a.out to execute. Which one is the one in the current working directory? Ok, so this dot is shorthand.  It's merely a string substitution for, for the [current directory] Yay, I didn't have to type all that, I can just use dots. Ok, './a.out' specifies do this one. Oh. You know, it's always good when something doesn't yell at you, but nothing happened. Are you surprised by that? No, there's nothing surprising by that, right? Our main is empty.  There's no... we didn't instrument any kind of status update or anything like that. So ok, so let's go make this more interesting. Let's put something into main. Uhh, I'm going to assume that you can kind of get caught up and play around with primitive types, so what I'm going to do is try to declare... is to declare an apple. Ok, you like it? No. Will the compiler like it? Do you want proof of... raise your hand if you want proof that the compiler will not like this? Alright, fine. Control-z uhhhhhhh where's my clang. Uh-oh, it says exactly what you would expect. And clang is a little kinder than g++ was  and so it tells us 'unknown type name'. Alright, fine, we'll go fix it. It's called programming by trial and error. So that it's no longer true that it has no content. I'm gonna keep my, uh, 
Okay, now will the compiler like it? Will the compiler like it? Raise your hand if you think yes. Raise your hand if you think no Okay somebody who says no tell me why Why won't the compiler like it? A semicolon ( ; ) that's right! Very good. Hopefully I left the cursor in the right spot. You will get caught by that bug! Somebody will get caught by that bug and post to Piazza. Okay? It's not unusual. So I'm going to save it, and then go compile it. Bang C. Bang C here just says, take my history, look at my history of commands and do the last one that's started with a C." Okay - Do the last one that started with a C." And so, That invokes clang++ demo.cpp Okay? Compiler liked it. There were no errors. *Gasp* We can declare a sphere that is vacuous. It has no data associated with it. It has no functions associated with it. It was perfectly fine. Okay? Any question about it? At all? Uhh what happens when we go... that! Nothing! All we did was declare something we don't expect to be able to see. Now, it is true that things did happen in memory and that's going to be the substance of the lecture slides today, but for now we're still in the experiential mode. Okay so now, let's go make a sphere class that does some things All right, I didn't think about this part too much But I do want to go ahead and uhh... umm. Tell me the name of that function? Constructor, that's right. You look at it and you go, It's a sphere, duh." But this one has a special, more general name called a constructor and I can tell that it is so because it has the same name as the class name. Um the only other function that I'm going to take the time to instantiate or declare here is... uhh getDiameter. And it will return a double, it needs nothing and if you recall, we specifiied that it had to have a const. And then we uhh represented our sphere using theRadius. All right so I think that this should be okay, umm... So let's compile... okay? You ready to compile? All right. Uh, first before we compile... maybe I'll do this first. What happens when you have no constructor? Well, yeah we'll leave it like that for now. UUuumm... C okay? Syntactically, we're in good shape. Am I surprised by that? Are you surprised by that? Why are you surprised? How about this? How about this? Umm what if I now say, umm double b = apple.getDiameter(); I was a little surprised by that, could you tell? I had to do a little debugging here Now, now I'm in danger zone kay? This is a true shared experience um because friendships are especially good when you have shared experiences, which are kind of tense And you have to like, you know, deal with a, deal with an unknown and uh that's this moment soo Raise your hand if you think the compiler's going to yell at me. Okay, raise your hand if you don't think the compiler will yell at me because after all  I haven't really changed things very much Okay, I'm not sure. Um, I hope it yells at me. Okay? uhhh... Ohh Yeess look, yay okay! Do you see what happened here? The compiler said, hey you tried to use getDiameter, you tried to use getDiameter and there is no getDiameter! It made for me no getDiameter so the lesson here is that you can declare a function without implementing it as long as, somebody volunteer to finish that sentence... As long as?  Yes? Right Right you don't use it. Pretty much period. pretty much you never call it The way to finish that sentence in a meaningful way is  in client code " because that's another little piece of vocabulary. The code that uses this object is client code. For the moment, the only client that we have here is main, okay. Any questions about that? Are you good? It's Okay? All right Uhh let's go So that says boy we better implement getDiameter Let's do that very quickly Uhh I need to connect getDiameter to the sphere class. It needs to be specified as const and I've already forgotten my return type there. Okay... *typing return 2.0 * theRadius; under getDiameter*
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
And then I'm gonna do this thing too. And I'll explain it a little bit more because I want to look at what happens. Okay, any questions about any of this code? Oh probably. Where? Oh, in my implementation. You're my compiler, yay! Thank you. What's your real name? I don't think you go by clang, right? It would be a good name though right? Well, who are you? Kevin, nice to meet you. Okay, alright. Yeah, so make a correction you run the risk of like public. And now we're friends because we have a shared experience. Okay, alright. Any question about any of this code? Yes. [no audio] Isn't that the question on the board? Let's go back to our discussion on constructors. Let's sort of think ahead in time here. Go back to our discussion on constructors. If we don't give a constructor, the system provides us one. But, we didn't control how the object was constructed. I actually don't know standing here what clang will do. It's a compiler specific thing. I think its virtual c++ does always really nice things which means that people who program that in their first language tend not to program very defensively. It's like training wheels for your life, right? So, not to disparage it but it's nice to have a controlled environment And so, I'm sitting here. I haven't messed with this particular compiler. I don't know which version of clang it is. And so, I'm gonna go check just with you to see what clang does upon that initialization that I have had no control overflow Let's go see. !c Okay, it liked it. We had no syntax errors. No type errors. a.out Oh, and it gave us zero so it happened to have initialized that particular double to be zero. I don't know what would happen if we try to do math on it. Alright, but I don't want zero to be the default value. So, any question about that? So clang kind of played nice there but you cannot count on it doing so. Yes? Yes, it's supposed to be. It's supposed to be. So the virtual machines we give you for this class that is part of the download for the laptop lab should contain the same environment that the engineering workstation machines use so clang should be there. I don't think we upgraded to 3.6 so I think it's 3.5 but maybe 4. I don't remember.  For which? For main? So here's what happens. So if you don't specify a return value, one is inferred unless you try to use it. For example, if I didn't try to assign from getDiameter, I think this is true, it wouldn't have mattered if I put it there. In any case, those kinds of errors are compiler errors so the compiler will say, Yo, you forgot your return type and I needed it". So that's an easy one. I fixed all my bugs now, right? So, that's a case where and I don't necessarily know, I count on the compiler to tell me what it needs. Okay, let's see. So, let's implement a constructor. Where can I define the constructor? Where can I implement the constructor? Where can I implement it? Could I implement it down here? Let's try it.
connecting it to the sphere class. and I am going to set the radius  equal to 1.0 and thats it right? and I better get rid of my comment because I have declared my intent to define inside the class definition Alright, let's do this! Liked it! [pause] and it worked! [pause] Ok How about Alright, so any question about that? So, anytime the declaration has been made the definition can occur. Ok. Actually its much more about also where you call it. So the here,let me get it back. [pause] Ok. So...this happened after that was processed. So when the main is executed it goes an looks for type definition sphere. [pause] [pause] It has it and so its says ok I got a sphere class and then all those things are declared It wont reach out to get them until it needs them but, that this interface up here is a promise that these things will be implemented somewhere. and that somewhere can pretty much be anywhere! Ok so also long as the declaration exists. When. Im sorry. As long as the class definition exists, when the declaration is made Then the implementation can be in lots of different places. But you know what, I do not like it down there. Thats not what readers of my code expect. So, I am going to put it back up here. In a more reasonable place.  Ok. Alright any questions about all that so far. Yes. [pause] It, no bang bang is the pervious line that I wrote, bang c does the previous one that starts with a C. Ok yes anything else? yes! [pause] demo.cpp .. O I will show you. So you know what demo.cpp looks like right? So the compiler is a piece of software that takes this as input and produces... this as output Um..cat a.out. Are you ready? [screaming] [pause] [confused and angry at code] So this is the interpretation of the context of that code. content of the code in a way that it can be shown to the screen Ok. That code is executable code which means that which means that my operating system knows how to deal with it. Ok the operating system knows how to deal with it. My eyes and my head and pretty much nothing about me knows how to deal with it in this form. But my operating system does, and it likes it! Ok, does that make sense? So the complier is the software that converts from my language that I like which is C++ into a language that my operating system can understand. Clear Does it make sense Ok [pause] Could I name?O yes i can. is it dash O. To name is something else? Is it dash O to name it something else? OK! Alright, you do not like the a.out. O fine. So I can do this so pound C, replicates my previous command that started with a C and then I can add dash out demo. just demo. I will just leave it demo uh oh! O clear O. O. duh bang C
yeah. I'm doing this for no real reason. I shouldn't but I am doing it just to show off. that's working out real well you know what? so this is a teachable moment. so showing off, showing off almost always ends that way. and I'm gonna go ahead and make a general statement that as I was, I was kind of embarrassed by showing off, right, I did something wrong arose out of my showing off. so as computer scientists, I think we kind of like to show off. we can work magic the lot of the rest of the world can't work, right? The problem is, that when we kind of show off among each other, we put up barriers to participation, and barriers to participation creates barriers to progress. Now, the reason that that's so important is that progress is our currency. Right? We are the technologists, we are the people that are pushing forward on what the world looks like, and the instruments that are available to the world. So, this is an issue of equity. What I'm talking about here is I'm jumping on the opportunity to talk about issues of equity. if we're showing off, which sort of implies that we are not listening to people who might go Wait, wait, wait, wait, wait!" then we're cutting off voices that might have a lot to contribute. So, that's just my exhortation to everybody in the room. That we do not show off, and that we be careful to listen and include everybody in our community. I really like our community, they have a cool community. Okay, so I was showing off, and it didn't work a little teeny tiny thing, my ego is not hurt by the fact it didn't work. But now we have something working. So this mean ban cla, the last time I started a command was cla, append -o demo, so this is just string substitution when I can't return right here, this command is what was instantiated and the compiler like it. There were no complaints between here and here and now, these are the files that exist in my current working directory. Any question about that? Alright, and now I should be able to go demo and why it doesn't know which demo I might be talking about, so I tell it. Alright, are you learning anything? My apologies if followup this is... you know. One more thing, I have been talking, when I look here, when I look at the list here, I've got everything in one big .cpp file Now suppose that my neighbor wants to implement something that uses a Sphere. I can go, Oh Virginia! I have a Sphere that I can give to you!", but right now, my sphere is wrapped up in that cpp code. It would be much more convenient if I can hand to her just the Sphere class. That we're creating this object and they might be useful for other code clients. So we want to de-couple the class from the client code. So let's see, my apologies, there may be faster way of doing this. But what I'm going to do is, copy demo.cpp into what I'm going to call sphere.h for now. And then, I'm going to vi demo.cpp And get rid of the sphere class definition and implementation here, and instead, I'm going to tell the system that I need it.
OK, so, effectively what happens very early in the process in that compilation process is that, the compiler sees that this pound include and it goes: OK, you want me to include in this file sphere.h, I will do that for you. OK, now, what should sphere.h looks like, oh let's go look. Uhh, vi sphere.h. And it should contain only the class definition. And in this case we are gonna leave the implementation in there for just a minute. OK? You good? Alright, so now, I can still just compile this thing...I think... Yeah? The part of the compiler that's saw the code saw exactly the same code that I saw before. OK? The pre-processer took the file and put it in here. Alright, and yet I had decouple the two. Any question about it? Yeah? Uh-huh? (Student asking question). So, things are not happening top-to-bottom , exactly, they are happening inside out from main. OK? So, Um... when sphere is seen, when the sphere is seen as a type, the system goes and check: OK, do I have a class definition.". And the class definition is Uh... is only complete. You can only use the thing in the class definition when all of the Uh...when all the implementation are seen, but they are all written into the memory at the same time. So it's already there even if we happen to put it beneath in a linear order. Does that make sense? Does that...so the file is written at the same time. OK? It's just, and there is no linear dependency top-to-bottom. It's when sphere type is used, the class definition that will be there. OK? And it's when getdiameter(), for example, is used, the getdiameter() implementation that will be there. OK? Same for the constructor, just the system always provides you a constructor if it doesn't yet see it. OK? Alright, yes? (Student asking question). Yeah, but don't. I did that just to make the point. It works if you do that but you can't do what I just did here. Right? I separate it out, the class from the client. So then...yeah. Yes, right. OK, oh the class decoration. Yes, that's right. Yeah, you're right. OK, Uh, let's see, Umm...where are we here? Oh, we are not quite done. Oh my gosh! I have some new staff for you. Umm, but we are not quite done, because, sphere.h is intended to be, it's intended to be just a communicate, effectively communication device. It's intended to be just a picture of what the class looks like, not an exposing of the implementation details. So I'm gonna do the same thing again, I'm going to copy, Umm...sphere.h into sphere.cpp. Think this will work, and I'm going to edit sphere.h, oh, abort for ground, OK. Get rid of the implementations. There are couple of different things I can do here, Hmm... Get rid of the...get rid of this. I'm gonna do this kind of hacky for the moment, I'm gonna do this in kind of hacky way for the moment. The non-hacky way is what Umm...your makefiles give you, OK? Then inside the...yeah, I think I will do it really bad. Actually, Hmm...
Hmm... okay.  Typically when you have a implementation file, you're going to include the header file so that the those declarations can be seen. Okay? And now, in order to get the code that I want in place I'm going to put cpp here. *Groans* Cuz I don't wanna deal... ...I don't wanna deal with it Okay. Any question about that? The reason I called this a hack is because the following. Remember my friend Virginia? She just wants the sphere class. The cool thing is that I can compile the sphere separately, and give her  that compiled version together with the header file. And she can use it. Your makefiles will make that happen, okay? But it's a two-step process and I don't wanna do a make file here.  You're supposed to do that in lab, okay? So
Linux. Linux workshop at DCL 1320 tonight at 7pm. Did anybody go last night? The room screw up was totally my fault. It was not the organizers fault. There is no room screw up for tonight. Did you learn things last night. That is all we wanted to know. Okay, so here is what I think you should be good with. You should be good with the idea of class definitions, class function implementation with the scope resolution operator, constructors and when they are used, and client code, and what it means to use a user defined type and class. Especially after spending all day today on it. But there is some vocabulary that we have not yet seen. One way of characterizing object-oriented programming languages is by 3 words you might have heard before but never thought about deeply. Those 3 words are inheritance, encapsulation and polymorphism .... Okay, this is interview prep. They are going to try and trip you up. they are going to see if you have seen this moment. How are object oriented programming languages typically characterized? Now what you will know is that there a lot of different ways of characterizing object oriented programming languages. But what they are looking for is those 3 words. And if you can reel off inheritance, encapsulation and polymorphism, they will go 'Oh wow, this person knows what they are talking about.' But, in case they dig a little more deeply into your understanding of C++. Despite the fact that this is not a C++ class, I want to tell you specifically how we describe the ways in which C++ supports the idea of encapsulation. Now what is encapsulation besides an E-word? It is a separation of the interface of the class from its implementation. Now there are 2 ways that C++ does this. One is that the private region of the class definition protects the data associated with the object.  And so you as the designer, because you believe in this idea, this is what you do in C++. Secondly, this is purely by convention, you already saw today that you don't have to do this, but by convention we separate the .cpp file, the function implementation, from the header file. We separate the function implementations.
Any questions about that? Okay that's just vocabulary. So the same two things. Listen just a minute and do another sort of high level view. So, these circles represent code for a class definition, consider a single class at this point, we've already said that we separate into a header file and implementation file. So the example is sphere.cpp and sphere.h and the vocabulary we use for that .h is interface because I can give you a .h file and you know how to use the class, you don't need the .cpp to get everything you need from the .h file. Now what are all these little blue bubbles? That one is my neighbor Virginia. Here is the main that I happen to use. Maddox came to my office, said hey you got a sphere I can use? I said sure, here's the idea. HEre's what encapsulation gets for you. It allows you to make it so that all these clients can do their business looking only at the interface and it can build a wall , demands that a wall is build between the clients and the implementation. The client can see everything they need to know about the interface and don't need to worry about the implementation. Any questions? It streamlines the communication about these classes at exactly the right level of abstraction. The substance of today is actually memory. If you came from CS125, most of what we've done is pretty much familiar. But it's probably very new if you came from the CE engineering prereq. If you came from the ECE department, you have a pretty good handle on memory. We do talk about this stuff and should be comfortable for CS majors and ECE majors but DO NOT click out because there will be a few things about the wa C++ refers to memory that will surprise you even if you have seen it. So there are some things here that are importa If the memory that you choose when you buy a new machine you decide how much RAM you're gonna pay for. The memory at the system's disposal when it's executing your code and processes it and producing results. All of the software sits as it executes mostly sorta. It can be a constraint on the performance of your machine if there isn't enough of it. 
Into a .cpp file. Okay? Alright, any questions about that? Alright, that's just vocabulary. Okay, so I wanna do this  Those same two things are here Lets spend just a minute and do another sort of high level view. It's okay. We are fine. We are gonna be fine for this semester. Wouldn't do another high level view. So, these circles represent called for a class definition. So consider a single class. The example that you have is this sphere class at this point. We've already said that we seperate into a header file. and an implementation file. Okay, so the example is sphere.cpp and sphere.h And the vocabulary we use for that h is interface. because I can give you a .h file and you know how to use the class. You don't need the .cpp. You can get everything you need just from the .h file. Now, what are all these blue bubbles. Well I'll tell you. You know that one is my neighbor Virginia. Here's the main that I happen to use. Mattox came to my office the other day and said. Hey Cindy you got a sphere that I can use and I said sure. Here is the idea Here is what encapsulation tells you. What encapsulation gets for you. It allows you to make it so that all these clients can do their business looking only at the interface  and it can build a wall, build a wall, it demands that a wall is built rather between those clients and the implementations. So, the client code can see everything they need to know about the interface. and they do not need to worry about the implementation. Any question about that? That's really nice because that streamlines the communications. Could say communication about these classes that exactly the right level of abstraction. Okay That's not what we are talking about today. The substance of today is actually memory. Alright, so if you came from, if you came from cs125, most of what we have done is except for the fact that it's c++, pretty much familiar. but it's probably very new if you came from the computer engineering prereq class 220, if you came from 220. a.k.a KL, a.k.a 190, a.k.a AHH But, vice versa, if you came from the ECE department. You have a pretty good handle on memory. Wait which way is it I don't know what I said before. Okay, we just talked about the stuff that should be kind of comfortable for CS majors we're about to talk about the stuff that should be pretty comfortable for ECE majors.  But, do not click out. Because there will be a few things about the way C++ refers to memory that will surprise you even if you have C in your backpocket. Okay? So, there are some things here that are important Okay, so we are gonna talk about memory Here's the memory we are talking about It's the memory that you choose when you buy a new machine When you decide how much RAM you are gonna pay for. That's the memory we are talking about The memory at the system's disposal when it's executing your code. When it's bringing data in, process from the derived, processing that data and producing results. It's where all of the software sits, as it executes, mostly, sort of. And, it's, you know, it can be a constraint on the performance of your machine if its excuse me if there isn't enough of it. So what is this?
Its a map. I forgot what it was. I think it is somewhere in Silicon Valley. Doesn't it look amazingly like a chip. I was like wow. Yeah. So heres the thing. Theres a really nice metaphor between you know, your basic neighborhood and memory. That is particular parts of memory are designed to be used for particular things.  Now, theres you know the. Lets see the schoolyard. Every community has a school yard. Ever map has a school yard. Right? Here it is here. You can tell because it looks like a school yard or a prison. And similarly memory has memory has places where everybody throws the data and maniuplates it. Its very regimented like a school or prison. How many times can I use that joke? Thats my question. And will it roll off quite so well next hour. Like I do not know. Okay, so just like a neighborhood has particular locations memory does too. And just like a neighborhood has places you cannot or should not go so does memory. The parallel in our world is the seg fault. The seg fault occurs when you go into a corner of your neighborhood where you do not belong. Where you access memory that does not belong to you. Okay enough with the metaphor. You're telling me I'm down. I see I have two minutes. Pen is in my hand. Okay. Oh you're turning over your slides. No. Alright, so we already dicussed the fact I'm starting on next slide. I am going to do this in minute and a half. Okay. We already discussed the fact that when I say something like int x equal five. In memory the following thing happens. A location is chosen for you. Its name is not. The name of that memory, the address of that memory. Again the metaphor address or map. The addresss of that memory. I do not care about. I don't care whether the system is using letters or numbers. Thats not the level the of abstraction we care about in this class. Now 233 probably different. We do not care. The name of my variable here is x. I happen to have instantiated it with a value that is five and its type is an integer, which tells the system just how much memory it needs. Now here's the cool thing. This thing that happens automatically when I say int x equal five. This thing that happens automatically. Think about what had to happen. Memory was looked for. The variable names were set up. The value was you know the bits were flipped so that the value is represented, etc. That was all taken care of for me by whats called stack memory. The system took care of it and it put my variable in stack memory. It set it up for me. No problem. I did not have to ask it do so. Effectively I was asking it to do so just by making the declaration. So this stack memory is system administered. And the nice part about that is when I am done with that variable, the system will also say, oh look she is done and will clean it all up for me. Now you don't you wish there was a metaphor that, but it never happens. Okay, so thats it for today. Stack memory. You love it.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
No audio.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  You need to post to Piazza to figure out who that is. Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Yes. No it's not right. Alright, so I am going to make this joke again. Alright, everybody sit down please, let's get started. I'm going to make this joke again, so if there's anybody in this room with a stapler, now's a good time to um make a lot of money, because there are people up here who need stables and you can say I'll staple your homework for 5 bucks. Um, I would prefer they be stapled. If you don't um, if you are unprepared to turn these things in, um, you need to make arrangements with your section leader to do so. I think we're fairly accommodating on homework zero, and moreover I apologize for the sort of lack of smoothness here. We admit that our system is bad but it's only one homework. So it's only bad twice a year.  We aren't putting a lot of resources into it. Let's see. What else was I going to announce? Don't know.  
Oh I know. So we have as I think you're all aware we have not yet posted the semester calendar for open lab hours. Um which is a problem because mp1 is due tomorrow night. Now here's our plan. We want to set an open lab schedule in stone and have course staff commit to it through the semester and it's taking us a while to settle in to exactly what that schedule looks like. So my recommendation for mp1, we'll get this straightened out don't worry. My recommendation for mp1 is to go to the piazza and look for course staff availability over the next 36 hours. Go and look and if course staff says they're gonna be available then they should be. They're committing to it, and your process for getting their help on debugging your code is to go to chara.cs.illinois.edu and put your name on the queue and be sure and put the room number in which you can be found because course staff will wander all over the basement of Siebel looking for you as long as you tell them where you are. Ok, any administrative questions or comments? Our intention is to return these to you in lab next week. We're probably not gonna get them to you this week. Just in all honesty here. Ok, let's work. Last time, yes? The lab section leaders eventually will be on the website too, but we're still finalizing those so the best thing to do is post to the piazza asking. Say who's in charge of section blah... And they will answer. It's not a huge, you know, we'll work it out even if you get in the wrong bucket we'll grade it and find you. It'll be ok. All right, any other questions, administrative issues? Ok, so let's start. Last time we were here. We talked about declaring and initializing variables of primitive type. And we made special note of the fact that all that happens is that this system-administered process for setting your variable up in memory takes care of finding where your variable should go. I'll put it here. Um, connecting the name of your variable to its memory location, keeping track of its value, and also keeping track of its type. Ok? And that was all just done for you upon a statement like this. Now, all of that is still true for user defined types. So we can say sphere y; and the system says Oh! I've got plenty of memory for you. I'll set that up." And all of this then is set up to denote a sphere. What's the value of the sphere at this point? This is a trick question. In what case is it garbage? If you don't have a constructor that's right. So you can use the constructor here to initialize that variable to have meaningful data.  Ok. any questions about that?
Yes. That's right, that's right. That invokes the no argument constructor. That line invokes the no argument constructor. Ok? Either the default one that's provided to you or the one that you have written. Now the default one that's provided to you will still set up theRadius and what other variables, but those values will be garbage. Unless theRadius is the kind of thing that has a constructor. Ok, but that's not what we're talking about today. So, suffice to say the system will still take care of setting up and administering the use of memory.  That is, it will detect when you're done with the variable and give the memory back to the system for somebody else to use. So nice that way. All right, now there is another kind of variable, so this is primitive-type user-defined types and there's another kind of variable that you may not have seen before. That kind of variable is a memory location. Explicitly a memory location and here's how we declare one. I would say int pointer p" Ok, now what happens is the system says Oh I see what you want here, you need a memory address," Oh, I don't know a52, p, its value is not known here, its type is the memory address of an integer. Now, I said the words memory address of an integer. But what I'm going to write is this. So these things are equivalent memory address of an int is equivalent to int pointer type. Ok? Any question about that? So just symbolic substitution there. All right, fine. So among these, from everything you see here, what's a valid value to go here? What could go here? What's the only thing given this diagram, yeah?  Yeah, so the memory location associated with x Because x is an integer is the only valid thing that you can put in this spot. Now, hmm, how do we make that happen is the next question. Any questions before I go on? Yes? Oh boy, we're gonna spend about the next 2 weeks seeing uses of this ok? Excuse me? Bit shifting? Maybe In some contexts. But there are others that come immediately to mind and I'll give you a heads up. Here's the heads up:  Data itself is huge. Pointers or memory addresses are small. So when you have a big chunk of data like a photograph or a movie or something and you don't wanna be passing it around, passing all that data around, you can use its memory address to refer to it from all kinds of different places. Ok, so that's kinda the biggest thing to keep in mind as we go forward and talk about these things. Ok? Does that help at all? But that's way foreshadowing, that's like Wednesday's lecture, ok? The question is, the question is how do we give p value? We all agree that our intention here is for p to point to, to contain you know a20 here. I should connect the dots, but I'm not going to because that's the mystery. The question is how do we assign to p? Well, what do you think of this? What do you think of that? Maybe I can give p x's memory address simply by having x on the right-hand-side and the system's smart enough to go Oh, I know what you mean." Is it? No. Ok, how do you describe what's wrong here? What gives you heebie jeebies about this assignment statement? Type mismatch, that's right, the thing on the left is an integer pointer, the thing on the right is an integer. That should be coursing through your veins as you read code. So this is a type mismatch. Can't do this, it's a type mismatch.  Ok, fine. Maybe what you do then is simply explicitly assign like 0xa20 there. What do you think of that?
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
What do you think? Blake. You like it or no? This one's a little harder to articulate why you don't like it, right? So these are memory addresses. Do you wanna say something? Right. Very good. Very good. Good point. So he says well how do you know the memory address of x and that's exactly the right point. Remember we said the system gives you memory addresses in stack memory, right? It says here it is. We're gonna put this right here. At the programatic level, at the client code level, we don't know where that is. We have no idea where that is. In fact, those memory addresses are designed for the system to use. And you know what? Their representation reflects that. The representation of the memory addresses themselves are in hexadecimal. They're almost unreadable and I for one don't ever want to know where x really is. Now, I understand that if you are concerned with the low level behaviors of the machine, you  care. But we will not care. We are gonna let the system handle its memory address representation. So, what we need this so we're not gonna do that either. Hold on, so we're not gonna do that either. And the reason is that we don't know where x is nor even how to represent a memory address. [no audio] Okay, so the solution to this problem involves an operator called the address operator. [no audio] And here's how it works. I can assign to p the memory address of x. So that ampersand when it modifies a variable pulls off the memory address and returns it. So that they can be assigned to the value of p Any question about that at all? So the result and notice at the programatic level you never actually need to know what this value is. You're effectively just referring to it through that ampersand sign. Any question about it? So what happens in the backside is again what happens to be represented by a20 here is returned. And then assigned to p So, in the end it looks like this. Now, I happened to like a different mechanism for drawing this. A different way for sketching what this looks like. I like to do it like this. When a pointer is declared, I like to make a little box with a dot in it. When other variables are declared, I like to make rectangles because they're kind of bigger somehow. And then, when an assignment like this one is made, what I'm saying is that p points to x. I believe x had a 5 in it. Alright, now, here's the thing. Right now, these pointer variables are not particularly useful to us. So let's pretend for a second that we had this memory setup but we happened to not have x labeling that space and we'll see many more examples of this later but let's think about this now. So suppose we didn't have x labeling that space. Is the setup completely worthless to us? No, so if we have a pointer variable, probably we are interested in the value of thing we're pointing to. The value of the thing we're pointing to. We can get at that value using yet another operator called a dereference operator.
Yes Right because they both go off the stack those are freed for you yes? Um yeah because its an array ok you need the brackets because its an array if it were just a pointer if we had instantiated this as just a string pointer, right a pointer to a word Then you wouldn't need the brackets, you would just delete it ok so  in general in general your deletes should match your news whatever kind of new statement you use to create the thing usually in your constructor youre going to use a similar thing in your destructor Any questions about that? Is this good? yeah? Its called right after the return  As this um execution completes and control is passed back to the calling function All right Any questions? you good? Ok I'm going to show you, yeah? Oh my gosh there is so much book keeping going on for you We are so lucky right? like our, your grandfathers, my parents Ah i shouldn't have said fathers there look at that Your grandparents in computing my parents in computing ummm they think that life is way too easy for us Actually its probably my grandparents your great grandparents but um they think computing is way too easy for us  And in fact you know the fact that uh we don't actually have to keep track of what variables were using ourselves is just  uhhh you know were not authentic programmers so  the early days of c were pretty pretty harrowing i think so theres a ton of bookkeeping that goes on  and part of what they keep track of is what amount of memory is associated with each variable all right and you'll learn about it in future classes because of course thats what generations do right you work to inflict the pain of previous generations on the current all right um any questions about it any other questions? you good? Ok i have another story to tell you here Im gonna take you through another little piece of code umm heres how this piece of code goes This time Im going to declare a sphere pointer b Ok so heres b And I'm going to ask for a new sphere Now we've made a constructor for a sphere we made a constructor a sphere that sets up a uhhh a default sphere to look like this so when i say new sphere that constructor is called for us so at the end of this statement its perfectly reasonable for me to draw this picture making note of the fact that the sphere constructor was invoked for us not the copy constructor, the no argument constructor ok, any question about that? ok  now lets look at what happens when we say  delete b what do you hope happens when you delete b when you say delete b what do you hope happens by default what do you hope happens All of this memory all of this memory is given back to the system right by default without the destructor only this part is given back no dynamically allocated memory no memory allocated with a new is given back so again were responsible for writing a destructor that makes that happen this is the same destructor its just used again so if you remember that code looked like this
Excellent question, can I answer that question on the next slide? So the question is ... what if you don't have an x but you have an integer pointer, does that summarize your question? Okay that's here So it turns out that you don't want to always have a stack variable to represent your, to have to point to  and in fact in this situation if you have that stack variable , you probably should just use x. All this indirection that's just play, as often as you can you just want to use x. So what are we doing this for then? What is the deal ? The answer is we have this other chunk of memory This other region of RAM called heap memory  and it is memory that you control. That is you control when something is allocated from it and you control when the memory is given back to the system to use. Stack memory was system controlled and Heap memory is programatically controlled Now how do we do this? Again I got it set up so we have an integer pointer p and I want to ask for a chunk of memory. I'm going to do that by saying p = new int  This is explicitly asking for that integer. Yo heap I need some memory and the heap hands me back a memory address the size of an integer somewhere  and this assignment statement gives that memory addressÂ  to the value of p Any question about that ? And there is no x in sight, there is no stack variable in sight And in fact we don't generally have a name for this  the name of this is really *p or the dereference of p, this target of p Yes? [pause for question] It creates a new one, it creates new space on the heap So p is, I don't know what you ummm, it , when you declare it it sets it upon the stack and then you can use, you can use that spot on the stack as much as you want [pause for another question] Right here? this assignment? Are you talking about b24? Show me what your talking about, okay p = new int [question] It will go to p's spot because p is on the left hand side, does that make sense? It's not scary to ask a question cause I might ask you to .. Okay yes? Yes very good, I can say sphere *s, s = new sphere and the sphere the sphere constructor is invoked but in this other space I've got an s and this thing is going to point to whatever that thing is. Any question about it? [question]
Oh, excellent question Can I answer that question on the next slide? Ok the question is, what if you dont have an x But you have an integer pointer, does that summarize your question? So it turns out that you dont want to always have a stack varibale to have to point to In fact, in this situation, if you have that stack variable, you know you probably should just use x, all of this indirection, that is just playing as often as you can, just use x so what are we doing this for then, what is the deal, and the answer is, we have this other chunk of memory, this other region of ram effectively this other region of ram called heap memory, and it is memory that you control that is you control when something is allocated from it, and you control when the memory is given back to the system to use ok, so stack memory was system controlled, and heap memory is programmatically controlled ok, now how do we do this again, I got it set up so we have an integer pointer p, and I wanna ask for a chunk of memory I'm going to do that by saying p = new int this is explicitly asking for that integer, yo heap, i need some memory, and the heap hands me back a memory address the size of an integer somewhere and this assignment statement gives that memory address to the value of p ok, any question about that? and there is no x in sight, there is no stack variable in sight, and in fact, we dont generally have a name for this, the name of this is really asterisk p, or the dereference of p, the target of p, yes? It creates a new one, it creates new space on the heap Ok? It asks So p is, when you declare it, it sets it upon the stack And then you can use it, you can use that spot on the stack as much as you want Right here? This assignment? Are you talking about the b24? Show me what you're talking about, ok so p = new int Yup It will go to p's spot, because p is on the left hand side, does that make sense? OK It is not scary to ask a question because I might ask you to Yes, very good, yes, I can say sphere * s s = new sphere And the sphere constructor is invoked, but in this other space Then i've got an s, and this thing is gonna point to whatever thing that is Any question about it?
The name is the only thing missing.  The type has to be integer, and the value (how do we give it the value as we only have x?)...  Here's how we give it value.  We say the value of p equals 42.  So we know P, you follow the pointer, and you put the value inside.  In other words, P is a pointer, we ask for a new integer, it has no name but it is a box.  We assign that one to P. And then when you do this statement When you do this, this says go to P, follow the arrow, give it value 42.  Yes, that's right. You still have to assign value to it otherwise it is garbage.   In fact all constructor rules apply there.  Alright, yes.  Possibly, yes.  And also so the system is going to decide when you are done with P, based on the scoping.  When you are done using P, when your function execution stops, P is going to be gone.  This won't be.  This will persist until you say you're done using it.  Okay?  Yes?  Umm, if I have the right constructors made I can.  So if I have a sphere class constructor that takes a radius, I put a radius there.  Okay, are we good?  I think the best way to get up to speed with this material is just to practice.  So we're going to spend a few minutes practicing.  Yes?  Yes! So I'll say this, because I think it's helpful.  New is a function.  In C++.  It takes an argument. The int, the type, is the argument to the new function.  What does new return?  A something pointer.  That's right.  On the left hand side you have to have a pointer.  On the left hand side of the assignment statement you need a pointer.  So you know that new will return new a pointer type.  Oh! Okay, now you're asking for me to keep going.  Alright, I want to show you something that's very fun in that it's part of your cultural heritage.  Before we go on though.  Okay Much smoother about this this hour Nope nope no I don't want you  And Okay ready?  Okay.  Hey Binky, wake up!  It's time for pointer fun!  What's that?  Learn about pointers? Oh goody! Well to get started, I get we're going to need a couple pointers.  Okay!  This code allocates two pointers for integers.  Okay well I see the two pointers but they don't seem to be pointing to anything.  That's right! Initially, pointers don't point to anything.  The things they point to are called pointees.  The pointees are separate. So how do you allocate a pointee?  Okay, well this code allocates a new integer pointee, and this part sets X to point to it. 
The name is the only thing missing. The type has to be integer, and the value, oh geez!  How do we give it value now because we longer have x right? Here's how we give it value.  We say the value of p equals 42.  So you go to p, you follow the pointer and you put the value inside. In other words, p is a pointer, we ask for a pointer, it has no name but is a box. Ok, we assign that one to p, and then when we do this statement, that says go to p, And then when you do this statement, follow the arrow, give it value 42. Yes, that's right.  You still have to assign value to it otherwise it is garbage, and in fact all constructor rules apply there Yes ....... possibly.... yes, and also this memory, so the system is going to decide when you are done with p based on the scoping so when your done using p and your function execution stops, p is going to be gone. This won't be.  This will persist until you say that you are done using it. Yes, if I have the right constructors made, I can. So if I have a sphere constructor class that takes a radius, then I can put a radius there. Ok, are we good?  I think the best way to get up to speed with this material is to just practice.   So we are going to spend a few minutes practicing.   Yes, so I'll say this because I think it is helpful.  So new is just a function in C++.  It takes an argument.  The int , the type, is the argument to the new function. What does new return?  What does new return?  Yes, ... a pointer. How do you know that?  Because on the left hand side you have to have a pointer. On the left hand side of the assignment statement you need a pointer, so you know that new will return you a pointer type. Yes? .......... Ohhhhh ok, now you asking me to keep going ok?  I want to show you something very fun that is just part of your cultural heritage. Before we go on though.... Ok... I'm much smoother about this hour.  I don't want you, I wan't you. And... Â  Â  Â  Â  Â Ok, ready!  Ok! *POINTER VIDEO BEGINS* Hey Binky!  Wake up! Its time for pointer fun. What's that?  Learn about that? Learn about pointers? Oh, goodie! Well to get started,we will need two pointers.  Ok, this code allocates two pointers which can point to integers.  Ok, well, I see the two pointers but they don't seem pointing to anything That's right.  Initially pointers don't point to anything.  The things they point to are called pointees. Setting them up is a seperate stem.  Oh, right.  Pointees are separate.  How do you allocate a pointee? Ok, well this code allocates a new integer pointee, and this part sets x to point to it.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
[Video Playing] I want to add one thing to this that is captured by the video that I sort of forgot to say, and that is if we also have integer pointer q, so he had, and that is set up somewhere in memory. You know, who knows where? And if I say q gets the value of p, this whole pointer assignment thing totally makes sense.  It's not magic at all because, think about what it means for q to get the value of p. It means b24 is copied into this space, right? B24 is copied into this space. So after doing so, q refers to that same memory address. So that whole sharing thing, it wasn't magic at all, okay? All right, any questions about it? Any questions about that? Okay, so like I said, practice is golden here, so let's spend some time practicing, yes?
P equals q. Yeah, cause q currently has garbage, right, yeah. He asked about the inverse assignment. Okay, fine. This first page is warm up. I think we should be able to kind of crank through this based on what weâve already seen. Okay so what type is q? Raise your hand if you think it is a pointer type, q is a pointer type. You know you would hope right, but it turns out the asterisk * actually modifies the variable. So in this example q is an integer. If you want it to be a pointer you have to say, âint pointer p, pointer q. And this chaining is fine, it just sort of, itâs a little idiosyncratic thing you need to know about. Okay so letâs do this next one really quickly. Iâm going to draw the pictures itâs very similar to what we saw. Integer pointer p itâs declared. Integer x itâs declared. P gets the address of x, makes p point to that space. The value of p, okay so we follow the pointer p, get six. Now what happens when we output x? It is a six. We have changed the memory associated with x underneath it. What if we output p? What do I get? Iâm outputting p, the next line, oh man I donât even want to know what I get.  This is a horrific hex number which represents the memory address of p. Alright now write a statement whose output is the value of x, using variable p. Iâm going to do this one really quickly, you can race me if you like. Asterisk * p That end line is just a new line. Did I say memory address I meant dereference of, sorry, cout the value of p. Write a statement whose output is the value of x. Oh, oh yeah sorry. Good catch. Iâd like to say I did that on purpose giving you a chance to like engage, but that would be a lie. Alright, good. Good. Good. Good. How would I output the memory address of p, how could I make that correct? Aww I should have thought of this.  I donât know what youâre talking about, and then I would have done what? Yeah the ampersand & p. Cout ampersand & p, gives you address of p. Okay, good. Alright, any surprises? Anything on this page surprising? Okay now letâs get to some nitty gritty. Okay. Alright, so I have these two pointer variables. You can probably go all the way down to here. Letâs meet here. Iâll do it and Iâll talk aloud, but you can tune me out if you would like to think separately from me okay. So this code says Make me a pointer p and a pointer q give p an integer and point to it make q point to the same space use q to give value 8 there and now output the value p What do we get? 8? Yeah. Okay. I strongly encourage you to sort of trace these on your own. Okay, now letâs do down to here. Go ahead and trace down to here. Add on. So now q gets a new integer and is assigned to it  and the value of q is 9. K, so you should have the same picture. p and q each have their own memory available to them they are not shared at p's new Yes. 
ask about the inverse assignment Ok, fine, this first page is warm-up Ok, I think, I think we should be able to kinda crank(?) through this based on what we have already seen Ok, so what type is q? raise your hand if you think it is a pointer type you know, you would hope right? but it turns out the asterisk actually modifies the variable So,  in this example, q is an integer . If you want it to be a pointer, you have to say int pointer p pointer q and this changing is fine, it just sort of, this is a little, idiosyncratic thing that you need to know about Ok, so lets do this next one really quickly , I am gonna draw the pictures, it is very similar to what saw integer pointer p is declared , integer x is declared  p is the address of x, makes p points to that space, the value of p, so we follow the pointer p got 6 now what happens when we output x? it is a 6 right, we have changed the memory associated with x underneath it Alright, what if we output p, what would I get, I am outputing p, the next line, oh man I don't even want to know what I get ok, this is a terrific hex number which represents the memmory address of p Alright,  write the statement whose output is x using variable p, I am gonna do this one really quickly, you could race me if you like asterisk p, that endl" is just a new line, yes? Emm, did I say memory address , I mean dereference, em, sorry c out the value of p write the output whose value is x, oh, yeah, sorry you catch, I'd like to say I did that one purpose , giving you a chance like engage but that would be a lie Alright, good,  how would I , how would I output the memory address of p, how would I make that correct , oh I should thougt of this I don't know what you are talking about , and I would have done what yeah, the & p.  c out & p gives you  address of p , ok Alright, any surprises? Anything on this page surprising, now lets get to some ........... Alright, so I have these two pointer variables, you can probably go all the way down to here, lets meet here, I will do it and I will talk aloud, but you can tune me out if you would ilke to think seperately from me ok? So, this code says make me a pointer p and a pointer q give p an integer and point to it, make q point to the same space, using q to give value 8 there, and now output the value p, what will we get 8? yeah, ok. I strongly encourage you to trace these on your own  ok, now.  lets do down to       ...........  here, go ahead, go ahead and trace down to here So, now q gets a new integer , and assign to it, and the value of q is 9 ok, so you should have the same picture p and q each have their own memory avaliable to them, they are not shared the piece, new , yes
Yes New is a keyword that we use. Its modified, its followed by a type Its arguement is a type It returns a pointer. It's a keyboard that returns a pointer. Okay Alright, so p equals. Alright, any questions about the picture so far?  Let me tell you about NULL Let me tell you about NULL NULL is a canonically zero memory address. K, so NULL is a canonically zero memory address Not garbage, its not garbage and the main thing that differentiates it from garabge, is that you can test against it. You can say if p is not equal to NULL, or if p equals NULL K, so the key point is that is that it is testable. Whereas garbage, not so much. Alright, so now all we are saying is Never mind, I don't want p to point to that old memory anymore. I want to set it to this canonically zero memory address. Okay, now. You like this? Why, not? Yeah What about p's pointee, look at this. We went to the effort of asking for that memory. We said, Yo heap please give me some memory. It did so, and then all of the ways of referring to it were removed. All of the variables essentially turned their backs. Okay. You can tell, because you can look around 8 and there's nothing existing coming into it anymore. This makes me very sad. And, in fact, so sad... Drip. Drip. Drip. We call it a memory leak. Okay, so a memory leak occurs when all reference to heap memory are removed. Okay. Well, this is a pain. How do we fix it? The answer is we fix it by using keyword delete. So delete is the keyword that we use to say, okay, I'm all done with this memory now. The system can reuse it if it wants to. So in this scenario what we're going to do is say delete q. We're going to say delete q. That frees this memory  And now we can say q is equal to NULL and we have not created a memory leak. So how could we have fixed, how could we have fixed the p leak. That will be funnier to you when you have children. How could we have fixed the leak around variable p. How could we have fixed it? Yeah. Right. Exactly. So he said we could have not set it to NULL before deleting it. So I could have said delete p right there. Free the memory then set it to NULL so that its testable. Yes. If you say star *p equal NULL you'll get a type mismatch, because *p is an integer. *p means the value of p What you are pointing to, and that thing that it is pointing to is an integer. So you'd have a type mismatch across the assignment statement. That's right if you set it to NULL before deleting it you cannot fix it. Its a memory leak We have tools to help us, but we should still play defense here. Alright, anything else, anything else about this that's interesting? Yes. Oh, oh, that gosh. You guys are amazing, its my next slide. Alright. Okay so everybody looks, wait a minute we're not quite done with this one yet. So deleting a NULL pointer, so saying delete on q. Is what we call a no op, that won't hurt anything. That's a no op. But, dereferencing a NULL pointer, think about what that says. It says follow the pointer coming out of this thing that is NULL. There's no place to go. There's no place to go out of a NULL pointer. It points nowhere. Its just test-ably nowhere. This is called a segfault. And it happens at run time. So actually dereferencing a NULL pointer is kind of a bad bug.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
okay alright so uh the question on the board is what happens if you have two pointers that point to the same thing like this heres the set up you delete the memory through one of them and this is a to be continued dun dun dun its tru;y a cliff hanger because this is insidious
Okay. Alright. So the question on the board. The question on the board is: What happens if you have two pointers that point to the same things? Like this. Here's the set up. And you delete the memory through one of them. And this is a to be continued... Dun dun dun... It's truly a cliff hanger because this is insidious.
Can you hear me?  Can you hear me in the back? Can you hear me in the back?  Can you hear me in the back? Can you hear me in the back?  Can you hear me in the back?  Can you hear me in the back?  If you could hear me in the back, stand up  You're not the back. Ok. I think this is good, do you agree this is good? The back row, the back row, you speak for the trees. Alright So last time we were talking about pointers and their behaviors in C++. And we're going to continue that discussion Right now, I want to show you a little bit of code that I think will surprise you Oh and I have a present for you, are you ready?  Ready for my present? Woah. Not sure I like the color scheme but I mess with my, I mess with my config file. So you should find the code a little easier to read.   Okay, so draw yourself a little picture. Process this code, it's got pointers which we learned all about last time. Draw yourself little picture about of what's going on here. I think you should have at least one question, but I also think you can guess at the answer to the question and you will be right. Oooh. We are speaking mysteriously here. And then we'll talk about this a little bit, so, you're going to have a question, guess at the answer, and of course, guess at the output here Alright. Draw yourself a picture. Draw yourself a little picture and guess at the output of this. 
Okay, turn to a person sitting next to you and see if they drew the same picture you did.   And ask them what they think the output will be. [Talking to students] Up there.  Yep. Yes so I haven't started the node stuff yet.  I might end up replicating them. Alright somebody speak for the crowd what you think the output is going to be? Somebody tell me... Yes? [Student answers] 25 for the first one and... how about that second one? Garbage for the second one. Ill tell you right now that that would be good news because the intention here is clearly to be done with that memory right?  That is kind of what we are saying when we say delete p we are saying we are done with p now. We can use the memory assosciated with p, but heres the problem.  uhhhhhhhh Ready.  Ready for this. Ohhhhhhhhhhhhhh Okay.  So look at your picture you have p and q pointing to 25 right.  And you basically, when we said delete p, all you did was make that memory available for the system to use again.  You did not pull back the pointers effectively.  The pointers still point to that space and that space for the moment still holds 25. Any questions about that? So I could do this as well.  I could do even after I delete p, I can ask for its value. (talking to herself) My hands are shaking today I do not know why. And still I can access it.  Yikes! Yes? [Student asking a question] Thats a really good question.  Um so any other application can also use it at that time, but for our purposes we do not need to think about it very much.  It depends on the virtual machine that is set up around that memory. Okay. Alright so but for our purposes you do not really need to think about other processes because you dont even have to its broken anyway.  Watch this, let me see if I can make this happen. Alright so we deleted p which means we gave it back to the system to use. For example I can say q equal new int.  What value should we put in there? 5 okay.  Fine.  And now when I say... uhhh the value if I ask for the value of p. So I am going to change this to a new hue.  Lets see what happens. [output on screen]  before del p: 25, after del p: 25, after new q: 5
how did that work? what happened there? do you need a picture? yeaaaa! this is insidious! lets look at code again because this is just nasty look look i shouldn't being using p's and q's they look to much alike right? i ask for the value of p? the only thing, the only thing that has a five in it is...? is Q and that should be brand new space, right? the problem is p is still poiinting to where it was before and the system happened to, happened to reuse that space okay so lets draw a picture? Ill do it on my slides in a minute in a similar context we'll do it here for now here is p here is q ok? we originally set things up like this so that p is pointing to this space  and q is pointing to this space ok? now we deleted p which mean't we gave back this memory for this system to use and then we didnt pull back this pointer we reassigned this pointer we said okay i want a new q ideally I wouldve been able to draw aÂ  seperate box here but guess what space the system used? it used the one we had just freed it happened to have chosen to give us that very same space which we initialize to have value 5  but think about P right? its like returning to the earlier part of the story, p still happens to refer to that space we didnt pull back the pointer so now when we ask for p we get 5 not because p was ever assigned to 5 or was intended to point to memory that we were using to have value 5 but because we left that pointer dangling into space and it got reused okay? yes? so that was, I was actually gonna do that so the question is would the space be reused again, what would happen if we used a different data type that is if that box didnt fix quite so neatly lets try that out because i dont want to do it incorrectly so lets a declare a new thing uhmuhmhm and lets declare a new thing a double r and let Â new double doubles are different sizes and we'll make it 5.0 and well see what happens okay? did i screw something up? its not a pointer  you all have that and i didn't did you see it did you see what i did i didnt make it a double pointer so new handed a double back or a pointer back and thats a type mismatch across the assignment to r okay so it didnt preserve, oh it still worked tho okay so it changed memory in such a way its not 5 and its not 25 and its not  you know we still ask for an integerÂ  so the moral of this story is the systems kind of using memory as it sees fit and so you have to be concious all the time of where you're pointer is pointing the safest thing to do is once you delete space be sure to set all the references to it that could be pointing to it to NULL so we can fix this if we had set p to NULL up here delete p, p = NULL and then whats gonna happen then what will happen Â yea right
Phew Ok, any questions about it? I'll be happy to indulge any of your questions.  You had a question when you came in? Oh, you did. Did this get at the question you had when you came in? Ok, what was your question. It was a good one. [Student responds] Oh, ok good. We'll try that one too. Alright, so let's go a different example. Here you don't want ... you don't want to even initialize the value, right? You wanna try that? [Compiles code] [Segmentation fault] [Modifies code] Alright, so do you all see his question? He said what happens if you try to give p value before asking for heap memory to be associated with it. And the answer is, look, you didn't ask for memory and yet you asked for p to be dereferenced so as to assign a value. That moment right there is a seg fault, that's where you're trying to access memory that doesn't belong to you. Alright, so the upshot of that lesson is, before assigning values, to be sure to ask for heap memory to be associated with your variable. Any questions about it? Good good. Ok, yes? [student asking question] [Opening other example to answer student question] Alright, so you are asking me, after I set this to NULL... Oh, I never ran this one, did I? What are you asking me? Go ahead and ask again, sorry. This one right here? Yeah, ok, so why doesn't it print NULL there? So the pointer is a variable with a type and that's a pointer type, it's not a string type. If it had said the word NULL, it would be reflecting the fact that the contents of the variable was a string or something that we could represent as a string whose value was NULL.  Now, in this context, you might find that more helpful, but in fact, NULL isn't a string that's spelled N-U-L-L. It is a memory location that we happen to represent by that word. Moreover, it is a memory location that cannot be dereferenced. It cannot be followed. There's no place to dereference it to. And so the error message if you tried to do that is a seg fault. Because you're trying to dereference something that isn't yours. Ok? Alright, yes? [Student question] No, very very very good question. And that makes me think you're ready for the next slide, because we're going to talk about that. So, her question is, are p and the thing it points to two separate variables? When you give back the memory, when you say delete p, does that variable still exist for reassignment? And the answer is yes, watch this. I can in fact say here p equals new int and ask for a different piece of memory to use p to point to. This gets it, right, at her question. And then I can ask for the value of p. No, what'd I do wrong. Ok. [exasperated sigh]
OK. umm. OK, here we go.  So I redirected the memory and reassigned it to work perfectly fine.  Alright, yes, you're free to ask questions now   That's right. Q no longer has as it's same target, P. It's still pointing off to where it was before, it didn't follow along. Okay? That's actually a really good point. Let's draw this picture really quickly That's actually a totally valid point. Alright, so, P = new int We delete P. Set P = null. Nice. And now we reuse P. So now, we say Okay we changed our mind, we'd like to use P again" And we're going to put 42 in there. Q still points over here. Q is still just a pain in our side. Kay? So. How do we solve that? This should be a gimme at this point. How do we solve the Q pointing there? q = null, that's right. And a reasonable place to do that would be at exactly the same place we said P = NULL So, the minute you couple the two variables via an assignment, you want to keep note of that fact. Yes? Oh, geez, then it's working for no good reason! Right? So, then your things are tangled up still, but they happen to work correctly  So this issue of being responsible with your memory is actually quite deep. Yes?  Yeah, you can, so you can mess up your friends, yes. And this is a security flaw, this is a common... when people are looking for exploitation of C code this is the kind of thing they look for. Access to pointers that haven't been cleaned up. Yes.  Yep. Because then they're just sitting there and they're both separate.  Then that couples them back together Oh! If P is equal to.. is q already null?  Yeah, that's fine. That sets q equal to null. So then they're decoupled. Right, that's right. NULL breaks everything. NULL breaks all association. It is a perfect place to start and end with your pointer variables. Yes?  Yep Yep Yep, so from the start you're kind of toasting yourself. Oh! And this is a good reason... Novice programmers, new programmers like to assign extra variables for everything. Like Oh I don't have something pointing to that, I'll just make one." And the danger in doing so is that you do lose track of the way that things are coupled.  We test you on this in MP3. MP3 has a crazy confusing function in it that is really only crazy confusing if you give yourself 150 extra variables and it's very tempting to do so, but you don't have to.  So, using fewer references or pointer variables is a good idea. Use the ones you have. Understand what they're for. Don't do gratuitous variables just because you think you might need them. Okay Yes?
what null does um ok yea its the zero memory location you can think of it as the zero memory location zero x um so if you alright alright so null is  you can think of as  um p's variable has this ok in it that's its memory address ok its the zero memory addres on memory  on the chip in memory that is the spot that belongs to the system ok so if you dereference it  if you ask for this variable to be expanded to ask you what its pointing to number one it's not yours number two it's never going to be pointing anywhere ok does that make sense so if I ask for  what is sitiing here so p's value is this so if i dereference itÂ  im folowing this it's memory that doesnt belong ito me it's belongs to the system ok yes no it won't so the question is if you dont iniitilaize your pointer will it alwyas initialize to null the answer is that it doesnt it'd be nice if it did and some compilers might do that for you but you cant count on it you should always  initialize it or atleast understand how it is initalized ok alright ok lets go to the slides and talk about some of this stuff really quickly i think the most important thing wil lbe that you draw the right pictures for a lot of it please connect ok so your only announcement for the day is that um mp2 is available umm due in two weeks  now i don't think we ever explained to you the extra credit policy in much detail there is an early deadline for the first part of the assignment and it is worth one full point towards your final grade so this is  uh oh why why tell me why i know why i know why i got it ok so this is one point of extra credit it truly is extra credit its pure grade inflation we do our final grading lines before we give you those points and um and its approximately  half of the mp so this is our attempt to give you incentive to start early on your assignment ok any questions about that and thats in about a week its also our attempt to  its our attempt to distribute the responsibility for  the course staff over the two week window yes do you have a question
No, it shouldn't we have run into that bug before, but it shouldn't. So I believe the question was, well what if you do the whole thing beforehand  do you still get the extra credit, does it compile separately, is it tested separately? The answer is yes, our intention is yes. In the past there was this bug, where if you started on 2.2, it messed you up on 2.1, but I think we fixed that. I promise you we will do the fair thing for sure.  Do you have a question? [Question being asked] Yes, the auto grader will run every night after the extra credit deadline, so the extra credit deadline happens in about a week. And then we will fully grade your mp every night between that intermediate deadline and final deadline and moreover, because we recognize if you get Â an 85 on the night before it's due, you're gonna scramble to fix it. And in the process, you break it completely. We take the highest of the last two submissions.  So you don't have to worry about that night before crisis [Video Playing] So I saw a miraculous thing last night. Raise your hand if you were in the lab last night on the MP, because I want to talk to you. Was it crowded in the lab last night? Not really? This is a strange phenomenon. In the past, on the night things are due. There are like 80 people on the queue, and the course staff is going out for dinner. And so it really like a fruitless thing Â to wait until the last minute, because Â if you run into problems, it is very difficult to get help. But last night there were only 3 people and 4 course staff. For those of you who do not know what I am talking about with the queue and the office hours. What you are going to do is go to chara.cs.illinois.edu. And put your name on the queue and the course staff will come find you. Our intention is to staff office hours everyday of the week from 9am-9pm. Choose a box, each one of you choose one box to examine carefully with someone sitting next to you, simultaneously while you're working on your one box, I will try to work on all four boxes. Then we'll come together and spend 2 minutes summarizing things. So, you go work on a couple of these boxes, I will too. And then we'll summarize. [Video Playing](Memory Leak Practice)
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
Ok. I want to pull you back together. This one is just information. This is a type mismatch you cant delete a non pointer type. This one is a memory leak it was just like the very first memory leak picture we did. This one is incidious because everything here works fine but its probably not what you intended. Anytime you refer to memory that has been deleted you have a problem. And then this is the last one I wanted to ask everyone to think about very quickly. Let me ask you a question. Is there a type mismatch anywhere? Do you see a type mismatch? Is everything ok type wise? Yes because if you dereference p the result is an integer. So across this assignment statement you have an integer on the right and an integer on the left. So is this box fine? No its not fine, why not? Yea p doesnt have any memory associated with it and you dereferenced it. So that's going to give you a seg fault. Alright any questions about any of that? Alright is a type mismatch a compile time or runtime error, that is am I going to get that error when I invoke clang on my system or am i going to get that error when I invoke a.out. Clang, this is a compiler error, those are the easy ones. Ok how about the bottom right box, compiler error or runtime error am i going to see that when i invoke clang or when i invoke the output file a.out. Yea this is a runtime error. That's unfortunate, you don't even know about it until someone is using your software. using your application. OK the problem with the first two is that they are both runtime errors with no notification. You need to be using debugging tools to even find them. So these are runtime errors but I'm going to put errors in quotes because there is no error message. Alright lets move on . Ok so somebody asked. What happens to the pointer p and we talked about the fact that it can be reassigned. What I'd like for you to do for a minute is to tell me, look at these two pieces of code and tell me whats the difference functionally. What do they do differently? Take a couple minutes and look at the code and tell me how are they different functionally what do they do differently. Main functions are identical. You can assume that string is a standard type. So we can actually do that if we are using, if we pound include string we can actually do this. ok so what is the difference functionally between these two lines of code or two pieces of code. Yes, 
Okay, I want to pull you back together. This one is just information. This is a type mismatch. You can't delete a non pointer type This one is a memory leak It was just like the very first memory leak picture that we did This one is insidious because everything here works fine but it's probably not what you intended. Any time you refer to memory that has been deleted you have a problem And then this is the last one I wanted to ask everybody to think about very quickly. Let me ask you a question: is there a type mismatch anywhere? Do you see a type mismatch? Is everything okay type wise? Yes Because, if you dereference p, the result is an integer, so across this assignment statement you have an integer on the right and an integer on the leftt So is this box fine? No it's not fine, why not? P doesn't have any memory associated with it and you dereferenced it That's going to give you a seg fault Any questions about any of that? Is a type mismatch a compile time or runtime error? That is, am I gonna get that error when I invoke clang on my system or am I gonna get that error when I invoke a.out? Clang, this is a compiler error Those are the easy ones How about the bottom right box? Compiler error or runtime error? Am I gonna see that when I invoke clang or when I invoke the output file a.out? Yeah, this is a runtime error. That's infortunate, right? You don't even know about it until somebody's using your software, using your application. The problem with the first two is that they are both runtime errors with no notification. You have to be using debugging tools in order to even find them. So these are runtime errors but I'm gonna put errors in quotes. Because there is no error message. Let's move on. So somebody asked what happens to the pointer variable p and we talked about the fact that it can be reassigned. What I'd like you to do for a minute is to tell me, look at these two pieces of code, and tell me what's the difference functionally? What do they do differently? Take a couple minutes and look at the code and tell me how are they different functionally, what do they do differently Main functions are identical You can assume that string is a standard type so we can actually do that. If we pound include string we can actually do this. So what's the difference functionally between these two lines or code or two pieces of code? Yes? [nothing]
OK, I want to put it back together. Eh, this one is just information; this is a type mismatch, you can't delete a NULL pointer type This one is a memory leak, like the very first memory leak picture like we did This one is insidious because everything here works fine but it's probably not as you intended.  Anytime you referred to memory that has been deleted you have a problem. And then this is the last one I want to ask everybody to think about very quickly. Let me ask you question: is there type mismatch anywhere; do you see a type mismatch? Is everything OK type wise? Yes, because if you dereference p, the result is a int So across this assignment statement you have an int on the right and a int on the left So is this box fine? No it's not fine, why not? P doesn't have any memory associated with it and you dereference it  So that's gonna give you a Seg fault Alright any question Is a type mismatch a compile time or runtime error? That is, am I gonna get that error when I invoke clang(compiler) on my system or am I gonna get that error when I invoke a.out?  Clang. This is a compiler error, those are the easy ones How about the bottom white box. Compiler error or runtime error? Am I gonna see that when I invoke Clang or invoke the a.out? Yep, this is a runtime error That's unfortunate, you don't even know about until someone is using your apllication The problem with the first two is that they are both runtime error with no identification You have to use debugging tools to  in order to even find them So these're runtime errors. But I'm gonna put errors in quotes Cause there's no error message Move on OK, so somebody asked what happened to point the pointer p when we talked about the fact that it can be reassigned What I'd like for you to do in a minute is to tell me, look at these two pieces of codes and tell meÂ  What's the difference functionally, what do they do differently [Students working] Main functions are identical [Students working] You can assume that string is a standard type so we can actually do this if we include string OK, so what's the difference functionally between these two pieces of code? Yes? [Student answering]
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
ok so they used memory differently right? they used memory differently for sure we're gonna spend most of our time talking about that but what about functionally? are they the same functionally? do they do exactly the same thing? yeah? exactly! one of the, heh I owe you, nathan alright yes, one of them is quite certain of its greeting and the other one's a little, little insecure about it alright exactly but it's worth pointing out, and of course it's the point of the whole thing that they use memory completely differently so i wanna talk for a minute about how they use memory ok so the example on the left the example on the left sets up variable s on the, what is known as the stack. it is stack memory and its data structure, the structure, the way it behaves is like a stack! so this is actually an implication in, or an introduction and foreshadowing on one of the first data structures we're gonna talk about suffice to say, a stack is something that you put - you stack things up on it and it grows upward and the only place you have access is at the top okay? so this is gonna be very simple, we don't have a lot of things to put on the stack, but, uh, s is going to be one of them okay? s together with its value below is set up on the stack and then we output its value, you know this tells us our greeting and then when control passes back that is, when we finish execution of the function and we pass control back to the calling function guess what? it's the nicest thing! the system says oh! you must be done with s! I will get rid of it for you!" okay? that's what we mean when we say that the system controls the use of the memory, the allocation and cleanup of the memory, okay? so now lets trace through the other one uh, again, we make the simple function call, as we make the function call, variable s is... ... set up on a stack! it is! s lives on the stack, its type is a pointer type its value is determined by this assignment statement which is the return value from this new function so the way we denote that is like this: okay? and now, the value of s becomes hellow uh oh uh, we output that we say okay, it's time to get ready to go home", so we delete s, which frees this and then we return control back to the calling function ok? and what happened then? s, which is a pointer variable, is cleared from the stack for us. okay? so s is a stack variable, we declared it. right? the memory to which it refers is not we had to put it away ourself. what if i hadn't said delete s? i woulda had a memory leek, good. very good. because we would then... s would go away, and that would have been our only access to that new space ok, which of these uh, do you think is faster? which of these, which of these pieces of code do you think would execute faster? yes, the one on the left, that's right. if all we have to do is deal with stack memory, then
We get faster execution. Right. One on the right really does have extra work being performed . Any questions?  So, we prefers stacks memory when we can.  Alright Let's keep going. So the most of what we have been talking about today refers to primitive type. So I want to spend a couple of minutes talking about pointer as it relates to user-defined types.  So I created a new little class appear. it has three private variables. Name Picture, and Boolean function to indicate if it gets done or not. I don't even know what that means I guess I could ask you. Are you done? Tim are you done today? You are done attribute is true. But we are not done So I am gonna keep talking Alright So now, question is what is the behavior when we are talking about objects. Let's review that happens if there is not pointers. Here is a little bit of summary. We have face A and face B declared. And I am going to initialize B. Raise your hand if your name starts with B Okay What is your name? Brian. Okay . B is Brian Your picture, Are you smiling Brian? YES now he is.  There is a picture. Brian are you done? So true.. Now What we are curious about. what happens when we do that assignment statement.. In C++, it's so awesome A member-wise copy is made of the object.  So,  Each of these members are copied as it knows how to copy itself. So string knows how to copy themselves. Part of string class definition, we will talk about it later. And so Brian's name is copied to the space P and G knows how to copy themselves. Know every pixel associated that P and G copied over presumably that is how it is done Similarly, copy booleans are super easy. And now when we refer to a dot set name. We are referring to that memory location.  Presumably, we can change A's name and Brian look alike, but they are not. Any question about that? Anything surprising or issues? Let me ask you this. How long does this take. Do you like this? You know, it is kind of unavoidable. But copying pictures might take awhile So there is that issues. But otherwise, that is just fine. Let's contrast it if we have things to do declare pointers instead So we have face pointer C, and face point D. Raise your hand if your name starts with D What's your name? David. So we are going to initialize the value of D, David and are you happy? Yea, you are happy and you are wearing glasses. Okay. And are you done? Yes, you are done. And that means D's values are pointing to it.  So presumably D equals new face.  * dot set name david is etcetera Now we are going to do C equals D So C's pointer points to same thing D does.  C gets the value of D And now, when we say C set name to Carlos.
and then we say d getname(). We have been effectively change your name, David. I will forever think of you as Carlos. Okay. Any question about that? You should have a question because I completely slid over something. Let's talk about this one first. This says deference the pointer until you get the object and then call one of its member functions. So that seems to make sense. Right? Deference the pointer and use what a value gave us. Get name up there and there it is. Okay. This one is just short hand for that. I do not about you but I hate typing parentheses and apostrophes.  So this is just shorthand or exact same thing. Syntactic sugar they say. So this is different syntax. Or explicit  deferenceing. Alright. Arrays. Title of today's lecture is arrys. Shall we start? You hold your breath. Class will be over, lets see how long you can hold your breath. Alright, you can go. [class ended]
And then we say deget name weve effectively changed your name david I will forever think of you  as Carlos Any question about that? You should have a question As I have completeley slid over something The heck right Ok so lets talk about this one first This says dereference the pointer Till you get tot the obeject and then call one of its member functions
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
[BLANK]Blankd
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
(no sound) (no sound) (no sound) (no sound) (no sound) (no sound)
 To begin, that when I sent this email last night, I was surprised to send it to only 700 students So I think there are actually must be room in this class so if you know of people who have been trying to get in and they given up, you should let them know that I think there must be seats available Hmm by Friday 5pm today is the add deadline is Nooo? I dont know Alright cause you know really what's the difference between 700 and 750 Ok, let's work I have no announcements for you except to say you may find weekend office hour to be useful But I wanna encourage you to check the calendar before you actually go to weekend office hours cause Im not gonna demand that course staff be quite as religious about attending. They are gotta be allowed to change their weekend office hour More so than they will be allowed to change to change their weekly office hour so before you go to office hours especially on the weekend, you should check the calendar on the course website which is now updated with all of the office hour information ok? Are there any administrated question before I actually start here today? Questions, issues, complaints that you'd like to make publicly ya? Will there be office hour Monday? Ya, I believe we are committed to staffing the office hours like 9, do you mean open lab hours? Like to get help with your MP or do you just mean you want somebody to talk to? Ya, I believe there will be office hour 9am to 11pm everyday going forward with a few gaps here and there Oooooooooh, Monday is Labor Day I don't know the answer for that, I haven't asked them You might ask them on the Piazza: Hey Monday is vacation, is anybody gonna be there Sorry Ok Lets work! C++ academic calendar Ok, hmm.. So you know this class will not be very interesting if we didn't have a way of re-configuring memory into contiguous blocks that we completely understood so contiguous blocks that we have a model for are called arrays so programming gets a lot easier when you have an iterative way of referring to pieces of memory so that's what we are gonna talk about today! Finally, we finally got to this point  Now arrays in C++ are not so straightforward as say might be in Java say you have an array class and you just make it Hmm, eventually we will get to the point where arrays are handled gracefully on our content but I wanna pull back that the current the curtain a little bit and show you what you speculate on kind of how arrays are actually implemented Ok so arrays fundamentally there are fundamental kinds of arrays, the first one we are going to talk about is static array when I say static array  I mean that once the code is compiled, that array, that specification for that array is not going to be changed there is nothing dynamic about it the minute you say you want your array to be size 5, you are signing a contract for it effectively  it's a commitment to using memory of that size OK, so here's what happens In stack memory, and there's the syntax right there, the type and the square brackets that you tell the number that you want In stack memory a sequence of that memory variable is set up so I am gonna do this by you know grabbing 5 pieces of memory, all of them are integers
Okay. They have a location. Chosen for you by the system. Location is always chosen for you by the system.  In the stack, it sort of next available space. And the name is there explicitly given. X zero , X (1) , x(2). Do I need to keep writing? Upto X(4). Okay Of course, their values are garbage.  Alright, any question about that?  Okay, Now, again. That memory, the size of the memory cannot be changed. So, it must be known at compile time. If you do not specify a size. Or if your size isn't in the variable, system cannot figure out. Some big block will handed to you that is irresponsible request of the system for your stack. So, you want, if you are using static memory, if you are intending to array on stack, you need to be able to specify how big it is. Don't let it be flexible because it will be too big and you won't know how big it is. So you won't know how to walk, how to avoid walking end of its iteration.  So, nice small arrays are perfectly reasonable to do only if you know how big it should be. Now, think of all situation where you don't know how big array should be. Any time the size of data is changing, can change, you don't necessarily know how much memory you are going to need, or contain needs. So, we have this contrasting idea of a dynamic array one which you can resize to whatever size you need Here's how this works. You set up x as in integer pointer in the stack, so ops X is somewhere in the stack. It's an integer pointers so it has something that needs to be allocated and then when you ask the system for a memory. you say, YO, I need three integers from the heap And the system goes out define you just a right amount of space. Just right amount of space. Returns memory address which is then what stored in X. Now, Here is the cool thing Here is the cool thing: the syntax referring to the memory, is exactly what you expect any old array that is square brackets find the right element. For example, I can execute for loop that says take i from zero upto size.  And put i + 3 in position in sub i. Now where is X sub of i in each case? This one is x zero, this one is x one, this one is x two. So we end up here, here is three and four and five. Any question about that? Alright, I want to give you another thing hang onto. Another thing to justify is to use of pointers, as the way creating things. Look at the syntax for second. Here is how to think of it. The square bracket is like a D-reference So X de-reference and then i steps forward Okay, Got it? So it's x de-reference i steps foward and that binds you the memory location Wondering if pointer arithmetic applied here, Yes you can use pointer arithmetic to find your element of array. But code would be unreadable and go head and use square brackets.
Any Questions, About it? Alright, Alright fine..  Then to remind the system to tell the system that uh you want to free or get rid of or  I would give back to the system for reallocation a block of memory, you put the square brackets here ok... I believe the compiler catches if theres incompatibility If you used square brackets up here but you didnt use them there, I believe clang catches it Yes? Sure? What? Yup you can still use square brackets, yup, if you've used square brackets in your declaration or in your request for space If you've used square brackets in your new statement, you can use square brackets  to find your elements of your array, Yes? Um, if you go passed it, probably a segfaultÂ  okay? Its not as, it doesn't know exactly what you're trying to do, but you probably going to access memory that isn't allocated there, okay? Yes!  Ahhhhh okay, so the question is, well that looks kind of static right? We said how big we wanted it to be and we asked for it and how do we change that and the answer here is we explicitly are going to ask for the larger space, so if all of a sudden we decided we needed 3000 of these integers instead of 3, our algorithm- and well talk about this explicitly later- but our algorithm is going to be to ask for 3000 copy the values over and then we've got 2997 extra okay? So that's, that's our  algorithm here, there is We don't use a graceful way of extending the space cause we don't know what the heap looks like, we don't actually know if there is space to extend. Right? Alright, uhh, lets see, one more thing I wanna say here, umm, that will get at your reasoning about this, My question for you is simply What happ, jeez, you guys are gonna like get whiplash, ouch Uhh, what happens if you say cout, uhh, the value of x What're you gonna get? Yeah? Ohh, you would wish right?! You wish it prints the whole array! Optimistic soul, thats a rep reflection of an optimistic soul What do you think it does? What? No. Yeah? Yeah? Only the first value, thats right! If I covered up If I covered, If we weren't talking about arrays and I covered up all of this, then this cout statement would say, find your variable x of integer pointer type, right? deference it and show me the value thats there, the value thats there is 3! So thats what we would get Now, would we ever do this? That would be weird, instead we would do Cout << x[0]  << endl because after all it is an array Okay? Any Questions? Yes! Where? Here? Oh! So his question is, his question is, you don't have to dereference x, x is the pointer. And my response is I did dereference it, I did dereference it! That Square bracket is a dereference and 0 steps forwards Okay? So, yes I do have to have dereference it, I did! Okay? Alright, did question, any other questions? Yes? What does the delete statement do? What do you hope it does? Gives back the entire array to the system to be used for future allocation! Okay? So the next time somebody asks for some, yes? Ahan, what did you say?  If I had 2x as the address of x[1], oh boy so that would be, ummmmm,  The address of x[1], like this, probably You don't usually have a reason to do that, You are usually interested in the values on the heap, okay? But, That is what you would do its still just a way of referring to that block of memory Okay? Alright, how are we, yes?
in the what?  um no Those are static variables  those are stack variables they're all  I mean you know they are memory addresses going on all over the place but it is not instructive to think about these guys as memory addresses they are stack variables they are not going to have memory on the heap that keeps track of them ok> right its still... right right there is no explicit pointer it's ..... Yes, thats right yes it just keeps track it keeps track of how much memory is.. it keeps track of size of x basically it keeps track of amount of memory associated with that so somebody who speak C tell me what 3 does what parameters are associated with 3 what parameters are associated with the three statement cuz this is like malloc free right? ok nevermind it keeps track of amount of memory for you uh hum yep there is a lot of steps going on behind the system the scene a lot of stuff behind the scene we clearly speaking something that is almost English right? and the processor doesn't understand anything close to that yes? so the question is what happens if we just do delete x here I believe that clang catches that for you at compile time I think thats true it used to be that if you say delete x there only that first one would be free but think now it is detectable at compile time alright. yes? no malloc doesn't But but Null does. NULL and free do yeah you know C still works here you can still ask for the size of your variable yea Yes yes yes yes so if you speak C++ already if you familiar with the C++ standard library what we are talking about now is under the hood of the vector class yes yes yep yep yep vectors live in the heap yes so the question is if it is possible to partially delete the block of memory and anytime anybody asks me questions in C++ starting with is it possible to the answer is yea probably but the more relevent question is should you and the answer is probably not so it was a ... we thought it was a straightforward conversation but it is always kinda (knew oddsed??) right? yes do you need to set the values to NULL before you delete  no\ is it a good idea to do this ? after you delete  Yes yes but you know when you are talking about values no problem dont get cocky with your Microsoft device thats just crazy I'm sorry okay if you are talking about reinitializing these values the answer is no you don't really have to you don't have to clean them up they are just going to go back to memory and the next allocation is responsible for initializing them the way they want them to be okay? alright. can we move on is that ok? yes
What do you do if you want to copy a static array? You just assign do the assignment Okay What do you do if you want to copy this array Oh we're gonna talk about that a lot Okay so I'm not going to spend a lot of time talking about this problem I want you to make sure you understand how to do this  because I think you can puzzle it out. I would love to see a discussion of this problem, um, on the Piazza, so here's the setup: I have declared, I have declared a double pointer of flowers, so I want you to assume that flower is a user defined type You can imagine how that would be true, I've defined class flower and I'm defining a double pointer to them Now I'll give you the first one here This could be a pointer to a pointer to a flower. Right? So it could be the memory address of the memory address of something that is a flower type. A box that contains a flower Or, what else could it be? Somebody give me one other thing it could be now that you know another use for pointers. Very, uh, close It could be a pointer to an array of flowers , right, because it's the array part that eats up one of those pointers. I don't know how to make flowers. There. Those are flowers. Yes, yes. Oh it could be a two dimensional array right. So here's what I want you to do, I want you to figure out the other couple of these, and moreover, I want you to write a few lines of code that look about like this that set up that memory, that ask for heap memory. Okay? I want you to think about what it looks like both to allocate and delete,free up, put away, finish using memory that is declared like this. And I'll give you a hint about this.  This is actually an important exercise because one of them - the array of flower pointers - is actually the substance of MP2. It's probably the hardest thing to wrap your head around in MP2. Alright, any questions about this? Yes So the way to think about this is that this one is a pointer and the rest of this is an array of flowers. No, an array of flowers. If it's a pointer to an array of flower pointers, I need three asterisks, three splats, who taught me splats? Three splats I'm gonna let you puzzle over it. you need to and you will and you'll unwrap your own model for this, okay? And we'll talk about it more, but not right this second. So I'm not gonna say the words 'Are there any questions'. There're supposed to be questions. Alright, so we're gonna move on. And this is actually the beef of the day. This is the beef of the day. So C++ handles parameter passing in important and different ways than you might be accustomed to if you come here from just about any other language on the planet, okay? So we're gonna spend a good amount of time talking about parameter passing. Now what do I mean by that? I mean when you have a very simple little piece of client code, like this. What happens when you declare a student, make a function call, so I have a function call, when the parameter gets passed into the calling function and then executed upon, what happens? What happens in memory, k? Now, the discussion of what happens when control is passed back to the calling function is a discussion about return type and I don't think we're gonna get there today. I think that's a discussion for next time, k? Alright any questions about that? Is it clear what we're gonna be talking about? Alright I think that you should have a question about this slide, cause I think that there's something new there. For some of you at least
Yes here? not that's not. that's not printed then printed, the code is  intended to be pretty simple what the hack is the struct?  that's right notice here oh oh what is it look lot like? if you kind of squeeze you eyes, what does it look like? the struct is a class struct by C++ compiler, struct is interpreted is a class where all the members by default is publioc exactly the same thing, why did I choose struct in this case? because I want to save screen space and I only have data associated with it, I have no function, and so it will be familar to somebody who speaks C yes you can, you can define functions, the c++ compiler will do the right thing with it so if you take c code and you put it in C++, you know, you can mess with it nathan? speaking somethinbg em a boy using typedef because you are using a class oh yeah you can just use it directly, but you can use in C too, right? ok I will look at it and make sure I answer correctly but suffice to say you can do this it's fine and use it just like a class ok alright any other question about this? ok alright we will look at the details of what's happening here this is largely replication of, look at you flip the page, we are like flying through the lecture today all the knowledge so this is largely replication of the examples of previous page and I an gonna tell you some vocabulary associated with parameters passing in C++ by default parameter passing is pass by value so default C++ is passing by value and here is what that mean it means when you set up student A they have a name they have a picture and they are not they are gonna be initialized to be not be printed ah ok, here is what happens when we make a function ncalls we gonna make a function call to print student one of A look inside the function, A is interpreted as s here is what really happened, s is also set up like the local variable on the stack and value of A is copy in to the new space on the stack allocated for s so string know how to copy themselves so n gets copyed over, PNG knows how to copy themselves and boolean know how to copy themselves so we have completely independent copy of A in the stack for s on which to operate we can write code looks like this, if its not the case s is printed, then output the name and here is what  em here is what we cannot do we could do s.printed = true here what's the problem with that
what thats right thats right i only set the one in the fucntion right so i have made note of the fact that we printed s yay good job and then  we go we return um the control back to the calling function and s goes off the stack so we have no record of the fact that we had printed it thats why in this code we return a true and we grab it on the outside and if we had hoped to change it we have to change it in the scope in which it exists alright any questions about that is that clear and thats default behavior ok and thats passed by value no questions you're good? ok lets do something different so this time instead of a student i have a student pointer b im going to set up b in memory so in this case right here i have for sure b=new student somewhere and maybe theres a param i dont know what constructors exits for this puppy bu I have set up b so its has value ben a smiley and not printed now when i when i make a function call here to be or with b as a parameter print student 2 has to take what what kind of thing must if take a pointer thats right the types have to match so this has to be a pointer  in that case what happens is  the variable s is set up on the stack as a pointer  and b's value is copied into it b's value is copied into s if you had this slide what would you draw to reflect that b's value is copied into s yup very good so s now  draw an arrow pointing to the very same memory laocation because their value is at the same memory location ok you good and now we operate on s i want you to spend about thirty sec finishing that code so that the output of this function call is  a ben so spend about thirty sec filling in the blanks effectively that would ummm make this thing print out ben oh you can yeah like i have there so  you need to finish that code or debug it if you want to use a different syntax youu're asking me exactly what im asking you ok to fix up this code yea yes yup yup but not for static arrays static arrays are all in the stack do you want to use them for smaller things ok how you doing alright so what should the conditional look lilke what should the conditional look like i left a space there whats goes in it
 can someone raise their hand and talk to me? I'm feeling kind of lonely.... YES, what goes there? [someone answers inaudibly ] yea, good. splat is splat. I'm gonna use splat on the exam yea.. k and i'm gonna do this to be explicit k... I probably don't need to but, ima be do that to be explicit so... de-reference S, and then I can get at it's value um as......asssssssss you might have noticed heeeeeeeree, you could equivalently use S printed..... to accomplish the same thing k, it's exactly the same just different syntax  Okay! What else do we need to do? how do I print out the name? de-reference, good, thats all- i just needed to hear somebody de", and I was good ok fiiiiiiiind and theeeeeeeeen yea, guess what I can do I can do, S printed is true here and this changes to true YEA and am I done? I should probably return, just to let people know that I know I'm finished  K, any question about that? Yea? [someone asks a question] um because of, so the question is why don't I have to write return true? and the answer is because this function has a different signature here it returns void my purpose for returning true last time was passing back the result of the computation here I didn't have to k? alright yes! [I guess someone is asking a question] uhuh...........yahuh [mumbling] uhuh....... yea ...............um, they are if you use parentheses correctly and there is a complexity in the mp because of the overloaded parenthesis  so for the png class, it's a little wierd and we kinda want you to, we kinda leave that there on purpose just to have you, have you untangle it sorry... OKAY! so are we done here? are we done????? ............. Yes???? .............. very good!. okay! so notice that  we cannot forget that what we are dealing with here is a pointer what we're dealing with here is a pointer so this needs to be de-referenced here as well kay?... now let's contrast the previous slide and this slide kay? who's..... so this is a popularity contest  who's speed do you like better? who's speed do you like better? which is faster? previous slide by value? or pointer by value, sorry this is pointer still by value, it's still, it's just pointer by value which one do you like better? speed wise? [space] pointer by value. thats right! passing a pointer no big deal it's this little teeny tiny representation of a memory location right? whereas in the previous case that picture, copying that picture around, bad idea kay, even if you..... even if it's super fast So! this is FAST alright fine. who's syntax do you like better? who's syntax do you like better? this one? or this one? it's like an eye test, left, or right? [pause to let people laugh] yea, le-hehehehehehhe right!... wait, left okay so the syntax here is better this is cleaner code but uh, so this is a comment on syntax but!... here's the thing... it's also safer to be dealing with; your less likely to make memory mistakes if you can refer to things that live on the stack so actually the stack variables make your code less likely to be buggy so it's much much much more than a pretty dress it's the substance of the quality of what you, what the code you create so code that uses fewer pointers is less likely to have memory errors kay? any question about that? so I'm going to say it as safer here especially for us mkay.... alright any question about that? is that good? so which one better? [pauses for dramatic effect!] probably the second....... [silence].... sighs well somebody is paying you according to how fast your code works well here's the thing, in C++ you don't have to make a compromise between the two so let's look at the third way that parameters can be passed this is called, pass... by... reference [silence]
Okay, so let's trace this code for just a second. um, notably, I'm declaring a student. I am declaring a student, raise your hand if your name starts with C.  Yes, what's your name?  Crystal. Is that how you spell Crystal?  That's one of my- you know how everybody has a word that's hard for them to spell?  Shouldn't there be an h in there somewhere?  But no.  Okay. Yeah. No.  Like Christmas, it's almost like Christmas but not. Okay. 'Cus that's gonna be on a test.  Alright. Uh, Crystal you're happy and you have not yet been printed, yes?  I'm sorry to impose emotional status on you but there we go. Okay, alright, so now this is a student in the stack and we give it value just like we normally would for this thing.  However that user defined type allows us to do so. In this case, it would just be c.name = Crystal, etc. Alright, so now let's trace this, we're going to call a function whose name is print_student3. It has as its parameter a student reference. Okay. Slightly different. Now, here's what we mean by that. We mean  take wherever s is set up wherever s lives, whatever s is, and rename it to I'm sorry - c - sorry - wherever c is okay, wherever c is take it and rename it as s okay, so give it another name which is s Okay? Now, when you write this code, if it's not the case that S is printed is it printed?  is S printed? No Then, uh, output it's name.  Can we refer to its name? Yes. That's Crystal. And moreover we can use s to refer to the contents of c so we can say s.printed = true here Change this to T. Okay? And when we get back out here what do we get? True Alright. Any questions about it? Yes? yes. And usually we will actually. Okay, there's not the uh there are software engineering issues here with changing the value of the variable underneath it within a function but we're not talking about that here we're talking about mechanics Yes? It's an ampersand before the s, yes that's right yes? Why don't we have to ampersand c? c is a student c is a student okay raise your hand if you feel uncomfortable with this because you feel why can somebody articulate why very precisely why you feel uncomfortable with this.  yes? Yeah, so it looks like a type mismatch right? it looks like a type mismatch. so two things to say.  number one the ampersand used in this context is not the address of argument you should not think of it that way, okay? you should think of it as a flag passed by reference number two the apperance of a type mismatch is to be overcome so take a few minutes and do some meditation and get rid of the of that feeling of type mismatch okay because in this context it's just a flag now what's really happening I shouldn't even tell you, right? yeah I don't want you to clutter your mind with it, but I will tell you. Yes? is it functionally different than passing by pointer that was exactly what I was going to say and the answer is no it's the same effectively effectively you are pasing a pointer but it's the way you refer to that variable thats different okay so the speed the cost of passing by reference is the same as the cost of passing a pointer by value but the syntax of it is completely different and so you're much less likely to induce bugs imposed by  the use of pointers when you write code like this okay any questions about that so this is  as fast as pointer passing but without the syntax complexity
of pointers, class. And there's one other teeny teeny tiny issue here. It's subtle. and it is a potential bug here when we pass around pointers. I'm gonna write a little piece of code and you're gonna respond yes? right. If you pass null pointers to that function, what happens? It's a segfault, right? so how would you fix that if you were writing that function? You'd have to put a conditional there, right? and you'd have to handle the issue if it is a pointer. So, another advantage here is that it's as fast as pointer passing without the complexity of dealing with pointers but also it can never be nulll it always will have a value So this is like a pointer that cannot be null So we love it ok. So i'm writing in red. alright any questions about that? no. Nope, so the question is all about the heap None of this involves the heap All of these parameters are set up in local memory, ok all are in stack memory. Al All the parameters are like local variables. They're like stack variables So nothing happens with the heap as you pass the parameter. Now, this could have been This could have been, let's see, this could have been asterisk c, and then we pass the address of c in which case, that memory location would be renamed s Right, the memory location would be named s and we could refer to it directly. Alright, any questions about it? Oh look at us, it's two more minutes Alright, so there's one more little tiny piece and we are gonna spend most of next time talking about it but there's one more little tiny piece that I think now's a good time to talk about it because the issues are analogous When you return control, that calling function. That is, when you say turn something, all the same issues exist. You can return by value or you can return a pointer by value, or you can return by reference. So the mechanics are effectively the same and next time we'll talk about the consequences of that fact.
Okay my clock says its a 11 o clock so let's get going. Umm. You haven't even asked for it yet but Im giving you an extension on the extra credit portion of mp3.  On the website it says its due on the 22nd and I just said that on the slides it was due on the 25th so we will go with the 25th. Youre welcome. I'd like to say anytime but that's not quite true either. We have more printouts coming so if you don't get a print out they'll be there. I swear I alway sprint out enough and they disappear I don't know who s taking these printouts who wants them. Maybe its sabotage. Okay so mp2 was due last night yes? Okay it was. Does anyone know how long the queue was? 66 people. Yeah no no. So that's like 10 percent of the class was on the queue. Can you guess how I feel about that.  So that says is that 10 percent of the people were working on the problem and got stuck so that means even if a higher proportion of the class was working on the mp at the last second so that just breaks my heart. Umm. Because its so fun you want to do it early. So here's the thing, I can't promise you that the queue wait times will improve. I can't promise you that. Now do you see how meta that was. Because if I say I can't promise you the queue wait will improve then you wont count on it and youll go earlier in the week and spread out your requests and then the queue times will improve.  So there's this kind of thing going on there. So I refuse to promise that the wait times on the queue will improve. There should be huge incentive to start early and finish early. I think course staff is most broadly available at like 9 o'clock in the morning or 10 o'clock in the morning. Think about your fellow students schedules and plan accordingly. Its this interesting problem right? like the flow of the crowd. We do try but 60 people on the queue is an awful lot of people.It was bad monday night too. Oh the other thing. course staff actually asked me to tell you that you have now have two labs whose focus was debugging so they are exerting you encouraging you to try to be a little more independent. When you run into a problem. Instead of just putting your name on the queue go ahead and be a little more tenacious than a month ago in trying to figure it out yourself that's going to be a valuable skill in going forward.
Â  Â  Â  Â  Â Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  There's already an important typo on them. So we'll leave it in red. This MP is due the 15th (tuesday night) Ummm and thats really my only announcement at this point. And then otherwise the errors in the slides are going to be minor, so I'm gonna go with it Okay. Let's see. So I haven't seen you in a really long time. Are there any administrative issues? Did anybody get a grade report from the extra credit last night? Have you looked at your SVN and it was there? Okay I have reports that some people didnt, so I'll look into that. If you expected an extra credit report from last night and there isnt one in Svn the first thing I would recommend is to go and refresh the page and otherwise I will also be looking into it to make sure that the entire run went successfully. I think it has to if anybody gets it everybody should My best advice is to reload the page. MP1's rerun: I'm not sure whether that happened last night. We were going to rerun MP1 one last time and I don't know when we;re going to do it, but suffice to say it'll happen at the end of the semester. Raise your hand if you're going to the career fair today? Yeah look at that. cool.
Its a good one I like it its fun I see lot of alums when I go there.  I do not go very often because I have a job. Alright [pause] So we were talking about code and C++ behavior upon parameter passing and we has just concluded last time by mentioning that all the cognitive that we talked about parameter passing where also true about returning control from a function to the calling function  So what we are talking about here is what happens so take a look at this client code, what happens when that call is made. Last time was all about the parameter passing and this this time its going to be after the function concludes what happens when you pass control back to the calling function. Now there was some keywords that come about in the discussion of parameter passing that sort of described the different ways that were interesting. We can pass parameters and that was O those forget that this says return by and remember back to pass by. and the words are the same. So what were the different ways of passing parameters? Do you remember? Value. Good! Value Reference  and pointer by value. Now that whole discussion was kind of a bridge between passing by value and passing by reference because the behavior of the system and whats happening behind the scenes is the same as passing by reference but reference gives you simplicity and some cleaner ways of stating your intentions. So this is a pointer by value Ok and you should kind of review the implications of each of those and syntax.. OK well like I said all the same things are true for parameter passing is return value and we are going to spend the first part of today discussing some issues there and kind of reminding our selves what those terms mean. OK So here again we have a little class a student and we are going to do some similar things like we did last time. Here is some client that is code that uses a student and it makes a function call one thing that guess I never said but now is a good time to say it, is that in C and in C++ , you can write functions in the global scope That is functions do not have to be class memebers They do not have to be associated with the class. And suppose all of these examples have exploited that fact.  Ok So we are going to initialize a student C and we are going to set up a student C in the stack and declare a student pointer D.  So I am drawing the wrong picture for C. Look I learned something new. When I initialize a student C, it has some fields associated with it....[pause] Cat.and the Cat looks like that. and the cat has not been printed.  and then what I am to do is print C and return a value. Ok so send C to the print student function and return a value from it who's type is a student pointer. Ok Alright so let's go and do this. When you pass a parameter in its by value so this one is called C and this one called now called S and it copy is made  Looks just the same Furthermore when we declare another student here there is a lot of gratuitous nonsense here. I understand that but its kind of to make a point the next line student w. declaareds a w and assigns the vlaue of s to it not yet printed ok and then we are going to process it like we did last . has w been printed? No so we cout the name and change this to true and then what are we returning?
The address of w. okay? The address of w and then, so, this right here, this eventually becomes the address of w.  This function call is sort of replaced by return value. Right? In the flow of the program. Then we assign it the value of d. Is this syntactically in type wise correct? Is work okay type wise? Yes, it does. 'd' is a student pointer 'w', this is the address of the student, those are the same thing. So type wise this works fine.  But let me ask you this.  What happens to 'w,' the second we leave the function? What happens to 'w'? Yeah? That's right!  The system does you a favor.  It clears the right off the stack.  Boom boom done.  Right? So 's' and 'w' are effectively gone because they were local to the function.  So what about the address of 'w'?  How do you feel about the address of 'w' out here in the calling code? Daaah!  Right? It's no longer valid!  Now will it work? Will this code work?  Most of the time, maybe? It's probabilistic thing.  You are rolling your die here.  So, the point of which this assignment is made, the point of which this assignment is made relies on the 'w' that is no longer in scope.  So, but, 'w' is not in scope.  So this is a horrific bug.  Why is it horrific?  It's worse than insidious.  Why is it horrific?  Because it might work a lot of the time you probably won't get a seg fault.  Another parts of, other times, you might get a seg fault, other times you would just get a value that you don't understand because that stack has been reassigned to be something else by some other process. Okay?  Alright.  So what was the error here?  What did we do wrong?  What did we do wrong here?  Yes?  We used stack and we returned what from the stack?  A memory address of something on the stack.  That's right.  We returned the memory address of stack variable.  Now returning that thing by value would have been fine.  Returning 'w' by value would have been perfectly fine.  So if 'd' were instead just a student and we had just returned 'w' here, then things would have worked fine.  That's returning by value, yes?  So the address is memory address.  It's the location in memory.  And, we returned it because there's nothing that says we can't return something of pointer type.  Right? We returned it pointer type.  So that types match up across this assignment statement.  This is pointer, this is pointer.  No problem.  Right?  Except that the thing that we instantiated that pointer with that, is, ephemeral, kind of.  Alright, any question about it?  Is it okay?  Alright.  That's the, that's the warning.  Don't return a local variable memory address, local variable's memory address.  Okay fine.  Uh, let's do something else.  Return by value would've worked fine here.  Returning a student would have worked fine.  Let's do something else.  Uh, let's talk here about... How would you describe that?  What have we done here in this function?  Are we returning a student?
Sort of.. what does that ampersand mean in that case? By reference, that's right. So our intention is to return a student by reference. Okay? Now we'll trace what that means here. Okay, so the setup in this case, oh brother, um here's C: cat, squigly, false. Um here's D: ok? its not initialized, we havenât taken great pains to initialize it. When we call the function, C goes in as the parameter, S becomes a copy of it on the stack. We create a new one, W, it becomes of that, also on the stack. Okay any questions so far? We mess around with W, we mess around with W, and then we return it by reference. First of all--first question: is there a type mismatch? Oh, it looks like there is, doesnât it? Is there a type mismatch? The answer is no. It looks like there is, but that ampersand in that context does not mean memory address, mostly. It doesnât really refer to memory address, it doesnât mean pointer. It means a reference. Whatâs the difference? The difference is..the difference is that behind the scenes, pointers are being passed around. But here, in the code, you can refer to everything by its student, by its student value. The dereferencing that happens is all done automatically for you. And in fact, you probably shouldnât even think about it as a pointer, just think about it as a student. Now, what happens in this case? W is passed back by reference and this thing right here, the return value of this, the right hand side of this assignment statement becomes essentially another name for W. So this is now the right hand side token, whatever the system decides to use for the return value of that token. Right here, this is another name for W. Kay.. and then we do an assignment statement. We assign that to D. Do you like it? Do you like it? Raise your hand if you like it or you see no reason not to. Raise your hand if you canât-if you can't stand it. If you detest it. Raise your hand if youâre somewhere in the middle. Okay. Good. Why do you detest it? Okay, so you think weâre wasting time there, right? Okay so I hate it too but not for that reason. Okay. I hate it too but not for that reason. Hereâs why-you wanna say why you hate it? Exactly! Thatâs exactly right. So the comment was: it seems like it goes away and yet weâre relying on it. But look, the assignment statement relies on something for its right hand side. But the minute control is passed back so that the assignment statement is the next thing, this is gone. So that right hand side gets obliterated effectively, effectively is gone the minute the return statement is made. Which means that the right hand side has nothing on it to use. Right hand side is nothing but certainly invalid. Kay any question about that? So what have we done wrong here? Can you describe what we have done wrong? Iâll give you a hint. I donât know, i donât know what that dance move is. Kay so the error here is that weâve returned a local variable by reference and thatâs forbidden. Okay? Because it's invalid - it creates an invalid right hand side in this case. okay. so our error um.. oh no.. 
 Sort of, what does that ampersand mean in that case? By reference, that's right. So our intention is to return a student by reference. Ok? And we'll trace what that means here. Ok, so the setup in this case -- here's C, cat, squiggly, false Here's D, ok? It's not initialized, we haven't taken great pains to initialize it When we call the function, C goes in as the parameter, S becomes a copy of it on the stack We create a new one, W, becomes a copy of that, also on the stack Ok, any questions so far? We mess around with W, we mess around with W And then we return it by reference First of all, first question: is there a type mismatch? Oh, it looks like there is, doesn't it? Is there a type mismatch? The answer is no, it looks like there is, but that ampersand in that context does not mean memory address  ...mostly. Ok? It doesn't mean pointer, it means a reference What's the difference? The difference is that behind the scenes, pointers are being passed around. But here, in the code, you can refer to everything by its student value, the dereferencing that happens is all done automatically for you And in fact, you probably shouldn't even think about it as a pointer, just think about it as a student. Now, what happens in this case? W is passed back by reference and this thing right here, the return value of this, the right hand side of this assignment statement, becomes essentially another name for W. So this is now the right hand side token, whatever the system decides to use for the return value of that token Right here, this is another name for W. Ok? And then, we do an assignment statement, we assign that to D. Do you like it? Raise your hand if you like it, or if you see no reason not to. Raise your hand if you can't stand it, if you detest it Raise your hand if you're somewhere in the middle Ok, good. Why do you detest it? Ok, so you think that we're wasting time there, right? Ok, so I hate it too but not for that reason, ok? Here's why - you wanna say why you hate it? Exactly, that's exactly right, so the comment was, it seems like it goes away and yet we're relying on it, so look The assignment statement relies on something for its right-hand side, but the minute control is passed back so that the assignment statement is the next thing,  is, this is gone, so that right hand side gets obliterated effectively, effectively is gone the minute the return statement is made which means that right hand side has nothing on it to use. Right hand side is nothing, it's certainly invalid.  Ok, any question about that? So what have we done wrong here? Can you describe what we have done wrong? I'll give you a hint. Ok, so the error here is that we've returned a local variable by reference, and that's forbidden. Because it creates an invalid right hand side in this case. Ok, so our error...
 Ok, got it, ok, any questions about that?  This is really all we're going to discuss int he context of return value, these two warnings. Um, on honestly you are not going to see returning by reference very often. Because you can't return a local variable by referece, you can't return a parameter by reference, because that's kind of the same, I cannot say return s because it's the same issue s is going to go out of scope So what can you return by reference?  What could you return by reference.  What could you return by reference, does anybody see it? it's a little puzzle  Yeah? You could return a global variable, hmm You COULD. Do we know how to refer to global variables at this point? ehhh I don't know! yes, you could return a global variable there because that memory address, that reference is not, that memory that it represents is not going to go away, so anything in the xternal scope you could.  y So if something in the heap you could return it' by reference, the problem is that often times we don't have a name for those things, we don't actually have a name for the values in the heap So it's a little harder ok?  The parameter as it is is like a local variable, ok? But there's a big hint there The parameter as it is is like a local variable, that means it gets cleared off the stack too  Very good! So if I pass something in by reference, if I pass  If i pass something in by reference, then it becomes another name for the value in the outer scope, and so I can pass that one back By reference, here, because then that would mean we're basically referring to c ok? any questions about it? is it ok? Alright. I think reading this and becoming comfortable with references requires just a little practice and the more code you see and the more code you write, you'll become more fluent with it. I remember looking at c code And not being able to figure out type information. Just not being able to do so, and now I'm like boy! It's not that bad! Yes! right, so the error is basically non existent you're only lucky if you get an error, otherwise it's just unreliable yeah  So the question is, when I return w though that reference, what's left on the stack? and the answer is c Basically, the stack is keeping track of it's top and anything below it is valid and when you pass control back  the top of the stack is moved down. Anything above it is moved down below the local variable, so anything above it, any of the local variables are basically invalid memory alright yeah? 
Um in this current example yep right now if I change s.  If I change s to true here so I have an s dot printed equals true.  And I refer to c out heres c value will be changed.  That is partly what pass by reference gets you. Alright any other questions about this?  Alright.  So these are the warnings. Okay.  So we talked about constructors in enough detail to be dangerous.  But when we did so we didnt have a very sophisticated understanding of memory so the kind of objects we made couldn't be very complex. Remember that the fundamental role of a constructor is to answer the question, what do you want the object to look like when you declare it, and in this case rather than a sphere with a radius we are going to talk about what we want the object to look like when we have a richer sphere. So take a look at this sphere.  We still have the radius.  What do you think this business is?  You can use the diagram on the page as a clue. If somebody said hey whats atts?  What type is atts?  How would you describe it?  There are a lot of right answers here. Yeah its a pointer to a string.  Okay fine.  What else can it be interpreted as? An array that is right. So remember that when you are looking at variables, if you see something that is a pointer it may be initialized to an array rather than just a value.  Okay. So and in fact that is what we intend here.  We intend to use that string pointer as an array in our structure.  Okay so let me show you what I would like a default sphere to look like.  And you can help me write the constructor that makes it so.  It is a perfect review of what happened last time or 2 times ago? Okay so when I declare sphere A here is what I want it to look like. I want it to have a radius of 2 inches and I want it to have 3 attributes.  I am just going down this list checking them off.  And I want those attributes to be a sequence of strings that are red and juicy and crunchy. The default sphere is an apple.  Okay.  Yay!!! Alright.  So how do we make thatn.  Yeah.happe Do I need an array of arrays?  No because this whole thing is going to be A.  This part is not intended to indicate an array.  This part is just going to be a list of these variables. Okay But yeah this yellow part is an array.  That is right.  And we have to use the constructor to make that happen.  I am going to remind you of some syntax here.  So we are going to right this constructor.  I am going to remind you of some syntax. You can use the initializer list to instantiate some of the variables.  Since we are not using user input here for this default behavior it is pretty safe.  We do not need to do any error checking.  So we can say the radius is 2.0 and more over it is safe to say num atts Sorry it is a little weird to say that word.  Num atts is 3 so they would actually be up on the same line.  Initializing this array though would be a little bit more complex. [continues writing on screen]
What is atts? What's the next character I'm going to write? Say what letter I'm going to write next, what's the next letter I'm going to write? Yeah? New, very good Att's equals new string, how many of them do I want? numAtts, very good Now notice these are not string pointers new returns a pointer and that's what type of thing we need This is not a double pointer here. This is simpler than MP2 Alright, so now I have this pointer instantiated with this memory address  Where this block starts in memory And I have this much preserved Each of them for strings But they don't yet have the values I would like. How do I give them the values that I would like? What's the next character I'm gonna write? A, good Oh I did the square bracket for you, okay @ zero equals red" K Can I do dot dot dot yet? K But I like to write 'Juicy K Alright, any question about this, and that's our constructer So, when I declare A, the system says, do you have a constructor you would like me to deploy?" We have said, Why yes we do have a constructor we would like you to deploy" And then the system deploys that code It sets the radius equal to two, numAtts equal to 3, and then it allocates and intializes that array to contain the strings we wanted Umm, so the question is, What's the difference between putting something inside the constructor explicitly Like, the radius equals 2.0" vs putting something in the initializer list And the answer is essentially nothing Using the initializer list is a little bit faster There's a little bit less memory manipulation, but that only matters in very rare circumstatnces The reason I did it like this was to remind you that the initializer exists because we're gonna be using it when we talk about inheritance Take a look here and tell me if anything surprises you What are each of those things? So this is the constructor we just wrote This is one, that allows you to adjust the size of the apple I dunno, because... Maybe you have a sequence of things that you can change based on the user input What the heck? So tell me as many things as you can that are weird about that First of all do you believe it's a constructor Why do you believe it's a constructor Same name as the class, no return type That's a constructor What else surprises you? Two things about the parameter list, I think, should surprise you Yeah, it takes a sphere as an argument and the argument is passed by reference, that's a salient point. Const? What the heck is const doing there. That thing, that constructor is called the copy constructor, and it's what we're gonna talk about for the rest of the day So, what do we need the copy constructor for? The last time, or two times ago, you let me get away with some language, almost I think somebody called me on it You let me get away with saying a copy is a made between the calling function and the parameter You let me get away with saying, oh look, when we pass a into s, a copy is made" Right there at that instant, the copy constructor is invoked for you
Okay, now if you don't write an explicit copy constructor the system will provide you one, and I'm going to tell you a narrative about what the default one give you in just a second. Okay, so one location where the copy constructor is called is when you pass parameters in, that's how by value happens, that's how pass by value happens. Another case that it happens is like this. You are allowed to declare a sphere and then to declare another sphere to be a copy of that one. Okay, so maybe in here you would change a somehow. And this b, the declaration  of b with another sphere as an argument is as close as we come to explicitly invoking the copy constructor. Okay, any question about that? Okay, there is a third use that merits a complex discussion. That third use actually occurs in the first example perhaps. Ah I cannot change my pen color, I'm so sorry, things are kind of broken here. So the question is what happens when you say return s? We sort of implied that the execution is the same between passing a parameter and returning a parameter. But in this case, actually, that copy constructor may not be called, it may not be called. The system will decide whether or not it knows what you mean and in certain circumstances the copy constructor will not be called. So you cannot rely on the copy constructor being called upon returning by value. So let's see, where can I write that? This may or may not call the copy constructor. And the reason for it is simply that when you're returning a value, if you can maintain the data in memory some place, making another copy of it ends up being like an extra copy. So you're code actually executes faster if it doesn't have to make extra copies all over the place and so where it can it will avoid invoking the copy constructor. Alright, any question about it? We'll talk about it more later. We say that the return copy is elided, if you wan't vocabulary associated with it. Okay, so we need a copy constructor and I said the system provides one for you. Let me show you what it does by default. Okay, so let's assume that we have an apple a set up in memory, a red, juicy, crunchy, and we pass a to a function. Here's what happens by default, the parameter gets a new version of a and a member wise copy is made. Now, that's fine, because doubles know how to copy themselves and it's fine because integers know how to copy themselves, they have valid copy constructors essentially. And it's also fine because pointers know how to copy themselves, what does that mean?
The address is copied. now i am pretty sure when you pass by  value that is not what you intend. YOu do not intend to have your onjects kind of be tangled together THe possibliyt of this entablement is why we specify a custon copy concstructor] lets take about what type of value we want instead we want the radius to be copied, and the number of attri we want new memory to be allocated and then the values to be copied so that was a checklist that was one, two, three that gives you the boxes and then four for the values i want you to write thouse lines of code and attempt to work with somebody around you to write those few lines of code in that green box Ill wtrite is slowly here to.  YOu are welcome to peek Ill race you Actually oh no i can do this who wants my tablet who wants to write their solution on my tablet you want to try it okay its okay. Oh be sure to do it a little bit wrong because debugging is a critical skill He writes way faster than me anybody have questions its an array but the way you specify an array is via a pointer does that make sense so this means its a pointer but we are going to build it into an array any questions or anything this is stil bad no audio
 thats called abdication. You abdicated. Was it fun?oh no no one will ever do it again. Ill erase it so youll have it. Okay so while we were doing this somebody asked me a really good question and that was actually there were two questions. Im going to ask them in reverse order. ONe of them was why did he use an arrow on the left side and a point on the right side. period on the right side this is a pointer to the current object.Okay it is not the current object. It is a pointer to the current object or the memory address of the current object. In C++ we dont have to write it inside member functinos. SO i get to erase all of this and i dont know what you guys think but i think the code is more readdable the less text that is there. So that is the style that course staff like to read Now all that is correct we have to explicity assign all of the member variables. Then we have to do some for loop for int i equals zero, i less than num, atts i plus plus. atts sub i equals orig.atts[i] any questions? excellent questions i am glad  you brought it up. Look what he noticed. We have got a function refering accessing a private member of the sphere class. surely that should be forbidden but no because this right here says sphere because we are writing a spere class member function we have direct acces to the private members it is worth pointing out that if we are writing a sphere class member function we have direct acces to the private variables Any time a parameter is passed by value. that code is invoked. Okay. We are not done. OH shoot i think we have to be done. This is such a bad place for a cliff hanger because we have created new memory and we have no mechanism for cleaning it up. Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â SO we are just going to leave ourselves in a mess until firday
ssil <silence>
Is the mic working? Ok. I have no new announcement except that is Friday How about the volume now It's still Can you hear me now? Ok I think this is good Alright, so I have no new announcement So let's just start working Last time we were talking about bad thing, bad one right there, I try jump roping last time for the first time in like two decades Cuz my child got a jump rope felt delighted You know, how little generator in I handle thing, and I kind of thought I would gonna die after jump roping.  So I wish I could leave and point to that function signature right there, but you are gonna save me from having to do that  Cuz you are gonna tell me what that is the function signature of, what is that So copy constructor, right, how do you know that is a copy constructor, what did you check in your mind yea, the parameter is that an object of a special type or not of the very sin class So the of sphere in that function signature what tells you it is the copy constructor OK, I have one question for you. Why is the copy constructor's parameter, first of all, what is that pbr stand for?
Did you giggle? You get it right? Are you from Nebraska? Okay. Who else giggled at the PBR? You got it too? Are you from Nebraska? Okay. I don't know. Pass by reference right? Who's from Nebraska? Do you get PBR? It's the beverage of choice. I don't know why. Yeah you go home. I'm from there actually. It might be the beverage of choice here, I don't know. It's like a fancy beer in Nebraska. That's because it's kind of close to this one. Oh man, we don't have time for this. I am so sorry. But here's why. It's close to that and if you're from Nebraska that has meaning. Go Big Red. Right? And it's football season. Okay. Alright, so why is the copy constructor parameter passed by reference. Why is it passed by reference? Not passed blue ribbon. Yes? Exactly, very good. So, think about it. The alternative to pass, oh here we go, I have a brain. The alternative to pass by reference is pass by value. What happens when you pass by value is the copy constructor is invoked for you. But that what's we're defining here, so there's sort of recursive definition problem that exists if we try to pass my value in this context. I encourage you all to go write your own little class and it can even be simpler than this. I don't think you need any data members. Define your own copy constructor and see what happens if you try to pass by value. Why is the copy constructor parameter passed by reference? Because the alternative is passed by value. Peanut butter value. And pass by value invokes the copy constructor. Which is what we're trying to define. So I encourage you to go test it out and see what happens when you try to set up a copy constructor pass by value. Okay, another question. What does it mean that the copy constructor's parameter is constant. So I'm asking you exactly about the present of that constant there. I think we talked about it really really briefly. What does it mean in that context? Yes, the parameter very good. This promises that the copy constructor and the function in general will not change that parameter.
Ok, so orig is effectively constant. Ok, um, last time we saw the, um, we saw that parameter used here. What's the difference? What's, I mean it's not a parameter, that keyword used there instead. What's the difference between using it at the end and using it in the parameter list? Do you remember what it meant when we used it at the end? I'll put a little question mark, here. Do you remember what it meant? Yeah, Nathan? Right, so this time, this time, if you put it here it means that the function will not change those guys, the data members associated with the class. So, it's still a promise that something will be held constant and it's just an issue of which thing will be held constant. Ok? Now, i wanted to spend a second and just tell you how I Â happen to read that parameter list in, um, in, uh, English. I read it like if you asked me, What is orig? What type is orig?" I would say it's a reference to a constant sphere. A reference to a constant sphere. Ok? So, orig is a reference to a constant sphere. You will also see in your programming journey, you will see that keyword const here, and in that case, the English makes more sense. We just read it backwards. Reference to a constant sphere. They're just different syntaxes. Uh oh. What's the plural of syntax? Syntaccc . . . I don't know the plural of syntax. They're just syntactically different ways of expressing the same, uh, the same functionality. Syntactically different ways of expressing the same functionality. Alright. That's kind of a meta thing, right? I found a syntactically different way of saying syntaxes. Alright, any questions about it? Alright, so, const will come up. You'll see it in code that you maintain and read. Um, we will also kind of gradually ask you to use what we call const correctness. Now, as, as we ask you to write code. Now, what does that mean? It means that you, as a software designer, should be aware of what you expect to allo-allow to be changed. So, for example, as I define a copy constructor, I'm pretty sure, that making a copy of something shouldn't do something crazy to it like change it to 42 or something, right? And, so, this is a way of promising inside the code, no matter how you implement the copy constructor, that the original value will not be changed. Ok, that's called const correctness. Yes? Though, right, so the, so functionally you could eliminate the const and then just, you know, be a good steward of the code, right? Well, I'm not gonna write any code to change that. But, here's the thing.  This construct allows for, um, delegation of code construction responsibilities, right? So, I can now give it to you to write the code and you are not allowed to write bad code that will change that, that, um, the value on the left hand side. So it's a matter of security, actually. Ok? Now, it sorta fails in some context. This is purely an aside, so, if this does not interest you then it's ok to kind of turn down the volume a little bit. Um, but, it's not a pure, um, it's not a pure security measure, because, you know what? Sometimes, we want to use the copy constructor to count how many times a copy has been made, say. So in that case, and we might want to store that with the object. And, so, that level of, but, but if you make it const you can't allow for it because you can't, you can't record the state change within the object. So, you know, in effect, it ends up being functionally limiting, but it's ok. For our purposes, const for the input parameter.  Um, and in fact, there are many style guides, software engineering style guides, that will tell you that all reference parameters should be const. Ok, so, if you go work for Google, they're gonna tell you that, and you're gonna go, *Gasp* What?" But, but, um, uh, we don't make that constraint here. But, there are principles involved in the use of const. Ok, any questions about that? That was too much for a bridge on my part. I apologize. Alright, here's the big kicker though. We spent all this energy talking about this, um, copy constructor. Whereas, the first thing I said to you was, you know, the system provides one. What was wrong, in this case, what was wrong with the system provided copy constructor, and in general, how would you be able to diagnose for a class whether a custom copy constructor was necessary? So, what about this particular class demanded that we had to define a copy constructor? Yes?
Okay let's get started. So you guys in the back here. Yes, no. Nooooo. How about now, now, now, now, can't have it be a multiple tree. Alright sooo. Mp2 is due tomorrow night. There have been grading runs every night for the past you know five days or so. Uhm its looking like things are going really well. Only thing is I didn't get an autograder message from last night. Did anybody get a result from last night?Yeah? okay. Alright so I didn't get the message, maybe I'm just not done with the mp2. Alright then I want to rest assure, I want you to be rest assured that if you get a hundred percent on tonight's run and try and make a change and you get a 0 for whatever reason some compiler error, we're taking the maximum of tonight's and tomorrow nights. So you don't have to stop tonight with your 92 you can keep trying to perfect it if you'd like. Okay are there any questions for grading for mps at this point Okay so mp3 is going to come out pretty much immediately. If I had to ah assess a relative difficulty of mp3 over the whole semester, I'd say it's not conceptually the most difficult, but you are likely to spend the most time debugging on it, so prepare to spend more time on it than you might on some of the other mps Okay. We were talking about well you remind me what were we talking about, whats a concise way of stating what the subject was last time last friday when we met. Operator overloading and in particular we were going to overload the blank operator. What's blank? Assignment operator, very good. So for example, if I do something like declare, ugh I am just not going to be friends with technology today. Look I got nothing. Here. Okay. If I were to declare---accck.  My family watched ghostbusters last night on the way home from chicago, I'm thinking I'm like set up some poor karma between me and ghosts everywhere. SO if I declare spheres a and b, and create a to be something interesting perhaps, and then make the assignment b gets the value of a, then what the things you told me last time that I need to be sure to do are to free up the space previously occupied by b, the dynamic part of the space previously occupied by b and then explicitly copy over the values of , oops, of a. Okay. And that means that means, that I need to allocated new space that in the end looks just like a's space. Okay any questions about that at all I'm going to seperate that out into two sort of sub tasks. There's the clear task and the copy task. Now the clear task should feel a lot to you like another function that you've written, which one is it. The destructor that's right. The clear task should feel alot like the destructor. And the copy task should feel a lot like the copy constructor. That's right. Now do you just call those functions? No you do not Alright. So there are these two tasks. There's clear and there's copy. Okay. Now, there are some little teeny tiny and we're going to w write the assignment operator to do these two things. But there are some additional considerations that would really only occur to you during debugging, but we're going to be explicit about. So now what I want to know, is what happens upon assignment if b and a already refer to the same memory address? Now this can happen in lots of different ways. It can happen if we've passed something by reference, or it can happen because a is a dereference of some pointer that has some other name so there are several different ways where two things can be referring to the same memory address, can be names for the same memory address, so now what I want to know is what's the problem here, remind me. I think we got this far but I want you to remind me. Okay, yeah? 
Right, so when we try to copy this string array it just copy the pointer value that atts" held, and that ends up tingling our memory, right?  OK, so one way of describing our use of the heap for this string array is that we use dynamic memory. So that heap memory is dynamic memory, and that's makes so that you have to declare and define a custom copy constructor. So, why do we need one, the object uses  heap or dynamic memory. At any time, you have an object that uses dynamic memory, there's a new in the constructor is a good clue  Then you need your custom copy constructor. Ok, you happy? Good? Any questions about this? OK. Alright. So we're not done, because we've got these complex objects We've got these complex objects now that may or may not be declared in the heap, if this is a sphere If this is a sphere, say 'a', then this part of it lives in the stack, and the other part is instantiated to be a new command that lives in the heap OK, so we got this object that has pointers all over the place.  I want to trace a little bit piece of code, and show you where a problem occurs. Or let you see where problem occurs.  So my Int Main"  here declares a sphere, its name is 'a', and we are going to pass 'a' in as a parameter to this function.  Now you know at this point that a copy is made of 'a', cause look we got a good copy construct here.  A copy is made of 'a' on the stack, we got this stoop pointing off into heap memory.  The copy constructor knows how to do that. And I am going to ignore this one for a minute, because it doesn't help with my point at this point.  Now, we are going to do some computation, and maybe ask it to change, maybe use it as an input variable.  Then the function stops execution and control is passed back to just after 'myFun'. So control is passed back to 'main'. Now the question is: what happens to 's'?  When control is passed back, what happens to 's'?  It goes out of scope, it's one way to describe it, and what happens behind the scene when something goes out of scoop? Yes? That's right, it's removed from the stack like this.  OK, what do you think? Yeah there's a memory leak, that's right.  That memory that we asked for from the heap, this memory is leaked, by default.  So we're going to help out the system, we're gonna provide what's called a destructor, for the system to use when removing variables from the stack.  Now, suppose that we have just asked for this memory via a new statement, actually that one up there If I just ask for that memory via a new statement, how would I give it back, and let the system know that I'm done with it?  So my destructor, or the code that I am going to write for the system to use when a variable goes out of stack is just 'delete[] atts;.  Ok, any question about that?  So in MP2, you are asked to write a destructor, but it's for a more complex type.  In MP2, instead of objects in the array, you have pointers in the array, and memory has been allocated for each of them.  So that's what differentiates what I just did here from MP2.  So be aware of that, and that if in MP2 I just deleted this array, then all of that memory will be leaked. That should be some insight for what your destructor should look like for MP2. OK, there's a question. Yes?
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
right so when we try to copy this string array When we try to copy this string array  it just copied the pointer value at the held  and that ended up tangling our memory Right okay so one way of describing our use of the heap for um this string array is that we used dynamic memory okay so that heap memory is dynamic memory and thats what makes it you have to declare and define a custom copy constructor so why do we need one the object uses  heap or dynamic  memory okay and any time you have an object dynamic memory that is if there is a new in the constructor  is a good clue then you need a custom copy constructor OKay you happy? good any questions about this okay aright So um we're not done because we've got these complex objects we've complex objects now that may or may not declared in the heap if this is a if this is a sphere I'm going to change this If this is a sphere say A Then this part of it lives in the stack and the other part is in instantiated via the new command and it leaves in the heap thats right so we have this object that has pointers all over the place Show you were a problem occurs or let you see where a problem occurs So my int main here declares a sphere it's name is A. And we're going to pass A in as a parameter to this function  Okay now you know at this point that a copy is made of A cause look we got a good copy constructor here we got a copy is made of A on the stack stuff pointing off to heap memory okay the copy constructor knows how to do that and im going to ignore this one fora minute It doesn't help my point any Now we're going some computation and maybe ask its change maybe Were going to use it as a input variable whatever then the function stops execution and control is passed back to  just after myfun so control is passed back to main now the question is what happens to s when control is passed back what happens to s it goes out of scope is one way to describe it and what happens behind the scenes when something goes out of scope  thats right it is removed from the stack like this   what do you think  yea there's a memory leak thats right that memory that memory that we asked for from the heap right here this memory is leaked By default so we help out hte system by providing a destructor for the system to use when removing variables from the stack suppose that I had just asked for this memory via a new statement actually that one up there if i had just asked for that memory via a new statement how would I get it back Delete thats right So my destructor for the code I am going to write when a variable goes out of scope is just delete atts  any question about that? So in mp2 hold on just a sec  in mp2 you are asked to write a desctuctor  but it's for a more complex type in mp2 ill put this in green Instead of objects in the array you have pointers in the array and memory has been allocated for each of them So that's what differentiates what I just did here to mp2 so be aware of that and that if in mp2 I just deleted this array then all of that memory would be delete so that should be some sort of insight to what your desctuctor should look like  
Yes! right, because those go off the stack, those are free for you, yes?  Um yeah because it's an array. ok you need the brackets because it's an array,  if it were just a pointer, if we had instantiated this, as just a string pointer, a pointer to a word then, you wouldn't need the brackets, you would just delete it, ok so in general,  you're delete should match your news. whatever kind of new statement you use to create the thing, usually in your constructor, you're gonna use a similar thing in your destructor any questions about that? is it good?  it's called right after the return, it's as this um execution completes, and control is passed back to the calling function alright any questions? you good?  oh my gosh, there is so much book-keeping going on for you, we are so lucky, right? like your grandfather, my parents, I shouldn't have said that. Look at me do that! your grandparents in computing my parents in computing, um, they think that life is way too easy for us Actually, it's probably my grand parents, your great grandparents, but they think that computing is way too easy for us when in fact, you know, the fact that we don't actually have to keep track of what variables we're using,  ourselves, is just ugh. we're not authentic programmers, so the early days of C were pretty harrowing, so there's a ton of book-keeping going on, and part of what they keep track is what amount of memory is associated with each variable Alright, and you'll learn about it in future classes because of course that's what generations do, we need to inflict the pain of the pervious generations  alright, um, anyt questions about it? you good? ok, I have another story to tell you here. I'm gonna take you through another little piece of code,  Here's how this piece of code goes.  this time, I'm going to declare a sphere pointer b So here's b, and i'm going to ask for a new sphere  Now, we've made a constructor for a sphere, we made a constructor for a sphere, that sets up a default sphere to look like this so when I say new sphere, that constructor is called for us. so at the end of this statement, it's perfectly reasonable for me to draw this picture Making note of the fact that the sphere constructor was invoked for us.  not the copy constructor, the no argument constructor, any questions? Ok, now, let's look at what happens when we say delete b.  What do you hope happens when you delete b? When you say delete b what do you hope happens? by default.  what do you hope happens? All of this memory, all of this memory is given back to the system, right? by default, without the destructor, only this part is given back no dynamically allocated memory, no memory allocated with a new, is given back so again, we're responsible for writing a destructor that makes that happen, this is the same destructor, it's just used again so if you rememebr that code looked like, this
And it is responsible for clearing up the dynamic array. The rest of it is taken care of. Alright, so I at least, found this a little bit confusing at first, because all of this is the result of a delete statement on a sphere pointer, right? But that delete statement invokes a function that also uses a delete statement. So there are kind of two levels of abstraction going on here. Alright, here's the secret, here's the secret, it's probably the case, so each of these things is a string. How do you think a string is implemented? What do you think the string class looks like? It's a type it has a class, it's just standard. Yeah? Yes, a character array, that's right. Is it a static array or dynamic array? Is it on the stack or the heap? It's a heap, it's a dynamic array. So inside this string class is a dynamic array, or we don't really know, it's encapsulated away from us, but we have every reason to believe it is a dynamic array. So how come I don't have to worry about that dynamic memory? Well I write this, why don't I have to say, Oh wait I have to clean out my strings?" Why? Who's they? So the people who implemented string, that's right. Exactly. So strings clean up after themselves. And look what we have done, we have written it so that spheres clean up after themselves. Right? Now, if you have a class that wants to make a dynamic array of spheres, they never need to worry about it, because when spheres go out of scope, they're just gone. When you call delete on a sphere, it's all gone. No big deal. Okay? So there's multiple layers here of things that work. Alright any other questions about this? Alright, fine. Here are some sort of summery information about destructors. We don't call the destructor, we provide it for the system to use in two situations, when a variable goes out of scope, and when delete is called on a pointer to an object of type "x". And so it's when a variable of type x" goes out of scope. And it's x's destructor is never called.  Okay any question about that? So, it's referring to a class, some class. Alright so now, how do we know if we need a destructor? And the answer is, if your constructor allocates dynamic memory, or if any other member function allocates dynamic memory associated with the object. So it's not just the constructor, but if any, if your object has dynamic memory associated with it, you need a destructor. 
And allocates dynamic memory. Heap memory is equivalent there. Okay any question? And then as we saw, a destructor typically consists of the sequence of delete statements, which means, and the way you handle that is basically to go through your private members and go Hey! Do I need to delete that?" No. The answer is no. "Do I need to delete that?" No. "Do I need to delete that?" Yes. So you go through each of the data members and ask yourself whether or not you have used dynamic memory. It's just a checklist. Okay, questions? Is it good? Okay. One more problem. Let's trace a little bit of code. I'm going to declare a sphere a and sphere b.  Okay so here's a, and here's b. And I'm gonna give 'a' value. That is, I'm gonna instantiate 'a' to be something. 4.8, 3, and black and white", "bouncy", and how would you characterize a soccer ball? Yeah all spheres are round, but okay fine. Whatever, not worth the time. Alright, so now the question is What happens when we do that statement?" What do you think happens when we do that statement? A member-wise copy. That's right. The assignment operator is by default member-wise. So again we have this groaner of a situation where 4.8 is copied appropriately, 3 is copied appropriately, and the pointer value is copied appropriately. Okay so the problem is assignment. Okay so the problem is, assignment is member-wise by default. Okay, so how do we fix it? We redefine what assignment means. We solve by redefining what assignment that. That symbol. Okay if haven't ever seen operator overloading before, I assert that this is not new to you. Even if you have not heard the phrase operator overloading, I assert that you will not be surprised by it because here is what I think. I think that if I write code that looks like this. If I say int a, b, c, like this and then I initialize a and b so a equals 37, b equals 63. If I say that then that code at the bottom is fine, right? Yes? Good. And moreover, I think you will take an alternative. I think if I say double a equals 37 point something, double b equals 63 point something, you're okay with that too. Right? So now, you know that what goes on behind the scenes when that operator is invoked is different in each of these cases. Right? It's a little bit different because doubles are implemented differently than integers, so this plus has to behave differently. And it didn't freak you out at all. Right? You're like Why is she even talking about this?" Well here's another thing that I think won't freak you out. I think it's true that I can say string a equals cat, and string b equals dog.
What do you think happens?  Here?  What do you think happens there?  Cat dog is right  what a minut? how come it doesn't line up arrays, take the character values and line does up?  that would be kind of a legitimate way of  doing addition as well. right? so how does it know  that in c++, how is it true?  that addition  is concatenation?  rather than some kind of numeric operation  how does it know? how does it know that the plus is different there? The plus is defined to behave differently for strings. And it is just a function. So in this case the + is a function that takes to arguements and does something to them. In the case of integers it adds them up. In the case of strings it concatenates undefined. So you already use operator overloading all the time k. Now the question is and and that is implemented in the string class. It's part of the string classes responsibility to implement  addition.  K it decided it would Okay fine.  What about this?  sphere a(5)  sphere b  eight  Let's go back to our stupid spheres. K let's go back to the spheres where there is only a radius.  How should that work?  Yeah? [mumbles (you need to find how spheres are....) of a student speaking] that's right  We haven't defined how it should work. right? What we've got now is a is a sphere and b is a sphere. We kind of want to add them to eachother. The way we make that happen is to declare a sphere class member function.  Who's name is operator+.  k so this a ...  this right here is the function that implements this symbol So we can do it no problem. Alright let's have a design moment. Lets have a design moment. What should it mean/ What should it mean for to spheres to be added to one another...together? What should it mean?  What do you think? Yeah?  Oh let's just add the radii right? let's just add the radii. We could like find the volume and add that together. Kinda makes sense but...but for the sake of illustration we are going to design an addition operator for spheres that simply adds the radius together. Kat so let's do that... OH and  can you speculate on what this thing is for? Can you speculate on what that return value is for?  You have to return one that is the sum. Right?  Okay. And it's by...we're going to return a sphere so we're gonna declare  sphere t  or return  Kay  Amd then we can say  t dot   theRadius  equals uh oh what do we have  what do we have here? We've got... we're defining what happens here.  This one is the parameter so this one is s  so its  s  dot the Radius  plus  this one is the current object K so this plus  is the member of the sphere class so it will be called on the sphere class object and so  the current one is a. So it's just s dot theRadius    plus  the Radius  and then we're gonna retururn t  Okay?  Yes 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
No, it means it's a reference to a constant sphere. Okay, it's a constant sphere by reference. So you cannot change the sphere, so b cannot be changed, and if we didn't want to change a we'd put a const right here. So you can never change the reference, reference can never be changed, once it's associated you can never change it. Okay, let's see, I want to keep going, it turns out addition and assignment are not the only things you can overload. That as of C++ 03 was the list of operators that could be overloaded. I, in my experience, in my programming lifetime, which is, you know, not all that extensive have only overloaded a very few of these. This, certainly, assignment we're going to do, these are pretty common, these IO operators are very commonly overloaded. But generally, you know, you really have to know what you're doing when you overload many of these things. We'll talk about overloading this one also. I don't know, other than that. Okay, but you may see code that overloads all of those things. Okay, what time is it? Oh we have plenty of time. Okay, so we're going to go back now, now that you're comfortable with operator overloading, we're going to go back and revisit the issue of the assignment operator in the context of dynamic memory, okay? The assignment operator in the context of dynamic memory. Alright, let's see, so just to remind you this is the code that we were trying to implement and it is this assignment operator that we want to fix. The way you declare, the way you declare the function that we're going to overwrite is to say sphere. It turns out that in this context it's okay to return it by reference but we won't here because that will freak you out, freak me out, freak us all out, so we won't. And now the question is, what does the parameter list have to look like? Well we want to promise that we won't change this thing on the right hand side.. So we're going to pass back a constant, I mean, sorry, we're going to accept a constant sphere reference and we're going to call it right hand side. And that's it. We'll talk about what goes here in quite a lot of detail, eventually. Okay, any questions? So that's what the function signature looks like, here's what the implementation needs to be. Okay, so what we're trying to do, what we're trying to do is implement b gets the value of a. So here's a, and here's b, and in the end we want b to look like it's own copy of a. Okay, so how can we prepare to do that, sorry, how can we prepare to do that? What do we need to do to make b look just like a if this is b and this is a? We don't get to call the copy constructor, that would be nice, but we don't get to. What do we need to do at a lower level, what commands do we need to run? Yeah? Very good, very good, so in the end we're going to want b to look just like this, right? Which means that I better get rid of this one. Alright, so let's clear up b, we're going to clear up b and then things can feel a lot like the copy constructor. Okay, we, you know, copy a's value over, copy a's number of attributes over, okay now I need an array that is that long. And then copy these values over, okay. So at that point, at that point it looks like a lot like the copy constructor. Okay, perfectly fine. What would be the consequence of not giving back this memory, before we make that copy? A memory leak, that's right. Because the minute we reassign that pointer to point to this space, this memory would just be sitting there, it would have nothing pointing to it. Okay, fine, here's another question for you. Given that, what we have said, is clear the left hand side, clear the left hand side and copy
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
right hand side into it. if that is our algorithm what happens if the lefthand side and righthand side are already two different names for the same space. what happens? it waste time copying it and even worse on that... yes? yes exactly. think about it. we have just said that are copying process is to first blow away existing memory and then make a copy of the right hand side which that pointer is not valid so one of the things that we are going to be sure to do is protect against self assignment because they are already the same thing for one thing there is no sense in making a copy but the other thing is if you do make a copy will destroy the current object and then we will talk about well i will ask you this could be quick we will revisit the start how do we implement that and i will give you a hint by doing this so how do we implement this chained assignment we will start it next time
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
(silence - video playing)
Okay let's get started. So you guys in the back here. Yes, no. Nooooo. How about now, now, now, now, can't have it be a multiple tree. Alright sooo. Mp2 is due tomorrow night. There have been grading runs every night for the past you know five days or so. Uhm its looking like things are going really well. Only thing is I didn't get an autograder message from last night. Did anybody get a result from last night?Yeah? okay. Alright so I didn't get the message, maybe I'm just not done with the mp2. Alright then I want to rest assure, I want you to be rest assured that if you get a hundred percent on tonight's run and try and make a change and you get a 0 for whatever reason some compiler error, we're taking the maximum of tonight's and tomorrow nights. So you don't have to stop tonight with your 92 you can keep trying to perfect it if you'd like. Okay are there any questions for grading for mps at this point Okay so mp3 is going to come out pretty much immediately. If I had to ah assess a relative difficulty of mp3 over the whole semester, I'd say it's not conceptually the most difficult, but you are likely to spend the most time debugging on it, so prepare to spend more time on it than you might on some of the other mps Okay. We were talking about well you remind me what were we talking about, whats a concise way of stating what the subject was last time last friday when we met. Operator overloading and in particular we were going to overload the blank operator. What's blank? Assignment operator, very good. So for example, if I do something like declare, ugh I am just not going to be friends with technology today. Look I got nothing. Here. Okay. If I were to declare---accck.  My family watched ghostbusters last night on the way home from chicago, I'm thinking I'm like set up some poor karma between me and ghosts everywhere. SO if I declare spheres a and b, and create a to be something interesting perhaps, and then make the assignment b gets the value of a, then what the things you told me last time that I need to be sure to do are to free up the space previously occupied by b, the dynamic part of the space previously occupied by b and then explicitly copy over the values of , oops, of a. Okay. And that means that means, that I need to allocated new space that in the end looks just like a's space. Okay any questions about that at all I'm going to seperate that out into two sort of sub tasks. There's the clear task and the copy task. Now the clear task should feel a lot to you like another function that you've written, which one is it. The destructor that's right. The clear task should feel alot like the destructor. And the copy task should feel a lot like the copy constructor. That's right. Now do you just call those functions? No you do not Alright. So there are these two tasks. There's clear and there's copy. Okay. Now, there are some little teeny tiny and we're going to w write the assignment operator to do these two things. But there are some additional considerations that would really only occur to you during debugging, but we're going to be explicit about. So now what I want to know, is what happens upon assignment if b and a already refer to the same memory address? Now this can happen in lots of different ways. It can happen if we've passed something by reference, or it can happen because a is a dereference of some pointer that has some other name so there are several different ways where two things can be referring to the same memory address, can be names for the same memory address, so now what I want to know is what's the problem here, remind me. I think we got this far but I want you to remind me. Okay, yeah? 
Okay, let's get started. Can you guys in the back hear? Yes, no? No? How about now, now, now, now? Can't have it be a multiple of three Okay that's good Alright, um sooo MP2 is due tomorrow night. Um, there have been grading runs every night, for the past, you know, five days or so. Um, it's looking like things are going really well.  Um, the only thing is I get an autograder, an autograder message from last night. Did anybody get a result from last night? Yeah? Okay, alright so I didn't get the message. Maybe I'm just not done with my MP Um, alright and then I want to rest assured, I want to rest you, I want you to be rest assured that, um, if you don't get 100% on tonight's run, and you try and make a change and you get a 0 for whatever reason, some compile error, we're taking the maximum of tonight's and tomorrow night's. So, you can, you don't have to stop tonight with your 92, you can keep trying to perfect it if you like, k? Are there any questions about grading for MPs at this point? Okay So um an MP3 is going to come out pretty much immediately. If I had to assess a relative difficulty of MP3 over the whole semester, I'd say it's not conceptually the most difficult, but you are likely to spend the most time debugging on it. So, prepare to spend more time on MP3 than you might spend on some of the other MPs of the course. Okay, we were talking about, will you remind me what were we talking about? What's a concise way of stating what the subject was last time, last Friday when we met? Operator overloading and in particular, we were going to overload, operator overloading is what I was going for, and in particular we are going to overload the blank operator. What's blank? Assignment operator, very good, okay so for example, if I do something like declare, oh I'm just not going to be friends with technology - look I got nothing. Here. Okay, if I were to declare, ugh, ack. d here. My family watched ghostbusters last night on the way home from Chicago. I'm thinking that like, I like set up some poor karma between me and ghosts everywhere. So if I declare spheres 'a' and 'b' and create 'a' to be something interesting perhaps. And then make the assignment 'b' gets the value of 'a', then what the things that you told me last time that I need to be sure to do, are to free up the space previously occupied by 'b', the dynamic part of the space previously occupied by 'b', and then explicitly copy over the values, oh oops, of 'a', k? And that means, that means that I need to allocate new space that in the end looks just like 'a' space. K, any question about that at all? I'm going to separate that out into two, uh, sortof subtasks. There's the clear task and the copy task.  Now the clear task should feel a lot to you like another function that you've written, which one is it? The destructor, that's right. The clear task should feel a lot like the destructor, and the copy task should feel a lot like the copy constructor, that's right. Now, do you just call those functions?  No you do not, but we'll talk about that in a minute. Alright so there're these two tasks: there's clear and there's copy Okay, now there are some little teeny tiny, and we're gonna write the assignment operator to do these two things, but there are some additional considerations that would really only occur to you during debugging, but which we're going to be explicit about, k? So now what I wanna know is what happens upon assignment if 'b' and 'a' already refer to the same memory address? Now this can happen in lots of different ways. It can happen because we've passed something by reference or it can happen because 'a' is a dereference of some pointer that has another name. So there're, there're several different ways where two things can be referring to the same memory address; can be names for the same memory address, k? So now what I want to know is what's the problem? What's the problem here, remind me, I think we got this far, but I want you to remind me. K? yeah?
Very good.  So remember that our two tasks are clear and copy.Ok? So letâs do that.  b gets the value of a.  So we clearâ¦.. And there is nothing to be copied anymore.  So we basically invalidate our algorithm here, invalidate our data here. We are gonna solve that in the code we write  for the assignment operator by protecting against self assignment. Ok? And then the other thing that we need to do is to implement this behavior.  So C-based languages tend to let you chain together assignment operators. ok?  And all we are doing by creating the , writing the assignment operator is a single chain right here.  I am gonna draw a pair of parentheses and see if that helps you come up with a suggestion that we might use to create a chain assignment operator.  How could we implement that. How could we make it so it is ok to return values.  I am sorry. To assign chain values. I just said the whole thing. I have no brain.  Ok, so I said the answer that I was hoping you would say. So sorry... Alright. So notice this is a function call. Right? This is just like b.operator=(a).  If it were to return a value and then that value could be the right hand side of c's assignment statement. Right? So effectively, what we want is c.operator=(b.operator=(a)). How do we achieve that? Well we have a return value out of the assignment operator. And I am just gonna describe that as return a helpful value. Ok? Any questions about it ? Alright. So let's make some plans.  Here is what the function signature looks like. We are gonna just sort of make a list of things that we are gonna need to do when we actually write the code. Ok. Make a list of things we need to do. First things is: We need to protect against self assignment.  And that's a conditional. That says if the things already don't refer to the memory address then we are going to clear out the left hand side. Then we are gonna make a copy of the right hand side.  And then in the end we are going to return a helpful value.  Ok? We will talk about that in a minute when we write code.  And any questions about it? Ok?  So this is our list right? This is a list of what code needs to look like.  Writing  code this way is really common. You know. Do your comments first and then fill in the blanks. Because no one of these is going to be Â particularly complex. And here we go. Alright. So how do we protect against self assignment?  How could we ask the question of whether or not being A" refers to the same spot in memory. Yes? So if this is no the same as right hand side it's almost correct. Help me debug it. What is the right hand side?  What kind of thing is right hand side?It's a sphere.  What kind of thing is this? I think I have only mentioned this very quickly once.  So I will write it again here. this" is a pointer  to the current object.  Ok? And in this case that's the left hand side. 
Very good. So remember that the two tasks are clear and copy, so lets do that. B gets the value of A. So we clear, then theres nothing to be copied anymore, so we basically invalidated our algorithm. We invalidated our data here. We're going to solve that in the code we write for the assignment operator by protecting against self assignment. And then the other thing that we need to do, umm, is implement this behavior. So C based lanuages tend to let you chain together assignment operators. And, all we are doing by creating the assignment -- writing the assingment operator is a single chain right here. I'm going to draw a pair of parentheses and see if that helps you come up with a suggestion that might be used to create a chain assignment operator. How could we implement that? How could we make it so that its okay to return values? I have no brain. So I said the answer that I was hoping you would say, so sorry. So notice this is a function call. Right? This is just like b dot operator assignment operator a. If it were to return a value then that value could be the right hand side of C's assignment statement. So effectively, what we want is c dot operator equals b dot operator equals of a. How do we achieve that? Well, we have a return value out of the assignment operator. And then I'm just going to describe that as return a helpful value. Any question about it? So let's make some plans. So here's what the function signature looks like. We're going to just make a list of things that we need to do when we actually write the code. Yeah... okay. Make a list of things we need to do. First thing is we need to uhhh protect against self assignment. And that's a conditional that says if these things already don't refer to the memory address, then we're going to clear out the left hand side. Then we're going to going to make a copy of the right hand side. And then in the end we're going to return a helpful value. And we'll talk about that in a minute when we write the code. Alright, so this is our list of what the code needs to look like. Writing code this way is really common. Do your comments first and then fill in the blanks. Because no one of these is going to be particularly complex, and here we go. Alright, so how do we protect against self assignment? How can we ask the question whether or not b and a refer to the same spot in memory? Yes? So if this is not the same as right hand side is almost correct. Help me debug it. What is the right hand side? What kind of thing is the right hand side? It's a sphere. What kind of thing is this? I think i mentioned this very quickly once. This is this is a pointer to the current object. In this case that's the left hand side.  
okay. Alright, fine, so help me debug this Couple different ways you can debug it I think It would be relevant Clearly, there's a type mismatch Right? Yeah? Right that's right. So we want to be looking at the memory address, right? The location in memory, the only time this is really truly broken is if they refer to the same location in memory So, we're gonna say, the address of the right hand side, so this is not the same as the address of the right hand side We'll talk about that in a little bit Ok, we're going to clear out the left hand side, gee, we have written this code before So I'm gonna go head and do it, we're just going to delete  The attributes Do I need to go through that array and free up the space associated with the string?  No, because they're just strings. They are not string pointers that we allocated the memory for, they're just strings each string might have dynamic memory associated with it, but it's not our responsibility to deal with it The string class can deal with it Okay? Any questions about that? Alright, fine, and now we need to copy the right hand side  So let's see if I can do this, um, the radius  equals right hand side the radius yes somebody told me about that woah numAtts equal right hand sides numAtts  atts equal new  string  how many of them do I want Good and then, for i int equals zero less than numatts, I don't know why I am narrating this Okay. Yes?  You write it faster than I did? Haha Okay So, while I was doing this, I had that feeling that you should have when you write code and you're writing code that you have written before If you're writing code that you have written before, you should be going, why am I writing this again? Why am I doing this again? And you should make for yourself a function that you can invoke in each case In fact, we're going to do that here. We're going to  Go ahead and pull this out, and put it into a member function called copy Uh, who's return value what kind of return value do we want for it?  Nothing. We don't need anything.  And it's code is merely this, ugh, that code  So this goes right in here Now, I have a question for you. Okay? Any questions about it?  Yes I don't know what you're talking about Alright. Any questions about it? Is it okay? I have a question for you So this is a sphere class member function, which means when we actually do the implementation we're gonna scope it to the sphere class, much like those are. Now if this is a sphere class member function, it means that it needs to be declared inside the sphere class itself Is it public or private
okay, private is correct. Okay, private is correct and the reason for that is... It's only used by other sphere class member functions right It's only created so as to simplify our internal implementation of the class So, clear here is a private member function. Any question about it? Alright, of course I have this feeling while i was doing this part as well. This one needs a member function It's not gonna return anything. It's going to be void copy this time it does have a parameter. I'm going to go ahead and pass through the right hand side As a constant sphere reference  Uh, right hand side.  It's implementation is going to be exactly that . And again it's going to be private Any question about that all all? Yes? That's a good thing to notice.  Yeah, no . You can not. His question is, Why are we doing this? We already have the destructor and the copy constructor. We have those ? Why aren't we just calling those here. The reason is because in principle. You are writing those functions for the system to use. They aren't yours You can't just call them willy-nilly The indication that is this true. There is no return type. The compiler is expecting you to be calling a function that yields a return type. There is no return type for the destructor and the copy constructor. So you as the coder have no business calling them. On the other hand, you are going to back and change your code for the destructor. The new shiny code for the destructor is simply going to be a call to clear The new shiny code for the copy constructor is going to be a call to copy. Okay so, i agree that we shouldn't have the same code in multiple places. I disagree where we should stash it. Yes? Um, so the question is.. Whether or not we should. How we should. Wait whether or not we could check for equality instead of inequality. If they are the same then do what. Nothing. So you want the other side. Or whether it wold be single or double assignment operator. If it is a logical question then it is double. I assert that you really don't want to do that. Then you are being explicit about the else. And then there wouldn't be anthing to do otherwise. We will run into this later in the class such that if something is true then we will do nothing Alright, let's return a helpfull value 
What kind of thing do I need to return? A sphere, right? So what I'm going to return is oh, you're not going to like this I'm choosing that one, in principle at this point I should be able to choose b or a the right hand side or the left hand side choosing the left hand side so that i can return by reference because nothing is going to happen to this" in the execution of that function Alright! Any questions about it? OK. Now, guess what, if you replace that rectangle with a call to clear and this rectangle with a clear to copy, except for type information, we have just written every single assignment operator you're ever going to write. You should just go, and cut and paste from this. Any questions about it? If you should decide to be creative, you are still responsible for all these parts you still need to check for self-assignment you still need to clear out you still need to make a copy, and you still need to return but, yes, you can do those in different order if you want, but I wouldn't, why? Ok! Any questions about it? Yes?! I'm not returning by value, I'm returning by reference. I could return by value if I wanted to but it would be slower to do so so I'm going to return by reference. I know that this" is not going off the stack, right? I know that this is not going anywhere because if it were, I wouldn't even have the function, so this is fine. this" exists in the outer scope. in the calling function OK, so I can return the value of 'this' by reference. Alright, so this is what it looks like in the end, and like I said, except for type information, every single assignment operator you ever write just like this. I have a question for you though, and it's on the board, (Repeating student's question) Process it? What does it mean? (Iterating question) What's the difference between it, and what we did? Yeah? Yeah! Very good. Instead of referring to the memory location labeled by this on the right hand side we're referring to its value right? The information that they hold. In this thing So we're checking to see if the value of each side of the assignment statement are already the same. It's kind of reasonable, right? Why not? Why wouldn't we do that? Why would that be a bad idea? It takes longer time, good. Why? Yeah, you have to go down and look at everything, right? I'm going to use that as the second one of these bullets. So, it might take significant time to check equality ok, fine. Why else? I could've put it first, there's no real reason. It's not like to other one is that much more expensive. It's kind of dependent. Yeah? Very good, very very good. This operator right here, has on its left hand side, a sphere and on its right hand side a sphere So the only way that that is going to work is if that operator is overloaded so, operator not equal must be implemented.
I don't know about you, but if I could avoid doing that I think I would like too. Ok.  And the last one, the last point is kind of subtle. There is a software engineering principle that says that you should leave the decision of whether to reassign to the client.  Ok. So leave the decision of whether or not a reassignment should happen to the client. So yes, they might both be the same, but they might do an assignment anyway and maybe that's to avoid a conditional maybe we do not know why. But what we do know is that when we when we check to see if they're the same, we are essentially doing the same amount of work as an assignment anyway. So because you have to you know we have to look at every last thing, so we are not going to presume that we are allowed to take that time here. So the short way of saying all of that is leave the decision  to reassign  to the client. so that when they say 'a' equals 'b' they want it to happen and the only time we are not going to let it happen is if it is a destructive maneuver. Ok. Ok. Alright, I think that is all I wanted to say here. Alright. We've been talking for about two and a half days now. About things that all feel kind of the same. They are all about responsible use of memory and sure enough we have the rule of the big three. A rule of the big three simply goes if you have reason to implement any one of the copy constructor the destructor or the operator equals (operator=) then you must implement all three What I want to know from you is a concise statement about when is that. When is it that you need to implement them rather than rely on the system provided. When is it, when do we implement these things? Yea? That's right. When the object itself uses dynamic or heap memory.   Now, umm... I guess I feel like that's a little bit inaccurate because if you use a string are you using heap memory  are you using string...are you using heap memory if you use a string  who knows is the right answer we don't know for sure but we might be and so what the real criteria here is not that it explicitly uses, but that it.. that the object itself explicitly allocates. Ok. So not that it uses cuz we don't necessarily know, but that it allocates that is it says the new word.
Alright, any question about that? The rule of the Big Three. Okay so, we're going to return for a bit to a object oriented programming. Because C++ has some idiosyncrasies and some distinctions from Java, in particular that you should know about.  And then many of you will have come here without a lot of experience in object oriented programming. So, historically, the objective for even creating objected oriented languages was two-fold. One was to create code that is smaller, that is to increase code reuse. And two, which sort of follows from that is to decrease the cost of maintaining such code. So, the idea that in objected oriented language should exist really arose out of the need to structure your code more efficiently. From a programmer's perspective, not necessarily from a code execution perspective. So from that understanding, from the understanding that we are trying to write less code and thereby make it more maintainable, these characteristics arose. So, encapsulation we already talked about. If you wanted a little quiz, you should sort of go back and make sure you know of two ways that C++ implements encapsulation. Or makes encapsulation easy to implement. Polymorphism we are actually going to talk about today. Suffice to say its definition follows its name. Basically, a function can behave differently depending on the type of the calling object. We will talk about that a little bit today. But the biggest thing we're going to talk about today is inheritance. And, without further ado, let's begin. So we have been talking about the sphere class. And now we have decided from a design perspective, that spheres are not specific to us. In fact, what we want is a named sphere class. A named, when I say named I mean sort of labeled, named sphere class but otherwise this thing should behave a lot like a sphere. I'm going to decide that I'm going to call this thing ball but of course I could call it anything I wanted to call it. Usually, it's the case that the name you happen to choose is a specification - is more specific - than the original thing. The original functionality, and we're going to set it up, we're going to define class ball, So that it is a - use language is a - public sphere. So this indicates inheritance. That colon is inheritance. Inherits from sphere. Now we have specific language in C++ to denote these things. We refer to sphere in this context as the base class. We refer to ball as the derived class. And this corresponds to superclass and subclass in Java. Any questions so far? So now, there's sort of an interesting little parallel between these two things that you might find kind of interesting. I have no english today, apparently. This word corresponds with this word. Is it just a happenstance that we chose the word public in each of those cases? And the answer is no. In fact, the inheritance type keyword can be the same as the access types. So we could have private inheritance as well, and in a minute we'll talk about protected inheritance. But, for this class, we're only ever going to have public. Okay so here's some - here's your first key fact. The access type - the access type - in the base class that is these public and private together with the inheritance type, imply the access in the derived class. So I'm going to write that down in just a minute we'll talk about what it means. So the base access,
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
plus inheritance type imply derived access and furthermore the most restrictive of those two applies. so let's do an easy example first So let's do an easy example first. So all of these functions are public access in the base class and it is public inheritance and so it is as if all these functions live in the public section of the derived class. So now it is as if all of those don't exist there. They actually exist here in the ball class for when we declare ball. Any question about it? You already experienced a little of this when you worked with images, I believe. There's an exception to this. The exception is that the private elements in the base class are never visible to any derived class. So the exception: private in base are not accessible. By derived classes Okay. Let me see what else I was gonna say here. Okay, there's one more thing that's key to pointing out. If all we ever had was private and public, things would be a little less interesting, but this last thing here can be perceived as quite a restriction. So what we have is something called protected access. and inheritance That, for example, might allow you to declare something like surface area, in which case any of these functions could access it, but this would not be allowed. So this protected is like public to a derived class but like private to client code. [nothing] So you'll see a lot of base classes with protected access sections, very common. On the other hand, what is not so common is any kind of inheritance other than public, and certainly for this course we will only ever use public inheritance. So you can kind of not worry about getting that tangled up Were there questions? [nothing]
Uhh, so the question is how come the ball class can access the radius. How do you know it can? Did you say can or can not? The ball class, the ball class member function can not access the radius. ball(double r string n). Where? There is just a comma missing there. OHOHOH, very good! We have to invoke the sphere class constructor in order to do that and it has to be explicit. So we can not, the constructor, that's really a good point actually, so what he detected and is really germane is that that ball class constructor has a problem. Right? It can not take a radius and set the radius because it doesn't have access to this. But what it will do and you'll see is it going to call the, explicitly call even, the sphere class constructor, OK? Does that make sense? Is that answer it? Sorry, I didn't...I don't think anybody ever pick that up before. Good job! Yeah? Yep! Yep! The base class of , the base class member can certainly access the protected values, they are just like they're sitting in here. OK? Alright! Anything else about this? There is, there is a hint. Bye! See you later! (Laugh in the background). Mean mean mean. OK, anything else about this? Yes? Yep! That's right! Yes, but it does exist, we are going to talk about that in just a second. So the question is kind of: OK, what's happening in memory?" and I think that the following will clarify some of that. I can draw you some picture that will clarify some of that. First of all, let's trace some code, OK? So, start with main here, start with main. We are just gonna declare a sphere, and it gonna has a radius and nothing is surprising about that, right? We can still, of course, use that base class to declare an object, there's nothing that says we can not, OK? Similarly, we can declare a ball, now, subject to the constrain, that the ball class can construct a sphere, it does so and the way to think about it is in fact it builds a sphere first with all of it staff whenever it has, and then adds to it, it adds to it the string corresponding to the name in memory. OK, so build the sphere class thing first and then it adds to it what it means to. OK so ball is a sphere with a little bit more added on to it to make it more specific. OK. Can I say b.getVolume()? Would you expect... first of all, what class member function is getVolume()? Sphere class, that's right. Its volume kind of thing, so its member functions are in the sphere class. Would you expect me to be able to do that? YES, yes, yes, yes. That's what most of this is about, is access to the member function of the base class through the derived class, OK? No problem. What do you think happens here? Anything surprising about calling printVolume? Is it OK? Anything surprising about PrintVolume there? Yeah? Yeah, you do. Right there. Yeah, yeah, yeah, good. I love the easy ones. (Laugh). OK. Nothing surprising about it right? It all just talking about spheres. Yeah?
This one, on the other hand, this one feels a little weird [laughter] this one feels weird What's weird about it? Yeah? Yeah that thing up there expects a sphere, right? And we're calling it with a ball Guess what? Whose copy constructor is invoked? is the question, right? It's passed by value, whose copy constructor is invoked? Sphere's copy constructor, that's right. And so that means, when that ball is sent to that function there is only a sphere inside of it But in this case, of course, that's fine, right? That's fine. There's a sphere, we needed a sphere So that's perfectly fine. Alright. So Sphere's copy constructor invoked even if it's the system provided one. Even if it's the one provided by the system and not our custom  One. Okay fine. Here's what I want to know next. I'm going to declare a base class thing and a derived class thing. Can I do that? [incoherent] Okay so this is - which one of these is larger? Which one of these things takes up more memory Tell me to stop when I get the larger one Yeah okay, this one I don't know if that was ever going to work. Okay. So is this assignment okay? The thing on the right hand side is larger than the thing on the left, is that okay? It does work! It actually works. It works; it compiles; and the result is that this thing is kind of sliced off to go here Okay so the base class thing can accept on its right hand side A derived class object - but it's sliced across This still is a base class thing Okay so this is okay... But b is still base or smaller How about this one? No, no way, compiler won't let you do this It says woah, woah, woah, you didn't give me enough information on the right hand side to create one of these" Okay, so the compiler actually does not allow that Disallowed by compiler Okay... [talks to student]. The question is what happens here What happens when we're talking about pointer instead And we'll start there next time I want to be the one that tells you
Okay. My clock says it's eleven o'clock so let's get going. You haven't even asked for it yet, but I'm giving you an extension on the extra credit portion of MP3. On the website it says it's due on the 22nd and I just I said on the slides it was due on the 25th so we'll go with the 25th that's fine. Yea right, yayyy. Oh you're so welcome. You're so welcome. I'd like to say anytime but that's not quite true either. We have more print outs coming so if you don't get a print out they will be there. I swear I always print out enough and they just disappear. I don't know who's taking these print outs. Who wants them. Maybe it's sabotage. Let's see. Oh, ok. So MP2 was due last night. Yes? Ok. Yea it was, it was. Does anybody know how long the queue was? Ok. Six people. Sixty six. Six hundred sixty six. Yea, no no. Ok. So that's like about 10% of the class was on the queue. Can you guess how I feel about that? Yea. So what that says is what what it says to me is that you know 10% of people were working on the problem and got stuck. So that means even an even huger proportion of the class was working on the MP at the last second. So that just breaks my heart.  Cause it's so fun. You want to do it early. So here's the thing. I cannot promise you that the queue wait times will improve. I can't promise you that. Now do you see how meta that was? Cause if I say I can't promise you the queue wait will improve then you won't count on it and you'll go earlier in the week and spread out your requests. And then the queue times will improve. So there's this kind of thing going on there. So So I refuse to promise that the wait on the queue on the last day will improve. There should be huge incentive to start early finish early. I think course staff is most broadly available at 9 o'clock in the morning, 10 o'clock in the morning. Think about your fellow students schedules and plan accordingly. It's this interesting problem, right? Like, the crowd. The flow of the crowd. Uhm, alright. Uhh. We do try, but sixty people on the queue's an awful lot of people. It was bad monday night too. Oh, the other thing. Course staff actually asked me to tell you was that you have now had two labs whose focus was debugging. They, they are exorting you. Encouraging you to try to be a little more independent. When you run into a problem instead of just putting your name on the queue go ahead and you know. Be a little more tenacious then you would've been a month ago in trying to figure it out yourself.  That's gonna be a valuable skill as you go forward.
Okay, let's work shall we? We were talking about inheritance and we are still talking about spheres. Maddox, the other instructor for the course came up to me this morning and said, You do love spheres, don't you?" I don't know, we all love spheres. Who doesn't love spheres? But we're almost done. We're almost done talking about spheres. Alright, so we had two classes last time. One of them was the sphere class. One was the ball class. Do you remember the way that we described the sphere class in the context of inheritance in C++? Base class, that's right. So the sphere class is the base class, Base class... and how about class ball"? It is referred to as the derived class, good. And, the key thing to observe here is that basically we are exercising code reuse. That is, if we already have a sphere class, then we can avoid re-implementing a lot of these functions if we just say we intend to use them via inheritance. So this is largely an issue of code reuse. Okay, let's see... so there are a few little behaviors that we should talk about. We talked about them in here a little bit last time, but I didn't get to them for the other class and so I'm going to review them for you as well. Oh, the other thing that I intended to say here is... from a design-- I want to talk about these two classes in particular from a design perspective for just a second. Notice that the ball-- a ball-- is a more specific sphere. So it's a sphere with more information. And furthermore, observe that the functions that are associated with the ball are concerned primarily with that added information. So from a design perspective, it's reasonable to think about, Okay, what's the functionality of the ball as it relates to the data?? That is, what functions do I need in order to make that data accessible, usable, et cetera? And leave to the sphere class all the functionality that every sphere might need. And most of those have to do with its data. So it's just sort of a little-- I just wanted to bring it up because there's this little design checklist going on where you can ask yourself, Okay I need this function to go here or here". Largely, that decision is made on what kinds of data each of the classes hold. And how general the use of the function itself is. Okay, that said, let's be more concrete here. I'm going to declare a sphere, declare a ball.  Okay, you know what that means. It's certainly okay to declare a sphere because that's just our stupid sphere class that we've been talking about since day one, right? So it's okay to just declare one of these. Declaring a ball-- also perfectly fine. This is not unlike the image class and the PNG class from MP2, for example. Alright, now, this assignment statement-- what do you think. Do you like it? Assume the assignment operator is well-defined. So even if there were dynamic memory associated with these things, know the dynamic memory would be handled responsibly. So assume that generally, each of these has a well-defined assignment operator, okay? That being the case, whose assignment operator would apply here? Sphere That's right, so it's sphere's assignment operator. So what is the result here? S stays a sphere, right? S is a sphere. It is as if and it's value is exactly like b's value except... This part isn't there, okay? So it's the sphere part of b. Any question about that? So this works, this is fine. S is the sphere part... ...of b, okay? Now, how about this one? So now I have the b... I have a ball, and I want to assign to it the value of a sphere.
the problem is we can't instantiate all of the ball from the sphere's data We can't take this spere, it doesn't give us enough information to fill out this ball So the compiler will say hey, you are being to ambigious with me , i can not process this So this is the dissallowed Can't write there. You have to write it yourself  Somebody is going to ask me what did I learn this semester and my answer is going to be I learned how to use powerpoint By the compiler  Now, Someone out there , someone out here, is wanting to ask can you cast that sphere to be a ball? So that the types would match Five people were wondering if you could force that sphere to be a ball You could, but... anyone anybody who read your code would go ughhhhhhh It is a hacking way, an ineloquent and an insecure way of achieving type agreement. So, don't do it Unless you absolutely have no choice Don't do it because it is the easier thing to do, only do if thought carefully about all the other options, and you know it's not going to break things Oh i don't know, that means that the only thing you can ever assign to a ball is a sphere. is that what you wanted? oh, then the parameter ,i don't know uhhhhh, so you know i don't claim to know everything , but if you are doing things that I don't know Then you at least better document it very well, and very carefully. Not only what you are doing but why you are doing it Right simple code. People like to read simple code, right. Simple code right, simple code Except in MP3, haha.  Alright, let's work, come on I'm sorry Oh i have a typo here. I left my old variable names here We need to keep moving Alright, this is now what i intended I intended s=b and b=s here Alright, so now though we are going to declare pointers instead. I want you tell me what you think happens I am going to declare a pointer s and b. And I'm going to instantiate   them with something. Instaniate a sphere with a sphere, but it will be a less stupid sphere. It will be a smart sphere. and ball is like a sphere but it also has a name associated with it Now, Question is can I do this. Is this one okay, What's the consequence of doing this in the picture Means that s points like this that alright? yeah?
No, it's fine. It would still be fine, it would still be there. Because the ball class is gonna clean it up  Ok, so right so pretend that in this case I cleaned this up responsibly. Pretend I cleaned that up responsibly before I made the assignment. So is that okay? Yeah that's fine The only thing is, so I can make this assignment but s is still a sphere pointer so I can't get the name. I can't say s dot name any where or s dot get name. I can't refer to the ball class member functions I still have to use only the sphere class member functions. But the ball is still there and b still points to the ball so I can still say b dot get name for example alright, and so this is fine but, s, the value of s is sphere. As you would expect That's dereferencing. This mess right here says this is fine, but the value of s dereference s is sphere type Alright, b equals s, is that okay? no, compiler doesn't allow that so that's not okay good, this is just the behavior right, like there's no - you just gotta know it. Luckily the compiler tells you when it doesn't like it. You probably noticed that each of these classes has a display function and so now I'm going to as you in which contexts, which display goes. Now just for the sake of discussion, I've implemented display so that it tells us which class it comes from. In each case so the sphere class display simply says, hey I came from a sphere and the ball class display, I came from a ball, and nothing else alright, just for the sake of illustration, so now the question is what happens in this example? s dot display gives you what? sphere, exactly what you expect, yay how about b dot display? Yay, gives you what you want okay it gives you all the right thing for the concrete objects themselves Now let's make it a little interesting let's use pointers instead let's use pointers So I'm going to set up a sphere pointer s and make it point to something that is of type sphere so it's just type sphere it doesn't really matter what this sphere looks like and now i'm going to ask for display what do I get? Sphere good so the right thing happens. Alright, and now the last example. ready? Here's a sphere pointer and we said last time that it was ok to point a sphere class pointer to a ball So here's the sphere portion of it and here's the name sticking down here we said that was okay And now the question is, what happens when we do this? I'm gonna ask you about what you hope for first this is a reflection of your optimistic soul. What do you think, what do you wish would happen here? raise your hand if you wish that a sphere would be displayed, that sphere would be displayed You hope sphere is displayed here Raise your hand if you hope ball is displayed here Ok did you all see that it's about half and half right? the answer is sphere is displayed no So this is an example of what we call early or static binding. compile time function binding so I'm gonna write some of that vocabulary down here So this is - I'll say it up here c++ is by default statically bound let me start over, sorry c++ uses static or early or compile time function binding by default
No, it's fine. It'll still be fine, it'll still be there. Because your 'ball' class is going to clean it up. Okay? So right, pretend that in this case, I clean this up responsibly. Pretend that I cleaned that up responsibly before I make the assignment. So is that okay? Yeah, that's fine. The only thing is, so I can make this assignment, but, as this is still a sphere pointer so I can't get to the name. I can't say 's.name' anywhere, or 's.getName' I can't refer to the 'ball' class member functions I still have to use only this sphere class member functions, but the ball is still there, and b still points the to the ball, so I can still say 'b.getName' for example. Alright. so this is fine but s, the value of s, is 'sphere'. as you would expect this mess right here - this mess says this is fine but the value of s, dereference s is sphere type. Alright, b equals s, is that okay? no, compiler doesn't allow that, so that's not okay, either. this is just the behavior, right? like there's no - you just got to know it, like the compiler tell you when it doesn't like it. you probably notice that each of these classes has a 'display' function and so now I'm going to ask you in which contexts which display goes now just for the sake of discussion, I've implemented display so that it tells us which class it comes from in each case. So the sphere class just displays simply says 'hey I came from a sphere' and the ball class display 'I came from a ball' and nothing else, okay? just for the sake of illustration. so now, the question is, what happens in this example? 's.display()' gives you what? 'sphere', exactly what you expect. how about 'b.display()'? 'ball', gives you what you want, okay?  so gives you all the right things for the concrete objects themselves. now let's make it a little more interesting let's user pointers instead. so, I'm going to setup a sphere pointer s and make it point to something that is of type 'sphere' so it's just type sphere doesn't really matter what the sphere looks like and now I'm going to ask for display what do I get? 'sphere', good, so the right thing happens. and now the last example. ready? here's the sphere pointer, and we said the last time it was okay to point the sphere class pointer to a ball so here's the sphere portion of it and here's the name sticking down here we said that was okay and now the questions is what happens when we do this so I'm gonna ask you about what you hope for first, okay? this is a reflection of your optimistic soul. what do you wish would happen here raise your hand if you wish that the 'sphere' would be displayed you hope 'sphere' is displayed here. raise your hand if you hope 'ball' is displayed here did you all see that's about half and half, right? the answer is ... 'sphere' is displayed ooooooooohhhhhh... so this is an example of what we call early, or static binding, compile-time function binding so I'm gonna write some that vocabulary down here [writing on the slide] C++ is, by default, statically bound... [wipes the notes] C++ uses static, or early, or compile-time, function binding by default
Okay but the fact that each of those words has an opposite or sort of an opposite static opposite is dynamic early opposite is late compile time well sort of the opposite is run time the fact that each of thsoe words has an opposite and this is just the default means you should probably suspect there is an alternative okay alriht so almost it's almost certainly true that this behavior is not what's intended it's almost certainly true that if we were to put effort to make this a ball then we intended for the pointer to behave like a ball and so um we have a programatic mechanism for making that hapen now why does c++ do it like this by default and the answer is that this assignment could be inside a conditional right? in fact you could assign any derived class to a sphere pointer because of that, you can even necessarily figure out until runtime which of all the different options are necessary so at compile time they all have to be expanded into machine code now the cost of that is huge it makes for larger and a thereby slower executables so uh by default you know c++ imagines itself a racehorse it'ts trying to do everything fast so by defaut its choice is to use early binding which says okay im just gonna go with the declared type information as the only type information okay? any questions? lol yeah! silence silence um oh we're gonna talk about that i have a whole slide on destructors is what you're asking about right? like what happens in thsi world with a destructor very astute of you to notice and we have a whole slide on it alright so how do we fix the problem and the answer is we use keyword virtual chirp chirp silence wheeee so the virtual keyword means tha the function may be overwritten in a derived class more silence yawn pull out your pillow like actually there's like 5 more seconds of silence wheeee jk there's more chirp chirp chirp ok alright! and so now and so now this code will work just fine k? i put things in a conditional and the rigt kind of display will happen based on which of these assignments occurs k? so now you can imagine instead of a=0 who knows what a is here you can imagine any conditional here like if the left button is pushed or the right button is pushed or if the temprature is over 75 degrees this can be any conditional and we can still attach at run time any kind of thing that we want and still get the display that we like so in the in this example in the case that a is 0 we get sphere otherwise so a!=0 we get ball k? that is polymorphism spooky because it we change the behavior of display based on the type of uh uh they type of uh the object yeah? oh there's two of you let's see if i stand way over here then you're in different palces places* very good question um um the question is do you need the virtual in both places? and the answer is nope you dont once the function is virtual, it will always be virtual k? so it's superfluous for me to say that but because code is communcation, I'm always going to say it just to remind uh future derived classes that display will be overwritten or can be overwritten k? you guys should jsut talk to eachother! wait wait then they'd be completely wait what huh? k don't talk to eachother what alright any questions about that so once a function is virtual it is virtual throughout the inheritance hierarchy but we are awlays diligent about writing it jsut as a reminder yes whee am i done yet? woo hooo!!!
so the question is does the sphere pointer also now have access to b's attribute?
Okay and that is really the only time I feel like it's accurate to say we call the constructor. Other than just letting the system invoke it for us, okay. Any questions about that first example so that's the ball class constructor we need to instantiate the name. But we also need to instantiate the sphere part of it and to do so we invoke the sphere class constructor. Yes? So umm, so let me if I got your question correctly. So by invoking that sphere class constructor it's gonna go lay out its memory. In the way that it wants to, right? So that's how you get it for the ball class. Now the ball class might have its own dynamic memory but that would happen inside the ball class constructor, okay? Does it help? Yes, on top of, below actually is how I think of it but it might be on top of. I don't know how memory does it. Yes. Yes yes yes, very good. That was the next thing I was gonna say. So I explicitly called the no argument constructor of the base class here. If you don't do it, the system will do it for you. But that's the only one, that's the only one it will ever do for you. So if you don't invoke a constructor. The no argument constructor is made for you But I assert you already knew this. When did you experience this behavior? Image class, that's right, this is what is going on in the image class, right? For mp2. You declare a image and the system says okay i'll make you a PNG with this additonal functionality. Okay so this happens by default. Okay and if the system provided one the system provided one will be used if there's a custom one the custom one will be used. Okay but those are kind of boring constructors. Let's talk about this more sophisticated one that takes not only a name but also a radius. Okay so here, here we really do want this is the behavior you wish you had for the image class. It would be nice to be able to invoke the PNG constructor that allows you to give it a size. But we didn't tell you about this yet. Alright so all you have to to invoke that sphere class constructor is essentially make a call to it in the intialization line. Right? And so object itself then looks like you know the sphere with radius r. theRadius and its value is r and it has name whose value is n. Okay any question about that? Yes? So the question is can you move it out of the initializaiton line.  Anytime somebody says can you in c plus plus I'll go oh probably. But number one I don't know how to and number two the expectation is that it will be there so somebody's looking at your code and you're wondering what constructor you're using. That's where they gonna look for it, if you hack something...
melts (I'm not sure) together. There gonna go I don't know what the heck he's doing. They're gonna throw your code away.  So  and that's like the biggest insult right?  biggest insult possible, if you right code and give it to sombody else and they go AAH  throw it away  Alright  Let me see if I was going to say something else here. Um... So I sort of implied this. I sort of implied this  and we're gonna talke about it more on the next slide but  The way these things are constructed goes in order from  base  through the derived classes so we can have lots of derived classes but they go in order from the base through the derived classes. So it really is constructed to think about it as the base class with additional things tacked on.  as you navigate the derived hierarchy  and such that's the order the constructors are effectively invoked  Kay. So the constructors  are invoked  base class  first  followed by  derived class  and notice that there's sort of a  there's sort of a recursive, there's sort of a recursive description here because that derived class could also furthermore be a base class. So you could have this sort of chain of... um...  chain of  inheritance. Okay.  Ummmm... Let's do next slide. I love this slide. Love it.  Always excited for this point in the semester yes?  uh huh  oh no, just the first one.  just the...justs the...just the one above it  Yep  yes  no  no  just calls balls because what's balls going to do?  yeah  right that's right so, his question was a good one and that is. is this like a makefile? It ...um if you have three, say a basketball. This example is a good one. If you have a basketball which is a derived class of a ball, does the constructor for a basketball have to call the sphere class constructor and the answer is no The answers no. You could just call the ball class constructor which in turn will call the sphere class. kay?  All right, I've given you some code here. Now this code is for illustrated purposes only. It's barebones a couple of class definitions and basically I want to know what the system does when I execute this. I want to know which constructors are called when and which destructors are called when. So the code is this, It's a base class pointer but I'm going to instantiate it with a derived class thing. So that's fine.  So ba...base class const...I'm sorry base class pointer instantiated with a derived class thing  and then I want to clean up memory  Kay I'm gonna clean up V The question is  what's the output of.... what's the output of main? Go ahead and talk with the person sitting next to you and write down what you think the output of main is. And I'm gonna give you thirty seconds to do this  Maybe 45  
Okay ready? Ready? Alright So I'm executing this code and the first thing I do is ask for a new derived class thing. What is the first output that I see? Constructor of...? What order do constructors go in? Constructor of...? Base! Good. So the result of the first statement is constructor of base And then because its a derived class thing, the next thing I see is..... Constructor of dervied Now the interesting things begin I'm doing two colors of ink here and the reason for that is because I'm going to go with what you hope. What do you hope happens here? So what you hope is....somebody say..somebody volunteer What do you hope happens here? Ok so what you hope happens is...Dtor:D and Dtor:B Anybody strongly disagree with the hope here? That feels like it would be responsible right? Guess what really does happen Which one? Only one of them goes by default Raise your hand if you think its derived goes.... Raise your hand if you think its base goes.... Okay so 50/50 So what I take from that is that collectively we're guessing What goes is Dtor:B The question is...how do we make Dtor:D go... and the answer is the we make the base class destructor virtual and then the right thing will happen Thats what causes Dtor:D and thats it! That just how it works! If only Dtor:B was printed...think about what that means if there was dynamic memory associated with it. There would be a memory leak The question is...do we need the virtual keyword in front of the derived class destructor I believe that implicitly its there but I'm not sure so yes you should put it there Anytime you are creating a class that might be a base class just make your destructors virtual
can't clean up after itself right? aughhh that's almost not certainly what you intend alright any other questions about this? kay.... alright uhh.... take a look at square in the upper left hand corner and tell me what's interesting about it [people telling Cinda what is interesting about it] tell me what is different it's the flower class, what is different? .......... this is an easy one [waiting] what is draw blossom? its just a..... function right? it's just a function happens to be virtual so we get the idea that this is intended to be a base class. so what's weird about it is that assignment statement here is what that assignment statement is its... its.. its...it means that draw blossom is a pure, virtual, function kay so....pure..... virtual.... function and what does that mean? it means a function that is not implemented here but will be implemented in some derived class kay? so a pure virtual funtion is a function not implemented................. in the base class........................ but rather................ in a derived class [pauses for dramatic effect] k? ....alright.............. so here's the cool thing about it basically in the base class, the base class now is prescribing what the derived classes have to look like if you want to implement a flower you HAVE TO, or i'm sorry, if you want to, uh, derive from flower you have to implement draw blossom function.... kay? so it ends up being a prescription for the functionality of the derived class or effectively an interface  uhhhhhhhh let's see, so an abstract base class is the name we give to any CLASS that has at least one pure virtual function .............. any class..... containing..... greater or equal to one pure ... virtual... function ......k? any question about that? yes..................yep yep that equal zero is sort of like i'm i'm intid- it's an indication that i'm intending not to implement here right? it's equal nothing function is nothing alright! any other questions about this? yes???? [listens to question] yep maybe put it on piazza, a question like that, cuz i dont really know java that well i might not be able to answer anyway so any other questions about this? ...... okay! yea? [] uhuh [asfasfasdfasdfasdf] yep.....multiple, right, multiple derived classes all have to implement draw blossom so look at this. I've got, in fact we've done that here we've got class, daisy and it implements draw blossom, draw stem, draw foliage  but..... we could have, we could have, uhh, class rose, or class tulip, class Astor. we could have any of those flower classes and they would all have to implement um, draw blossom. I have one more thing to say though!!!
You're so sweet. :) Um, what I'm gonna say is, I want you to look at this and tell me what you think of this for next time, that's where we'll start next time. Kay, so respond to each of these for next time. [Student] Um, on the previous slide... Yeah? [Student] Er, you said, well, first you go to print(?) B Yup. [Student] 'Cause the virtual was not there. Right. [Student] So if we add virtual here... It will do all four. [Student] All four. [Cinda] Yup. [Student] Ok. [Student] Um, so what do you mean by having more than one? [Student] 'Cause in the previous lectures, the class didn't - Right. They didn't - we've never seen an abstract base class til today. So this one - this one is our first abstract base class. [Student] So every abstract base class will contain... Yes. At least one. Any. That says, any class containing greater than or equal to one pure virtual function is an abstract base class. Ok? [Student] So all you have to do is type virtual infront of this, or what else- Yup. Yup, that's it. Mhm? [Student] And what does that change? It tells the system to look for additional destructors. [Student] Um ok, so it's gonna say, like, if it's a derived class [Student] that it's gonna call the base - er, no, sorry - [Student] the derived class and what if it's like the base [Student] class it won't care [Cinda] Yup. It doesn't care for it. For the functionality of the base class, it ignores it basically. [Student] All you need to do is add virtual to the class. [Cinda] Yup. [Student] So the virtual class destructors call all of the superclass destructors? Erm, no, the sub- ones. [Student] All of the sub- ones. You put it on the base class. That is- it's kind of - [Student] Oh, ok right. [Student] So then, here, when we change [Student] when we put virtual in front of here -  It was this one. We did it in front of this one. [Student] Right. [Student] So then it will print - it will call both of these destructors Yup. [Student] whenever we want them. [Cinda] Yup. Yup, exactly. [Student] We don't have virtual here so we are only triggering - [Cinda] Yes.  [Student] Is it just not so - a drastic impact - I mean  Is it what?  [Student] Is not - we like, we like always(?) Right, we probably don't - we probably don't want that action. Like if you had written something that had invoked a constructor You want it's destructor, just in case. 'Cause you dunno what the constructor did, so you want its destructor too. So back - [Student] This is bad(?) Yes. So right. Back here... This - this was - destructors can and should be virtual. [Student] Oh. [Cinda] Ok. What's up? [Student] Don't they already inherit those functions, [Student] so why would it be important to have them? Um, they're not implemented here. So it's admitting, in the base class, that those functions probably have to be different in all the derived classes. They're gonna mean - they'll explicitly mean something different. In each of the derived classes. Like, drawing a blossom is going to be a different process for a carnation, than, for whatever, right? [Student] Yeah. They're just very different. And, so, And there is no default flower, right, like there is no flower that you could draw and implement in drawBlossom that is like the average flower or something, like it kinda doesn't make sense. [Student] So you wouldn't execute(?) this function if you wouldn't [Student] call on like, just from its base class. That's right, right. And in fact, um, what we're gonna start with next time, is that box where I've declared a flower, (whispering) and you're not allowed to do that. There is no flower class. The flower class actually needs derived class, it does. That's right. But it doesn't have those functions. [Student] Why couldn't this be just an empty class?(?) It is essentially an empty class. I - well, no it isn't, it might have data associated with it it might have a string that it's name, it might, you know it might have data associated with it but we can't draw anything about it because we don't know what it looks like So, so yeah, I mean it can be a full - in fact, we could have all of them except the blossom we could have all the functionality except the blossom but you still can't declare one. Nope, it has to be more specific. Ok? [Student] You said that initally that for the definition of pure virtual functions [Student] That means that in one of it's derived classes that it's defined, like [Student] This function is gonna be defined. [Cinda] Yes. Yes. [Student] But even if somebody else asked, they said,  [Student] that, suppose you say, a rose, [Student] and then you say, daisy, and each one of [Student] these, it has to be defined. So Yes. No, no. Yeah, so it's greater than or equal to one that isn't implemented here - [Student] Oh - and that
You're so sweet Hmm, what I'm gonna say is I want you to look at this and tell me what you think of it for next time, that's where we will start next time OK? So respond to each of these for next time.
OK, alright, let's get started. So guess what's coming up in two weeks? Yes! The exam, very good. But also wait a minute, this is a problem actually, the exam comes first, then we have reflections projections, the coolest student run experience I have ever seen, closely followed by Hack Illinois, which is later. Yeah so we're well represented here. So Jessica and Victoria want to talk to you about opportunities for, um well, to tell you about reflections projections and how you might participate. Hi I'm in Victoria I'm the chair for reflections projections this year. We have a lot of cool speakers coming in this year between the first and the fourth of October. We also have a programming competition so if want to come build an AI we have awesome prizes, including an Oculus Rift in those. So if you want to come compete and try to win that we'd love to have you. It's October 1 through 4. The programming competition is between the second and third. We have a puzzle competition going on over the course of the event. We also have speakers all of Saturday and some scattered throughout the rest of the event. Two job fairs, one is on Thursday, one is the big job fair on Friday. So if you want to come meet recruiters, see speakers, and maybe compete in a programming competition, come to RP. And here's Jessica to tell you how you can get involved and volunteer. So yeah in addition to experience the event itself, we would love it if some of you or all of you would come help us our during the event. So there is a sign up URL for that, it's www-s.acm.illinois.edu/rpvolunteer. Essentially it's the ACM URL slash rpvolunteer, no special cases, no spaces, just rpvolunteer. If you go there and sign up we will get you fitted for a time slot. And if you volunteer you will be fed, you get food. And you get a free t shirt! Who doesn't love free t shirts. Also food is free for the entire weekend. And it's always good food. OK thanks guys, are you coming back for the next hour? OK nice to see you both. Let's work! Seriously, when I go to reflections projections, I walk out of the talks going oh I'm so glad I'm with computer scientists." It It's really inspiring to hear all the huge variety of cool things that people are doing. And the most interesting thing for me is that the speakers tend to be kind of younger, so there's this generation between you and me kind of, and those tend to be the people who come to speak. So I'm always very excited.  So I want to work, and so unfortunately I'm going to have to erase all of this. I know, I know, erasing all the fun. There shall be no fun. 
OK, so last time we were talking about inheritance and we really truly left things hanging because we basically had. We basically had. Talked about the existence of abstract base functions, I'm sorry, abstract base classes, ABC, and we said abstract base classes are classes in which some of the functions are not defined. That feels to me like, you know, we left it on a cliffhanger. Well, if they're not defined, where are they? Where are they? Well, we did talk about the fact, I guess, that they are implemented in derived classes. That is the only place. OK? So here's the example, we have this abstract base class, you can tell because it has these pure virtual functions. Just reminding you of the vocabulary. Here, there it is, pure virtual fun-ction. I better put it there, that's just too, too weird. OK. Pure virtual function Um, there's the example, and here is a a derived class. Here is a derived class. Now, the point is, and you can see that the implementation is done here. The point is that I could not declare a class rose that neglected to implement any one of those things.Â This serves as a prescription for implementation. Any question about that? Is that clear? So the base class serves as a prescription for the functionality and implementation of a derived class. Should I write that down? OK.  Alright, I will. Alright, so the abstract base class serves as a prescription for the functionality of any derived class.  OK, so in our previous example, where, you know, that we talked about the fact that, uh, we talked about polymorphism. Like a ball could have a display function, but a planet could have a display function as well. um, this is a way of saying that every derived class must have a display function and we'll see in a minute, um, an example where that is pretty cool. Alright, any questions about what you see here neglecting this blue box, the next thing we're gonna talk about is this blue box, so anything, yes? Uh-huh. Uh-huh. Yes. No, you do not have to use any kind of keyword to overwrite it, you're already saying. Keyword overwrites? No. No. No, no, no, no. I do not have to. This is a straightforward simple, nothing else is necessary, OK. Alright, anything else about this? Yes? Right, yeah we don't have to here. That's right, right. That's right. OK. Uhh, let's see. So lets talk about how we use this then. You can imagine, well, let's talk about how we use this. Can we use this? Can we declare a flower? No we cant. There shall be no more flowers and the reason for that is simply that flower is not a complete class name. Flower is not a finished class. Can we do this? Sure, of course, right. This is. Now we have all the functionality we need, so this is fine. How about this one, can we do this. OK? We can still do this one so that might be a little counter intuitive. We can't have a flower, but we can have a flower pointer and the reason for that is we already said that a declaration like this OK.fptr equals new flower. And it looks like I only have a default constructor there. OK? Any question about it? Yes?
ok so last time we were talking about inheritance and we really truly left things hanging because we basically had talked about the existence of abstract base function or I'm sorry abstract base classes. a b c we said abstract base classes are which some of the functions are not defined ok so that feels to me like.. you know.. we left on a cliff hanger well if not defined where are they? well we did talked the fact I guess that they are implemented in derived classes and thats the only place. ok so heres the example we have this abstract base class i can tell because it has the pure virtual functions. just reminding you of the vocabulary here there it is pure virtual fun..ction i better put it there thats just too weird.ok pure vitual function hmm. thats an example and heres a derived class. okay now the point is as you can see the implementation is done here . the point is i could not declare a class rose that neglected to implement anyone of of those things. so this serves as a prescription for implementation. okay any question about that? is that clear? so the base class serves as a prescription for the functionality implementation of a derived class. should I write that down? ok i will. alright . so the abstract base class serves as a prescription for the functionality of any derived class. ok? so in the previous example hmm you know where we talked about the face that hmmm. we talked about polymorphism where a ball could have a display function and a planet can have a display function as well hmm this is the way of saying that every derived class must have a display function. We will see it in a minute and the example of that is pretty cool alright any questions about what you see here neglecting this blue box. the next thing we will talk about is this blue box so anything? yes  no you do have to use any kind of key words to overwrite it. You are already saying keyword over writ.e no no I do not have to. this is straightforward simple. nothing else is necessary.okay? alright anything else about this? yes? right, yea we don't have to here. thats right thats right. okay. hmmm lets see. So lets talk about how we use this then you can imagine,well, lets talk about how we use this. can we do this? can we declare flower? no we cant there shall be no more flowers,okay?and the reason for that is simply that a flower is not a complete class name.okay the flower is not a finished class. can we do this? sure of course right, this is , now we have all the functions we need so this is fine,how about this one? can we do this? ok , we can still do this one. okay so that might be like a bit counterintuitive there.can have a flower but we cant have a flower pointer. and the reason for that is we already said the declaration like this is okay. fptr=new flower. that looks like i only have a default constructor there. okay? any question about it? yes?
hmm so we..so yes there's a jump here. you didn't know when I first talked about inheritance why i was telling you that it was ok to have a pointer type, base class pointer on the left and a derived class pointer on the right you didn't know where I was going with that but you did talked about the fact that that was okay. So this assignment is okay because the thing that we were making is a flower we are building up flower at this point. right here. Im sorry. this is wrong, this is wrong thats why I almost broke your brains.I am so glad you asked this question.what could I have said that would have been not very confusing here. daisy very goo thank you oh my gosh. the whole point of the whole slide was the word i wrote here and I screwed it up great ..come back next hour that mistake would not be made or maybe it should be. ah maybe I should have do them on purpose just to see if people are as awake as you. alright.alright, so everything i just said is true still. Its still okay to declare a flower pointer cause there's no flower constructed there it would not be okay to say that new flower here cause we can't build the flower but we can build a daisy, we can plant a daisy okay? alright any questions about this? you should have more questions i think yes? theres no slicing so we make a daisy, right , right, so the things is thought, so the problem is once you do this daisy, you don't have daisy's specific functionality but you do have access to any polymorphic function. so when you prescribe what functionality it has to have, you know they are all gonna have it anyway and they are virtual,and, so we can't reach them through flower pointer. Does that make sense? because there, the,the functions are declared in the flower,okay? hmm,oh,lets talk about it later,cause lets talk about it later, if they encourage it to go experiment. okay, so heres the thing about inheritance, you see it about twice in this class about twice.. well maybe 3 times. We are doing it mostly because you are gonna see it in your life not because you need it a lot for data structures in the our context so sort of, we are trying to do is increase your curiosity about it. give you a little bit of functionality, and then, move on to the stuff okay, so I encourage you to go experiment , but i wanna stop it. okay, all of that said,, hmmm, notice that , oh i have a question for you, what if i had done this,yea? ah-ha?  hmm,no that presence of that equal zero do the same thing. okay?  if it is one of them equal zero, it is an abstract base class, okay? alright, can I do that? did you see what i did? this equals zero, can i do that? ignore the blue box, now can I do it? yes, i can. But then i can't do them, i have no daisy, right? what this demands is that i derive from the daisy class and further specify well, is it a gerbera daisy or freeway daisy right? so this demands that we'll be specific about the kind of stem that we draw apparently okay, any question about it, yes? oh there may be sort of some redundancy there, infact i don't think the compile will let you say equal zero without putting virtual
Um, so we already, we yes. There's a jump here. You didn't know when I first talked about inheritance why I was telling you that it was ok to have a pointer type on the left. A base class pointer on the left and a derived class pointer on the right. You didn't know where I was going with that, but we did talk about the fact that that was ok. So this assignment is ok because the thing that we're making is a flower. We're building a flower at this point. Right here, I'm sorry, this is wrong. This is wrong, that's why. I almost broke your brains. I am so glad you asked that question! What could I have said that would have not been confusing here? Daisy, very good. Oh my gosh. the whole point of the whole slide was the word that I wrote here, and I screwed it up. Great. Come back next hour, that mistake will not be made, or maybe it should be! maybe I should do that on purpose. Just to see if people are as awake as you. Alright. So, everything I just said is true still, it's still ok to declare a flower pointer, cuz there is no flower constructed there. It would not be ok to say new flow, because we can't build a flower, but we CAN build a daisy. Alright, any questions about this? You should have a question I think. There's no slicing, so we make a daisy, right? Right, so the thing is though, the problem is that once we do this daisy, we don't have access to the daisy specific functionality, but you do have access to any polymorphic function, so when you prescribe what functionality it should have, they're all going to have it anyways because it's virtual, so we can reach it through the flower pointer. Because the functions are declared in the flower. Let's talk about it later, and i encourage you to go experiment. So here's the thing about inheritance, you see it about twice in this class, well maybe three times. We're doing it mostly because you're going to see it in your life, not because you'll see it a lot in data structures in this concert. We're trying to increase your curiosity about it, a little bit of functionality, but not a while lot. I have a question for you, what if i had done this? No, the presence of that = 0 does the same thing. If there's one of the =0, then it is an abstract class. Can I add an equal 0? can I do that? Yes, I can, but the I have no daisy. What this says is that I derive from the daisy class, well is it a Gerber daisy or a freeway daisy?This demands that we be specific about the kind of stem that we draw, apparently. Any questions about it? There may be some sort of reduncy there, in fact I don't think the compiler will let you say =0 without putting virtualÂ Â f
So we already, yes there is a jump here you didn't know when first talked about inheritance why I was telling you that it was okay to have a pointer type, a base class pointer on the left and a derived class pointer on the right You didn't know where I was going with that but we did talk about the fact that that was okay So this assignment is okay because the thing that we are making is a flower We're building a flower at this point Right here, I'm sorry THIS IS WRONG, this is wrong that's why I almost broker your brains [pause] I am so glad you asked this quesiton [pause] What could I have said that would have been not confusing here? Daisy, very good. Thank you Oh my gosh The whole point of the whole slide was the word that I wrote here, and I screwed it up Great, come back next hour that mistake will not be made Or maybe it should be? Maybe I should do that on purpose? Just to see if people are as awake as you [transition words] Everything I just said is true still, it's still okay to declare a flower pointer because there is no flower constructed there it would not be okay to say new flower here because we can't build a flower but we can build a daisy, we can plant a daisy Any question about this? You should have a question I think Yes? [question] There is no slicing, so we make a daisy [question] So the thing is though, so the problem is that once you do this daisy you don't have access to the daisy specific funcitonality but you do have access to any polymorphic function So when you prescribe what functionality it has to have You know they're all going to have it anyway and they're virtual So we can reach them through the flower pointer, does that make sense? Because there the functions are declared in the flower [question] Lets talk about it later and I encourage you to go experiment, okay? So here's the thing about inheritance, you see it about twice in this class Well maybe three times We're doing it mostly because you're going to see it in your life not cause you need it a lot for data structures in our context  What we are trying to do is increase your curiosity about it, give you a little but of functionality and then move on to the stuff the course is actually about So I encourage you to go experiment but I want to stop it Okay, all of that said  Notice that , oh I have a question for you What if I had done this? [pause] No that presence of that = 0 does the same thing If there is one of those = 0 it is an abstract base class Can I do that, did you see what I did? I added this = 0, can I do that? Ignore the blue box, now can I do it? Ignore the blue box, now can I do it? Yes, I can but then I can't do , then I have no daisy. What this demands is that I derive from the daisy class and further specify, well is it a Gerber daisy or a Freeway daisy? So this demands that we be specific about the kind of stem that we draw apparently. Any question about it? [question] There may be some redundancy there, in fact I don't think will let you say = 0 without putting virtual. [question]
You only use virtuals if there is a chance that it is a base class. Furthermore, if your class is available, you do not really know whether it is going to be a base class or not because that is a part of the design.  Where you can strongly argue that virtual is not necessary, you should eliminate it because it will make faster code. So use it judiciously. Anyway, so here is an example that I think is really cool. I am going to declare a farm, it is not unlike a garden, but it is a collection of animals. Notice what I can do here. I can use this pointer to represent an array. When I instantiate it I can declare it with square brackets to make a dynamic array. And I can let every element be of type animal pointer, each of which can then be instantiated with a different derived animal.  So, when I actually fill in the value of farm sub k I say new animal sub whatever or animal whatever. So, new pig, new horse, new cow. Alright, notice what this is. It is an array where the things are not necessarily the same. So this is the way that you would implement what is called a heterogeneous array in C++ So this is a heterogeneous array. in C++ Not all elements have the same type. But it gets cooler than that, because it means we can do things like this. The polymorphic behavio The polymorphic behavior and the ability to insist that that function be defined means that we can demand that each of those classes has a speak function and that they are instantiated in a class specific way. So what happens for this for loop? You get 'barf, oink, nay, moo, quack'. Alright, so we already talked a little bit about the fact that inheritance gives you this polymorphic behavior at the significant cost to performance, because at compile time the system has to look at the code and see what kinds of things might require this polymorphic behavior, and it has to build the machine code for all of it. So that makes for bloated machine code. Now that is called dynamic polymorphism, where you might not know at the compilation of your code what kinds of things this will be instantiated with and you do not need to know it. So that comes at a performance cost. There is another kind of polymorphism that because of this performance issue was introduced into the language a little bit later. It is implemented via this construct called templates. And it is a kind of polymorphism where all of the type dependent information is known at compile time. So there is no ambiguity and there is no need to build in this flexibility at compile time. So that is our next topic. Templates. I have some code. Here is my main. I am using some integers and some characters and I have got these two functions that swap them. There are my two functions. What do you notice about the code. There are 2 germane points to be made.
Yes? Yes very good. So err the code is identical except for type information. Okay what else do you notice about this code? Yeah. You. Very good. Yep. It actually doesn't do anything! Neither function actually does anything. Okay and how could I fix that. I will fix that one first. How could I fix that? Pass by reference. Very good. Don't say pointer to me. Alright, good. So let's talk about the first point in a little bit more detail. So this is fine, right, to have these two functions that do pretty much the same thing.  In fact if somebody were asking you to include these two functions in an mp you go 'oh yay they're about the same I can cut and paste'.  I can cut and paste my solution from one and I got the other one done. Yes, right? The problem is that then you have to go back through and kinda check and make sure that your type information is updated correctly. Now the compiler's gonna help you mostly with those kinds of bugs but it's still a pain in the neck. And in fact if somebody, if somebody came down and said 'there is new technology for swapping'. Okay? Unlikely to happen but it could.  Somebody came down and said there is new technology for swapping. Drawback of doing it this way is that you have to go find all of these little swap functions and change them, right, to take advantage of this new swap algorithm. Okay. Yes it's artificial but. Alright so code reuse is important for maintenance and incremental improvement of codes. Okay? And we admit here that look they are about the same. So how on earth are we going to unify those two functions into one thing but still allow for type information to be err recorded in the code? And the answer is that c++ provides syntax for passing as a parameter hah my gosh type information, type information into the function. Okay? Alright, so how does this work? I have my same main except that I'm writing a single swap function. The way we, the way we tell the system exactly how we want swap to work is we have this alternative syntax for, alternative syntax for parameterizing type, and we put it between angle brackets. So first you have the type parameters and then you have the value parameters, okay? Similarly here we would do char. And I'll tell you right now that if you forget to do this, when the compiler can it will infer it for you. So sometimes it's not the case that you'll see those angle brackets even for a templated class. Okay so the system can infer it , it will. Okay. So now that's how you use these template functions, how do you define them? Well you prepend the function signature above the, above the first line it becomes the first line with this keyword template. This is a keyword. Class which is also a keyword but it could be typename instead.
Yes? Yes very good so uh the code is identical except for type information. ok. what else do you notice about this code. yea. yea. you.  very good. yeup it actually doesn't do anything. neither function actually does anything. ok and how can I fix that. well fix that one first. How can I fix that. Pass by reference. very good. Don't say pointer to me. Alright good. so lets talk about the first point in a little bit more detail. so this is fine right to have these two functions that do pretty much the same thing. in fact if someone were asking you to include these two functions in an mp, you'd go. oh yay. They are about the same. I can cut and paste. I can cut and paste my solution from one and I've got the other one done. yes right. the problem is that then you have to go back through and kind of check and make sure that your type information is updated correctly. now the compiler is gonna help you mostly with those kinds of bugs but its still a pain in the neck and in fact if somebody came down and said there is new technology for swapping ok. unlikely to happen but it could. somebody came down and said theres new technology for swapping. A drawback of doing it this way is that you would have to go and find all of these little swap functions and change them right to take advantage of this new new fangled swap algorithm. ok. yes its artificial. alright so code reuse is important for maintainence and incremental improvement of code. ok. and we admit here that look . they are about the same. so how on earth are we going to unfiy those two functions into one thing but still allow for type information to be recorderd in the code. and the answer is that C++ provides syntax for passing as a parameter type information. type information into the function. ok. alright so how does this work. I have my same main except that i am writing a single swap function. the way we tell the system exactly how we want swap to work is we have this alternative syntax for parameterizing type and we put in between angle brackets. so first you have the type parameters and then you have the value parameters. similarly here we would do char and I'll tell you right now that if you forget to do this when the compiler can. it will infer it for you so sometimes its not the case that you'll see those angle brackets even for templated class ok so if the system can infer it. it will. ok. so now that's how you use these template functions. how do you define them. well you prepend the function's signature above the first line. it becomes the first line. um with this key word template this is a key word. class which is also a key word but it could be type name instead.
... and you will see type name. And, the reason I put class there is because of pure character. And that's what I am optimizing for sometime on the slides. So template class T or type name T, and then T is effectively a type variable. So every place you see T in the code, especially when it is in the type location. The type variable T is replaced with whatever you give to the function through the template parameters
know what's this? Here Um Try to draw this space shuttle. Ok, that's kind of what I (want)... I don't know. You can put rocket ships in there. Spaceships, right? Spacecrafts. I think I used to no more spacecrafts than I do now. TIE fighter, X-wing fighter... No? Isn't it obvious? What's number one? What? It's the Enterprise. That's right Alright, I have to know I have to know this. I have to know this, okay? So, yes, here is the TIE fighter. I think; I don't even know really for sure. And this is the Enterprise. Doesn't it look like the Enterprise? Which of those do you like better? Okay, this is a deep deep question. This is a deep deep question and it's gonna affect our relationship, okay? Just let you know. Raise your hand if you like... If you are a War's person. A war's person or a track person. It's gonna be the alternative. War's, star wars' person. You had to choose. A star trek person? Hey, did you see half and half. Neither? Okay. I gotta go with star trek. Okay Alright, oh, man. The point is you can put anything you want to in these things. You can put anything you want to in these containers because you can parameterize type. Yeah?  Next generation all the way... Of course. Yeah. Okay, what's this? Right, this is a linked list. This is actually... this is actually these structure that you are going to be manipulating for MP3. Okay? MP3. Each one of these little arrows there is a pointer and the point of MP3 is to get you frustrated in manipulating these pointers, okay? Now, we are gonna talk more deeply about these particular structures starting next week and sort of give you some classic things to think about. But, so if I [is] to say now, at this point, really all you should think about these things as boxes that have pointers and that you have to, you know, that you have to tangle with.  Okay? Alright, I don't expect you to... and oh, and the point is...  It's a stupid joke but I feel like, every time I say point, like pointer... Uh, the point of this exercise is that we can put in here anything we want, like integers or pixels. And, the connection to MP3 is simply that we are asking you to implement something that manipulates pixels but testing that code would be a pain in the neck. So we strongly encourage you to get the code working with integers and then re-parameterized the thing... generalize the parameters so that it well take pixels as well. And the magic will be whala, that now, that your same functions can be used to manipulate images, okay? That's MP3 in a nutshell. Alright, this one serves to provide four shadowing to the rest of the course which is very data structure centrics. See, you can look at that and go wow, there is a lot of structure to that illustration or to that class, to the data that it contains... And our point will be not to care about what goes inside of here but rather what is the characteristics of the structure itself. So we will be thinking very loosely about the types of the things and more concretely about how they are ranged, okay? Alright, so classes can be given templates to... uh, how do you do that syntactically. That was really just inside and uh, you know.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
Welcome to the rest of the semester. Er, how do you do that syntactically? Much like you do for functions, you preface the class definition with a template syntax, ok you warn it(?). And then anywhere you see a T inside, anywhere you see a T inside the class it is replaced with whatever you happen to put in. K? Alright, so let's look at this code in a little bit more detail. Right, so I'll pull out my list so I don't forget anything important and it's been a while. So... My notes are fantastic. They tell me Start with the blue code" Yay, okay! I'm gonna start with the blue code. Ok? Er, so I'm declaring one of those things and I'm recognizing that it needs a type. Now you can tell from the name that it's a pair of integers. Ok? The variable is - so this is the variable name, so variable twoNums has type ezpair of integers What is this? What's going on here? What's going on here? I'm - right. I'm using a constructor. Right? I'm using a constructor. So I should look up here and go, oh yay, the ezpair class has a constructor that accepts these two things. Now at this point I think, you can probably guess what that constructor does it simply, takes the two arguments and uses them to instantiate all the member variables. Ok? That are right here. So this, comes from there. And the constructor. Any question about that? So far. I think you will have questions, but let's keep going. Alright, so now we also have declared getmax. What does this version of getmax return? What does it return? A T? It's not a T. This code doesn't know anything about Ts. Right? It doesn't know anything about Ts. So what does it return? An integer. That's right. That returns an integer. Ok. Er... let's see... So I wanna emphasise that point. That this code, once you instantiate the template, you don't have to use that again. Right? You've already told the class that you want an ezpair of integers. It is as if, now, this is the name of the class. You don't have to keep reminding it that you're talking about integers It's like this is the name of the class. If we had said ezpair char, that would have been the typename and if I had said getmax and this was an ezpair char there would have been no ambiguity. K? Just like display, there would have been no ambiguity. Yeah? Um, so I think the compiler, so if you just said ezpair here the compiler would infer what you mean so you wouldn't have had to do this but I actually - when I read code it helps me a lot to have that there. So yes, it's optional for functionality, but it's, erm it's important for maintainability. K? Alright, so lets see... So let's talk about getmax. So if you execute this code what do you get? You execute this code what do you get? Take a look at what getmax - oh, getmax is funky What would you expect if you couldn't see that code up there what would you get? A hundred that's right. Now lets go look Now let's go look at the code. Alright. So getmax is implemented to return an integer, right or to return whatever the parameterized type is and, er, it sets up a value for return What is this?
Yeah we refer to it as a yes you wanna tell me instead of me telling you? Say it loud. It's an if statement, that's right. That saved me three lines of code right there which is important here. Oh I don't what I intended for this but it feels like it was important. Actually the reason I did this is because I want you to see it, right. I want you to know that it exists. This is called a ternary operator and it effectively in very very simple cases replaces a conditional. So this is a shorthand conditional. Okay so it says if this then return a, otherwise return b and then assign that by return value across the equal sign to retmax and then return retmax. Okay there's something that should bug you about this code. It's very very subtle. And the way to think of it is think of all the things that come in pairs. When I say name something that comes in pairs, what's the first thing you think of? Shoes, okay, okay fine. It feels like then that we should be able to instantiate ezpair with shoes right? The shoe class. Right? What would happen for getmax if we did that? Yeah? That's right, very good, so did you here him? He said he made note of the point, I don't know what greater than means for shoes. I know what it means for integers. I can guess what it means for characters. I have no idea what it means for shoes. Um and so the implication of that is in order for that code to work on the shoe class, we would have to have overloaded the greater than operator. So the greater than operator must be implemented in any class using, wait, any class passed to is the right way to say it, ezpair. Okay? Alright so it feels like a restriction but it's okay and the really good news about it is when the mistake is caught. Okay so if we tried to use ur ezpair on the shoes, who would tell us NO NO NO you can't do that? Who would do it? The compiler, that's right. The compiler would say I know you want to use ezpair on shoes but you can't. You need to define a greater than operator in order to do so. Okay? Any questions about that at all? So is a compiler demands that er this exist. So the compiler has to be able to look at all of the code, all of the code and determine exactly what functionality it means. Yes? twoNums, it's an variable, this is a variable. It could be frog, it could be Alex, it could be... It's just a thing that holds two numbers. Yeah, sure! What about it surprises you?
No. So how do you declare type. When I say int x(5), okay, this is simple syntax right?  For declaring an integer. So I want to this for all of you, because I think it's a germane point, okay, it reinforces something good.  When I say int x(5), x's copy constructor, which is implemented for us for integers is invoked And x is instantiated to 5, ok? Not a copy constructor, It's constr- you can do this. There is a constructor for integers that will allow you to do this Ok? Now, it's probably an assignment Now, look at how this matches. This is type, this is name of the variable, this is parameters passed to the constructor, ok? You got it? Same thing here, this is the type of the variable, this is the name of the variable, these are the values passed to the constructor.  Ok? And there's that constructor. Any questions? You need that name and then from then on, two nodes is one of those things, could've been frog. Alright, so there you go. So this is how you will be writing your code for MP3. It's a templatized class.  The List class is a templatized class. Ok, I have some challenges for you to do, let me see where I'm going here. Look, we're almost done! Ok, go for it, spend a couple minutes on the three challenges on the bottom. Â  Â  Â  Oh! That's the other thing to say about MP3. We want you to struggle in isolation. It's a solo MP3, and to clarify what that means, it means that you can draw pictures with a friend, but that sweaty time of debugging, and actually crafting the sequence of commands that wiil fill the pictures that you draw on the white board, those have to be done on your own, or in the presence of course staff. Ok, so don't work with your friends while you're writing the code. You can draw pictures all you want, but if more than two eyes are on the code, then that's probably not valid collaboration case. Ok? And yes, I recognize that two people can close their eyes, close one eye, ok,  That's not okay. Alright, how's this going? Anyone want to write solutions on my tablet? That'd be great. No way?  Ok, anyone want to write their solutions on my - alright, fine. I'll do it.  Challenge 1: write the function signature for the copy constructor, oh brother. It's called ezpair, and the name of the function 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
So how do you declare a type? When I say int x(5):"  This is simple syntax for declaring an integer. I want to do this for all of you because I think it's your main point. It reinforces something good. When I say int x(5), x's copy constructor, which is implemented for us for integers, is invoked and x is instantiated to 5. Not copy constructor. You can do this. Let's just say it that way. There is a constructor for integers that will allow you to do this. Now, it's probably in this assignment. Look at how this matches.  This is type, this is name of the variable, this is parameters pass to the constructor. You got it? Same thing here. Type, this is the type of the variable, this is the name of the variable, these are the values pass to the constructor.  and there is that constructor. Any question about it? You need that name and from then on towNums is one of those things.  could've been fraud. Alright. so there you go. so This is how you'll be writing your code for mp3.  It's templatized class. The list class is a templatized class.  ok. I have some challenges for you to do. let me see where I'm going here. Look we are almost done. Ok. Go for it. Spend a couple minutes. spend a couple minutes on these. On the three challenges at the bottom. That's the other things to say about mp3. We want you to struggle in isolation.  It's a solo mp to clarify what that means.. It means you can draw pictures with friends, but that sweaty time of debugging and actually correcting the sequence of commands that fulfills the pictures that you draw on the white board.  Those have to be done on your own or in the presence of a staff. So don't work with your friends while you are writing the code.  You can draw pictures all you want but more than two eyes are on the code than that's probably not a valid collaboration in this case. Alrignt. How is this going? Anybody want to write their solution on my tablet?  Anybody want to write their solution? Alright. Fine. I'll do it. Challenge 1: write the function signature for the copy constructor. It's called ezpair and the name of the function
[Silence] Question is, where do you need the angle brackets? [Video Playing] Template, class T, ezpair T, here is the only place you don't need it, in the function name itself. [[s Const, ezpair T reference, what do we call it? Copy constructor, so it's orig. Raise your hand if you happened to get that right [Video Playing] How do you declare a dynamic array of mypairs of integers? So this part down to this line, challenge 1 is related to lecture for today. These two are review because you have this exam coming up. How you declare a dynamic array of mypairs of integers. So this is a declaration, not a definition, not an instantiation. So I want to declare this thing, what should we call it. It's a declaration so it needs a name.  [Video Playing] Dynamic array, I'm gonna call it ma", my array [Video Playing] I want a dynamic array of mypairs of integers [Video Playing] How do we do that? [Video Playing] I think this should be ezpair [Video Playing] Alright, the dynamic part gets an asterisk, and ezpair of integers, is the kind of thing you're gonna put into it [Video Playing] So, now you've got this array we declared. I guess this is not review. And inside is 2 integers. 175, each one of them has a pair of integers in it. Alright any questions? Okay, how do you allocate memory if you want that array to have 8 elements? So, ma" equals, I know I want "new", I know the last thing is going to be 8.What goes inside? [Video Playing] Ezpair, int [Silence] Any questions?  [Question being asked] It does, it doesn't point to it, it contains it, it contains an ezpair
Alright, you ready to work?  Okay, I think I'm ready to work, let's do it Um Okay, so today's the first official day that I'm announcing next week's midterm.  Um, it's on Wednesday night. So, those of you who have sections on Wednesday might be a little confused. Should I go to section or should I go to the exam.  I think you should probably go to the exam. Um, and what we're going to do, what we're gonna do for you is um, give you a attendance, the people for whom there is this conflict, if you go to the exam instead, we'll give you credit for attendance of the lab. The lab will still be due, there will still be work due on Sunday, just like every week. Um, but you just won't you know be able attend the lab section to do it. You are welcome to attend any other lab.  Um, this is kind of a new thing for us, we don't know how this feel this yet. We always do our exams on Tuesday night, but the room, the space wasn't available, so we couldn't, we couldn't do it like we usually do. Um, so, let's see. So there are additional things that go along with this.  Um, class is canceled, so the, the lecture is canceled that day.  Lab, moved, okay. You can go to any other lab you want and we'll give you attendance automatically Um, and there will be review sessions going up to it In fact, the first review session that you should know about, the review sessions are these  There's one that meets at 11 AM And, one that meets at noon Uh, can you guess where? Yeah, here On the day of the exam, yeah, cause we have to cancel class, but we figure that it's a good time to just meet anyway optionally Um, we'll do other reviews too, that's kind of just a little joke, right? Class is cancelled, but we're gonna work on anyway Alright. Uh, any questions about the exam? There are sample exams posted I believe, I'll have to double check and make sure that's true. Um So for years, the format of the exam has not changed But, we're writing all new, all new exams, and we're gonna have new exam procedures, things are going to be a little different this semester, so i actually don't know exactly what the exam will look like yet, um I think it will probably be similar format though, so multiple choice questions, some short answers that are based um on lectures, some short answers that are based on labs, some short answers that are code, largely coming from the MPs. So, that's kind of what these exams are like. Uh, alright, any questions At this point. Yes.  The rooms are TBA, um, cause we have this script that we run that allocates people into rooms, and we just haven't run it yet, so it will be announced on the website and on the piazza Okay? Any other questions about that?  What What's the giggle Oh yeah, exactly, pretty much You can figure it out, you figure out where to go If you didn't do the second lab you're toast. Okay Um, let's talk about templates Everybody good? Monday is monday, you know? This is tough here It's tough crowd today Talk about templates Alright. So I think at the end, so last time we were talking about um templates, and we got pretty much through the material, um there are a couple little details that I want to talk about, and we're gonna revisit them and a sort of rich, use for them in another week or so So, we're gonna leave C++, and, and moreover templates are our last C++ topic. C++ specific topic So, today is the day, today is the day, we actually start the data structures portion of the course. Yayy The day of celebration for me, but we have some loose ends to tie up. Not that I don't like C++, but. 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
So I did something this weekend.  I've never done it before, and its incredibly empowering. I signed up for an amazon EC2 instance and installed my own web server, and got my website running on it all by myself. Up until this weekend I had no idea what a web configuration file was or a server configuration file. I didn't know what httpd meant. And I just feel like I'm a bigger person today because of it. It is really empowering. This thing that we do, its a blast! Alight, I thought I would share that with you. Its one of those intimate moments between friends. Okay, so lets talk about templates. Why did that occur to me because we are leaving behind the C++ portion of the course and moving more into the abstract data structures. A little more mathematical portion of the course. So I was waxing about the fact that I like to program and I am going to miss it. But, here we go anyway Alright, so the couple of little things you notice about this immediately. You might have wondered about last time or we might have talked about it but I can't remember. Its  okay to pass more than one type. More than one type as a type parameter to a function or to a class. So what you see here applies to a class template as well. Any question about the function addEm? Addem. No questions about the function addEm. Its okay. Alright, now I of course have questions for you. I want to know how this does. So look at this client code, the code that uses addEm and speculate on what each of these function calls returns. Speculate on what happens when you run this code or when you compile this code. Okay what happens when you've compiled this code? What do you think? Works fine? It doesn't work and it doesnt compile. Tell me why? If these are the line numbers in the code and the compiler tells you what line fails. Which of those fails? Four. Thats right. So, suppose I get rid of line four. So line four doesnt compile because. Actually, well someone else describe it. Say my sentence for me. Somebody raise their hand and say my sentence for me. Why does line 4 not compile? Why? Yes ? Right, operator plus is not defined for strings plus integers. Good. Not overloaded. Okay fine. Suppose I get rid of line four then do you like it? So  I am going to get rid of line four. Then do you like it? Way in the back, do you like it? Also, line five the compiler doesn't like. Okay, so again operator plus is not defined for the alternative order as well. Okay fine. Then just to double check very quickly. Now assuming that this code compiles, tell me what the output is when we run it. Whats the output of line one here? Seven. Good. Whats the output of line two? 7.2 thats right becasue the first template. The first template variable is the type that is returned. So you get 7.2 How about here? Line three. Right it truncates to integer. Good. Any question about that? Alright, so I want to talk a little bit more about the compliation process. Because it kind of changes the way we do buisness. So, I am going to give you kind of a diagram of compliation as we done up until this point. So, imagine that this purple box includes the code for sphere.h and the green box includes the code for sphere.cpp. And the blue box is client code or main.cpp in this case. Okay. Now, our complilation process combines these two compiles sphere.cpp. And the way that it knows about header is because we have pound included sphere.h here. Okay, any questions about that. So we can compile those files together into a .o file.
There we go, ok? And it's executable code.  Ready to be linked with anybody who would like to use it. Alright, fine. Well, I know somebody who would like to use it. This main would like to use that compiled code. All that has to be done, is sphere.h has to be included, oops. Sorry. #include, sphere.h here. And then these two, are effectively compiled together. Into main.o. And, how do we get sphere and main linked? Yeah, the linker does it for us.  So, it's the linker that creates the union between main and sphere. Ok? And, that whole process is sort of orchestrated for you by the makefile. That's the whole point of the makefile. So, that you could do all that seperately, and then put it all together. And, not have to type it out every time.  When you're trying to compile your code.  Now, the world is a little bit different. In the case of compiling templates. So, again we've got sphere.h and sphere.cpp and main.cpp. But, if you noticed on the previous page, the compiler detected. The compiler could detect. That it didn't have a plus operator for integers and strings. And what's going on there. Is that the compiler needs to know ahead of time, exactly how, and so you got a compiler error. The code for the addEm function, was not created. Now, the reason that that happened is because, The code for all of the use of your template functions, Must be visible to the compiler, all at the same time. That means that, main cannot be compiled separately from sphere.cpp.  And more importantly sphere.cpp cannot be compiled separately from main.   More importantly sphere.cpp cannot be compiled seperately from main.  Because, in order to make the sphere class. You need to know how spheres are used. The type of thing that you're passing in to spheres. To use for its radius, I don't know. The parallel falls apart a little bit here.  Ok, so what do we do? The main principle is that we do not expect different behavior from the client codes. The client code is still going to say #include sphere.cpp, ok? H! Geez, sphere.h. We don't want the client to have to change. So, the client is still going to say sphere.h. But it can't just be sphere.h, it also has to be the implementation. So, how are we going to do that? What are we gonna do here?  Hmm.... When we compile this, we have to compile it all together, and the code has to be all visible. And we don't want to client to change code, change behavior. Yeah? Yeah. Look at this. The only thing we're including is sphere.h. So that's the only code we get. So the only way that that include statement can include all the sphere class definition. Is if we say, #include... sphere.cpp at the bottom of sphere.h. And now when you do this #include sphere.h, you actually get all the code. And then, you compile main.cpp, and all the compilation happens at once.  There's no use for the linker, in this case. Yes? Because the declaration of the class has to come first.  So you have to have the class declaration, the implementation of the member functions, and then the client code that uses them. Ok? Alright, yes?
Yes, if you don't have a template, then yes, So more efficient isn't really the point. The point is in practice. If you do it the first way, and then someone came to you and said, I need a sphere class, Do you have one I could use? In the first case he can say yes, and you can give that person a compiled sphere class that they could use. As long as he also gave them the header file And not have to expose the implementation In the second case, you lose that and in fact, in my mind, from a software engineering perspective, that is kind of the cost of the template instantiation. You kind of lose a little bit of your elegance. Alright No, so the pound include thing is a string substitution, so You could do that, you can say #include sphere auto, but you would get code that you don't ever want to look at That would'nt be interpreted correctly That can't be parsed or processed. Um, so the question is can you use the same make file, um and the answer is that you would have to get rid of the sphere target, because you can't compile this sphere seperately, but that you could Yes? You cant change it In the client code, yes anything that is private is still private, its just that you do expose it, you still show it I mean it is just code, so they could actually change it But, not in the client code, it would have to be using an editor or something Its a differerent thing, yes you have to expose your code Good question, ok so his question is very astute, he said how bout if we have the behavior in the class be the same, and then just make this #include sphere.cpp The answer to that is we want the client to not have to change what they do because of our implementation choice What do clients typically do? They make a list of all of the classes that they are going to use and look for their class definitions in .h files, so we dont want to impose that burden on them to go huh, I wonder if that's a .h or .cpp We just let them go to the .h file, you could yes, but functionally you shouldnt Any other questions? Yes Um, oh do you need to, Im gonna throw that back at you, do you think you do? Because then you will have the circular include Alright anything else? And I didn't, right? I did it right Alright anything else about this? Beating a dead horse, I've got something new Yayayayayay, we are doing something new today Um, i wanna move us to something new very slowly, ok because there are lots of points i want to bring up, take a look at my new struct here Um, and what I wanna know about it What I wanna know about it is what is this line What is that line Somebody raise their hand and tell me what that line is, there is a good way to describe it Good succint way of describing what that line is It's a constructor, thats right, its a listNode constructor very good, now when I actually declare a listNode, for example If i say, well look at this, listNode<int> nln(5) new listNode 5 What happens effectively is that this constructor is called, this data is oh look, put in the data field, and this next becomes what? Null, that's right, so upon this declaration, the result is this In general, what we have is this sort of rectangle that has two fields The way im gonna describe it, and always draw it, is a rectangle These two fields are going to exist here, and here Just the way I'm always going to draw these This one is a pointer, the other one is just, oh what is the other one? What is the other one?
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
List item type, ok? So LIT there, list item type. You saw it as class T before. Alright, any question about that? Ok. Yes? Why not? This is C++ we're speaking here. Ok? So the c++ compiler will look at that struct and go oh I know what a struct is. It's just a class where everything is public. It's exactly the same thing and you can put functions in there too. Guess what? You can even put a private section in there if you wanted to. You can store dat- I mean you already do store data. You can put functions. It's exactly like a class, ok? Why did I do struct? Exactly so that you would ask me that question. Thank you. Ok. Yes? Uhm, oh you tell me. I'll tell you right now that this is a declaration. So what does it mean when you have a variable declaration? You've got a type, you've got a name. You might a param- an initialization parameter. It's just the name of my variable. Ok? So, you know if I were drawing this out.. here's nln. It's not a keyword, it could've been frog. Which at that point sounds sort of like a keyword. Alright, any question about it? Yes? Yea. Excuse me? Nope. No no no. Except to keep in mind who you're communicating with. If people expect a class you should use a class. If people expect a struct you should use a struct. That's really it. Yes? Yea. Yep. Alright, uh, or at least mostly so that it is. I mean maybe it's kind of convenient to not if you're making things with everything public. It's just, I don't know. It's class where everything's public. Ok, uhhh. Let's see... Here's what I want instead. I don't want this uhhh stack variable nln just sitting here. Instead I want this. Write me the line of code that you could use to create this in memory. Ok? So.. Instead I've got a pointer. Do you want me to give you a name for this? Ok, call it yum. I used yum a little this weekend so it's on my mind. Ok. Anybody want to write it on my tablet? You can. You want to try? Oh, mine's terrible too. It's kind of a pain actually. Sure. It's fun isn't it? He say's it's intoxicating. Good. Good. Anybody want to comment at all?  Yea I would be explicit probably the system will infer it but I would be explicit. So I would've put an int right here. That's all. Ok? Alright, any other questions about this? Good job.  Alright, now why did we do this? Why do we do this? We're going to admit that... this thing holds on to future ones of these. Ok? And we're going to consider a unit to be we're going to consider a unit to be the pointer together with the data in a sense. Together with this last box. So a unit in our structure is going to be one of these things. And then notice that that's what we have hanging off here. It's a pointer to a box. Ok? So if we do this. If we make this like this. Then every list node... is effectively the same. Ok? Here it's kind of you, you'd have to you'd have this case where sometimes it's null and sometimes it points to everything else something else. And so we're not going to do that. We're going to... uhm, for elegance sake hold on to the first thing via a pointer. Ok? Now, here's what I want you to do next. I want you to change this in memory into this. So write the line of code or two lines of code or whatever you need to make yum now instead point to this where this is what yum this is what yum used to be. Ok? It makes sense and you can work with the person sitting next to you to make it happen.
Who got it? Want to do it? Somebody want to write it? Okay, I'm going to talk loud and do it, okay? So I need to make a new, I need to make a new list node here whose value is six and I know just how to do that. It's going to something very much like this line. So this is going to be list node pointer new equal new list node... Oh, int six. Okay, I'm going to give myself clearance here, okay? You're going to want to raise your hand a hundred times over the next few days and say, You forgot a template!", okay? I hereby absolve myself from the responsibility for including every last template. If it looks like I need one here and here, please just pretend that I did it, okay? These are compiler errors at worst, so, you know. We're much deeper than compilers here. Okay, so I have list node pointer, I better not use-- that isn't new", that is n-u-u. Alright, new... u-u. Okay, it isn't the word new". Equals new list node six. Okay, so now what I have is something that looks like this... Right, and I have yum" over here. So here's six, here's yum" like this. Hmm... how am I going to do that? Hmm... this is n-u-u. Nuu dot next equals yum, good. And... No... what next? Good, and then yum equals nuu. Yeah? You like it? It's okay? Okay, because that means now nuu next, I'm going to do this in green. Nuu next equal yum, that means it points way over here. Right? And yum equal nuu, so... that means yum-- oh, wow! That was cool. Woah! That's really cool! Now yum points to nuu. And look! It looks just the same, right? Yum goes to there goes to back to where it used to be, okay? Any question about it? Alright, so if you have not started MP3 yet, MP3 is like... it is like a million of these kinds of puzzles in much more complex scenarios. Moreover, in MP3, instead of just having a next pointer, we also have a previous pointer going to the previous element in a chain of these things. Okay, so let's write, let's write a little bit more code here. We did an exercise that we probably want to generalize and replicate. This inserting something at the front. Okay, so here's what I'm going to assume is the setup. I'm going to assume that I have a series of these linked nodes and I'm holding on to them by a list node pointer called head. Okay? Any question about that? Is that alright with you? Okay, and we've already somehow built these up, kind of like we put the two together on the previous page, Now what I want to do is to write a function that, given a chain of these things, will just insert one at the front, okay? Alright, so let's do that. Hmm... How does this go? Do you want to write it, or shall I write it?
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
I'll write it, so listNode pointer again, template's missing, you would have to put it there listNode pointer n = new listNode, what should we put in it? e, good! And so now, we've got this box called n, that looks like this, and there's a cow inside, alright? For our little example, now what? n's next equals curr, good, and then curr equals n, right, isn't that what we wrote on the previous page? This code is broken, is that what you're going to tell me? Oh, very good. Yeah this code is broken. Here's why: I slid one by you, okay? And we're going to see this lots of times, so I want to kind of go over it carefully. Alright, here's the deal. This code, as it's currently written, takes a pointer by value That means a copy is made of head, okay? Like this, we happen to call it curr. Okay? Through our manipulations, we assign curr to point to here, and this one points here, and then when execution stops, curr goes out of scope. So what happens? Curr goes out of scope and n goes out of scope, so we no longer have a hole on the front of this list anymore, right? On the front of this chain. Okay? We no longer have a hold of this chain from the front anymore. Okay. So how can we fix it?  What we want is for curr to be a different name for head. Then, when we change curr we also change head, the way to do that is by passing by reference Any question about it? Now, do I like this code? No, I don't, there's actually a better way of doing this, but I wanted to bring this potential for error up to you  If I were really writing this code, I would return a pointer that is the result of this thing being inserted at the front, rather than doing it by side effect, ok? Ok, alright, any other questions about this? How long does this take? How long does this take, what's the running time of this, ooh it's our first running time question! Okay, let's take a look at what the code does. The cycliant point here is that there is no iteration and there is no exploration, recursive exploration, okay? It is an assignment statement followed by another assignment statement followed by another assignment statement, okay?  Each of those will take, effectively, a fixed amount of time. Choose the slowest of them, probably the new listNode's going to take the slowest, I don't care. Choose the slowest of them, think of that as your constant amount of time and understand, then, that you can bound the running time of that entire function by 3 times that largest amount Now, the way we write this, is to say that it is constant even if we don't know what it is and even if it changes across machines Or, we write it as big O of one. Okay, so and the observation, the sort of back of the envelope observation, says that there's no iteration, no exploration.
Just a sequence of assignment statements that are going to be the same every time we execute this code. Alright, any questions about it? Okay, fine. Here's another one. 8 4 2 6 3. So suppose we built up this list; suppose we built up this chain of linked memory and this one is we'll call it head and we'll pass it in. We want to printReverse(head). So what we expect out of this is the sequence of printed numbers. We want this to return 3 6 2 4 8. Any questions about it? About what we expect this hting to do? Alright, here's what we want to exploit in this code. We want to exploit the fact that this chain of memory all linked together is a listNode pointer instantiated with the listNode together with another chain that looks just the same, that is just a smaller instance of the original problem. This situation begs for recursion, that's right. Any time you can break a structure down into something that is smaller than the original but has the same characteristics of the original, you're talking about a recursively defined structure. Alright, so that's what we have here and that's what we're going to exploit. So suppose I can print the reverse of this, the rest of the list. Suppose I know how to print the reverse of the rest of the list. How do I assemble that into a print the reverse of the whole list? Yeah? Very good, very good. So you print the reverse of... print, reverse of the rest of the list and then print the first node. Node's data, should be careful about that. Any questions about that? What's the base case here? Oh, we're in the world of recursion. No, that's right. What's the reverse of the empty list? Nothing right? There's nothing to be done. Alright, I think you just suggested all of our code here. So my code is going to look like this. If (curr != NULL) then I'm going to printReverse(curr->next) and then I'm going to cout <<  curr->data << endl.  
Alright, and it better have this. And nothing happens if it's NULL. Okay. Any questions about it? You like it? Yeah? Do I? I was going to ask you that! He said do we need to pass by reference? What do you think? No, because we're not changing anything about this list. We're just sucking values off for printing. Okay? So we don't have to in this case. Alright fine. Uhhhhh... This comment is in the wrong place. Any questions about this code? Okay. Let's talk about the running time. Kay, now we can no longer say that there is no iteration and no exploration, right? Uh-oh, we got a problem. So let's look at this holistically. Well there is a couple of different ways of looking at it.  We will look at it holistically first So I'm going to parameterize the running time by... uhh...a function by n. Okay, so the running time is T(n) Function for the running time is T(n). Now I don't know how long this thing takes, but I do know that it takes time. But the amount of time it takes to print the rest of the list Plus some constant sum of time it takes to print a single node, the data from a single node, right? I also know that the time it takes a list of nodes of size 0, or the NULL case, is  some constant amount Kay? Alright So there is our first recurrence Ohhhhh Raise your hand if you did not take CS173 or a discrete, if you're doing this without the  discrete prerequisite.  No, you don't have to raise your hand.  If this is unfamiliar to you, find a friend. Kay? Because this is...this is part of the prerequisite of the course Okay! So one of your friends who has already done this, what is the solution to this recurrence? What's the solution to this recurrence? T(n) equals I think it's n times c plus d, yeah? Yeah, alright! n times c plus d I don't know about you, I don't know about you, but this back to algebra one  Where y equals m x plus b Alright? f of x equals m x plus b What is this thing? It's a line Right? And in fact, if we can express the running time of a function in these, in this line We call it linear So the running time is linear In the size of the data And in big O terms we express it as big O of n And we'll talk more about the definition of big O later but suffice to say that it also is prerequisite from 173 Okay, any questions about that? You doing good, yeah? Oh boy I'm not in jogging shoes today   Ahhh, so the question is.. oh this is excellent discussion. Let's talk about this code a little bit So he's really worried about...he thinks that base case should be curr next not equal NULL right? okay But here's the thing
I said we said an empty list is our base case, right? And the only the empty list is the case where curr is equal to null, so the alternative case is that it is not equal to null. The general case is that it's not equal to null. So the list of length one is not the base case here. Even though, yes, it's true, even though yes its true the reverse of the list of length one is, you know, the list itself If I pull that off then I have to have two base cases, because if I'm allowing an empty list then I better handle it in the code. Right? Does that makes sense to you? Okay, so there something else I wanna ask. How do I know that this thing will not segfault? How do I know that this is okay, to call printReverse on the rest of the list, that there is a next, how do I know that? It's not null, thats right. We already checked as validation of the general case, the not base case, we already checked that it's not equal to null. Okay, so thats the sa-so dereferencing it is a safe thing to do. Alright, any other questions about this? Same with curr->data, you dont have to worry about dereferencing it Alright, uh, sorry for the scribbles and stuff there maybe the best thing the best thing for me to do is to go to the next slide. Okay. Alright, lets write this code too, really quickly. [pause] So this is going to end up being useful to us. This is going to end up being a useful function for us, because it turns out,Â  that walking around on these lists is a function that occurs anytime we're searching a list for anything. So the one that we're gonna want to write, the function that we're gonna write here is simply  given a position in the list, given a pointer to a position in the list walk k steps forward. Okay, walk k steps forward. Um, I'm gonna go ahead and write this code really quickly is that alright with you? Yeah? Okay. Let me get my notes so I don't screw it up. I dont have my notes I already lost them, I will screw it up -we'll screw it up together. Alright. [pause] So I'm trying to think how, okay, alright, so what is the  base case here? [pause] Yeah, k == 0, very good, or what if I called  find of, uh, on this list of 42 [pause] Oh, and notice we're gonna return a pointer to the kth the node we get if we walk k steps. I should do this, look, this is how this works find on head pause of 3 walks 3 steps, so theres 0 steps, 1 steps, 2 steps, 3 steps, and returns that pointer. Okay so returns a pointer to that element. Okay, any question about it? Okay Walks three steps forward. Okay fine. So, I'm going to say if k is 0, or if curr is null, then I'm just gonna return my current position. And in the case where curr is null thats fine it's an indication that we have walked off the end.
Okay, so that is either the current position. That is, when there are no more steps to be taken or it's an indication that we walked off. Otherwise, it's the recursive case, right? Otherwise, return the find of curr->next and k-1. You like it? Kinda boring. Why are we returning? Because I want a pointer to, I mean I want to return a pointer, I want to walk a pointer down case bases in the list because this one is going to return something. Wait! Before you leave, whats the running time of finding the kth thing in an array? Right? That is array sub k. That's constant time, random access memory allows you constant time access to a particular place. Soooo, that's a problem.
So that's either the current position that is when there are no more steps to be taken or it's an indication that we walked off Otherwise, it's the recursive case right? Otherwise, return the find of curr->next  and k minus 1 You like it? Kind of boring. Why are we returning? Because I want a pointer to I mean I'm returning a pointer to I want to walk a pointer down k spaces in the list Because this one is going to return something Wait before you leave What's the running time for finding the kth thing in an array? What's the running time for finding the kth thing in an array? Right That is array sub k That's constant time Random access memory allows you constant time access to a particular place So that's a problem. Yeah 
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
Okay, so that's either the current position, that is, when there are no more steps to be taken, or it's an indication that we walked off. Otherwise, it's the recursive case, right? Otherwise, return the find of curr->next and k minus one You like it? Kinda boring, why are we returning? Because I want a pointer to - I'm returning a pointer - I want a pointer to - I wanna walk a pointer down k spaces in the list. (Student question) Because this one is going to return something. Wait, before you leave, what's the running time of finding the kth thing in an array? What's the running time for finding the kth thing in an array? Right, that is array sub k. That's constant time, random access memory allows you constant time access to a particular place So, that's a problem (Student questions) (Class ended)
Ok Alright, let's work I am both proud of you and dissapoint of you today I am proud of you for coming here But I am just a little-tiny-tiny-bit dissapointed in you for coming here giving how beautiful it is out side So I am pretty sure... I know I know I know I know I know I know thank you for coming here I understand how It might have been difficult to walk over here and like come in the doors. Like, I can't see outside so emm, my, eh, my admonishment to you is to find a way some time today To breath these breezes, look at some trees, play some frisby with some friends Skip some other classes Oh.... Ok ok so the out side Emmm, alright, so here we are, yet here we are We have an exam coming up, if you have an academic conflict or you think you would like to convince us that your alternative conflict is worth discussing. Is something we should discuss, which I don't mean to trivilize it, no I shouldn't say it like that  It's always worth discussing If you feel like you have a conflict with the final or with the midterm 1 please send an email to Terry Emmmm That's his email address and please send it from your U of I account so that he has your netID, or at least be sure to include your netID in the email at the very least. Umm, so that's with conflict requests On Friday I should have a clear picture of the review sessions that are avaliable to you. One of our course stuff people want to do a review session tonight Like, that, it's too early We will try to do that in weekend some time, and if we dont please request them on piazza and then We will feel guity at least for not doing that  Alright, I think that's all I have, MP3 out there is due Friday night The early part of it will be on the exam. So you will be responsible for the material in the first part of MP3 on your exam Tell me your name one more time I think I know it but I don't wanna embarrasse myself.  Ahhh, really?  Does it start with an A? What is it? ??? Oh it's ???? and sorry I'm sorry You maybe embarressed by self, go ahead
um, yeah, the auto grader will still, will run on 3.2 begin Um, yeah, the auto grader will still, will run on 3.2 beginning on the 26th. Ok? No, i don't think so, i don't know, I don't know what actually got put into the grading scripts, ok? Yeah, it'll run for a week before the final due date. Ok, let's see, where are we, should we work on linked list? I think we should, Um, so  Um, so we had created this structure, we created this structure here of memory that is chained together ok, and I want you to think for just a second about this as simply that, memory that is chained together. Because this Designation of this thing as a linked list is merely sort of our culture's way of describing memory  Memory that is chained together, cause we don't like to say memory that is chained together every last time. Ok? Now  When you say linkedlist, you are not necessarily implying a particular implementation of a  Of a list, no, I'm sorry, that's exactly wrong. When you say linkedlist, you are implying a particular implementation of a   list of thing. Ok? And that particular implementation happens to be this sort of chained together  Um, chained together pieces of memory, nodes of memory. Ok, we wrote this code last time, we wrote this code last time, and um it works like this, it works like this if I have a set of memory that is all chained together and Um i designate the first thing as a variable called head, the very first memory address, as variable called   head, and if I say find k  On head, for, um, i don't know, two steps, find the second one effectively. What this mean, what I intend for this to mean is   please, function, return me the pointer that points, that effectively walks me forward, this  meant steps in the structure, ok? So, head curr in this instance, in this case begins here And the one that I'm going to return is the one that constant to walking to forward in the list. So   There's the pointer to something after taking one step, there's the pointer to something taking two steps, it is this one that    I want return in that function call. Any question about that? So it's sort of if your consider yourself be in the first walk forward two steps, yeah?  Um, so right now, he's asking I think about  where this code go, right? Ah ha, ah ha, yes, right, so um the, I'm gonna say it again That I'm gonna change the vocabulary just a little bit, ok, so if function like this is useful to you in  your, in your mp, where this is not a function in the globe scope, but it's rather a function inside the list class then it is true you have to declare it inside the list class. See you have to add that function's declaration to the list  class. And we'll actually see that later today when we do the same thing here. So it's pretty astute observation to see  that what we have here is a function in the global scope, rather than member function of some class, like a list class, ok?  Alright, last time we got far enough in this section to actually write down clearly we didn't, for find K. Maybe we didn't get this far. I can't remember Here's what I want to know, I want to know what's the running time of this function. That's a general thing that I want to ask, a lot of time that's how I ask the question What it means is i want the asymptotic running time that means approximation on the running time for input of size, some parameter N, ok. So I'm gonna write that down  here, just because I don't ever want you mystified for it. So when I say running time when I ask for the running time, of a function, what I mean is the 
asymptotic. asymptotic. that's not a p there. running time. that's in terms of big-O on a structure of size and now again I could write anything I want here. I could write k. I'm going to write n to differneitate it from k so I want. not asymptomatic but asymptotic running time. asymptotic here means big-O. ok uh running time, we'll write a function for that on input of structure of size n. ok alright so that means in this case, I'm asking if my linkedlist has size that we parameterize by n. my chained together structure has n elements.  my chained-together structure has n elements what's the very worst case for the running time of this thing could be? big-O of the worst case is we might have to look every element, right. we might have to look at every element and so the analysis the running time is big-O n. ok O(n). you want to talk about that more or is it ok? the way to think about it is how much work do you do at every node?" at every node, how much work do you do? well well, I look at it. and I evaluate whether or not I'm done and k is equal to 0.Â look at it and evaluate whether k is 0.Â look at it and evaluate whether k is 0.  that's the same every time. there's no iteration or exploration at each node so each node is just a constant amount of work for all the elements is c times n ok. too much talking... it's too much talking raise your hand if you're kind of worried about k in this. you're a little bit worried about k. you're not worried about k at all? ok. alright. so k is. k is a particular input to the problem the very worst k that somebody could give you is no worse than n because this thing is going to bottom out at when uhhhhhhh current is equal to null it's going to stop at the end of the list so even though k could be 593,000,000 or a two element list, this thing is not going to run that far so it's bounded by n. n is the worst thing we need to consider ok. alright. uhhhh let's see. how long does it take to find the kth thing in an array? constant time we say it's constant time. and that's was random-access memory gets us that's what letting the computer figure out the memory address for our data does for us alright. I'm tired of this slide. let's move on it's a big moment. it's a big moment because we're going to look at our first abstract date type. ok now, the rest of this class is going to be the rest of this course is going to be an exploration of a sequence of abstract data types now, what is an adt? it's simply a description of the functionality of a data structure a description of the functionality
of a data structure. And data structure is a little bit loosely used here, but its okay, You'll let me get away with it. Alright, so the first abstract data type that we are going to talk about is, dun dun dun, a list. Now, this is an abstract notion of a list. This is a list like your to do list for today which includes playing Frisbee outside. And doing your homework and studying for your exam and working and uh, I'm sorry for the stress of your lives. Alright, so this abstract notion of a list includes your list of things to do today, it includes your list of favorite movies, it includes, I don't know, your contact list, it includes any list that you might want to keep track of data in some ordered fashion. Any question about that? Grocery list, the list of classes you go to, any collection of things where you care about their positions. Now, heres the cool thing about the abstract data type for the list class, and in fact for any abstract data type that we will study. C++ puts the abstract data type into the class definition, the public section of the class definition. So, the cool thing is, if I asked you about the functionality of your general notion of a list, you could point to the header file, point to the class definition contained in the header file and say look, I can create you a list, that's part of its functionality, I can tell you the size of the list, you can insert new things into it in a particular spot, you can remove things from a particular spot, and you can return the data contained in a particular spot. And that right there, this is the ADT for a general list. Operative word there is list. And the only reason i say general there is to distinguish it from what we thing of as a linked list. This is not necessarily a linked list. Okay, notice that we can use this list, this abstract data type list, by simply looking at the public section for it, and I get to keep this secret. I don't have to tell you what data is associated with the list, i just have to promise you that i will fulfill that functionality. that I will implement that abstract data type. Okay? Alright, so fine, lets get a feel for what these lists are by walking through a little bit of client code, designed to illustrate the fact that we can be functional without having to know about the implementation. So the first thing we do is we initialize the thing, it is a list containing integers, that's good. And now I'm just going to use it. I'm going to insert into the first position number 4. Here is my list. I'm just going to put it right here. I'm just going to put my list right here, the front of the list is on this side. And now I'm going to insert into the first position number 6 and now where is 4? The second position, right? You are moving things down. It's sort of like you have a list of favorite movies and you see a better movie, its not like your previous best movie disappears, rather it moves to your second best movie. And that's just how a list class is supposed to function. And now I'm going to insert 8 into the front of the list. Okay. Then I am going to insert into the third position, value 0. Okay, so I think i put it right here. Yes? And then I will insert into the fourth position, the get item number 2, so in the end it should look something like this. And it should be sort of opaque to you what actually happened in memory when scratching out and moving around happened. That's all encapsulated away. Alright, and then I want to Cout the size, we better get 5 here. I want to remove the second thing. And then i want to get the third thing, so this should give us 6. Okay? So this list is really an ordered collection of items. Ordered...
... collection of items, okay. Alright, any questions about it? Yeah?Â Raise, your hand, if you had that question. He said, How come you aren't using Â zero?" Raise your hand if you that was a question you had and you kind of wanted to ask it. Raise them hight. Okay.  I need to whisper to you, okay, because this is a secret. We are the only people in the world that worry about this. Alright. Okay. So thank you for asking the question. I was hoping someone would. Ummm, yeah, so you know we're custom to indexing things by zero, right? But, when you are talking about a list, you know, if I ask you to write down your top five movies... If i ask your top... okay, we'll do three. Write down your top three movies. You can initial them, I don't care what they are, okay. Write down your top three movies, real quick, just so you can remind yourself one two and three." And I say, put your finger on your favorite movie, there is no ambiguity there, right? Like, favorite means first best. Put your favorite... put your finger on the first one you'd see if you had a chance. Like, there really is no ambiguity on the understanding of the first thing in a list, in the rest of the world. And that's what we're implementing here. So, raise your hand if the Princess Bride is among your top three movies? Okay, if you... and raise your hand if you have not seen the Princess Bride. Okay, so if you want to change your list, go watch the Princess Bride. Alright, so the point is, ummmm, whats the point? The point is that you always want to think about what the client expects. The world expects lists to have a first element, and that first element is not something you say a first element," right? You say a first element. It means one. And because thats what the user of your class expects, that's how you implement it. The interface has to behave in a way that is not unfamiliar to the people using it, okay? That's a little software design... a little piece of software design for you. Alright, any questions about that? And yes, I know, we start from zero, and there's lots of economies to be gained. When we right code for each other, we can start at zero, that's fine, okay? But when we write it for general use, we should be very sensitive about who's reading the code. Did you have a comment or question? You're good? Were you going to point out that we're really writing code for each other? Yeah? How does a destructor work for a list? Well it depends on how the list is implemented, and that's actually the next thing I want to talk about. So notice here that I didn't tell you how we made this happen. The implementation of an abstract data type is not necessary to be known. We encapsulated it away. It's a separate conversation. Now it's absolutely true that we are going to be talking implementations a lot, and in great deal, but to talk about the abstract data type ermm generally, discussion of implementation is not part of the discussion. Okay, ummm, let's see, but you are asking about what's my little secret, and I'll show it to you. Now, look at the class here. Look what I did. I made a list, I created a way of us implemented a list, yes? Yes, do you like it?
Tell me what that implementation is? Is you have to describe that implementation, what would you say?  It's an array, good. I even drew a little picture for you. Got any problems with that array? It can't get any bigger that's right. It's a static array and you know what? That one even won't hold your to-do list. Probably. It would hold my grocery list but it would not hold your to-do list. It's too small.  So this thing is a, the more appropriate name for it would be a short list.  Or a tiny list or something like that.Â  Okay, what is meant by size here is the actual number of elements in the list. The number of valid things in the list.  So what this implementation does is it sets up a potential slot but then it's intention is to, you know, put the first thing here, the second thing here, and ect.. I'll go ahead and use your zero if you like, okay?  And that's the implementation. Any questions about it?  So notice what I'm neglecting here. I'm neglecting kind of what to do about the fact that some lists are longer.  We are gonna handle that in a couple different ways over the course of the next week or so.  But we that said, I want to talk about a little bit of a technical detail even if we used an array to implement an ordered collection of things.  Try to ignore for the moment the fact that this is a fixed size. We are still gonna look at the use of an array of any kind assume it's big enough in this context.   Oh because I made these an abstract base class.  Oh you know what I don't know what happens if you templatized type is in an abstract base class. I would have to think about that.  So it won't compile unless it So it could be an abstract base class. But that's tangling up in here templates, in a way that there are a hundred different ways of doing that and so it gets kind of  Like you'd want to look at particular compilation procedures for handling that.  So I think you have a clear picture in your mind and I probably don't have it in mine. But it suffices to say it would be more complex.  But we are allowing for any old type here, so you can put any type here I can't go there right now Alright, we are we though? Let's talk about use of arrays for implementing lists in general Don't look at this code, but I want to talk about what it is.  So our process is that we need to be able to insert into a particular position in a list, and we need to be able to remove from a particular position in a list. Alright, I'm going to pretend that we actually.Well no I'm not gonna pretend anything.  Alright, I want to say insert into position 1, item I don't know. Let's put integers in because I'm not creative.  I wanna insert into position 1 value 3, where should I put it?  Zero that's fine. I'll do that. Now I want to insert into position 1 again value 4. Where should I put it?   Position 0, okay. What should I do with the 3? Move it over. Okay okay. You are saying open up a hole for 4 and put it in right? So the 3 has to come over here  and the 4 goes here, yes? Okay, pretend that I do this a few times. Okay I'm gonna insert to postion 3 an 11, I'm gonna insert into position 4 a 5, I'm gonna insert into postion 6 a 9 and now dot dot dot  I'm going to insert into position 1 a heart how do I do that?  How do I do it?
...to two four, yea. So in the end it looks like four, three, eleven, five, nine. And then there's room for my heart. Okay. What do you think about this? Say it stinks. Thank you. Why does it stink? Oh my gosh. All we're doing is inserting into this puppy, and you have to open up a space?! That shifting is incredibly expensive. So this incurs an order n because it's a loop...potentially all of your data to shift. Okay. And so, this is bad. This is not a heart. It's rather a sad face. I guess you can do it like this. Oops. Yea you can do it like this. Why is that funny? If that's all it takes man, woooo haha okay. Here. There. All right. Any question about that? How else can we use a list for, um, I'm sorry, an array to implement a list? Well, you can put the front of the list out here, right?  But you can kinda... But you incur the same problem so if I say insert one three. Put it here. And then one four. Then I can put four here and here's the front of the list, right? That makes sense? So here's the first item of the list. Here's the second item of the list. And then if I say one five. I can put five here and move the front of the list to there. Do you like that? Yea? How would I keep track where the front of the list is? Right? I can put it there. I can put an index there. Fine. Um, but then I'm going to say, eh, I-I'mma add a bunch of things to it: nine, eleven, twelve. And now I'm going to say insert into position, uh, I don't know. Where do you want to put it? How about six, value, um, frowny face. Okay? Where's frowny face supposed to go? Right between these guys, right? So it means I got to scoot all of these over. Okay, so there's a shift. So this one's here, this one's here, nine, five, four, and then the frowny face goes here. Okay? And again, that's big O of n. Okay. So we can't keep the front at the start of the list. We can't keep the back at, I'm sorry, at the start of the array. We can't keep the back at the start of the array. There's no good place to keep at the start of the array and honestly, you know what? We can always do insertions right, like, between sort of halfway in the middle. Right? Because those openings must occur or can occur anywhere in the list, and we can't predict it, we will always have this shifting problem. So we can't avoid the shifting problem if we allow insert into the middle of the list, so given the list interface we defined or the list ADT. Okay? All right! Any question about that? So here's a better way of implementing a list.
How is this one implemented? If you have to describe this implementation, how would you describe it? Somebody raise your hand and speak for the crowd, yes? It's a linked list, very good. Chained memory put together we are using it now to implement my List class. Is there anything special about it? Yes? Yeah, it's not like MP3. We do not have previous pointers here. A typical way of describing this you might have seen in your earlier class is a singly linked list.  Okay, we will refer to this as a singly linked list implementation of a ADT List. Ok? Alright. Let's see what we have then. We have a way of holding on to the front of it. A number of element that it includes. This little Find function that we are going to find helpful; that will be helpful to us. Okay, and here is the implementation. Guess I changed the variable name but otherwise, lol, Ohhhhhh.. Wow.. Okay, do you all see my little bug? The compiler will help me so I don't even feel guilty about it. But you see my little bug here? These things are... in the wrong order, you can handle that one. And then we have this class defined... I was thinking about this last night and I think I should've been explicit. When I demanded that our base cases been NULL, I should have actually assure you that we intended to have a no-argument constructor for the listNode class. Okay? I should've assured you of that.  Alright! So this is an implementation of the List class together with one helpful helper function. Now, I have a question for you that I don't know if you can answer yet. But I want you to think about it. OK? We put this helper function in the private section of the List class definition. The question is why? Why is Find in the private section of the List class definition. Find is in private, why? I am gonna point to something that might help you. Yeah? Right, so we don't want the user to know the implementation and look, this Find function completely betrays.. Well, actually it only halfway betrays our implementation, right? It shows them, oh bud, you got a pointer-based structure. And you know, built of nodes, and furthermore, the way we have this set up, they can't access it. Why? Because look, listNode is also private. So this listNode class right here that is so important to navigating our implementation of List. It isn't even useful to client.  Right? but that's OK, they don't need it. They only need to know positions inside the list. Alright? any question about that ? So why is Find private? The answer is because it relies on the details of the implementation for its functionality. And that implementation is hidden away. from client. Alright. Anything else? Any questions about this? Ok, let's see if there is anything else I want to say on this page. Hold on...
ok. alright let's write some more code. we can write this together alright. so umm if you notice one of the functions here is insert() um I want us to implement insert() ok. and that's what this slide is for I want you to write an implementation of insert() into the list now notice this is the interface for insert() this is the connection between the code that the client writes. they write insert() into position a value and then you're going to take that function call and actually put things into the linked list ok so go ahead and write this code really quickly. I will write parts of it too I'll write parts of it as well and I'll remind you we know how to create new list nodes because we did it last time so... let's see what I'm going to do is ummmm list node pointer new node equals new listnode e I'm going to find starts here maybe I should just talk aloud do you want me to just talk aloud alright sorry alright so what's going to be my process let's say somebody says insert into position 2 ummm value oh. we have to have an integer 8 ok insert into position 2 value 8 now what do they mean by 2 tell me when to stop when I'm underneath the position that it should be inserted ok. yeah, right they intend in the end that 8 will be between 3 and 6 so that means that what we're going to want to see is an 8 here pointed to 6 and then this goes here alright alright now this would be easy if only we had a particular pointer. which pointer do we want. which pointer would make this easy? I'm changing this to 3. I'm sorry I need to not, like, ermmmmm. sorry changing this to 3 ummm so that all of that discussion led up to here instead makes it more interesting k now where do you wish we had a pointer k this is what we want it to look like where do you wish we had a pointer? ok yeah, you wish you had that pointer. right? like ooooh how do we get that pointer ? how do we get it. how do get a pointer to that place find! right. find will help us walk down the list. ok ok find() uh. we're going to find how many steps from head how many steps do we want to take location minus I started with 3 here how many steps do I want to take? I want to take one step. I started with 3 so it's actually minus 2 yes it is Noooooooooooo!!!!!! so that's the combined effect of you want a pointer to the thing before together with our list you know we're counting this thing by 0 steps by steps by the number of steps and you want it to the thing before ok alright so I want to go loc minus 2 and then oh and I need to grab that thing oh my gosh what I mess I'm going to call this oh I can't call it curr how would you like to hold on to it. um temp ok temp equals this guy so now this is temp alright I am so sorry guys tmp uhhhhhhhh let's see I can do temp ahahahah I'm going to do this in canonical order. new node next equals temp next yeah right. is that true? that the right thing to say? ok and then.... tmp equals tmp next ummmmmm. equals
Where's temp next? It's this one right? Where do I want it to be pointing? To my new node, Good. Good Good Good Alright. You happy with it? Yes? Very Good! Exactly! This code's a mess! It doesn't even work if we want to insert in the first position, but we have a function that inserts in the first position. So, if location is one ( if loc == 1) insert at front(e) else do all of this. okay, and then... then we know that thing will never be 1, we already know it won't be 0 because 0 has no meaning. We know it won't be 1 because that's a different case, and so in the worst case it will be 2, right? This code will go if we're inserting into position 2 and the number of steps we walk forward will be 0 and this code is fine. Okay, do you like it? I don't like this code. Okay? I don't like this code because it makes a special case out of something that's the same as everything else? Right? It made a special case out of inserting in the front of the list, and I think we can write code that avoids that. So, let's work on that. Here's what we're going to do... we're going to redefine our implementation of an empty list, okay? So we're going to redefine... geez *Pause* What we're gonna do is we're gonna say an empty list is a single node. Followed by the rest of our list. Okay? This single node and then yes... empty list is a single node, all other lists are this single node followed by our data. This node, this auxiliary node, that we place in the structure is called a sentinel node. This is a sentinel node. *Pause* This is a sentinel node... Thank you And, look what it does for us. So the empty list has a sentinel node; all lists have this sentinel node in front of this. Look what it does for us. No matter where we insert into the structure, we're always going to be after a list node, right? If we insert into the first place in the list, it's going to be after the sentinel node.  If we insert into the second place, the third place, etc. and so we remove this special case of not being able to grab the pointer before because every node that we insert will have a pointer before. Okay? Any questions about that? That means that the code we write to actually insert this thing looks more like this. This is no special case because we've created an invariant situation where we're always inserting between two nodes even though at the front of the list that node is kinda meaningless. Okay, any question about it? Yeah? *Pause* So that would have to be handled via error handling. Right? We're not talking about that, we're assuming the user is going to honor our abstract data type which says it starts at 1. Okay, so how do we make this happen? How do we create an empty list with a sentinel node in it? In the constructor! That's right. Your opportunity to shape memory upon declaration is in the constructor. So this is where we'll start next time. Oh my gosh... *End of recording* *very end*
oh shoot I forgot to tell you  you are wondering what hack is given the arbitary okay so the location is known, it is a fixed location like k is equal to 3 or something a location is equal to three this one is parameterize so you are allowed the user to input whatever they like for the location you gotta go find it okay ready? should we talk where are the mistakes? where are the mistakes on this so I guess I start walking my pen down actually I will start my pen down up to bottom  alright You tell me when this stop where ther is a mistake stop? okay is this costing ordering to shift in an array which of these two is wrong? this one, okay why, is, why can we not do insertion in old place could you have to walk down the list you cannot just get to any position that you want in a list so this big O of n to find here just like removal okay fine any question about that? alright I m keep walking up remove a given location is okay insert at a given location which one is wrong yes this one is wrong because we have still have to include the shift to open up the location the spot, the space  okay fine should I keep walking up? okay so you are happy with this?no no this is a fixed location i know where it is  which one  which one are we talking about? who am talking to  I forgot already which one you asking about anything esle? is this good? reallly? yeah? ohhhhhhhhhhhhh,this guy right this is the red haring thats the reason I start at the bottom I make this red this is the red hairing
ummm that was little break because it's friday. how about that I owe you 5 minutes in your life sorry umm let's see so I have a new announcement related to the exam there's going to be a review session umm on saturday from 11 to 12:30 we don't have the room for that yet but we'll be announcing the room saturday as in tomorrow but we'll be announce the room on the piazza so ummm ah go to the piazza to find out exactly where it is so let me write it down. ooohh that's pretty oh man getting old sucks ok so the review is 11 to 12:30 o umm 11 am to 12:30pm saturday and that is tomorrow room tba on piazza and the plan is to do the spring 14 exam k. so they'll be ummm they'll be going over the spring 14 exam we may have additional yes ummmm it depends on what room it's in. so I will automatically ask for video tape of it. but it depends what room they put it in so I hope though um ah if not, you know the collective intelligence you know its you know you guys can recreate that sort of review experience by getting together with other people to study you know like that sort of transitive what they said at the review session was this. and I think that's actually a great way to study because it's good for you and the person who is telling you the stuff ummm so any other questions about this? alright. we'll keep you posted the exam still feels like a long way away to me so I apologize for not having a whole list yet seems like we've got a lot of time still ok ah the extra credit is due tonight how was the queue last night? little dicey, right? I think I heard that there were quite a few people on the queue last night maybe right after class today you might want to go maybe a good time ok so I ended last time kind of in a hurry and I wanted to revisit some of the uhhhhh very last closing thoughts from last time because i wanted it to be clear ok so here's the story. here's what we were trying to implement we have this chained-together memeory that we use as an implementation option for an adt now this adt allowed us to insert things into particular locations the application that you should think of I think or a reasonable application is like suppose you have a list of your ten favorite movies your top 10 favorite movies there they are and then you see minions they you see minions ok then you see minions well, you might need to change your list right so  at the number 3 stop, probably because minions is not better than prince's bride or idk what's your favorite movie? or back to the future ok so in the 3rd spot. you need to make space for minions and that means sliding everything else down this is the list adt that we are intending to implement ok any question about that now it's not some clasic data structure ok it is a this is a adt that we're sorting crafting for instructional purposes there are equivalent or there are similar ones but there is no sort of unified language around this particular umm adt ok now furthermore we were talking about implementing this insert function insert into the location into a particular location ok now think about what is necessary for that to happen you need a position and a data element that you're putting into uh the list say of movies ok that's the interface. that's what calls this function or what this function is called with um I have a question for you before we even talk about details here is insert() in the public or private section of the list class? definition is it in the public or private section and when you answer. when you raise your hand to answer, I'm going to have a follow-up question so raise your hand and answer somebody raise their hand to volunteer yes it's in public how did you know what did you check
uh ha xu... very good two key points we need the client to be able to use this function to give it the insert date into the structure dot and when you look at the parameters they are public variable none of them are private to list class okay now let's talk about elegance, last time when we talked about our first implementation of inserting into this linked memory implementation of a list we had a complexity with inserting at the front of the list ok so every place cells inserting every place cells other than the front was a matter of  positioning a pointer before the node we want to insert and creating the new node readjusting pointers that set up but there is a special case in the case of inserting at the front so I am gonna write it down for a second  so our old technique for inserting creates a special case out of inserting at the front now the way we diagnose that the special case is by putting in the conditional the whole code was if  this okay that's a problem later on in your suffering generic experience you learn about a uh... a contact called cyclematic complexity and it basically has to do the conditional branching the amount of conditional branching in your code every time you can redo an if statement every time you can get rid of the neat conditional and a if statement  you reduce the cyclematic complexity or the branching of the program magziqusion of your code  now you might not care about this until I tell you that when you writing code, you have to write a test case for every possible conditional branch in your code now I don't know about you but I hate writing test cases It's tidious I don't want to think about it and so if you don't this many that is cyclematic complexity if your code is lower then you relive yourself of that responsibility  okay so think what we did even in this case, we don't have to write a test case for inserting at the front of the list different from inserting anywhere in the list because everywhere we insert is the same now how do we do this ideal, how do we make it happen the answer is we put a node, a sentinal node at the start of our list now what is this node It's nothing It's data is garbage there is nothing meaningful in it in fact we can't put anything in ti because it's just a list node if is a list node and we don't know what kind of thing list node hold so we just let that be garbage we don't care what its data is okay? all right so it's called the sentinal node we put it the start of the list gives in the insertion that means it gives us the fact that inserting is the same no matter where we are going to do it in the first in an a whatever any question about that said okay is it better? I hate tail ok all right what's the process for inserting is I say inserting into position 1 element eight eighty-five just to make sure difference then what is this code do is takes that many steps forward from the start so this is still head
very good, two key points, we need the clients to be able to use this function, right? To be able to insert the data into this struct this function, right? To be able to insert the data into this structure, duh. And when you look at the parameters, they are all publicly available. None of them are private to list class. OK.  Now, let's talk about elegance. Last time when we talk about our first implementation of inserting into this linked memory implementation of list We had a complexity with inserting at the front of the list, ok? So Every play cells, inserting every play cells, other than the front was a matter of positioning of point before the node we wanted to insert and creating the new node readjusting pointers etc but there was a special case in the case of inserting in front so I'm gonna write that down for a second so our old technique for inserting created a special case outof inserting at the front now the way we diagnose that special case is by putting in a conditional the whole code was if this now that's a problem later on in your software engineering experience you'll learn about a  a concept called cyclomatic complexity and it basically has to do with the conditional branching, the amount of conditional branching in your code every time you can reduce an if statement, every time you can get rid of the need for a conditional, a if statement,  you reduce the cyclomatic complexity or the branching of the program execution of your code now you might not care about this until I tell you that when you're writing code you have to write a test case for every possible conditional branch in your code i don't know about you, but I hate writing test cases It's tedious, I don't wanna think about it and so if you don't have to write this many, that is the cyclomatic complexity of your code is lower than you relieve yourself from that responsiblity ok? so think what it did even in this case we don't have to write a test case for inserting at the front of the list different from inserting anywhere else in the list because everywhere we insert is the same, now how do we do this? or I guess that's the ideal How do we make it happen? The answer is we put a node, a dummy node, a sentinal node at the start of your list, now what is this node? It's nothing it's still a list node but its data is garbage there's nothing meaningful in it in fact, we can't put anything in it, because it's just a list node.  it's a list node and we don't know what kinds of things list nodes hold  so we just let that puppy be garbage, we don't care what its data is ok? alright, so it's called the sentinal node we put it at the start of the list, it gains us in variance in an insertion, that means it gains us the fact that inserting is the same no matter where we are going to do it, in the first, in the eighth, whatever ok? any questions about that? is that ok? is it better? ok so what's the process for inserting if I say insert into position 1, element of eight? 85, just to make sure it's different then what is this code do? it takes that many steps forward from the start this is still head
Head take that many steps forward from the start. Oh look! It has position pointer exactly in a useful spot.  okay? Any question about that? I'm sorry. This must be trerribly painful to listen. And then it does these things. It creates a new node, inserts our data inside, and then fits a pointer. New next euqals curr next, curr next equal new, and that's the code! This pointer's no longer there. When you start from the head, you see the sentinel node, then you see the one we just entered, then you see the rest of the list, which is what we intended. Any question about that at all? So how do we make this happen?  Well, here is a thing, the question to ask ourselves is, what do we want an empty list to look like? That is, when I say, when client code says: List<int> brandNewList, my brand new list. What do we want an empty list to look like, and the answer is what we want it to look like. We want head to be pointing to this sentinal node, like this. That's it Cause then it's ready If you gonna insert into the first position, want the pointer to point right here, we create a node and we are done! Fix up the pointer and we are done. How do we do it? I don't know. I think what we must do is, say, head equal new listNode. Depending on what the constructor looks like, we simply want listNode next equal NULL. So head next. equals Null. Any question about that? And I guess these parenthesis are optional and you don't really need those there and I am gonna erase them because we should do that. Any question about this? Yeah? You don't see what the point of the sentinal node is? Raise you hand is you agree with that question. That's a very brave question. Look at those hands. I can tell the looking in your faces, Why? I don't like conditionals. No, we don't like conditionals. In the old way of doing this, we had to use a conditional because this code didn't work if the head in intended to point to the very first thing. There was no NULL" before. So what this empty node does, is it makes it so that every single data node will have a NULL" before. There's no differece. in structure between the first data node and any of the others. Does it make sense? It's an empty node. It is a node, but it's data is meaningless. It's data is garbage. Oh, very good points. So the question was, to achieve the functionality in a doubly link list, should we probably have a tail? Yes. You should. Yep, you should. Yes?
So there is a little location zero right?. I cannot say to you. I canno say to you.  So I am gonna take it around the ben.  So first in principle there is no location zero . You don't ever say what's your zerothÂ  favorite movie.  ok? So from the client side of things, there is no location 0. But from the implementation side of things  If it helps you. If it gives you peace to think of that as Â location 0. Perfectly reasonable to do so .  Â That's a perfectly reasonable way of thinking about it.  Yes.[question asked] [asking questions ] YesÂ  Ummm. So location is passed in.  So remember that the parameter for find is the number of steps you walk forward .  Right? That is what it means.  It happens to be a function of the location asked for but itÂ  right,yup,zero steps[answering question] ok. How we doing. Is it better. I felt really bad last time. It's like ahhh... And then I got 6 so it's like no no I am not gonna be able to make it better . Is it better. Oh, yeah.Ok. Thank you. You speak for the crowd.  Ok.  Alright, any other questions.  So, so this is kinda fun.This is kinda fun So here is waht I know about you guys . You guys are here after having taken an introductory class  which means you are in command of the basic structures, like iteractions and conditionals  And variables and arrays and functionsÂ  You are in commoned of those things  But it is unlikely that you have in your experience had Â an opportunity to think creatively aboutÂ  how you use memory  and so this is sort of the first opportunity Â where you can kind of use memory to your advantage.  Now am I worried about this amount of memory that we used here? It is a little expansive how much do we pay? for this additional list node?The answer is no. Â I am not worried about it at all. Ok ?  But it's a reasonable question. And [answering questions ] So, Â this implementation the list has no tail pointer. This is a singly linked list . But if it's Â a doubly linked list Â you are gonna initialize the tail to point to the tail. In fact .  Alright,Let's have this conversation. Let's throw it down right now.  Alright,so what does an empty doubly linked list look like?  I think it looks like this,  Here is head. Here is tail. Umm...The next of head and the previous of ...oh I did this wrong  Ok? The next of head and previous of tail point to each other, ok ?  So I think that's an empty doubly linked list if you are using sentinels Ok Now, I really feel bad that mp3, every semester , every single semester. I say we should change mp3 to use sentinels and Course staff goes, no no no no. They should have to do this.  So I am on your side on this one. I never ever throw course staff under the bus but this time .... Yeah?[answering question ] So our implementation of the list class already doesn't use sentinels.  Ok? Our constructors don't create sentinels for you.  So I am sorry this one is not my fault. Just kidding, I am kidding  I don't even know we had that conversation recently . Hey  shaw we work on sth new? ok... I got another puzzle for you .  I have another puzzle for you.  Here is what I am gonna give you ok? We got some big linked list. We got some big linked list . Umm, that what's that little dot dot...you can use a a sentinel if you like in fact I think we need one.  Um, and I am going to point to the node that I want you to remove. So I am going to give you a  pointer explicitly to the node that i want you to remove. Ok? There it is. I want you to remove that node.  containing 7.  From this list  Ok? Remove the node containing 7 from this list now I am gonna let you vote.  Do you want a few minutes to struggle over the code yourself?  thereby kinda giving a you a testy sort of experience? Or do you want me talk over writing the code  Raise your hand if you want to. Umm... Do a little test review by wrting the code  Raise your hand high so I can see.  And raise you hand if you want me to talk aloud to do this? Alright. I am gonna give you guys a few minutes  To write this code.  And Then I will talk aloud. We are just never get through this semester.  Figure out this code. I think it is clear.  Ummm. You could call this guy head.  [ending]
And it is a singly linked list I'm going to start writing here because I'm bored, so if you're really stuck feel free to follow along Okay I wrote my code Okay, so raise your hand if you wrote something similar Okay, good Okay, let's trace it really quickly, I'm going to give myself, effectively, a way of iterating down the list Okay, I'm not going to call it an iterator because that's a special word That we're going to learn about soon; but I'm going to give myself a way of iterating down the list It's called t" and it's a list node pointer, okay?  Started at the beginning of the list, walking down to where? Where should I draw the pointer t" after that while loop? Yeah, it should point to 2, right? So right there is where it is after the while loop And then I just, now that things are set up, all I have to do is fix up pointers I'm pretty sure all I need to do is this and then free up this space And sure enough, that's exactly what those two lines of code do Now, seems pretty clean to me Do you like this code? No. What don't you like about it - and there is a one word answer for this, starting with w While, that's right! Think about this I'm telling you exactly what node I want you to remove I tell you there it is, I point to it; and yet you have to incur the cost of starting at the front of the list and walking down the list All the way to the node that you might want to remove, even though I told you it to begin with, right? This is an expensive problem, this is an expensive proposition Okay So I'm going to show you a potential solution to this problem Okay, so first of all... what's the running time of this?  Linear of n, that's right So what would be better than linear? Constant time, that's right So I'm going to show you a constant time solution to this problem And then we'll talk about this choice of word in just a minute, okay? Alright, so suppose I give you this And I'm going to ask you a question I tell you I want to remove that node and then give you that pointer What node would be easy to remove? The next one, right? Oh, but then we'd lose some data... I wonder what we should do with that data Store where? Does anybody see it? Does anybody see this completely? Yes? Do you want to tell us
and it is a singly linked list can i start writing here cuz im bored if youre really stuck feel free to follow along ListNode * t = head; okay i wrote my code raise your hand if you wrote something similar lets trace it really quickly im going to give myself a way of iterating down the list im not going to call it an iterator because thats a special word that we're going to learn about soon but im going to give myself a way to iterate down the list called t and it is a list node pointer starting at the beginning of the list and walking down to where where should i draw the pointer t after that while loop yeah it should point to two right? so right there is where it is after the while loop and then i just now... now the things are set up ... now all i have to do is fixed up the pointers im pretty sure all i need to do this and free up this space and sure enough thats exactly what those two lines of code do now think pretty clean to me do you like this code? no what dont you like about it? and there is a one word answer starting with a w ... while thats right...think about this im telling you exactly what node i want you to remove i tell you there it is i point to it and yet you have to incur the cost of starting in front of the list and walking to down the list all the way to the node that you might to remove even though i told you it to begin with  this is an expensive problem / decision okay so  im going to show you a potential solution to this problem and i  ok so the first thing of all whats the running time of this? linear o of n so what would be better than linear? constant time thats right so im going to show you a constant time solution to this problem and we'll talk aboout umm this choice of word in just a minute okay alright so suppose so i give you this and im going to ask you a question and tell you i want to remove that node and i give you that pointer what node would be easy to remove the next one right but then we would lose some data .. i wonder what we should do with that data store it where? somebody ssee it? does anyone see it completely do you want to tell us?
d d Suggested Delete the next node Write the code that does this.  I wanna grab hold of the next one Put a handle on it. Curr next is going to look at this and get that value. Make it more of a chain. Data constant for this MP. We can't do stuff like this Fix that problem by putting a sentinal there. Now imagine the constructor for that. Copying around data uhh yuck This should be ok functionally. It could be expensive. This class could be expensive. 
Okay! There's one other issue with this that is actually the reason I hate this, the reason I think it's very hacky, and that is that any algorithm that hap- that any piece of code that happened to depend on the identification of a node with its contents, is now broken. Right? Like... we have decoupled the data from the container that holds it, and any code that happened to have been written so as to depend on the identity between those two- now we're creating a bug. So you know that's subtle and maybe an unlikely situation, but there's one case where it absolutely does occur and I'll talk about that when we talk about iterators. Suffice to say now that this thing invalidates iterators because an iterator is a type of thing where you know its location, you know both the data and the location. We'll talk about it later. And we're decoupling those two. So this mechanism invalidates iterators. Alright and if you read the standard template library in fact there's a comment that says if you do a particular thing your iterators are invalid because the standard template library uses this kind of optimization. Yes, what should we use?  So this was an exercise because let me ask you this: is this particular function in the private or the public section of the list class? Private, right?  This is kind of a manufactured because it has got a list node in its parameter. This is kind of a manufactured situation and in fact if you were implementing remove- if you were implementing remove for the client you'd set it up so that your pointer's position is in the right place to begin with. So this situation where I give you the pointer to exactly the one you want to remove is maybe a little bit artificial. But I wanted you to have seen it because this is exactly the kind of thing that- is exactly the kind of little cultural trick question that people like to test you out with and see if you've seen it before. So I wanted you to see it here. I wanted to give you your first taste here in this class. Would this implementation cost you points on the exam is the question. Uhm no, no no no. Not, I mean.. probably what we would do is we'd ask you to implement it and then ask you to analyze it and discuss. Our point in asking it would be exactly to see if you internalized the distinction between the two. Alright whats the running time of this again? Constant time because it's all a bunch of assignment statements. Alright yes. Okay we created a pointer, so like T in that picture. Okay! Uhuh So the problem is that we don't have the pointer to the one before. We have to walk down the list to get the pointer to get the one before in a singly linked list. Okay, alright! Let's go, let's move on. Ohhh my gosh. Have we flipped the page yet today? Ohhhh my gosh! Alright. We're gonna summarize what we've talked about about list class functions. Uhmm and I'll tell you that there are two errors on this slide. There are two errors on this slide and I want you to find them. Go! You have three minutes to do it. Find the two errors on this slide.
Oh, shoot, I forgot to tell you. You are wondering what the heck is given versus arbitrary. Okay, so the location is known, it is a fixed location. Like, k is equal to three, or something, the location is equal to three. This one is parameterized. So you allow the user to input whatever they like. For the location you gotta go find it. Okay, ready? Should we talk? So where are the mistakes Where are the mistakes one this? So I guess I will start walking my pen down. Actually I'm gonna start walking my pen up from the bottom, OK? Alright, and you tell me when to stop when there is a mistake. Stop? OK? It doesn't cost you O(n) to shift in an array? Or which of these two is wrong? This one, OK? And why, why can we not do an insertion at any place in a List? 'Cause you have to walk down the list right? You cannot just get to any position that you want in a list. So this is Big O of n to find here. Just like removal. Ok, fine? Any question about that? Alright, I'm gonna keep walking up. OK, remove at a given location is OK? Right? Insert at a given location? Which one is wrong? Yeah, this one is wrong because we still have to incur the shift to open up the location, the spot, the space. OK, fine? Should I keep walking up? Okay, so you are happy with these? No?  No, this is a fixed location; I know where it is. Right? Which one? Which one are we talking about? Who I talking to? I forgot (inaudible). Okay, do you see which one you asking about? Okay, alright. Anything else? Is it good? Really? Yeah? Ohhhhhhhhhhhhh. This guy right? This is the red herring. The reason I started at the bottom. I'll make this red. So this is a red herring .
Raise your hand if that phrase isn't familiar to you. Ok, go look it up, this is a, this is a cultural  Moment for you, we are a inter cultural group here, ok, alright, it means it kind of it's led there to lead you astray effectively. Alright, so I know, I know that it's true that  you can come up with, bye, see you, have a great day I know you can come up with an implementation, they cost you O(n) to insert and remove in the front, using array to implement the list right? But, I also know that it's not very hard to come-up with  an implementation that allows for constant time, insertion and removal at the front of the list using an array. And we talked about it very briefly last time. And that is simply that we put the values backwards into the array. So the end of your list is here, and  your favorite movie of front of your list is here and you arranged them backwards, and the only thing you have to do   to make that happen, so then inserting and removing is just matter of messing with what happens at the threshold inset, remove, no big deal, and maintaining  an index that keeps track of where that front is. Ok?  Any questions about that at all? There is a little bit of discussion to be that might not make you happy. Is it Okay? What is that  What is that to do with inserting and removing at the end? makes it expensive maybe we can keep track of where the end is. True right? what about making it the middle That I have no answer for. That one expensive. so for this particular example There is more kind of a clever way of looking at this I mean it doesn't require a whole lot. Fairly clever way of looking at this allows for a constant time max Ok, I'm gonna go ahead and start on the next stop, because the next slide is very introductory anyway. Look at you flip your paper Yay! We are closing the book on abstract data type list.  And here's the deal, here's what I want you, here's what I have want you have taken from experience.  I want you to have learn the vocabulary abstract data type. And i want you to have internalize this model of talking about specific implementation of an abstract data type.  So, you understand vocabulary of abstract data type and then we kind of had discussion of whether implemented using a list or an array  That's kind of how the rest of semester going to go. I'll introduce an abstract data type and sort of let you know  what functionality we want  to accomplish and then we will argue over implementation, ok? Now, our next abstract data  type is called a stack, and I guess it looks like we'll start that on Monday.
[Video playing] Oh my gosh. It's time to work. I am sorry. I don't... It drives me crazy. Ok hmm, let's work Back rows, is that better? Feel like that's better? OK Alright, hmm. See you will have an exam this week. On Wednesday. We're still writing it. You're still studying for it. Hmm... Classes cancelled on Wednesday here. But there will be your review session in this place. So officially you don't have to come. But you know, you don't have to be here today, either. but... Here you are. And, by that point, we sort of expected we will be answering last-minute type questions. We may be announcing another review session sometime tomorrow, but I'm meeting with course staff this afternoon or this evening. So, we will let you know to make sure to advertise any additional review sessions, publicly.  Are there any questions about the exam, or the preparing for the exam, or? Yes?
Umm either or the question is what will be the form. Oh you mean Wednesday what will happen? So the intention will always be to answer student questions. Right? Thats the best case scenario. But a lot of times, we prepare to do that and student don't come with questions. So they fall back on the review papers.  No its not on the computer. The first exam will be very much like the previous exams. Though it is written by a new instructor so there is a bit more creativity involved here.  But we're on the same page. Mattics don't you say we're on the same page of what constitutes a reasonable exam. Not to put any pressure on your or anything. We can duke it out.  Oh yea right, that's right. Don't worry its ok. No thank you for asking that. So the exam is still written with the intention that it should take you that if you came in here you could take it during a single class hour.  In the old session, in the old way of doing things that is how it always was. You came and there was some high pressure moment of taking the exam during those 50 minutes and part of the score of based on if you could finish it during that time. I think those exams written for that were probably too long to being with. Probably its not true that the average student would take 50 minute to do our exam.  But I'm pretty sure we can get 90% finished in an hour and 15 minutes.  Does that make sense? But because we don't want time to be such a component of it we spread it out to three hours.  Two and a half officially but we're not going to leave until 10:30. Alright any questions  Its gonna be ok. I don't want you to feel like your life depends on this one time period.  Lets work shall we?  there is new stuff on the screen. Uhh these things, these little dotted graphs all have something in common. They have a common interface. Now raise your hand if you never felt a pez dispenser. Raise your hands if you never felt a pez dispenser. It is a cultural experience that you really should have. There is a very characteristic feel to a pez dispenser.  I should have brought more.  They usually don't yell at you! Alright, you can pass them around. I don't care. I want them back at the end of the hour but they could rotate around. Just to reinforce the idea that the pez dispenser as a candy dispenser Right? You put the candy in and you can only get the candy off the top. The top of the pez dispenser. This is a real problem if you have a multi-flavored stack of candy. It means in order to get to the purple down here, if you want the purple one you have to go through the top and pull them all off until you get down to the purple one. That make sense? The way I think of it is a constrained access structure.  Now in terms of data I'm going to describe it like this. It is a constrained access linear structure.
Where our data is going to exist in sequential positions somehow that is   there is a notion of what is the next piece of data or piece of candy there's this notion of next but we are only going to allow access to the data  where we want the end of the structure much it has dispenser any questions about that? alright so this is the kind of structure we are going to study next it is called stack and I'm going to show you quickly a couple applications that are different than the dispenser applicaiton ...sorry... okay so what application do i wanna do  well first of all i'm gonna use this as my source of diagram for how a stack is going to work in this context and as such im going to say the entrance to the structure is at the top okay?the entrance is at the top and i'll be placing data inside of it i guess there are other analogy you hear all the time the trays in the dining halls and I think the one I'm gonna do is  this sequence of function call because I find it kind of interesting ok we'll talk about other application latter  but i'm gonna start with this one so this is intended to be a sequence of functions inside a main so inside a main you study hard and you do good work but the process of studying hard means that you execute functions  MPs and Exams etc. okay? so this is a sequence of function calls  main calls study hard and do good work do good work calls these four functions in sequences is that clear how this code this pseudocode as diagram here ? okay we  we refer to the stack as stack memory  earlier long and this is what was really meant by that this is why that region of memory is called the stack okay? when function main executes when function main executes eh.. all of it's variable and parameters are set up on the stack and as they are on the stack they are entered into the stack and as they are on the stack we say that they are in scope  and execution passes then to study hard the second study hard is executed  it's variables and parameters study hard bars and params are set up on the stack on top of main effectively on top of mains in the process of executing studying hard, MPs are setup in the process of setting up MPs we have plans okay? and then right here the second the function plain completes execution  all of plains variables and parameters are removed from the stack or we say popped from the stack okay? any questions about that ? so we finished our first function here and then execution proceeds to the code function and all of  so plain is gone and now all of codes variables and parameters are put on the stack or pushed onto the stack  then code finishes execution and it is cleaned off then Mps finishes execution and they are popped from the stack and then we hit in course of execution exams  here we are  exams functions with all of it's variables and parameters are pushed on to the stack wingit ..all with good advice  pushed on the stack wingit complete execution so it is removed from the stack we finished the exam and look  we finished study hard, and now we precede to do good work DGW any questions about that? so you can see that memory is being reused as the execution transfers from one function to another  it is kind of easy to see how interpretation of memory location would get convoluted if you are not very careful to track of what your re doing
Where our data is going to exist in sequential position somehow, that is, there is a notion of what is the next piece of data or piece of candy. There's this notion of next. But we're only going to allow access to the data through one end of the structure, much like a pez dispenser. Ok any question about that? Alright So this is the kind of structure that we're going to study next called a stack. And I'm going to show you really quickly a couple applications that are that are different than the pez dispenser application. Ok so what application do I want to do? Well first of all I'm going to use this as sort of my diagram, the source of my diagram for how a stack is going to work in these contexts. And as such I'm going to say that the entrance to this structure is at the top, ok, the entrance to the structure is at the top. And I'm going to be placing data inside of it. I guess the other analogy we hear all the time is the trays in the dining hall. And I think the one I'm going to do is this sequence of function calls because I find it kind of interesting. Ok, we'll talk about maybe these other applications later, but I'm going to start with this one. So this is intended to be, this is intended to be a sequence of functions inside a main(). So inside of main() you studyHard() and you doGoodWork(), but the process of studyHard() means that you execute functions mps() and exams() etcetera. So this is the sequence of function calls. main() calls studyHard() and doGoodWork() doGoodWork() calls these four functions in sequence Is that clear how this code, this pseudocode is diagramed here? Ok, we used, we referred to the stack as stack memory earlier on, and this is what was really meant by that. This is why that region of memory is called the stack. When function main() executes, when function main() executes, all of its variables and parameters are set up on the stack. And as they are on the stack, they are entered into the stack, and as they are on the stack, we say that they are in scope. And execution passes then to studyHard(). The second that studyHard() is executed, its variables and parameters, studyHard()'s vars and params, are set up on the stack on top of main. Effectively on top of main In the process of executing studyHard(), mps()'s are set up In the process of setting up mps() we have plan() and then right here, the second that function plan() completes execution, all of plan()'s variables and parameters are removed from the stack. Or we say popped" from the stack. Any question about that? So we finished our first function here. And then execution proceeds to code(), the code() function. And all of, so plan is gone, and now all of code()'s variables and parameters are put on the stack, or pushed onto the stack. Then code() finishes execution and it's cleaned off. Then mps() finish execution, and they are popped from the stack. And then we hit in the course of execution, exams(). Oh, here we are. exams()'s function together with all of its variables and parameters are pushed onto the stack. Winging it, always good advice, pushed onto the stack. Winging it completes execution, so it's removed from the stack. We finished exams() Oh and look, we finished studyHard() And now we proceed to doGoodWork(), DGW Ok, any question about that So you can see that memory is being reused as the execution transfers from one function to another. And it's kind of easy to see how the interpretation of memory location would kind of get convoluted if you're not very careful to keep track of what you're doing.
Variables, variables and parameters, so this is main()'s variables and parameters all inside that box. Ok so the question is: what's in scope? The question is what's in scope. And the answer is everything on the stack is effectively in scope. And things go out of scope when they're removed from the stack. Ok this is just an example albeit a fairly, this is a superficial explanation of what goes on here. It's not the substance of this course to actually look at this in great detail. I believe that's a 241 topic to look at how that memory is actually used and allocated and what it looks like. This is a diagram for what happens. Alright similarly you've probably seen, you've probably noticed when you use a good editor, I'm going to change the type of my stack here, when you use a good editor, it keeps track of parenthesis for you. It keeps track of opening and closing parenthesis for you. The process of doing this goes something like this We are going to read this sequence of brackets and parenthesis left to right and you can imagine that there are other strings in between. But we're going to process this and our whole question is: is this a valid sequence of parenthesis and brackets and square brackets. Is this a valid sequence? The algorithm for checking is merely this. If you see a left bracket of any kind, push it onto the stack. If you see a right bracket of any kind, pair it with the top of the stack and pop off the left. Pop off the left. Alright lets do that really quickly here. So if you see a left bracket push it on the stack. I see a left. I see a left. If you see a right bracket pair it with the top of the stack. Do they match? Do these two match? Yes they do. So pop them off. And then we see a left. And then we see a right. They pair. Pop them off. Then we see a left. And another left, uh oh, and another left. I'm up to here. We see a left, I mean sorry, a right. It matches, so we pop. A right, it matches, so we pop. A left bracket, a left, a left, a right - it matches, etcetera. So the code for doing this is actually very very simple. If left bracket, push. If right bracket, pair and pop. About two lines, right? Lets move on here. Any questions about this? Boring? Sorry Alright. Let's write some code, that's always comforting right? Instead of talking lets write code. So stack is, we have an abstract data type that describes a stack. Here are the classic functions: push and pop. Push is our way of inserting data.
It is not called insert because it is not a generalized notion of inserting into the structure. We do not have the flexibility of putting the data wherever we want It has to go at one end of the linear structure. Similarly for pop, pop is a remove that it is not a generalized remove at all. It's going to give you a particular value from the stack that is the thing happens to be on top Now this is the interface or the abstract data types struct. You may see some modifications of this  For examples, sometimes pop does not actually return the value sometimes it just remove it sometimes there's an additional function called peek that allows you to look at the top value almost every implementations of stack i've ever seen has had a function that will tell you whether not the stack is empty and then you know possibly there are the big three depending on the implementation alright so three though are classic and part of the abstract data type now notice that that means we can use the structure now because if you write code like this you can tell at any given point what the data structure looks like so i mean this is just, i will warn you again if i go to this so i mean this is just, i will bore you of o go through this I'm going to push a three push an eight, push a four, do a pop and 4 is returned, do another pop and eight is returned  push a six, so right here the appearance of stack is like this, okay? any questions about that? alright, so do you feel like you understand how this thing works okay so know let's talk about this part, the elephant in the room how we gonna make this happen, how we gonna implement this it is a linear structure, it is the stack itself is a linear structure like I said the data there's a notion of the next one so that suggests particular implementations  what are some ideas, how could we implement this what kind of structure do we know about that we can use to support that interface  somebody raise their hands and have a conversation with me. nope? if i close my eyes and point to sombody? you 233333333 what are some ideas can we do I can use a linkedlist right very good  I can use a linkedlist  is that the only alternative? raise your hand if you were kind of wanting to suggest linkedlist  but you are glad I pointed him instead of you, okay? raise your hand if you might have another idea for implementaion could use an array right, so any time at this point anytime you have a linear structure that is a structure where your data falls right next to each other your two alternative consider  are linkedlist and array now the technical detail are yet to be discussed, we have not talked about if it is a dynamic or static array we have not talked about if it is a singly link or doubly link or crazily linkedlist? but nonetheless it is pretty easy to have a conversation about the two and in fact those are the two we gonna consider for this okay? any questions about that ? so just out of curiosity raise your hand if you think, well, if you prefer linkedlist your favorite choice is linkedlist here, raise your hand high, come on this is fun and raise your hand if your are sort of array-centric  if you'd rather use an array in this context look it is about fifty-fifty  there's no right answer here both of these are good options alright, so it turns out the first one i decided to talk about is a linkedlist and here's how we gonna implement it we are going to prepare a stack node  it should look pretty familiar to you, you've seen this before okay? and we gonna keep a hold on the stack be at the top that is we are just going to call that pointer that holds towards data on the top okay? hm.. and we are going to keep track of its size okay so just because it is a .. any questions about that part at all? okay is the constructor implemented there?  no it is not i'm going ahead and do this the stack top equals  null implements the constructor there size equals zero top equals null okay? I thinks that should leads to a question
Does that lead to a question? I didn't make a slide for the constructor of this thing. Is that ok with you? So there's the constructor. Just set the top equal to null. Is that okay? It's probably okay. Alright fine we'll talk about it in a second. Alright so I wrote the code for pushing onto the stack. It creates a new node and fixes up pointers. What I would like for you to do is write the code for pop okay? go ahead and take a couple seconds given this setup go ahead and write the code for pop. And I'm asking you to kinda get into this consecrated mode just because it's good practice. Force yourself to write a little bit of code in this contexet cause after all this is much safer than the exam moment. You don't have to check for empty. You can assume that we're not goning to let the client pop an empty stack so you don't have to check for empty here. Okay, did you write the same thing I did? Okay so what my plan was to grab hold of the top here, grab hold of the top via a temporary pointer, move the top down so that it points down to the next one, and then delete the first node. Oh oh totally screwed up right. Do you see what I aww... No problem. Okay I totally screwed up. Do you see what I screwed up? Yeah? Thats right I have to have a return value, not only that I need to grab that return value, so I better have a declaration. My very first line should be stack item type returnval. = top's data right? Oh boy. Okay. I'm not going to make it that messy so stack item type returnval = top's data should go first, I'm sorry, and then return returnval. Okay a couple different ways of doing that the second you have a hold of it you can get it. Okay sorry about that. Any other questions about it? Okay yeah? You'll need to what? I did I updated the top, I moved it forward. Okay, alright so this is fairly simple, no problem here especially if you don't have to check to see if it's empty. Yes? Oh very good. Size minus minus. Okay good. Boy.
Any other questions about it? I am so glad that you guys are here. Debug my code. Wouldn't it be good if we can code like this all the time? It's pair programming taken to the extreme. Alright. Fine. So there is one thing I wanna say about the interface. I made a simplifying statement and that is, you don't have to worry about popping an empty stack. If effectively, I mean, in fact, you probably should write code that is a little bit defensive to that. You should have an exception handled here. But we are not in a business of doing that. And moreover, in this class, and moreover, the fact that we gave the client the capability of checking to see whether there's an empty stack. The fact that we created this empty function means we can say, Ho, dude, that your responsibility." You have to check, to the client, you have to check, whether or not this is empty. I made no promises if you tried to pop an empty stack, Ok? So, providing a functionality to the client for checking for empty is kind of our way of saying that it's the client's responsibility to do so. OK And this is it. This is about the simplest guess in terms of the implementation. And I thought you would ask, don't we want to use a sentinel node?" And the answer is no, we don't need a sentinel node here because all of our insertions and deletions are happening in that first spot." Right? We don't need to worry about the general case. In this case. So sentinel node is just sort of a waste of time here. Makes for more complex code. OK. So let's take about the array-base implement for a minute. OK. So the interface is the same. We are going to be implementing push and pop and, you know, empty just returns a boolean value referencing sending whether or not the size is zero. So that's easy. Here is the constructor I don't know which order I may wanna talk about this. OK So in this case, I've gotten an item's poin... I have items which is an SIT pointer. And because we are implementing this as an array, you recognize this is just a dynamic array. Right? This is just a dynamic array. Now size here, is intended to be the number of elements in the stack. Capacity is the number that our stack can hold. So this is... Capacity is capacity. Size is size. Right? Capacity is, the number we can hold. And size is the number we are currently holding, or the number we do hold. OK. Any question about that? Yeah? Ah, do we wanna make capacity constant. So this is the moment. This is the moment where, we actually begin to discuss what it means to have a dynamic array. Because if we did not allow, for the the array to have variable size, then that would present a huge drawback over using a linked list, right? And so now it is the time we are actually going to first exploit the fact that it is a dynamic array. OK? Any question about that? So it is exactly the right comment. Alright. So this is going to be a dynamic array. Capacity is deliberately not going to be something fixed. We are going to allow it to vary. Alright. So what does the constructor do? It makes... It starts off with an array of size four. Arbitraryly chosen. Could 've been one. Probably couldn't be zero though. That would not be accepted probably? And then it allocates the memory. So now, effectively, after this thing is constructed, we are dealing with an array of size four. Any time we push onto it, we're going to check to see whether or not the size is greater than or equal to the capacity. That is, is the array full? Is the array......full? And if it is, we are going to grow the array somehow. Oh, that's new. That's what we are gonna talk about the whole rest of the day. OK, we are going to grow the array somehow. And then, we are going to enter in the element that we want and increment the size. What does the code look like? for pop? What does the code look like for pop?
yeah right we have to return the value or grab this value for returning and then decrement the size, and that is it.  so pop pieces of cake    alright now let's talk about this issue of growing the array somehow okay so this discussion we are about to have apply not just for stack but also for queue any linear structure that uses dynamic array list 2 I just obfuscated it for list.  I said we are not gonna talk about it Umm, so here is the scheme suppose your array is full and another piece of data comes along okÂ  the idea is going to be that we are going to allocate some new spaces copy over the data from the old spaces yeah, copy the data the data from the old spaces and then insert the new spaces in its position in the larger array and then of course, you know, free up the old space and then rename the new spaces okay? do you like this ok that whole copy the data thing Laaaa that should make you crench right? copy the data ouch that hurts so our goal is to make the copy the data something that is rare our goal is to make it rare and somehow still make it so that we can accommodate flexible data size so how do we do this resizing? let's look at three different options, ok? so for simplexity, all of these resizing schemes are going to start with an array of array of size one then go build from there. so we are always gonna start with an array of size one, after it fills, we will do copying more over in analyzing these particular resizing schemes we only really gonna care about the copying that happens the inserting new data would have to happen anyways so it is sort of the extra work that we are gonna count for alright so lets say that our resizing scheme says well if new data comes along, if your array is full, and new data comes along it supposes to look like a person, did you get that, can you tell? so if your array is full and new data comes along then what you are gonna do is to make an array just big enough just big enough, then copy and insert that is the first scheme and the question is: how does this scheme do over a sequence of say n pushes to the structure so this bottom row is supposed to be, supposed to indicate n ok, alright, lets look at this in the first case, one thing gets copied in the second case, two things get copied. in the third case, three things get copied so we can write the expression that captures the amount of copying
it is 1+2+3+ all the way up to how far  n - 1 right okay and then I don't know about you, but I prefer to write this like this: k = 1 to n -1 of k because that reminds me of the sum, that reminds me of a result what is that sum? what is that sum? the closed form is : n (n-1) / 2 right? so here is how to calibrate this. ok? here is how to calibrate this, if you miss defined, you should get your calculus book and look this up, ok? If you are like, oh yeahhhh, I known that before in my life then you should get a 3 by 5 card and write that sum and put that on your mirror so that it get into your subconscious that is where it should live for you that sum right there should live like oh yeah, like yeah, I got it, ok?Â  it is ok if it doesnt yet because somebody, nobody else might told you that it should live there yet but it should alright, any question about that? ok, so for us we are concerned with asymptotic results so this is your , this is your index card if you dont have it we are concerned with the asymptotic results and as you would have learned in your discrete math classes this function grows like n square the laregest degree term is n square but remember this is n square over n push to the structure so we can just divide through by n so big O of (n^2) / n pushes implies an average of big O of N per push ok, which would kind of make sense because you are doing a lot of copy every time a new piece of data come in does this make you smile or frown is this good news of bad news this is really bad news ok that is a frown face and the question is can we do better? so let's try to do better instead of just making , um instead of just making the array big enough to handle one more piece of data what we are going to do is make it big enough to handle some fixed amount more data ok, we will call this c so if three and four full fill here dont put these here if three and four fill the array and 6 comes along, then what we would do is copy three and four, insert 6 and then we get a freebie right?  one more piece of data could come along and we wouldn't have to encoure any additional copying cost, and in fact in general  if you allow a fix number, say c of additional spaces then c - 1 free copy happen in the future, free insert in the future does that make sense? so let's see how this does in term of asymptotic running time do you have an instinct how well it does? yeah this one is gonna be a sad face too, this one is also going to be n square umm, should we do the analysis? probably ok, so umm, in general we are looking at blocks of size constant, some constant in the picture it is two and the amount of copying that happenes is some constant , i mean sorry some , Â oops
I'm gonna put a little question mark up there, we'll talk about it. Is k times the size of that block. It's k times the size of that block. Once for every-- so, you know , here's where k equals one, here's where k equals two, here's where k equals three, et cetera, we have n pieces of data. Now the qeustion is, how many of these-- how many times do we have to do this copying? Yeah, n divided by c and it turns out, minus one. So the top of this sum then is n over c and then there's this nasty minus one there because we're not counting what happens in the last case. Alright, well I know how to deal with sums like this. c factors out, and then you've got k equals one to n over c minus one of k. And that's just c times n over c times n over c minus one over two, and that's still big O of n squared over n pushes. Okay. Last one. What else could we do? This time, well take a look at the picture. What's our scheme here? Double the array every time. And this is what I believe you were asked to implement in MP2, right? And this is why. I believe, was that right? In MP2 did you implement a doubling of the array? Really? Okay, nevermind, maybe I don't remember. Okay, so suppose the thing filled, and new data came along. Our scheme is to take however big it is now and double the size, okay? So here's copying and here's inserting a new one. If a new piece of data comes along, double the size, insert the new data and now we've got a freebie, right? New data can come along and no additional copying is invoked. And when you get to this level, it becomes significant. There's copying, but then look at how many free inserts you get. Now, we want to analyze this in much the same way as we did the previous example. That is, we want to look at the amount of copying per copying event and sum that up over all of the copying events, okay?  So, let's see. It looks like we're going to go from k equals zero to I don't know yet, we'll talk about it in a minute. How much copying do we do every time? How much copying do we do every time? Somebody raise their hand and tell me the expression. Yeah? Yeah, good. Uh oh. What a mess. Okay. So, it's-- Two to the k, good. And how many of them do we have? How many of these things do we have?
Here is my hint. This is n.  And effectively, if you count, you're counting the number of times you can take n and divide it by half. How do you express that yea? Log based 2^n. Log is basically log b and number of times you can divide by b. That is the piece that should be internal. It turns out that this is. Oh, Log based 2 of n there is this minus one. We're not doing this in a row. Not counting it for the last row. Ok! Here let me ask you this. K equals 0 to 2 to the n equals what? I'll make this a T to make it less confusing. Whats that back pocket sum? It is 2 to the t plus one minus 1 divided by 2 to the minus one.  Two to the log based n two of n minus 1 over one. Or N minus one good.  N minus one copying. N minus one additional work. So how does this scheme do on a sequence of n pushes? It incurs big O of n work or n pushes or big O of 1 per push.  So on average, the additional work is just a little bit. Just a constant. OK? Alright I'll see you friday. 
There is only static here the mic was not working
(no audio)
(no audio)
[No Sound]
Hello I really hope I can listen to some kind sound here But I only see an indian guy's head Sorry Hand not head
(no audio)
[Silence]
[Video Playing] Operator+() overloading [Midterm 1 Review]
Okay, let's work Â Okay, I know it's October It got cold, that's right Last time I saw you it was before you had an exam Now it's after you had an exam Our intention is to return those papers to you next week in section So, go to the section that you wrote on the exam, cause that's where we're gonna be intending to return it Did we define? We didn't.. Oh, this is our flaw This is the flaw with the system Right, big news! Huge changes this semester We're actually scanning your exam There we go You'll get your scores back via email It was me, not you! Okay And our intention is to have those back to you by the time sections meet next week So that we can give you averages and discuss the exam in that context Let's see, MP3 is still due Tomorrow night Today night, I'm a mess No, I'm sorry, no, no, no, but you said! IÂ meant tomorrow relative to yesterday
So I apologize. It's definitely due tonight, the other thing that's going on in this window of time, I don't know what window it is exactly, but if you go into Siebel Center, it is filled with people, most notably alums. So yes, it's all their companies and stuff like that, but the cool thing for me is that it's people who were sitting in your seat just a few years ago.Â  So they're doing the recruiting thing and you're nervous about talking to them, but they're just like you, just a couple years farther on. So, be inspired by them, enjoy talking to them, don't be nervous talking to them, because we can break the chain of nervousness. They are, really, take it from me, I've known them and I know you, they're just like you. Maybe not even quite as smart. I'm just kidding. There's a million different definitions of smart, so when I say that I don't even know what I mean. Should I stop talking? Yes, yes. Okay. Last time we were talking about a new abstract data type called a stack. We're going to finish up that discussion today, and also complete discussion of another data type called a queue, that's right. So it turns out that stacks and queues are lumped together in almost every data structures book ever written. And the reason for that is because they're both constrained access linear structures. And a lot of the implementation issues that we talk about are the same between the two of them. What's very different about the two of them is their applications. So as we go on through the semester we'll see applications of each of them and we'll be pretty careful to distinguish one from the other in those contexts. Notably, MP4 helps you see some differences between them, how they work in the different application. Alright. So we were implementing a stack with an array, and I wanted to just ask you to revisit that. I understand that this is completely warm-up, but frankly, I need a warm-up. You might not, but I do. So, um, the stack had the following public interface, or abstract data type, both of those are sort of interchangable in terms of expression The function push" which is a specialized notion of inserting into the structure and the notion of "pop" which is a specialized notion of removing something from the structure. It's a linear structure that is the data, that is, the data is all lined up, in our understanding of that data not necessarily in memory, but you know, we can sort of think of it as being lined up in memory. As such, when we insert and remove from this linear structure, we're going to take advantage of this idea of the data being next to each other. Specifically when we push onto the stack, so pretend 8 wasn't there, we're going to push it onto the stack, the notion of next is generated there. Because the next data after 8 (8 becomes the first data element then), the next data element is 6, and the next one for 6 is 3, and the next one for 3 is oh, I don't know, nothing. There is no next one for 3, 3 is the end. Okay, so this idea of a next element is what creates this linearity in the structure itself. Similarly, when we pop from the stack, or when we remove elements from the stack, we exploit this notion of next, because standing behind this 8 ready to take its place is a value just sitting there, the next value takes its place. When 8 is removed. Alright, for the details of an array-based implementation, you take a look at the data contained in the private section and you see I'm going to start at the bottom. What is this? Not literally, but what does it mean? It's a dynamic array, good, we'll talk about that in a second, what's this one, what does it communicate?
I went to San Louise in Tuesday I am sorry You have a exam Yeah I am grateful for that freedom I couldn't done this last semster I was just completely screwed up I've apologizedÂ  it is definitely due tonight  The other thing that is going on in this window time  I don't what window Â is exactly but, I go over the siebel center, it is filled with people umm most notably alum so yes it's all the companies and stuff like that but the cool thing for me is that is people were sitting in your seat just a few years ago so they are actually yes they are known doing the recruiting thing and your are nervous about that talking to them but they are just like you just a couple years a around so be inspired by them   start to talk with them don't be nervous about talking to them because we can break the chain of nervous they are really, were taken for me they were known and I know you, they were just like you  maybe not even quite as smart I am just kindding There is a million of definitions of smart so when I said that I don't even know what I mean should I stop talking yes yes okay Last time, we were talking about a new abstraction data type called a stack we are gonna finish up that discussion today and also complete discussion of another abstract data type called a queue that's right it turns out that stacks and queues are longed together In almost every data structure book ever written  and the reason for that is there are both contained access linear data structure and a lot of implementation issue are the same between the two of them  what's very different about the two are their application so as we go on through this semester we will see application of each of them notably MP4 helps you see the difference  how to see the context of one application alright when we were implementing a stack with an array and I wanted to just ask you to revisit that I understand this is completely warm up Frankly, I need a warm up\ you might but i do so umm the stack has the following the public interface or abstract data type both of those are sort of interchaneble in terms of expression the function push which is a specialize notation inserting into a structure and the notion of pop()  which is specialized notion of removing something the structure  it's a linear structure that is the data is all line up  in our understanding of that data not necessarily in memory we can sort of think of it in line up in memory and as such when we insert and remoce and can take advantage of this idea of the data being next to each other specifically, when we push onto the stack so pretend it wasn't there the notation of next is generated there the next data after eight, eight becomes a first data element then the next data element  the next data element is six and the next data element for six is three and the next one for three is ohh I don't know there is no next one for three, three is the end so this idea is for next element is what create this is already in the structure  Similarly, when we pop() from the stack or when we remove elements from the stack we exploit this notion of next  because standing behind this eight ready to take its place is a value just sitting there next value takes its clicks  when eight is removed  for the details of a array based implemention  we take over the data section the data take over the private section and you see I am gonna start at the bottom   what is this not literally but it means it is dynamic array good we will talk about that in a second what about this one what does it communicate
Stacks and queues are lumped together in almost every data structure for most every written and the reason for that cause the most constrain access linear structure 
How many items are on the stack? Probably one way of saying it was this one. Size of the array. That's right. Or how many items could be on the stack. Ok, good. So we completely understand this implementation. Let's look at the function themselves. The way we have this set up, is so that the bottom of the stack in the array is at the front, or in position zero in the array. Okay, now, think about what that means. It means that,  position sizes will alwasys be one past the end of the data. Yes? Alright, so if you are gonna push something on, where are you gonna push it? In to postion size, that's where you gonna push it, and then you increment size. So size becomes an indicator for the top of the stack.  It is the location for the top of the stack or one path. So it indicates,  top of stack. Any question about that? Is that clear? Okay. That's what this push code does. Except for this part. Which is what we gonna talk about in a second. Let's talk about pop for just a second. Before we go on. Notice that pop returns the value ont he top of the stack, and then moves the top of the stack. What am I going to fill in here, the retun value, the thing that we are gonna return, lives where?  Make sure you can answer this, make sure you can answer it. Where does it live? Size minus one, that's right. The one before the sizeof() elements. What's missing there? I left the line, what's missing there? Decrementing size. Very good. Notice that simultaneously, I wrote code that says decrement the size. But what's really happenning is, I move the top of the stack down, the top of the stack is being moved down. Any question about any of that? I had quesitons for you. What's the running time of this thing? Running time of this one? Constant time? Absolutely. How about the running time of that one if you ignore the blue circle thing? The running time of this one if you ignore the blue circle thing, is also constant time Now that blue circle thing, the blue topological circle, is topologically a circle. is a source for concerns. I am gonna spend the next slide, alieviating your concerns of the cause of growing the array. So we spent a good portion of time last time. Deciding on an algorithm of growing the array. And the analysis that we did, let us to dispicture. I'm gonna remind you. Our staring position is with in a array of size one. We put data into it bacause we can and it causes us almost nothing. But we have a problem when new data comes along. At that point, the algorithm is to, I'm gonna put a little dot by it. What does that dot mean? I'll use a word allocate". You finish the sentense. Somebody raise their hand. Allocate... Please. Yes? A new array? Good. How big? Double the size. Twice as big. That's right. So we gonna allocate a new array, twice as big and then the bad news is we copy the data into it. That's right. We gonna  take this data element and copy it, and now, the cool part is now there is nice space for out new data. Hey that's our algorithm. I'm gonna pretend that we did that for a while. And look what happen when this array is full and new data comes along. Okay? The algorithm was, allocate new space, copy data. I am doing this so it reenforce that you have to wait a long time. For me to even copy that data, right?
And then we place the new data element in and now, here's the beautiful moment. Look at this. Look at how much keys we have bought ourselves. We don't have to worry about new data. We don't have to worry about new data arriving for this long. That's a super long time right? In fact, it's almost as much data as we already had in the limit. We are effectively buying our selves relaxation in proportion to this stressful copying, okay? Does it make sense to you? You know what I'm saying there? You know..bring it on, bring more data. I got no problem. I got space for a really long time. Questions about it? Yeah? I'm gonna address that in just a minute okay? Iâm gonna address that. I have a whole slide about it. Alright, we're specifically talking about an array, and how we're using an array here. Okay, so think about what this means. It means that, umm, where should I start this... Oh, I will start it here.  It means that we got fast fast fast fast fast, right? All that, no waiting, perfectly fine. And then, when something comes alone here, we've got.... Waiting time for data to be copied And then, things move fast again, right? So imagine what this means in the algorithm. It means over the course of your use of your stack, sometimes things are going great. No problem and sometimes you have to wait a little bit. Now anytime you don't have the same thing going on. Each time it becomes more complex to analyze. So what we are gonna do is to add up all the data we insert and items. We're gonna look at all the data that we insert and items. And we're also gonna look at the amount of time that we spend waiting over that time. And it turns out, if you look at the amount of time that you spend waiting, you get wait time on the order of N. Or constant time on average per push. So it's a rare long wait. So the punch line is, its order n for n pushes and the analysis of that comes from last time is a geometric sum which means O(n)/n and you can go back and look at your discrete math and homeworks for proving this, that this is O(1) per push. on average We admit some of them are gonna be long but on average. It's just like you are paying a little bit more for each one of them. Some of them are gonna go faster. Few of them are gonna go way slower. Okay any questions about that? Who else raise their hand? You are number 2 in the queue. (Can't hear) Umm it doesn't matter. I mean doubling is really easy. Oh you mean non-one? Oh it turns out that won't make a lot of difference, unless your stack is on average much shorter than the small ones you start off with. So if you have reason to believe your stack is likely to be pretty short, then yes. Any other questions?
and then we place the new data element in and now here's the beautiful moment look at this, look at how much keys we have bought ourselves we don't have to worry about new data, we don't have to worry about new data arriving for this long that's a super long time, right? in fact, it almost does much data as we already had in the limit you know, we are effectively buying ourselves relaxation in proportion to.. this, you know this stressful copy, okay? does that make sense to what i'm saying there?  that look, you know? bring it on, bring more data, I've got no problem, I've got faithful for a really long time question about it? Yeah? oh i'm gonna address that in just a minute, okay? i'm address that, I have a whole slide about it. okay? Alright, so we're specifically talking about an array and why and how we're using an array here Okay, so think about what this means, it means that... where should I start this.. oh, I'll start it here, it means that we've got fast....... right? all of that, no waiting, perfectly fine and then.. when something comes along here, we've got, waiting time for data to be copied and then, thing right? so imagine, imagine what this means in the algorithm it means over the course of your use of stack, sometime things are going green right? no problem and sometime you have to wait a little bit now, anytime, you don't have the same thing going on each time, it may becomes more complex to analyze so what we're gonna do is we're gonna add full of data we insert right and items okay, we're gonna look at all of the data that we insert and items and then we're gonna also look at the amount of time we spend waiting over that time and it turns out that if you look at the amount of time you spend waiting you get, waiting on the order of n, or constant time on average per push, okay? does that make sense to you? so it's a rare long wait alright, so the punch line is, it's order n or n pushes and the analysis of that comes from last time, was a.. geometric sum? I believe, just a little geometric sum which means big O of n over n, then you know you can you can go back and look at your discrete math homeworks for proofing this.... that this is big o of 1 per push on average.. we admit some of homework are gonna be long, but on average it's just it's like you're paying a little bit more for each one of them some of them are gonna go faster, few of them are gonna go the way slower okay? alright, any question about that? yes? who else raise their hand, you're number two in the queue yeah, go it doesn't matter, no, I mean doubling is really easy, so start off with one oh, you mean non one? oh yeah, that.. it turns out that isn't gonna make a whole lot of difference unless your stack is on average much shorter than the small one you start off with so, if you have reason to believe that your stack is likely to be pretty short then, you know, yes, that's.. okay, the other question..
And then we place the data elements in and now, here's the beautiful moment. look at this! look at how much piece we have bought ourselves. Â es we don't have to worry about new data we don't have to worry about new data for this long that is a super long time,right? In fact, it is almost as much data as we already have  in the limit, you know, we are effectively buying ourselves relaxation in proportion to this, stressful copying.  Okay? does this make sense to you? see what i'm saying there? that, look, you know, bring it on,bring more data,I get no problem I've got space for it for a really long time. questions about it? yeah? Alright. oh,I'm gonna address that in just a minute. okay? I'm gonna address, I have a whole slide about it okay?alright. So we are specifically talking about an array and what, and how we're using an array here. okay. So, think about what this means. It means that, uh... where should I start this oh i would started here. It means that, we've got, fast,fast,fast,fast,fast,fast,fast right?all that.  no waiting. perfectly fine and then. when, something comes along here. we've got waiting time.... for data to be copied... and then things move fast again,right? So imagine, imagine what this mean in the algorithm. It means over the course of your use of stack. Sometimes things are going great.RIght? .no problem and sometimes you have to wait a little bit. now, anytime you don't have the same thing going on each time ,it becomes  more complex to analyze. so what we're gonna do is we're gonna add up all the data that we insert, right? n items. okay we are gonna look at all the data that we insert, n items. And then we are also gonna look at the amount of time that we spend waiting over that time and it turns out that if you look at the amount of time you spend with waiting you get,wait time on the order of n or constant time on average per push does that make sense to you? So, it's a rare long wait. alright So, the punch line is, it's order-n or n-pushes and the analysis of that comes from last time geometric sum I believe? just a little geometric sum? which means. big-O of n over n and you can go back and look at your discrete math uh, homework for proving this that is Big-O of 1 per push on average we admit some of them are gonna be long but on average it's just it's like you are paying a little bit more for each one of them. some of them are going to go faster a few of them are going to go way slower okay? alright, any questions about that? yes [joyful laughter ] who else raise their hands? you are number 2 in the queue. [students got the joke ] yeah you go uh, it doesn't matter.  no, i mean double link is really easy so, start off from  oh, you mean non-1? oh yeah, it turns out that that doesn't gonna make a whole lot of difference unless you stack is on average much shorter than the small one that you start off with. so, if you have reason to believe that your stack is likely to be pretty short,then you know, yes ok the other question
[Video Playing] And then we place the new data element in. And now here is the beautiful moment. Look at this. Look at how much piece we have bought ourselves. We don't have to worry about new data. We don't have to worry about new data arriving through this long. That is a super long time. Right? In fact, it is almost this much data as we already have in the limit. We are effectively buying ourselves relaxation in proportion to this, you know, stressful copying. Okay? Is that make sense to you what I am saying there? Look. You know. Bring it on. Bring more data. I've got no problem. I've got space for it. Questions about it? Yeah?  Oh I am gonna address that in just a minute, okay? I am gonna address that. I have a whole slide about it, okay? Alright. So we are specifically talking about an array and why and how we are using an array here. Okay. So, think about what this means. It means that, Uh, where should I start this. Oh, I will start here. It means that we've got fast, fast, fast, fast, fast, fast, fast, fast, right? All that, no waiting. Perfectly fine. And then, when something comes along here. We've got waiting time for data to be copied. And then, things move fast again, right? So imagine, imagine what this means in the algorithm. It means over the course of your use of your stack. Sometimes things are going great. Right? No problem and sometimes you have to wait a little bit. Now any time, you don't have the same thing going on each time becoming complex. So what we are gonna do, is we are gonna add up that we insert, right, n items. Okay, we are gonna also look at the amount of time that we spend waiting over that time. And it turns out, that if you at the amount of time you spend waiting. You will get wait time on the order of n. Or constant time on average per push. Okay? Is that make sense to you ? So, It is a rare long wait. Alright. So the punch line is its order n for n pushes. The analysis of that comes from last time was a geometric sum. I believe. Just a little geometric sum, which means big O over n. And you know you can go back to look at your discrete math. homework for proving this. That this is bigO of 1 per push. On average, we admit some of them are gonna be long, but on average, It is just like you are paying a little bit more for each one of them.  Some of them are gonna go faster. A few of them are gonna go way slower. Okay? Alright. Any questions about thatï¼ Yes. Who else raise their hands? You are number 2 in the queue. Yeah, go.  It does't matter. I mean doubling is really easy. So start of looking at one. Oh you mean non-one? Oh yeah. That it turns out that it is not gonna make a whole lot of different. Unless, you stack is on average much shorter than the small one you start off with. So if you have to believe that you stack is likely to be short, then, you know, yes. Okay, the other question.
Very good, so you really really really want me to contrast to the linkedlist implementation I'm fully intending to do that but there's one more point I want to make before we get there, okay? Yes? Clear the heck out to here! Yeah? Yep That is exactly the point that I want to make Alright So imagine that we build this thing up We push a whole ton of stuff on our stack Way out to here, it's huge And all of the sudden we decide, oh, we're just gonna pull things off the stack Then we've got this array, maybe we push a few on here And, do that a while and eventually we get down here and our stack goes for ten year Just right in here, but we've allocated all this space That's a problem Is that what you're asking? That's his complaint What do you think? Yeah? Very good, exactly We're not gonna do the details of this Suffice to say, all of the same arguments hold in the process of resizing down I like the word I'll use it forever Resizing downward and in fact the accepted, the practical accepted mechanism  is to take it down when you're less that a fourth full If this array got down to here If this stack got down to about here We would resize it back to this size And, it turns out that the math involved in the analysis is exactly the same You're gonna be adding up a geometric sum and, you know what the argument you can make then is that you're never using more four times as much space as you need You're never using more four times as much space as you need and that's constant Does that answer your concern? Good, okay Good Yes? Yep Yep Yeah, very, very, good, very good That's right, so but, look what we've done We said we're gonna shrink it Down to here Right? We're gonna shrink it down to here The next thing we're gonna do when this thing... no, sorry We're gonna shrink this array, I'm talking about this example We're gonna shrink it when the data gets down to here So that means all of this Is available for your back and fourthiness Right? Because I'm not gonna resize up to this one again Until I get to this one Does that make sense? Am I pointing to the right things to make that clear? Yeah? And it turns out in the analysis, we did it carefully Allowing for that much of a slosh is good enough to prevent the behavior you're observing So in practice this is what we do Alright, any other questions about this? Actually the analyses hold whether you double it, triple it, go down by thirds, etc. But you have to use constant fractions or constant factors every time Alright, questions?  You good? Okay So lets talk about this, the elephant in the room Why are we even discussing an array based implementation when we can make the argument directly That we get constant time push and pop Remember, push and pop can occur in front of a linked list in constant time Just allocate a little bit of memeory Update some pointers, and we're good to go Oh, maybe I'm just lying to them, maybe I really should go test this out So I implemented, I did it in the context of a queue So I implemented a queue instead and added a whole bunch of data to it And did about a million operations on it And compared that with the same interface, the same test case, implemented using linked memory and  the queue, the array based implementation...
Despite the copying was ten times faster so, that right there is the benefit of using arrays assuming that they don't have poor cache-ing behavior which we learn about it in different class arrays win every single time if you can think of a clever way of implementing something using an array, do it. Alright, but the analysis here is array based implementation of stack to constant time pop it's a constant time push if capacity the cost over n pushes is big O of n for an average of big O of one per push when you take the algorithms course, cs 374, instead of calling this average, they are going to call it amortise analysis just an issue of, they have a different use of the word average" they are taking an average over different probability space it's okay for us to call this average in this context. So why consider an array? it's faster, duh That's just because of the way system handles memory allocation. Alright, any questions about it? Let's talk about Queue, YAYYY So this is a Stack, it's linear, constrained access. Often times people will refer to a Stack as a Last In First Out. Linear structure They might even refer to it as Last in First out Queue we're not gonna be so ambiguous about this. For us, we're going to say the term Queue, for a First In First Out structure. Now I cannot go forward without making this point I can never remember whether this is first in first out like whether the colloquial description of a Queue is first in first out, or last in last out.  And I like this form better, I don't know why But I think that the world imagines that you'll say this one, I don't know. Doesn't matter. So how does a Queue work? It's profoundly fair it's the way you line up in the dining halls are your dining halls cafeteria style or buffet style? Buffet? Oh maybe you still have to line up for buffet. We don't have to talk about this very much. Probably more interesting use of the Queue is to line up events in some time-driven application like a video game for example and there is an explicit event Queue in math case, so that means probably a little more useful if you are not hungry. What is the Queue ADT? There are different ways of specifying it, the language we are gonna use is Enqueue. We are gonna enqueue an item. Dequeue will return an item of some kind, and then we're gonna have this boolean function that allows client to detect whether or not the Queue is empty. There by freeing us of the responsibility including that code. Any question about it?
...was ten times faster. So that right there is the benefit of using arrays, assuming they all are going, you know, they don't have poor hashing behavior which you'll learn about in a different class. Arrays win every single time. If you can think of a clever way of implementing something using an array, do it. Okay? All right! Uh, but the analysis here is array-based implementation of a stack is a constant time pop, is a constant time push if there's capacity. Uh, the cost over n pushes is big O of n for an average of big O of one per push. When you take the, um, algorithms course, uh, CS 374, instead of calling this average, they're going to call it amortized analysis. Um, it's just an issue of, they have a different use of the word 'average'. They're taking an average over a different probability space. It's okay for us to call this average in this context. All right! So why consider an array? Heh. It's faster, duh. And, um, and that's just because the way the system handles memory allocation. All right! Any question about it? Okay, let's talk about a queue. Yea! Uh, so this is a stack. Um, it's cons- it's linear constrained access. Often times people will refer to a stack as a last-in-first-out linear structure, linear structure. Okay. They might even refer to it as a last-in-first-out queue. Ah! Okay, we're not going to be so ambiguous about this. For us, we're going to say the term queue for a first-in-first-out structure. Now I cannot- I can't go forward without making this point. I can never remember whether this is first-in-first-out, like whether the colloquial, um, the colloquial description of a queue is first-in-first-out or last-in-last-out. And I like this one better. I don't know why. LILO, right? Um, but I-I think that the world imagines you'll say this one. I don't know. It doesn't matter, right? They're the same. Okay! So how does the queue work? It's fair. It's profoundly fair. It's the way you line up in the dining halls, right? Oh wait. Do you- are your dining halls cafeteria style or buffet style? Buffet? Oh, maybe you'll still have to line up for a buffet. We don't have to talk about this very much. Uh, probably a more interesting use of a queue is to line up events in some time-driven application like a video game for example. Um, and if- and there is an explicit event queue in that case. So that means probably a little more, uh, useful if you're not hungry. Okay! So what is the queue ADT? There are different ways of specifying it. The language we are going to use is enqueue and we're going to enqueue an item. Dequeue will return an item of some kind. And then we're going to have this boolean function that allows the client to detect whether or not, uh, the queue is empty, thereby freeing us of the responsibility of including that code. Okay? Any question about it?
What do you think the next thing what we will going to do? We talked about the abstract data type. What is the next thing what we will going to do? We are talking about the implementation that's right. So how think our choices are for implementing a queue. We are implementing using a .... an array...or...a linked list. It feels deja vu. Right ok. We used an array or linked list to see how it plays out. Its a surprise for me for the first things what are we talking about. Oh yeah I love it. (Queue) So we are going to set up a linked memory base implementation and I am playing a game with you. I assert that we only need a linked list to do this because after all you keep blowing in one away for a queue.  In addition to the head, holding on to the linked list. I am giving you another pointer at the tail. And that tail is going to point directly to the last element. We are not going to mess with sentimals in this content.  The tail is going to point directly to the last element.  I want to know from you is which of these pointers first is entry to the queue and which of them is exit from the queue? Which of them is entry to the queue and which of them is exit?  I am asking you which one is the head. I will be question you about where is entry or exit from the queue? Ok.  When are you ready with your answer, put your head in your head. Ok. Right.  Alright. So raise your hand if you think that is the entry to the queue. The head of entry is the queue. Ok...Everybody see. And raise your hand if you think the head is the exit from the queue. Ok. Good. So there is a bit of disagreement here. Right.  The disagreement arises because of way the arrow is making you think. Ok. Because you think Oh look, those arrows tell the person where to go through this process. But think about it. Let's think about what we will have to do if this is the exit. Ok.  If that last element is the exit, how are we going to do it. What is that code look like? What is the code look like? You got to get the hold of this guy right. You need a pointer to that know right before. How much does it cost you? Big O of n. Ok so, um that's too expensive. You can do better. Ok. Let me summarize it first. Um so a tail exit is a induces-I think is right word-a linear time Big O of n a reset of the tail pointer. Ok. Can we do better? Removing this one taking that in the front. Sure. So, the exit needs to be the head all this means the head is the exit.
all right any questions about it oh yeah this only apply to a singly list I know. I just want to think okay plus who wants to keep track of all those the extra pointers when we don't have to  just gonna meaning you have bugs ok ?all right  let's see so what's running time of enqueue then constant time if we set it up wisely oh no it's dequeue either way so constant time either way wants running time of dequeue constant time if we are careful all right and that all I am going to say about the link list implementation of a queue. It's that ok I am assuming in this point you can write that code because it just about like insert that front Right? Yes? so this is a queue so the entry point is the opposite of what you chose for exit so we have to be careful with exit and entry is the other one now what you might asking about or what is an relevant question is what if you have some structure that allows entry and exit at either end and that called a deck or double ended queue and it's a real thing I mean it's like I think this is a perfect test question because it something that we don't spend a lot of time on but is perfectly with in your grass in terms of reasoning about how you should implementd so that issue that you bring up even through you didn't intended is actually dreaming. all right any other questions about this yes I am in the through that the quad ok? cause it a great question ok so the question is if we all command our structure if we all command our structure and the choice of ink color is a glue if we all command our structure with a tail before tail yeah we love thursday not thursday  if we all command with that do we limit the problem we have having to ret the tail pointer well we do but then we have a problem because we have  to reset the through by thursday pointer right? so so yeah it's also went a problem that it create another all right any questions about it ok let's see so the array based implementation of the queue given touch with the array based implementation of the queue I do know what I was gonna to say about it okay any question about the set up here, any question about the set up okay you can look at oh she must copy and paste it right? this slide looks a lot like that the stack in a face that has all the thing data associated with this  the question is what might we be talking about here so let's spend a few minutes kind of speculating on  kind of speculating on how we might use an array for the queue now just like we did for the link list implementation we need to decide where is going to be the entry and where is going to be the exit for our data okay? uh.. let me make sure I don't do something stupid here
All right any question about it yeah oh yeah this only implies to a singly linked list I know I just want you to think Plus to one simple keep trackable all those extra pointers when we don't have to Just gonna mean you are gonna have bugs All right let's see so what's the running time of enqueue then constant time if we set it up wisely oh no it's dequeue  Either way so constant time either way so what's the running time of dequeue constant time if we are careful All right and that's all I'm going to say about the linked list implementation of a queue is that okay I'm assuming at this point that you could write that code because it's just about like insert at front right So this is the queue so the entry point is gonna be the opposite of what you choose for exit. So we have to be careful with the exit and then entry is the other one Now what you might be asking about or what is a relevant question is that what if you have some structure that allows entry and exit at either end And that's called a deck or double ended queue and it's a real thing I mean it's like I think of it as kind of a perfect test question because it's something we don't spend a lot of time on but it's perfectly with in you grasp in terms of reasoning about how you should implement it So that issue that you bring up even though you didn't intended is actually germane All right any other questions about it  Yes I'm gonna throw that to the crowd cause it's a great question so the question is if we augment our structure and the choice of ink color here is the clue if we augment of our structure with a tail before tail  If we augment it with that do we eliminate the problem of having to reset the tail pointer Well we do but then we have a problem because we have to reset the throwback Thursday pointers So it solves one problem but it creates another All right any question about it Let's see so the array based implementation of a queue I don't know what else can say about this just absorb it meditate for a second give a touch with the array based implementation of a queue I do know what I was gonna say about it any questions about the set up here You can look at it and go oh she must have copied and then pasted it This slide looks a lot like the stack inner face it has all the same data associated with it  the question is what might we be talking about here so let's spend a few minutes kind of speculating on how we might use an array for the queue Now just like we did for the linked list implementation We need to decide where is going to be the entry and where is going to be the exit for our data
Alright Any question about it, yeah? Oh, yeah, this only applies to singly linked list, I know. I just wanted you to think.  Okay? Plus, who wants to keep track of all those extra pointers when we don't have to? Just gonna mean you're gonna have bugs, okay? Alright! Let's see.  So what's the running time of the onqueue then? Constant time if we set it up wisely. Oh no, it's dequeue. Either way, so constant time either way. And what's the running time of dequeue? Constant time. If we are careful. Alright!  And, that's all I'm going to say about the linked list implementation of the queues, is that okay? I'm assuming at this point that you can write that code because it's just about like insert at front, right? Yes? [Student Questioning] So this is the queue, so the entry point is gonna be the opposite of what you choose for exit. So we have to be careful with exit and then entry is the other one. Now, what you might be asking about or what is a relevant question is what if you have some structure that allows entry and exit at either end? And that's called a deck, it's called a deck or double ended queue. And it's real thing. I mean it's like I think it of as kind of a perfect test question because it's something that we don't spend a lot of time on but it's perfectly within your, your grasp in terms of reasoning about how you should implement it, okay? So, that issue that you bring up even though you didn't intend it is actually germane, okay? Alright, any other question about this? Yes? [Student Questioning] I'm gonna throw that to the crowd, okay? 'Cause it's a great question. Okay. So the question is if we all comment our structure, if we all comment our structure and the choice ink color here the clue, if we augment our structure with a... tail before tail Yeah. Thursday a throwback Thursday, it's not Thursday! Ha... Hahaha If we augment it with that, do we eliminate the problem of having to reset the tail pointer? Well, we do but then we have a problem because we have to? Reset the throw back Thursday pointer, right? So, so, yeah it solves one problem and creates another, okay. Alright, any question about it? Okay. Let's see. So, the array based implementation of the queue [Silence] I don't know what I was gonna say about this, just absorb it. Meditate for seconds. Get in touch with the array based implementation of the queue. I do know what I was gonna say about it, okay. Any question about the set up here? Any question about the set up? Okay, you can look at it and go oh she must have copied and pasted it" right? This slide looks a lot like the stack interface. It has all the same data associated with it. And the question is, what might we be talking about here? So we've spent a few minutes, kind of speculating on... Kind of speculating on how we might use an array for the queue. Now, just like we did for the linked list implementation, we need to decided where is going to be the entry and where is going to be the exit for our data, okay? Let me make sure I don't do something stupid here.
Well, I will let you vote. it's not gonna matter allÂ that much. I'm gonna put e here and I'm gonna put an e" here, the other end. Â And I wanna know,if I should write an x" next or "n" Okay? So raise your hand if I should write a x" next.Â So the exiting from the structureÂ will happen here   Or n" next. Because the entrance into the queue should happen here, ok? You guys are voting. It's democratic, okay? All right, so raise your hand if you think I should write an x" Raise your hand if you think I should write n" All right, fine. It's all right. Raise your hand if you want vote again? Ok. Raise the hand if you think I should write x" Then raise your hand if you think I should write n" Ok, n" still wins.Â IÂ tried "x"s. I tried.   All right. So the entry into the structure is going to be at the front of the data.Â And the exit from is going to be here. Okay?  Let's see how this goes.Â We are going to enqueue value 3 And you are telling me that should go right there. Yeah? Cause that's the entry enqueue(8)  Where should that go? At the entry, right?Â There's no room at the entry  You like it?Â You want me to write x" there instead?  All right. Fine. Startover.So I've got bunch of these Put the exit there and put the entry here Ok? You are not gonna like this one either  I got three of them. Can't you tell.Â Ok. Enqueue three.  Enqueue eight. Maybe you do like it better. Maybe I've just forgot how to do this class Enqueue 4. Oh this is easy. Dequeue.   So three comes marching off And I gotta do that. So what are you telling me Who said that Move the exit. How am I gonna do that? Yeah, ok. I'm gonna change what you said Change the index, right?Â What is the entry? It's just the location. It's just the index of the array, right?  So go ahead and move it. Who cares where it is. Just some small integers. That's what we gonna do This empty space here is going to be used to keep track of where the entry and the exit are to our contiguous collection of data  So I'm gonna have a integer exit and a integer entry And enqueue occurs at the entry and they start off both at zero I guess. Now let's play this out a little bit. Ok any questions about that? Do you see what are we gonna do?  So at this moment where I say dequeue for the first time, exit is just gonna be moved over and I just always keep track of where it is And in fact, where's the entry going to be? What does entry mean?  It's always gonna be, I'm gonna keep it is actually one pass. Sort of like size in previous example. So entry is just the index  showing that location and exit is just going to be the thing that leaves okay? Any questions about it at all? All right. So lets carry this out a little bit Iâm gonna carry it out on this slide. It's gonna be a mess. Be ready for a mess? Take a deep breath and think of your dorm room. It's a mess. I never really moved out of my dorm room you should see my car. All right,  All right, enqueue seven. I'm gonna put seven in there and move entry. Dequeue becomes a matter of moving the exit and returning the a and it's very much like the whole pop. Dequeue again. You are gonna return four. Enqueue two. This is gone and this is gone, sorry. Enqueue two moves entry here. The entry ones are on the top and they are moving to the right. See what I did there? To the right  I did enqueue two. I'm gonna do enqueue one. I'm gonna do enqueue three. I'm gonna do enqueue five. Uh-oh
well I'll let you vote, it's not gonna matter that much... I'm gonna put an E here I'm gonna put an E here, another end. And I wanna know if I want to write an x and store in...ok so raise your hand if I should write x next, so the exiting from the structure will happen here, or an next because the entrance into the queue should happen here...ok can you guys vote it, it's democratic. OK, all right, so raise your hand if I should write an x raise your hand if you think I should write an n... all right fine... all right. raise your hand if you want to vote again? ok, raise your hand if you think I should write x... raise your hand if you think I should write x?... x still win  I tried access, I tried.  All right, so the entry into the structure is going to be at the front of the data. and the exit from it is going to be here, ok? let's see how this goes we are going to unqueue value 3 and you're telling me that should go right there, cause that's the entry onqueue 8 where should that go at the entry right? there a room in the entry yeah you like it? you meet the next room instead all right fine start over, that's why we got bunch of this ok... the exit there....put the entry here ok ....em... I grab three of them... can't tell ok unqueue 3. unqueue 8 oh.. maybe you do like it better. Maybe I just forgot how to do this class unqueue 4 oh this is easy, dequeue so 3 comes matching off...and am I gonna do that, so are you telling me... this said thaty move the exit... how am I gonna do that yeah..ok, I'm gonna change what you said.. change the index, right? what is the entry? it's the location, it's just the index of the array...right? so... go ahead and move it, who cares where it is, it just some small integers. so that's what we gonna do ok this ... this empty space here, is to be used to keep track of where the entry and exit are to our continuous collection of data. so... I'm gonna have an integer....em...exit and an integer...entry and unqueue occurs at the entry, and they start off both at zero I guess now let's play this out a little bit ok, any question about that, do you see what we gonna do? so at this moment, where I say dequeue for the first time exit is just gonna be moved over and I just keep track where it is. and in fact, where is the entry going to be, what does entry means. it's always gonna be I am gonna keep it as actually one path, sort of like size and previous sample ok...so entry is just an index and em... showing that location and exit is just going to be the thing that leaves ok... any question about it all? all right so let's carry this out a little bit I am carry it out this slides... it's gonna be a math, ok? you ready for a mess? take a deep breath and think of your dorm room. it's a mess ok  and I really moved out my dorm room maybe you should see my car...all right... all right ...unqueue 7, I'm gonna put 7 in there move entry  dequeue... becomes a matter of moving the exit ...yeah and returning the 8 is very much like the whole pop  dequeue agian... gonna return 4... on queue 2 ok so this is gone and this is gone, sorry. unqueue 2, moves entry here ok, the entry wants on the top, and moving to the right see what I've did ther to the right very hard ok um...I did on queue 2, I'm gonna do  ...  I'm gonna do unqueue 1, I'm gonna do unqueue 3  I I'm gonna do unqueue 5...
comments Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  i can resize the array right? then what should i do? why not? cuz I could dequeue all of this and resize the puppy to one day element  right? so resizing is what we want to do here what you wanna observe is the look it theres all the empty space over here there is all the empty space in the front of the array and so effectively what you are gonna do is wrapping the array around, if you are gonna wrap the array around and move entry to its new spot okay and I'll make it a double way to kind of see okay any questions about it? and how do I do that functionally? mod is your friend the mod operator is your friend  here okay yeah? oh very good. So just a second. Let's get there. Okay. So is it clear where we are here and then I'm gonna dequeue that moves this guy down here and then I'm gonna enqueue nine nine goes here and in fact what we end up with is this okay I think entry's on the top. This thing should be on the botton okay alright. Any questions about it? Yeah?  You can figure out where entry goes by taking incrementing it mod tablefies and it will always just put it in the right place okay yeah so in fact in my code, my index is a mod index. So I know that I will never go outside of the bounds of that array because I'm always going to take mod the array size. Okay Alright! So lets do this a little bit more. Any questions about it so far? Yeah? un-huh un-huh I'm not quite with you yet. okay? Hold on just a sec. I wanna just get us there for a sec okay so you guys are really bothered by the fact that we are kind of screwing up where the start of the array is. Okay? Alright! Fine. Let's do a couple more enqueue y, moves this, enqueue i, moves it again, enqueue s, moves it again. right? so now entry is here, exit is here. so that becomes a task when you enqueue right? Are they in the same spot? Has there been data, is there data in the array and are they in the same spot? then you can argue that the array is full. Okay? Alright! and of course, the next thing is dequeue so that doesn't actually happen at that moment  but happen in a couple more a bit. We are going to keep going okay? Alright! So. What are you gonna do? I've got this sort of gap here I got this sort of gap between what's in the start and what's in the rear what should I do?  I'll give you a hint. The hard answer, the complex answer, the one that makes you go like huh? is not the right one I know haha right? I would set a.. okay, well, lets fix this first and then I'll tell you my stories , so let's see okay. Alright! so all you do is totally easy. All you do is you just reset.  you take the exit an you put it here and you increment. Exit increment forward size number of things, items, sub, you know, k  where k is in the element of exit up to entry mod table size  and those go in the position 0, 1, 2, 3 up to k capacity. those go up to capacity minus one okay. Does that make sense? So don't worry about like Oh there's yeah. there are overlapping here and just start over. give yourself a clean slate feels great Alright! Any questions about it? is it good? I'll tell you my stories some other times, it's cute. Alright that's all I have. Look at that we did it. Yay!
Umm So let's see Mp4 is out If you are going any extra credit all term This is the one, this is the one to go for 4.1 is - who's done it. Who's already done 4.1? How many lines of code did you have to write? 10-ish on the order of 10-ish But There's a cognitive leap that happens There's a cognitive leap that happens Umm For those particular 10 lines of code So you guys all saw - Raise your hands if you are done with 4.1. So then, put your arms down. Okay that's maybe 20% of you tops. Now Among you who are done, raise your hand if you were surprised by how it all turned out Raise your hand if you are kinda surprised by what that code ended up looking like And raise your hand if you were surprised in a good way with how that code ended up looking It's really - really? That's all you want us to do? Okay Fine\ Okay Especially for the queue class The stack class is little bit more Alright So There was apparently someone posted in Piazza that 4.1 was due tomorrow night I don't know where they got that idea. It's actually due Friday night. So you have some time here. Alright Are there any other administrative questions or issues you want to address before we start working? Your exams are being graded. I don't know the status because I couldn't look at the Google docs.. They told the status this morning. So I don't know the status. We'll all find out together. I have some code for you. It's my little Monday gift. And here's what I want you to do: I want you to figure out this code and put a little dot beside everything that surprises you So for about the first 10 minutes or so of today We are going dissect this code And talk about all the things that surprise you about it. Nothing surpises me anymore But we're gonna talk about the things that surprise you about this code So scrutinize it Talk about it with a friend  I'm gonna take a break [Silence] [Silence]
Â  walk my pen down the edge of the code and you yell at me or raise your hand and start dancing or something and tell me when there is something you would like to discuss. In the code or it doesnt even have to be something that you think is interesting. let me know if you see something that you think someone else in this room will think is interesting So you don't even have to commit to being interested just if you think somebody else is interested. speak for the crowd here. intertesting yet? yea okay guess what our converstion about adstract data type list was unneccessary.  we didnt have to have it because the standard template library provides a list for us. a list class for us We didnt have to define our own interface So the point is that there is already a list abstract data type defined for you and implented for you in the standard temple library and the only thing you have to do to access it is you use angle brackets And its also very well documented so i am not going to spend a lot of time in theis class tlaking about the differences between our list class and their list class. but suffice to stay that most of those differences aris ein the interface between the user and the clss itself so the functions they have for oyu are slightly differnet but larglerly the purpose to fthe thin gis the same  Sequentail ordering of objects That is true for a lot of different container classes so going forward it will be true that we will look at some abstract data types that are in fact also avlabile to you via the standrd temple librayr but we will be discussing here is what they look like under the ood so just beyound the interface I am going to keep walking down the screen then  tell me when to stop i am going to stop  because okay fine somebody who didnt want me to sotp You didnt want me to stop so im going to ask you what is that thing and if you dont want to answer than you can name somebody else we dont have to stop on structs anymore because they are just classes where the default of everything is public  so those are exactly equlvant to what i have just odne there keep wlaking down the screen stop first of all what is that line 
its a constructor.  oh you snuck in two lines there, you snuck in two lines.  its a constructor, very good, with an initializer line.   good. so he snuck in two, did you see that, the constructor,  and then everything after this colon is used to initialize the members of the Animal class, I mean struct.  OK?Any question about that? can I keep going?  no, I can't keep going, i can't keep going, are you kidding me?  there's some new syntax here. Let me tell.. (crying and laughing..)  Sorry, well, this is, I'm like blushing, I'm sorry.  I did! I saw you running outta the building!  Oh they are having so much fun! OK, no more giggles, there shall be no more giggling, ok, for me.  Alright, take a look at the constructor for a second.  It's not just one constructor.  It's a whole bunch of different constructors because it allows you to give default values in the absence of specifications.  So in the absence of specified parameters, this construct allows you to give default values.  Now, I do have a hard question for you related to this.  And that is how many constructors is it?  six is one answer. four might be another answer.  Take a look.  eight might be another answer. one it's not one, I'll tell you right now it's not one, it's a whole bunch.  OK, so think about all the different choices here, think about all the different choices.  What you might think you can do, this is a reasonable thing to think , you might think that inside each of these locations, you can either specify a name or not,  specify a food or not, specify a big or not.  If that were the case, this would be like eight constructors, right?  This would be like eight constructors because it's 2 to the 3rd for the different options there,  but in fact, in fact it doesn't work that way.  It doesn't work that way.  If you choose to make, let's see how does this go, what's the best way to.  If you choose to specify one, you must start specifing them from the left.  So, the defaults are allowed from the right, so you can leave off the big or not , you can leave off the food and the big,  but not the food and then specify the big.  Make sense? and you can leave off all three if you like,  but you can't just pick and choose, you can't say ok I'll specify the name and the size"  you can't do that. OK?  not even with clever use of commas. The fact of the matter is that the grammar that describes the language doesn't allow you to do this.  Any question about that? That will become clear, I'll talk about that a little bit more as we actually declare some of these things.  OK, so that said, how many constructors is this?  four constructors, that's right. There's a no argument constructor. x What's the no argument initialize things to?  a big blob that eats, yes, big blob that eats you.  The default animal is a big blob that eats you, and that's you specify no parameters,  or you can specify, uh, wait. Or you can have one parameter, or two parameters, or three parameters.  Alright, let's see. OK, yes?  that's right, you cannot just initialize the boolean value.  If you are gonna initialize one thing, if you are gonna pass one parameter to your constructor,  So, if you're gonna pass one value to the constructor, it's gonna be the name of the animal.  OK? That make sense? If you're gonna pass two, it's gonna be the name and the food.  If you're gonna pass three it's gonna be all three. Yes?
Yeah, exactly. Right. Â  Yup. Yup. Yup. Okay, any other questions about the animal class? The animal struct, whatever? Ok, it is worth noting that this semicolon is necessary. Just because it's such a common bug we don't want you to deal with it. Alright, so now let's use this class a little bit. These are a sequence of valid declarations. These are a sequence of valid declarations invoking each of the constructors that we just talked about except the no argument constructor So, here we are declaring a giraffe that eats leaves. Is it big or not? It is big. Giraffes are big, duh! Ok, this one is a penguin who eats fish and its not big. Right? Okay, and b is a big bear that eats you, that's right. So blobs and bears eat you. All right. Ok, fine, and now I'm gonna walk down just a little bit farther here and ask you about this one. What's going on here? What is it? You might want to use a D-word in describing this.  Yeah?  Yeah good. Its name is... So you're declaring a list of animals named zoo". So zoo" is a list of animals. So this is using the STL List class. Now it's a quick Google search away to find out what the interface to the List class looks like, but I'll tell you that the insert... what we could call insert at end"... if we were to make a function, we would probably call it "insert at end" The standard template library uses push_back". So, we're adding our giraffe to the zoo. How many things does it have in it, right here? One, so it's a list of length 1, by here. Then we add another thing to the zoo. And then we add another thing to the zoo. Ok? Any questions about that at all?  Ok, let's take a break then, or take another couple minutes... ...and do the same thing with this code. This is gonna take a little bit more untangling. You should see something entirely new here, so go on a quest, and try to figure out this code. And up till here it's the same. So up till there, this is just a continuation of the code on the previous page.  Take a couple minutes, and figure it out
Yeah exactly right yes Okay all right any other questions about the animal class,the animal struct whatever It is worth noting that this semicolon is necessary  just because it's such a common but we don't want you to have to deal with it All right  so now let's use this class a little bit These are a sequence of valid declarations invoking each of the constructors that we just talked about except the no argument constructor So here we are declaring a giraffe that eats leaves is it big or not it is big, giraffes are big This one is a penguin who eats fish and is not big, right, false and b is a big bear that eats you that's right so blob and bears eat you Fine and now I'm gonna walk down just a little bit farther here and ask you about this one What's going on here What is it? You might want to use a d-word in describing this Yeah good So you are declaring a list of animals named zoo so zoo is a list of animals  So this is using the STL List class Now it's a quick google search away to find out what the inner face to the list class looks like But I'll tell you that what we would call insert at end if we were to make a function we would probably call it insert at end the standard template library uses push_back   We are adding our giraffe to the zoo How many things does it have in it right here One so it's a list of length one by here Then we add another thing to the zoo and then we add another thing to the zoo Any questions about that at all Let's take a break then or take another couple minutes And do the same thing with this code this is gonna take a little bit more untangling You should see something entirely new here so go on and quest and try to figure out this code And the only thing up till here is the same As this is just a continuation of the code in the previous page Take a couple minutes and figure it out
yeah yeap yelp,exactly right yes? yelp yelp~ yelp okay uh,alright Any other question about the struct the animal class? animal struct,whatever? ok.It's worth noting that this semicolon is necessary because it's such a common bug,we don't want you to deal with it  alright so now let's use this class a little bit these are  uh these are a sequence of valid declaration these are a sequence of valid declarations invoking each of the constructors that we just talked about except the no argument constructor  except the no argument constructor so,here we are declaring a giraffe that eats leaves, is it big or not it's big,giraffes are big okay this one is a penguin who eats fish and is not big right? and b is a.... big bear that eats you that's right so block and bears eat you alright ok fine. and now now i am going to walk down just a little further here and ask you about this one. what's going on here? what is it? you might want to use a D word in describing this yeah? yeah good whose name is, good so you're declaring a list of animals named zoo" so zoo is a list of animals so this is using the STL list class now it's a quick google search away to find out what the interface to the list class look like  but i'll tell you that uh, the insert well, we will call insert at n,we would, if we were to make a function we would probably call it insert at n uh, the standard template library uses push back okay?so,uh we're adding the giraffe to the zoo. how many things does it have in it right here? one,so is a list of length one by here then we add another thing to the zoo and then we add another thing to the zoo any question about that at all okay. let's take a break then or take another couple minutes and do the same thing with this code this is gonna take a little bit more untangling. you should see something entirely new here so go on a quest and try to figure out this code and the only thing, it mean, up to here, it's the same okay, so up to here this is just a continuation of the code on the previous page take a couple minutes and figure it out.
[Talking about the football game.  Nothing related to the lecture.] All right. Should we work? Let's work. All right. So I have a for loop for you. I have a for loop for you. OK. What you normally see if this were a for loop like those you had seen before most frequently?    What would you see right following the letters F, O, R ? What would you see there?  An integer right? Integer i = 0, right? That's what for expect. That's what the for function expects to see right? It expects to see a type of thing that can be initialized to a start value. Now. In this instance what we have is not an integer. It's a generalized notion of something that can be incremented. And we refer to it as an iterator. Okay. If you look at the role that the integer i plays in that place. It is something to use to iterate through some structure right? It is incremented incremently. Umm... It is incremented as by virtual for loop. And  that's what you should expect to have happened here for this new type of thing that we happened to be calling an iterator. OK. All right. So yes. Just as you normally expect to see an int there. In this case we have another kind of thing called an iterator. Hold on.I'm gonna make this right. So this replaces the int kind of thing okay? But it's just an iterator. All right. Fine. What is IT? The name of it right? It's like i. The name we happen to choose . All right. And in stead of setting it to zero which happens to be rather arbitrary really as our place where we normally start counting.  We're gonna use this abstract notion of this starting place called begin(). OK? What normally goes here? It usually goes like i is less than size or something right? OK. All right. And so now instead of that, we say okay.  I'm gonna take this generalized notion up to the end of whatever it is. So we go from the begin to the end okay? Uh... What is this ?What is begin()? It's a function. Very good. It's a function in our class . Does it dwell? well list class... The standard template library list class gives us this function  calledd begin().What's begin()'s return types? What is  begin()'s return type? Iterator. Right? It's return type is an iterator. How do I know that?
Because of the assignment statement. That's right. So, zoo is a list class thing. It must have.. oh is begin public or private? Public.That's right! This is a client code where we are using that function. So, begin is a public function in the list class returns something of type iterator. Where the heck did that come from? Where did iterator come from? It's a type. Where does it live? Also in the list class, that's right, it's a new type of thing, lives in a list class. Is it public or private? Public. Has to be. We are using it, right?  So the standard template library's list class is actually much*4 more sophisticated than ours. because it's got all these sexual stuff. It has this iterator class that we get to use if we want, and these other functions that help us set up our iterators, OK? Alright. Fine Just as if IT were an integer, will allow ourselves within the for loop to increment our iterator,  so we can increment the iterator just like we would if it were a integer. But there are other things we can do within an iterator. Take a look the next row. What on earth is going on here. what on earth is going on here. We dereferenced an iterator. What do you expect that to get you? If we are asking for a name, what do you expect to come out of here. An animal, right? An animal.  Who's animal? Where was it? It's in the list class. It's in the list, right? OK. So what is an iterator It's something that is stepping through the list. It allows us to move it, and allows us to deference it. It allows us to ask for its value. OK. That's cool. Yeah? So is an iterator an address or something? Any other...Raise your hands if you agree with that question, if you are like what the heck. about this. OK. So here is the thing, you don't get to ask. You don't get to ask how it is implemented You are asking me You're asking me.... Think about this for a second. He is asking for on behalf of all of you, it's not just him, he's asking about the implementation And I'm saying: you don't get to know how it is implemented. Why? What principle allows me to do that Encapsulation. That's right. The implementation of that iterator is encapsulated away. All we know is how to use it, OK?  So swallow that pill. Swallow it. Go ahead and ask. Yes, Yes There is this notion of next. Now in the list class you have this adjacency but, and you kind of Â have this notion of first and second and third. But, you know, we will see structures where the ideal of next  is a little more ambiguous. I don't know. Should I go left to right? I don't know. which one is the next one? And an iterator promises it will give you your stuff back out of your structure in some order. OK. For list, it promises to step through from beginning to end in a predictable order. Alright. Yes. OK! So let's talk Â implementation for just a second. How do you think this happens? What do you think this implementation kind of looks like?
It does this and it does this. so what are you thinking, it kinda looks like? it's got. yes? yes! exactly those operators are overloaded inside the iterator class. that's what the iterator class does, it overloads those operators so that you can do, can work this magic. now the question was, why don't you do this instead and the answer is that that would require that to be overloaded and i'm not sure if it actually is for this standard template library list class. i just don't know ok. um iterators promise that the plus plus will be overloaded and that the asterisk will be overloaded so you can both move this thing and look inside your structure. that is a promise from an iterator k? this is a good time to say uhh where that promise came from like it's a promise but who said, who said thats a promise? So an iterator is a notion that was added onto the language later because it was so frequently deployed, it's called the design pattern. It's not fundamentally part of the language but it is a part of the cultural experience of the language to know what it is. So what is an iterator, anybody you talk to about c++ will know what an iterator is. And it is formally described but only functionally not as an inherent part of the language it self. so there is this conventional agreement that iterators will always implement something that increments and something that gives you its value. Nathan? Yeah? right. So how do you know you're overloading dereference, or multiplication and the answer is in the number of arguments, so when you dereference, so remember that a function is in part declared by its parameters, i can have two functions of the same name but if they are parameterized differently, then they are different functions, and the same thing is true for dereference operators. it has one and in fact in this case, effectively there are no arguments, it is just the thing. K. and instead of the binary operator. Yeah? could i accomplish this same thing with primitive types? not nearly so elegantly right? So i could do this if i implemented my own list class with a dynamic array and made it but so i could do this in C is sort of what you're asking me basically right? but i wouldn't want to. i wouldn't want to, this is one of the elegances,  elegancies from having C++ ok? Alright any other questions about this right now? ok alright. so uhh, my question is for you, is what is printed out? this is cout, this is the contents of our list, what is printed out? k so the names so we get giraffe, and leaves, and then the next time through we get penguin, and fish and then... do you? 
find the end implementation of structure container overloading
Then the standard template library container classes, usually will have a forward iterator, a backward iterator, a bidirectiional iterator, it can go forward and backward, and const versions of each. Which means you can look at your data, but you cannot change your data. Any question about all that? Okay, how do you think we achieve this reverse iterator? Going backward through the list. Minus minus. it overloads minus minus Any questions about it?  Okay, alright so lets talk. Oh. Here's what I want for you. I want you to be able to leave this room and feel confident using iterators Get the right google search and find the appropriate iterator to write code that traverses any kind of container class. Also, if your employer or your advisor ever says bring me somebody to implement a new iterator, I want your to be the one that goes oh Ill do that So we are going to pull back the hood a little bit and look and speculate about exactly how these things are implemented. So that you see what kinds of decisions your would have to make if you were actually to do an implementation. So, We agree I think that we're going to need for if say a linked list were the thng that was encapsulated, we would need some private member to keep track of where we were To keep track of the fact that your iterator is pointing to that one instead of to any other one. Were going to do that via some private member It means private member so if you were a linked list and you want to keep track of where you were. What kind of thing would you do. What kind of thing would you keep track of if you were trying to keep track of where you were if you were a linked list. In a linked list, you have a listnode pointer, you might call it curr and it might sit there until somebody did this plus plus If somebody said iterator, what would happen to that curr Plus plus is implemented like curr = curr->next And how would you look at the value inside how would you dereference How would you look at the value inside of that pointer You would look at curr's data you return curr data Look your have almost implemented an iterator for a linked list class What would a reverse iterator for a singly linked list look like
And then, uhh, the standard template library container classes usually will have a forward iterator, a backward iterator, a bidirectional iterator... ...so you can go forward and backward... and const versions of each. Which means, you can look at your data but you cannot change your data, okay? Any questions about all of that? Your world changed today, huh? You did know these existed. Okay. How do you think we achieve this reverse iterator? Going backward through the list... minus minus It overloads minus minus Alright, any questions about it? You doing good? Okay? Alright. So let's talk... oh... lets go... lets move... so, here's the thing. Here's what I want from you. I want you to leave this room and feel confident using iterators. Like, ughh, I need an iterator for this, and get the right google search and find the appropriate iterator to write code that traverses any kind of container class. That's what I want from you. But I also... if your employer or your advisor ever says, I need somebody to implement a new iterator," I want you to be the one to go "Oh! I'll do that!" So we are going to pull back the hood a little bit and look and speculate about how exactly these things are implemented, okay, so that you see what kind of decisions you would have to make if you were actually to do an implementation. Am I in the way? I'm not in the way, right? Okay. Alright, so, ummm, we agree... we agree, I think, that we're going to need, for... if say a linked list was the thing being encapsulated... we would need some private member to keep track of where we were. To save the state inside the object of the class.  To keep track of the fact that your iterator is pointing to you know that one instead of any other one. Okay. And we are going to do that via some private member, that's what this PM... PM does not meet message me... it means private member. Okay, it doesn't mean afternoon either. It doesn't mean nap-time. No yawning. Alright, so if you're a linked list and you wanted to say keep track of where you were, what kind of thing would you do? What kind of thing would you keep track of if you were trying to keep track of where you were in a linked list? Curr pointer, good. So in a linked list, you'd have a listnode pointer. You might call it curr. And it would just sit there until somebody did this plus plus. Now, if somebody said plus plus to an iterator, what would happen to that curr? Yeah? Yeah, good. So plus plus is implemented like curr = curr->next. Okay. And how would you look at the value inside? How would you dereference? How would you look at the value inside that pointer? You'd look at curr's... what did we call it? Data. We called it curr's data. So you would return curr->data. And look, you have just implemented... you have almost implemented an iterator for a linked list class. Okay, what would a reverse iterator... what would a reverse iterator for a singly linked list look like?
Oh. Going backwards you'd have to come forward and find the next one by coming through the forward.Â Okay fine. Â What if your encapsulating an array? You're iterator helps you step through an array. How would you keep track of where you were? Just an integer right? An integer index. I'll call it k. How do you move forward? You increment it and lets pretend your array was named 'a' How would you get your data out? Your overloaded operator would return a k right? What if your.. Oh boy. What if your memory were arranged like this. Into some hyper cube. These are still the questions you'd have to ask. You'd say okay. How do I keep track of state? How do I determine what the next one is? How is my data represented inside? Those are the exact same questions you would have to answer in designing this thing. Alright any questions? You good? Okay! We already talked about a lot of this, but we're gonna go through it again so that you have it all in one place. I have made a list out of the things that you need to implement an iterator. I have made a list of the things that you need to implement an iterator. And I wanna remind myself what do they return here? Here's what I want to know. Where does the iterator class go? You remember? Where am I going to define there is gonna be this class iterator. Where does it go? Public or private? Yeah everybody agree? I heard public is that true? Yes! Because in fact we are writing it for the client to use. That's the whole point! So... class iterator is going to be an inner class. We call it an inner class to in the public section. Kinda like list nodes but not private. We may also have list nodes here who knows. Okay. Where are begin and end defined and what is their return type? They are public.  Begin has no parameters. What does it return? It returns something of type iterator. That's right! Where a re these operator++ and Operator* overloaded? Inside the iterator class and are they public or private? Public good! Public inside here you have operator ++ and operator * etc. And where is the private member associated with the iterator? Where is the private member that helps you keep track of where you are? Oh it's private. Duh. Inside what class? Think you keep it here. Yeah. Right? You wanna keep track of where you are in whatever is defined in this structure. So you got a list like this. Like this and you got something that you're gonna keep track of one of those. Might as well store it there. Yeah? No. It's an inner class. This is an inner class. Alright. Yes?
The representation of what?  So this has to be in order to keep track of this, you have to do it in terms of the way the data structure is defined, right? Like, its pointers if it's a pointer based structure. Integers if it's an integer based structure, etc. Does that make sense? Yeah?  No, you can have many iterators at a time.  You'd have different ones for different iterators You'd have different...Â   So the client doesn't know that They don't know what you're doing Right? They only know  What you're referring to by your individual one so you'd have This would be cur forward iterator You'd have cur backward iterator Cur  Yeah, I see what you're saying. I get it. Lemme think about it, ok? I'm not gonna be able to able to do it this way. But I think you may be right. About, about what you're worried about. But lemme think about it, ok?
[Pre-lecture]  Alright lets get started. Sorry about that. I have a couple announcements in addition to the mp4 announcement. A couple days ago you should have received an email from me about Class Transcribe and I want to tell you a little bit about it. So wouldn't it be nice if the lecture videos were searchable, yes. Wouldn't it be nice so you could just enter search term and have it find for you a list of videos where say I talk about pointers or whatever you would like. Well we can do that if you guys will work together to do so. So a few students have created a system whereby we can crowdsource video transcriptions. and the deal is that for any one person video transcription is an overwhelming task. But if all of us, if each of us contributes to getting this done then the burden is not to extreme on any one person. In fact, in fact, if each of you give 15 to 20 minutes to this task then we will actually have triple, we'll have fault tolerant transcriptions. So we'll have three different English translations, captions of all the lecture videos. So, I would like for you, we would all benefit from you going back to my email, the mass mail. Clicking on the links, signing up for task, doing a task. Once the videos are approximately half covered then they will open it up for search. So you have to get a few of them done before it is worth while actually providing them for search. Lets see, any questions about it. [Silence]
So the organizers of this, say that I need to incentivize this. Now we go, Notice how we held that off until the very end.  What I'm thinking is that it's 20 minutes of your time right?  I'm thinking about this on-the-fly, just so you know. I don't know I'm thinking about a point of extra credit. If you actually do it, one point towards your grade. No, don't even negotiate with me. Alright, Weâll let you know what the actual incentive is, we probably will send you an email on how to do this and I'll let you know what the incentive is other than the goodwill of the community, come on!  All right so class transcribe is one announcement and the other announcement is that the honors class is going to start on October 20th. If you have not yet registered for it and think you would like to do so, weâll help you do the late add form. Post on Piazza for more instructions on how to register for the honors course.  Okay and that's all I have for announcements. I would like to remind you where we were last time.  We had basically gone through this code and we had become fluent users of iterators, yes? And we had talked a little bit about how they might be implemented we didn't implement our own but we talked a little bit about how they might be implemented.  So that should anyone ever ask you to do so, you know kind of where to start with the process. Well I have some code for you to look at today that's sort of starts right here it comes after this it employs some of the concepts that you have used and it's probably different than anything you've seen before. So I have this function up here, it's a templated function, and what I want you to do is to write a short description of this function.  Now when I say, âWrite a short descriptionâ it means I want to know it's name, Its inputs and outputs, this function has no return type anyway, and then a very short one sentence description of what the function does, it's almost like you're writing the comment for this function. So take a couple minutes, untangle the template, and see if you can figure out what it does and once you write that sentence, I want you to describe to yourself what printer is, you might want to write it down as well. Would anybody like to come write their response on my tablet up here, it's not wireless today. Its not wireless today. You want to come?  Would you come if I incentivized it?  Anybody want my pen? You can have my pen but not my tablet. No way? What if I threw it?  It would be helpful if you put some errors in there. Like miss spellings or things like that.  The rest of you could do it too because most of you have pencils I think. [Wait for student to finish writing on the tablet]
So, the organizers, the organizers of it, hold on, the organizers of this say that I need to incentivize it. Now, we go, yeah yeah, noticed how I kinda held that off for the very end. And so what I'm thinking is that you know it's twenty minutes of your time, right? And normally I'm thinking about this on a fly, just so you know. Uh, I don't know, I'm thinking like a point of credit. You actually do it, one point towards your grade. We can, no, don't even negotiate with me. [Crowd laughing] Alright, we'll let you know what the incentive is. I'll probably send another e-mail to remind you how to do this and. I'll let you know what the incentive is other than the good will of the community, come on! God! Alright. So class transcribe is one announcement. Um Oh, see this is gonna be bad today. Hmm, traffic fixed. Okay. My wireless thing isn't working so... The other announcement is that the honors class is going to start October 20th. And if you not yet registered for it and you think you would like to do so, we'll help you do the late add form, okay? Um... Yea, you'll have to contact us to, actually post it to the Piazza asking for instructions on how to do that. Okay!  And that's all I have for announcements. I wanna remind you where we were last time. We had basically gone through this code and we had become a fluent users of iterators, yes? And, and, we talked a little bit about how they might be implemented. We didn't implement our own, but we talked a little bit about, we reasoned about how they might be implemented. So that should anybody ever ask you to do so, you know kind of where to start with the process, okay? Well, I have some codes for you to look at today. That sort of, you know, starts right here. It comes after this. It employs some of the concepts that you've used and well but it's probably different than anything you've seen before. Okay? So, I have this function up here. It's a templated function. And what I want you to do is to write a short description of this function. Now when I say write a short description, it means I wanna know its name, its inputs and outputs, this one has no return type anyway. And then, a very short one sentence description of what the function does. It's almost like you are writing the comment for this function. So take a couple minutes, untangle the template, and see if you can figure out what it does. And once you write that sentence, I want you to describe to yourself what printer is. You might wanna write it down as well. And then, oh I can't hand off my, oh would anybody like to come write their response on my tablet up here? It's not wireless today. You wanna come? Would you have if I incentivized it? [Laughter] Anybody want my pen? You can't have my tablet but you can have my pen. Anybody want it? No way? What if I threw it? [Crowd making sound] Did you want it? You are looking at me. Okay, did you want it? Thank you! No, in fact, it would be helpful if you put some errors in there. Like, misspellings, you know, things like that. Okay, the rest of you can do it though, cause you mostly have pencils, I think. [Silence]
You're late. This is mean to put the hand up in front isn't it? hahaha. Uh oh. OH. Ok. Ok excellent, any questions for him. I will facilitate discussion. Any questions for him? alright. thank you very much. yeah. *claps* that is the cheapest applause you're ever gonna get. ok alright fine, um did anybody have any other speculation on what this function does or any other description they'd like to add to it? so what i want to know next is what what is printer? what is printer? now yeah? it's a functor what the heck is that that's a new word. that's a new word, he said its a functor, i just wanna say it a few times because its so fun to say. try it. functor. that's right. good. ok. in fact that's correct, in fact that's correct, ok. now. but, there's a little bit of ambiguity but i asked the question for a reason. what is printer look like in a the middle of the function there? what is it look like, it looks like a function right? it is applied to some parameters right? with parenthesis so it looks like a function but where did it come from. it came in as an object, it came in as a parameter to the function so in fact, printer is what we call a function object. AKA say it, thank you. also known as a functor ok? alright any questions about that. alright fine well all of that is quite abstract, right? all of it is quite abstract so lets make it a little bit more in the context of this function, so lets make it a bit more concrete. the question is how do we make a functor? what is a functor? well take a look at this code right here, take a look at this code what does it do? overloads the parentheses operator, very good and that's it. that's all it does. it overloads the parentheses operator to do a little tricky function, a little cute function, ok? fine. now but it's a class so we can declare something of that type so the first thing i want you to do is remember the previous example declare something of type animal. anybody want to come up here and do this on my tablet for me? ok how about verbally tell me what to do. how do i declare something of type animal? you remember ? from last time. you know the struct is behind here, you can almost see, oh look look look, right here, you can see it. k? alright who wants to do this, raise your hand. somebody raise their hand, ok close your eyes and raise your hand. close your eyes and now raise your hand. chickens, you bunch of chickens. animals c is a chicken and if you remember its a big chicken that eats you. you right k. ok! so i declared an animal, now printigbig is a class, which means i can declare something of that type right? yes? right i can cover over all of this and it says class printifbig, it's not templatized or anything so i can say, printifbig 
emm, what's we call it frog hey cause is doesn't matter ok, just a variable, now frog is a type printiIfBig now using your answer for one and two invoke some member function of the printIfBig class  will what member function do we have only the overloaded operators so how does it work, oh I know just tell you go frog.operator() para parameters the c, so I will put one parameters so i will put c in there yeah, how do we invoked member function right ohhhh that is exactly equivalent to saying frog of c ok, that's how that overloaded principle operator look ok, any question about that, you good? so now, now what we can do is  we can do clear this functor, this functional object passing around in two functions, right, like we did a of there ok any question about it so far, you good? so ok, yeah? aha yeah so the question is why do I choice more intelligent names for the type parameter and templet statement and the answer is because I what to give you a hint as to what they do what kind of thing yes  but it could be told, could be tea, could be icecream, etc no, iter is not the key word ok, but it is carefully choosing to give you kind of glimpse to how we were going to use it right, like iter is a short for...indeed, is there another word start with iter" iter internet, not internet is how you see of code internet ok, interrupt it even funny, alright, fine your next task, your next task is to decode this, ok so take a couple minutes, you will want draw some circle on you page, decode, figure out what's going on  here oh yeah you can touch the screen while you are working
What should we call it  frog because it doest matter okay just a variable now frog is of type printifibig now using your answers for one and two invoke some member function of the printifbig class. well what member function do we have.  only the overloadded operators so how does that work oh i know just how you go frog.operator() and that takes one parmater so i am goiing to put c in there  thats how we invoke member functions right oooooohhhh ooooohhhhh that is exactly equivalent to saying frog(c); thats how that overloadded parthensis operator works  any questions so now what we can do is declare these functors, these function objects and pass them around into functions like we did up there alright any questions the question is why did i chose more intelligent names for the type paramters in the template statment and the answer is because i wanted to give you a hint as to what they do it could be t it could be ice cream with no space iter is not a keyword but it is carefully chose to give you kind of a glimpde into how we are oging to use it. like iter as in short for iterate alright fine.  your next task your next task is to decode this Take a couple minutes. draw some circles on your page  decode, figure out whats going on here  -nothing-  turns out you cant touch the touch screen while youre working 
Hi! What's going on? Yeah? Yeaaaaaah. Very good! So the output of this is to print only the animals in the zoo that are big So from the example of the last time that would be  the giraffe and the bear giraffe and the bear Penguin will no be printing Ok. So should we untangle it? Alright, so, print big Oh wrong pen printIfBig is called myFun so the name of the function that we're gonna pass around is called myFun Last time it was Frog, but here we're gonna use myFun as my fuctor Ok. Then we're gonna call, simply call function print, okay? so that the top function of their Now what does print mean? It means two types and three parameters Two types and three parameters Here are the two types, oh It's an animal iterator and a type of the functor okay? And now I need three parameters What is the first parameter? Oh, it better be of this tupe and the intention is that the processes going to go from one to the other so it make sense that we are gonna walk forward through the zoo. so make sence that we would choose zoo begin, which is just a member function of the zoo class that returns an iterator one of these right? something of that type zoo end, and then whatever i called that fuction name for that function ok! so what does it do? it applies this function to every element of the zoo between these two iterators. and print it out if it is big here, ok? any question about that? yes? oh, so we are printing out the very last element, because it's going to go while the first is not equal to the second so it's gonna keep going until it becomes the same as the second. ok? and then oh, end is one pass for last end is one passable last from that time, that's the key point there. ok any other questions either question about this? ok, so, you know i am not as eduminded probably as you are but i will tell you how i respond to this and maybe, maybe you will be a little born mentally flexable every time I don't have a mechanism for remembering exactly how this goes every time. i had to think very hard and very carefully about how to set this up but what's important is that you know it can be done. that is you know you can define a function that you can pass around and apply to members of the container. ok, that's what is important tha you know, ok? and untangling exactly how to do that every time is a matter of practice you had to do that everyday you realize that oh yeah all you gotta do is declear a couple of iterators .etc
Alright, so whats going on yeah? yeahhhh, very good, so the output of this, is to print only those animals in the zoo that are big alright? So from the example of last time that would be the giraffe and the bear ok, the giraffe and the bear and the penguin will not be printed Ok! Ok, so should we untangle it? Alright, so, printifbig (Oh, wrong pen), printifbig is called myFun So the name of the function we gonna pass around is called myFun Last time it was frog but here we gonna use myFun As in my functor Ok, then I'm gonna call, simply call funtion print Ok, so that's the top function up there Now what does print needs? It needs two types and three parameters Two types and threeparameters Here are the two types Ohhhh, it's an animal list iterator And the type of the functor Ok? and now it needs three parameters, what is the first parameter? Oh it better be of this tupe and the intention is that the processes going to go from one to the other So it make sence that we are gonna walk forward through the zoo. So make sence that we would choose zoo begin, which is just a member function of the zoo class that returns an iterator One of these Right? Something of that type Zoo end, and then whatever I called that fuction Name for that fuction. Ok! So what does it do?  It applies this function to every element of the zoo between these two iterators. And print it out if it is big Ok? Any question about that? Yes? Oh, so we are printing out the very last element, because it's going to go while the first is not equal to the second So it's gonna keep going until it becomes the same as the second.  Ok? and then Oh, end is one pass for last End is one passable last from that time, that's the key point there. Ok any other questions Either question about this? Ok, so, you know I am not as eduminded probably as you are but I will tell you how I respond to this And maybe, maybe you will be a little born mentally flexable Every time I dont have a mechanism for remembering exactly how this goes every time. I had to think very hard and very carefully about how to set this up But what's important is that you know it can be done. That is you know you can define a function that you can pass around and apply to members of the container. Ok, that's what is important tha you know, Ok?  And untangling exactly how to do that every time is a matter of practice You had to do that everyday you realize that Oh yeah all you gotta do is declear a couple of iterators .etc
sure yeah we can pass something different here if we had a different thing. yes yes ok? yes.  so the question is can you do more than one function with a functor? so you can imagine class functors. and the problem with that is i only know how to overload  parenthesis one time and that ended depends on that function. so the thing is that what you probably can do and I haven't tested this we are in open water here for me what you probably can do is have a different one with a different parameter here yes yes I am pretty sure you can do that. you can overload operator parenthesis with different parameterization. in the same class pretty sure that will works I don't see why it wouldn't ok yes steven?  complie well I will throw back at you if it can't find that function it will say: yo you didn't define the function so that the compiler will tell you that ok any other questions about this?  oh the question is: the question is a really good one  do you only overload the parenthesis operator or can you have other stuff too?  can you answer that? based on your experience on this class?  yeah you can certainly you can probably do anything  but based on the  experience on this class I assert that you actually has used a class of this type   where was it? right. so it 's actually the PNG class rightï¼ yeah the PNG class has its parenthesis overloaded and it is the function that will look up that that position in the table yes?   right tell me where it is to stop. right here?  a value? so if it is a value  up here. so I am not ganna say no because maybe I have maybe I am imagining something different than you  but what has to be true up there its has to be completely generic there can be no expectation of any particular type. but it could be something of you could parameterize it to be something of type animal  in the template and pass one of those an element of  and then stop when you find so that will be like a find right? find an elephant for example  oh you can to change that code completely instead of comparing first and second would have to be compare the value of first with whatever the second parameter was so you can do what you are talking about different funcionality but its fine thats a nice little adaption of it  sure inside here  sure like the PNG class has a lots methods right for example and an overloaded parenthesis operator
sure yeah we can pass something different here if we had a different thing. Yes, yes yes ok? Yes? Em, so the care so the question is can you do more than one function with a functor? so you can imagine class functors. and the problem with that is i only know how to overload parenthesis one time and that ended depends on that function. so the thing is that what you probably can do and i haven't tested this we are in open water here for me Em, what you probably can do is have a different one with a different parameter here yes yes i am pretty sure you can do that. you can overload operator parenthesis with different parameterization. in the same class pretty sure that will works i don't see why it wouldn't Ok yes Steven? complie well i will throw back at you if it can't find that function it will say: yo you didn't define the function so that the compiler will tell you that ok? Alright, any other questions about this? Yeah? oh so the question is, the question is a really good one, ok? Em, can, do you only overload the parenthesis operator or can you have other stuff too? can you answer that? based on your experience on this class? yeah you can certainly you can probably do anything but based on the experience on this class i assert that you actually has used a class of this type where was it? Yeah? What? right. so it 's actually the png class right? yeah the png class has its parenthesis overloaded and it is the function that will look up that that position in the table, ok? Yes? Right Tell me where it is to stop. Right here? and a, and a value? so if it is a value up here so i am not ganna say no because maybe i have maybe i am imagining something different than you but what has to be true up there its has to be completely generic there can be no expectation of any particular type. Ok? but it could be something of you could parameterize it to be something of type animal in the template and pass one of those an element of and then stop when you find so that will be like a find right? find an elephant for example oh you can to change that code completely instead of comparing first and second would have to be compare the value of first with whatever the second parameter was Ok so yes, you can do what you are talking about different funcionality but it's fine thats a nice little adaption of it Yes Sure! inside here? sure Sure, like the png class has a lots methods right? for example and an overloaded parenthesis operator
And you can even save state, you can even save data associated with it if you want.   Alright, we need to kind of keep going because this is the end- this is the last I'm going to say about C++ specifically. So this is our last moment of talking about C++.   I threw it in here after linear structures so that we would have talked about lists in a lot of detail before we did this lecture.  And so, we're moving into data structures proper.   This is the data structures portion of the course.   And it makes me excited!!  Alright, we're going to start with trees.   Donald Knuth says it's the most important nonlinear structure in computer science."   DUN DUN DUNNN!   Okay, so I have drawn you a picture of a tree here.    If you notice a tree is simply a collection of vertices and edges, but it's a special collection of vertices and edges And I want you to meditate for a second and then remember a way of characterizing trees from CS173 Okay so think back to your discrete math experience I know there are lots of different ways of characterizing trees, but I'm looking for one in particular  Bye Tim, I'm sorry I hope you feel better Alright, so I'm looking for one particular way of characterizing trees.  So think back, what was the definition of a tree from CS173 A definition From your discrete math experience I love this because, you know, there's this word on the street, this meme that says ohh you don't need 173 for 225"  Like oh yeah? This moment right here. Hey, characterize a tree for me.  What would I do if nobody- yeah? [Student speaking] An undirected graph with no loops Okay good So, we're going to go with the undirected part as a given So I forgot to actually say that. So yes, we're going to start with an undirected graph. I'm going to reinterpret the no loops part I'm going to reinterpret the no loops part to say that it's acyclic  So a tree is an undirected graph. We'll usually assume undirected here.  That is acyclic and there's another key word Is every acyclic graph a tree? What other characteristics must it have? What, who's talking to me?[Student speaking]Â  Connected, that's right So, a tree is a connected acyclic graph Any question about that? Alright, there it is Here's an example of one Now, this is a little bit premature.  We're not actually going to study general trees yet Later we will, but we're not going to study general trees yet. Rather, we're going to further specify the kind of trees we're going to talk about first. To do so, we're going to pull out a special node, and call it the root. And the trees we're going to study are rooted trees Furthermore, we're going to make it so that every path from the root is a directed path So these are rooted, directed trees The directed path away from the root And furthermore, we are going to differentiate our trees based on order That is if I redraw this tree so that it looks like this 4, and then 1, 2, 3, 5, 6 If I draw this tree like this 1, 2, 3, 5, 6,  That tree is different than this tree 4, 1, 3, 2, 5, 6 So it's rooted, directed, ordered
And I don't know how to draw attention to the fact that I  switch this. Now by convention, we are always going to draw these trees hierarchically. We wouldn't have to. right? Like we could draw like this andÂ  say oh you know there you started  travel clock in their orders determined by a uh...clockwise rotation around the root.  But we are not getting to do that. We are always going to draw them with the root at the top. As backwards. The root at the top. And we won't draw these arrows either, because they are always directed away from the root. So we won't actually draw them in most of the pictures.  Ok. Any questions about all that? Ok. So today is not tree day, it's actually rooted directed ordered tree day.  Ok? All right. Any questions? You good?  Alright. So here's the problem.  A classic course in a discrete data structure would spend a whole day on definitions. And I can't do that because it will put you to sleep. You will be asleep at the end of it. So what I'm gonna do instead is ask you to infer and to create your own definitions in your brains  probably review should be reviewed at this point. Of all of these terms, based on the...based on this example tree,  right here, and I wanna point out as you answer these questions that the first two intend for this not be interpreted as a rooted tree.  And then the rest of them do intend for this to be interpreted as a rooted tree. So the first two, no root no direction nothing special, uh but then the rest of the exercises assume tree as rooted. OK? Alright, and directed, and ordered. Ok, any questions about all that?  So spend a few minutes doing these questions, uh, I think you can use about three minutes for this. Go fast.  And you can do in pairs. You can do it socially if you like.  Anybody wanna come up here and do them? Here? I want a pair of people like a commonly routine. Like a...like the oscars, right?  The academy awards to people could come up and share. All right. What's the longest English word you can make using the vertex labels in the tree? What?  Alphabets? No. There is no F. Oh wait there is an F. There is no P, H.  No. No just use the vertex labels and make a word. Like I could make high", h-i-g-h, right? I could make high" like "high", but I could also make h-i-g-h as an example, ok? Sure. Because I'm allowing for re.... It doesn't have to follow any connectivity, just using the vertex labels. Ok? Yeah, it doesn't have to.......That's the longest word you could make, could those letters? Yeah? Yeah. So wait! So read the question carefully. It says, using the vertex labels in the tree.  Ok? It doesn't say that you have to honor the connectivity.  Ok? I don't care where you walk around on this structure. It's fine. Just use these labels and come up with the long word. Or not. 
Anybody have longer than baggage? Oh, haha. Alright, fine. Debaggaged. Ohhhhhh. Now there's no 'R'. Okay. Alright, the only lesson we need is to read the questions carefully And make sure, you know, what's being asked at all, you know. Not being entirely here, so, fair, fair point Find an edge that is not on the longest path in the tree. Now we are talking about connectivity. Now we care a path is defined on edges that exists. So what's an edge not on the longest path in the tree. And I understand that's not unique, but the edge is unique. What edge? Yah. A to B, very good. How should I write that? How should I represent this edge? So I can draw very easily right?  Oh look, here's the edge. How should I label it? What's a good name for that edge? AB right? There's a lots of way to do this, I'm going to do this right now. OK? Since it's undirected. Since it's graphic is undirected, I'm going to say that that is equivalent to edge BA. Alright, for the rest of the exercises, assume the tree is really one of the vertices is called the root. Guess which one is this? Everybody say it? Good. Make an English word containing the names of vertices that have a parent but no sibling, or brother. Well the words are those. So B, G, H. Think of word that have those three letters. Huggable. Okay. Yah, containing, here we go.  How many parents does each vertex have? One except for (root), okay. And I pointed that out because programmatically, it has implications. Right? It makes special case in that respect.  If you're writing code that refers to its parent. It makes a special case of the root only in this structure. Right? Alright, which vertex has the fewest children it's a tie between E, F, I, J. So I'm going to make a little set of them. Which vertex has the most ancestors? I and J, it's tie. Good.  Which vertex has the most descendants? That will always be the root of the rooted structure. List all the vertices in b's left subtree. So there's a lot of vocabulary there, and when we talk about left, we referring to the conventional notion of left, okay? It means, this, it's not as b adds a standing on b's left, okay. Very confusing. It's b's left as you're looking at B. So all vertices in b's left subtree, E, C, F, in no particular order. All the leaves we're asking about that set again, E, F, I, J. Okay. any questions about it? Good? No surprises? Yah What's the longest path? It's the path with the most edges on it. Path link? Okay I'm not going to say this now. I'll so more formally later. Path link is determine by how far you walk, if you're walking on a graph. Which means the number of steps you take, or the number of edges that you traverse. So path link is the number of edges, not the number of vertices. Okay? Alright, any questions about any of this? Alright, let's keep going here. Oh good we got time. This is my favorite tree. It's my favorite tree. No it's not Pokemon. Pokemon would be a good one too. Can you tell what it is? Mario
Yeah, so these are the, these are all the Mario Games.  I said, I describe this as the Mario family tree, but it isn't really that. It's family is not that big, but there are, this is the set of games as of 2007, so I actually don't know what happen after 2007. But I'll bet you can tell me what this is. You know what this is? Super Galaxy I believe. Mario Galaxy. Sorry, I am not actually as well birth as I am pretending to be here, OK. Not as cool as that. Amm..  but here is why, here is why I love this tree. This is why I love, so first of all, raise your hand if in your household you have had one of the games on this chart. OK, or you have played it. Or, yes, so I am thinking 90%. Tell me what this game is. All the way to top No, you can't read it, it's Donkey Kong. And Donkey Kong like was That's from my childhood, right? So this thing here connects us in a very unexpected way, right? Like it's one of very few things that like spends the ages and, so I love this cuz it connects me to you. I also love it because Donkey Kong itself is the substance of a painfully fantastic movie called 'KING OF KONG'.  Did you not.. 8.4 user rating I think? I'm not sure. Maybe only 8.2, but 'Fistful of Quarters' is the subtitle. 'King of Kong' is a documentary about professional 'Donkey Kong' players. And..  and.. I say it's painfully fantastic because we know people like this. We might even be some of us probably, people like this. So anyway, that's my recommendation for Friday night. Am.. maybe we should screen it in Siebel. I'm not sure. Or here, we can screen it here to get permission. Alright, anyway what I really wanna know is, what I really wanna know is if you were making this into an application  into an application on an iPhone Apple whatever, that is if you were allowing for electronic navigation and manipulation how would you configure memory, so as to ah.. how would you configure memory that is what structures would you use, how would you do this so as to store all of this things. What would you do? If this is a tree, probably worth figuring out where are the vertices cease and where are the edges. Where are the vertices cease? The, the games themselves, right? And where are the edges? Yeah, so I think that instead of you know, instead of these edges that they are actually drawn, maybe what is really going on here is like is. You know that this is a sub-structure that would be meaningful to us. OK. So know what I'm asking you is what does the node look like? What does a node in this structure look like? What does a game look like? Is the same question, right? Games are nodes, what does it look like? What information does it have?
Yeah, so there are all the Mario games.  I describe this as the Mario family tree, but it isn't really that.  It's family is not that big, but this is the set of games as of 2007.  So I actually don't know what happened after 2007, but I will bet you can tell me what this is.  You know what this is? Super galaxy I believe. Mario galaxy, sorry. I'm not actually as well birthed as I'm pretending to be here, okey?  Not as cool as that. But, here is why I love this tree.  So first of all, raise your hand if in your household, you have had one of the games on this chart.  Okey, or you have played it, or... yeah.  So, I'm thinking 90%.  Tell me what this game is. All way to top. No, you can't read it, it's donkey con.  And, donkey com, like was that's for my childhood, right?  So this thing here connects us in a very unexpected way, right?  Like it's one of very few things that like spends the ages.  So I love this cause it connects me to you.  I also love it because donkey com itself is the substance of a painfully fantastic movie called King of com".  Did you node? 8.4 user rating I think, I'm not sure. Maybe only 8.2, but.  A fistful of quarters is the subtitle.  King of Kong is a documentary about professional donkey kong players.  And, I say it's painfully fantastic because we know people like this.  We might even be, some of us proudly people like this.  So, so anyway, that's my recommendation for Friday night. Maybe we should screen it in Siebel, or here. We could screen it here, to get permission.  Alright, anyway, what I really know is, what I really know is, if you were making this into an applicaiton, undefined Into an application on iPhone or Apple whatever.  That is if you were allowing for electronic navigation and manipulation, how would you configure memory?  So as to eh... How would you configure memory that is what structure would you use.  How would you do this so as to store all of these things?  What would you do?  If this is the tree, probably were figuring out where are the vertexes and where are the edges.  What are the vertexes?  The games themselves, right? And where are the edges?  Yeah, so I think that instead of, you know serves there edges as they are actually draw, maybe what is really going on here is like this.  You know, that this is the substructure that will be meaningful to us.  Okey, so now what I'm asking you is, what is the node look like?  What does a node in this structure look like? What does game look like?  It's the same question, right? Games are node, what does it look like? What information does it have? 
Ya, so these are all the Mario games. I said I described this as the Mario family tree but this isn't really that. Family is not that big. But there are... this is the set of games as 2007 so I actually do not know what happened after 2007 But all that you can tell me what this is. You know what this is? Super Galaxy I believe. Mario Galaxy, sorry. I am not actually as well versed as I am pretending to be here, OK? Not as cool as that. But, here is why I love this tree. First of all, raise your hand if in your household you have one of these games on this tree. I am thinking of ninety percent? Tell me what this game is. All the way of the top, no you can not read it. It is donkey kong.  And donkey kong like was from my childhood, right? So this thing here connects us in a very unexpected way. Right? Like it's one of very few things that like spends the ages so I love this cause it connects me to you. I also love this because donkey kong itself is the substance of a painfully fantastic movie. Called king of kong. Did you know 8.4 user rating I think I am not sure. May be only 8.2. But it is full of quarters. It is this subtitle, king of kong. It is a documentary about professional donkey kong clears. And I say it is painfully fantastic because we know people like this. We might even be. Some of us probably are people like this. So anyway, that is my recommendation for Friday night.  Maybe we should skirmish in Siebel or here. We could skirmish here to get permission. All right. Anyway what I really want to know is if you were making this into an application.  An application, an iphone app or whatever. That is pure allowing for electronic navigation and manipulation. How would you configure memory? So as to... How would you configure memory that is what structures would you use, how would you do this?  So as to store all of the things, what would you do? If this is a tree, probably worth figuring out where are the vertexes and where are the edges. Where are the vertexes? The games themselves right? And where are the edges? Yeah, so I think that instead of insert these edges that they are actually drawn. Maybe what is really going on here is like this. You know this is the substructure that would be meaningful to us. So now what I am asking you is that what is the node look like?  What does a node in this structure look like? What does the game look like? It is the same question, right? Games are nodes. What does it look like? What information does it have?
it needs a name it needs a picture what else? it needs.... it's.... it's children right? How are we going to store it's children? inside it and an array maybe. right? maybe an array? this question this design moment is relevant and but yet just a little beyond us at this second because it's not really true that what we're going to study is rooted, directed, ordered trees rather we're going to study rooted, directed, ordered, binary trees so rooted, directed, ordered, binary trees what is binary mean? aka binary trees and i'm not gonna say the rooted, directed, ordered part ever again i'll just refer to binary trees so what does that mean? it means that every node doesn't have a million children like the mario structure did but rather has only two and they are specified as left and right we specify them and refer to them as left child and right child ok any questions about that so far? so we will start on friday  maddox are you listening? we will start on friday with a recursive definition of a binary tree
binary trees
everything else has a child, so 18 has one child, 20 has two children 20 is called the root node it is the only node in the tree that has no parent so everything has one... every node has exactly one parent now, a little bit trivia there will be, if there are 4 pieces of data in the tree there will be 5 null pointers if you think that through like you have one piece of data you have two null pointers you have two pieces of data you'll have 3 null pointers because one of the one of the null pointers gets used up to point to the other thing, the new thing you add adds two, right so you're always leaving one null and adding two new ones every time you add so here we have 1, 2, 3, 4 , 5 for the 4 pieces of data the other thing that's really interesting all the leaf nodes you take them all together that's called the fronteir of the tree in a binary tree, half of your data is gonna be in there so you can imagine if you wanna do something to this tree you have a pointer to this you're gonna have to descend down, go looking around to find your data half of it is gonna be as far away as possible as it can get from the orot which is not very far, usually but that's something to think about now try to imagine in your mind how you're gonna implement this thing you're at the console, you've opened up vim, cursor's blinking at you, what are you gonna type? try to imagine that, you can look at your handouts i printed something there i shouldn't have done that, okay a little typo that should be class <T> but the slides are very forgiving compilers in that they don't complain if there's an error so this is just a standard we have a wrapper class i'm gonna call binaryTree today and then inside that wrapper class is gonna be the node which actually contains the data so the wrapper class handles things like maybe keeping track of the size, it needs to keep the root pointer so it knows where to enter the data structure and then the node class is where all these all these pretty diagrams come from so how's this looking for you guys? do you like this? it's making sense? alright now this is a recursive data structure, so almost every function you write on these things is going to be recursive you could use a for loop or a while loop but it's actually not as natural uh, how do you guys feel about recursion? how many of you think you know it'd be nice if you reviewed that just a little bit before moving on?" yeah? alright i mean like no way man i'm sick of recursion" well really, the only thing you have to do to know recursion is to understand recursion alright well let's talk about it i actually want to draw a recursion i know cinda's talked about it i wanna talk about it again because recursion is the second most powerful concept in all of computer science abstraction if you know abstraction, you know recursion, you are a computer scientist so you don't even need a computer hahahahaha it helps but you don't really need one alright, so i wanna talk about proof by induction how many of you are familiar with proof by induction, how many of you feel like yeah i got proof by induction and i'm okay with it"? how many of you feel like ehh" i hope it's not on the test alright so proof by induction, this is the wonderful thing about computer science we have turned being lazy into an art form and we've tricked people into paying us dearly for it so here's how it works, proof by induction we have a property, i'm going to call it P(n) so some property P we just give it a name cause i don't wanna think about a specific one right now n is some thing, maybe it's integers, maybe it's trees, doesnt matter uh, as long as you have some idea that there can be... if you have n you have some concept of what a smaller version of that n might look like, so for an integer, it's easy to make a smaller one, just subtract one right? for a tree you have this tree, how can you make a smaller tree? you go to the left or right side now you've got a smaller tree now this gonna turn out to be very important that you can do this the other thing you need is the idea that you have the smallest version of a tree, the smallest tree is a leaf or maybe null depending on how you're thinking about it, so what you do with induction is you say that for n=1 or whatever the smallest thing is, you prove that your property is true for that and that's usually really really easy, almost trivial, right? and the induction case, what you do is you want to prove p(n) now some places they'll say you wanna prove p(n+1), doesn't matter it turns out to be the same now you just assume that p(n-1) is true, you pretend that you have some grad student go off and do all the work for you, you come back with it and you take all their credit, okay? so uh, don't tell the grad student union i said that the uhh so what do you do with this? you use this fact to prove this fact you say if this is true then with a little bit more work, then you can prove that this is true also now here's the beauty of it, you did not pick a specific n
Therefore, it's like you prove all of them simultaneously. Now, this whole n minus one thing, the only reason this works is because you prove the base case. Now have you even those camping cups, where they kind of open up. They're like  inside of other rings. I don't know may not seen it. Or maybe set up a bunch of dominoes, you have to be able to knock the first one over. That's what the base case does for you. Now, let me go over a concrete example to illustrate this Now you may not have known this but if you take the first n odd numbers and add them all together, you actually get n squared. So next time youre at a party you can tell people this. They'll look at you the way they always do when you talk at parties Hey we're all geeks here, we're used to this. Right? You go to a party and say yeah, I'm studying CS yeah I;m learning all these theories and these data structures and they look at you I have this problem with my word processor you know? That's gonna be your life. Alright so, base case, n = 1 right? This just 1 all by itself, 1 squared is one, so Base case is true. Got it.  Now what you do is for the induction case, you want to show the P(n) is true but you assume that p of n minus one has already been proven true. What's p of n minus one, you take the n - 1 odd numbers and just assume that they're equal the minus 1 squared assume that that worked out, now what do we do? We add the nth odd number to both sides and theres this huge huge cloud of algebra and when the dust settles you got n squared that's how proof by incuction works is this making sense?Â  I'm not gonna make you reproduce this, but looking at this like okay I get what's going on are there any questions? there's a nice geometric proof odd this too if you take a square and you go down the south and east ends keep layering more squares you get a nice geometric proof too. Now the reason why im showing you induction is that recursion is actually the same thing. a recursive function is really just a computational proof by induction because what you have is just some input you have two cases, you have a base case, and you ahve a recursive case so when I teach I will often use recursive case and incuctive case interchangeably beacuse it's really the same thing right? so here's a cfunction that can computes n square it's not very efficient but it uses the same algorithm so this is the base case y is 0 this time if i should have wanted to set n = 1 and returns 1 but then when i return i take n square of n  -1 and just assume that it gives you the right answer, dont think about it too much and then what are you going to do with that? youre' gonna add the nth odd number to that and that gives you the recursive function the recursion and proof by induction are really the same thing now uhhhhh one thing about recursion that you need know that this is about CS culture. have you heard the story about the little kid who asks his  dad what's holding up the world. the dad says well it's an elephant. so the little kid goes away happy and the day later he's thinking about this and comes back and asks, dad what's holding up the elephant? A Hippopotamus. Oh okay kid goes away this time and hour passes. he comes back and goes so what's holding up theÂ Hippopotamus? a turtle. come on dad whats holding up the turtle, he says son its turtles all the way down. okay if you forget this thing that check for the base case, you're gonna get turles all the way down youre gonna get an infinite loop and so you'll hear people talk about this. when they talk about recursions if a recursion goes or if you get an infinite loop or something like that youll hear someone say oh it's turtles all the way down. That's what they mean. That is where it is come from.  this is really just the same thing to say so what do i dofor my base case , what do i do for my recursion case, the only thing different is you have to tell the computer how to tell the difference so you have an if statement Hows this? is this good? is this helpful? If it's not well too bad sigh.... alright uhh I actually like recursion far far better than for loops and while loops uh they take a little bit of getting used to but once youre used to them they actually tend to be far more reliable and uh when you take cs421 with me I'll tell you all about that but alright lets see lets go on so here's what a recursive function on a tree will look like so the base case for a tree usually its a null you wanna know what happens if there is a null tree node coming at uh so youll do your base case here and the recursive case what will happen is you'll call two recursions one you go down the left side one you'll go down the right side and you'll take the data and youll do something to combine them all together and that's it, that's really all there is to it alright lets look at an example now try to think about how would you define the height of a tree?
You sitting down there's an exam and says ok, write a function that computes a tree. How would you do that? Go to web browser www.google.com? Better not do that on my exam. Alright yah.  Yeah. So it's longest path from root to the leaf. So to do this recursively, you're gonna have to think about ok, what's my base case?  Well if you get a NULL, that's a zero height tree. Now, what's your recursive case is gonna look like. You have a node that's not NULL, you go down the left side take its height, go down the rightside take its height.  What are you gonna do with that information? Come on, yell it. Yah compare them. And you're gonna take the biggest one right?  SO just take the max, and add one for the root that's your holding onto now, the nodes you're holding onto now and that's it. So, you return zero for the NULL, you take one plus max of the heights of the two children. How's that? Does this make sense to you everyone? Any questions?  You probably noticed by now, my lecture sounds very different than Cinda's. I like to do life codings, so if you have any questions or wanna see an example, we can just type it up and run it and see what happens. Ugh, so here move it down little more. So here's a tree, so 10 is the root, then 20 is one child then 15 and 25s. We want height.  Let's do this. Take this, paste it in. It's fun showing off. Come on. Actually I'm not gonna be very good at showing off. I haven't programmed the C++ since I was undergrad here. So I actually don't remember half of this stuff that we used to do. I don't even remember there's actually a max function. There it is, that's good. It'll look something like this. So, if we have something in here, we're just gonna return one plus max of the two things. Otherwise, we'll just return 0.  Let's see if it compiles. It compiled, that means it works, right? uhm... well, let's move on actually. Oh you want me to run it?  That said three, uhm... that's right this time. Looks like it worked. Let's hook it to the space shuttle. Alright now how about the sum of a tree? Pretty similar, right? Though, here it's NULL. That we'll wanna do for the NULL? No, you'll get a seg fault right? Null, you probably wanna return 0. Uhm.. Otherwise, you return a data + sum of the left and sum of the right.  Good so far. Alright, your turn. On your handout, there's this crazy function that asks you to write.  So here's what we'll do. Spend maybe 2,3 minutes. Don't feel like that you gotta get every bit of syntax just right, but try to figure how to do it in about two minutes three minutes, I'll say something and then turn to your neighbor, compare your solution. Then after that we'll talk.
 it said binary trees but really there functions are nodes i wil fixed that to  hows that going? yes? yes?  you wanna call some of your own funcion? sure  well so the idea is that you will call calc on the left subtree and the calc on the right subtree thats gonna give you a value and the way it ganna combine those is determined by the current node you have so if it say if it is a minus one you add them if it is minus two you multiply  so positive numbers should only come to leaves otherwise  you ganna chunk it a lot of data I mean really that what we are computing is that important. the whole idea is ok can you think recursively what we are doing that's the point  alright why not you turn to your neightbour and just outline what you had in mind I am not really looking for you to write down the full code and have it compiled or  the reason I do that is  it turns out if you actually expanded thoughts trained  work with this your brain figures out that its important it will keep the data longer. you just watching a lecture and nodding: oh yeah, thats cool! I got it!\ it turns out that after you leave 5 minutes later you know what happens its all gone right? you ever had the feeling that taking an exam that you took out every information out of your head you put it on the paper you give it back to the professor we try to avoid the situation here so I want you to turn to some one show them what you have in minds see if you agree
[Video Playing] Alright Let's talk about this, so we're gonna call this calc  [Video Playing] What's my code [Video Playing] Is there an else if? [Video Playing] Else space if alright fine [Video Playing] Alright so [Video Playing] n data is what? [Video Playing] You want to do the greater than equals zero? Ok [Video playing] And just return the data right? [Video Playing] What are we going to return now? [Video Playing] Never type something twice if you can avoid it Cut and paste and then modify it [Video Playing] Alright, lets see if this thing works now. [Video Playing] So we have this population. So this was a minus two,  this was a minus one This a two, this is a one, this a minus one this is a six and a eight [Video Playing] And so what we want to do is we populate, we calculate it's height and then we'll calc it [Video Playing]  Alright it said forty-two So the code's right even if the math might not be Let's bring that back up So any questions on this code? Does everyone get this? [Video Playing] Is there any other fun thing with a tree you might want to see recursively? Anyone want to see an example? [Video Playing] Don't worry tree functions will get a little more complicated later on What's gonna come next is something called a binary search tree Where there's a lot more constraints. Right now we just have these nodes and the top nodes connected to the bottom nodes So the recursions tend to be a little simple cause we don't have to worry, we're just traversing [Video Playing] Alright, last call. Any questions? [Video playing] Do you feel like you could write this now? Ok good  [Video playing] Alright, so there's one really interesting recursion Looks kinda like this You have three lines, you print the node and then you preorder the left, you preorder the right and you really should have an if in there to check if it's null but im just showing you the outline
[Waiting] Let's talk about this, so we are gonna call this calc() What's my code Is there a else if .... else [space] if alright So... in n->data is what.... You wanna do the >=0"? OK And just trying to return data, right? What are we gonna return now? Never type something twice if you can avoid it. Cut, paste and modify it Alright, let's see if this thing works now So we have this population... this is a -2, this is a -1 ...this is a 2, this is a 1... this is a -1, this is ..6 ...8 Then what we want to do is we populate, we calculate its height and we calc() it Alright it said 42 So the code it's right even if the math might not be So any questions on this code? Everyone get this? Or is there any other fun thing about a tree that you might want to do recursively; you'd like to see it in an example? Don't worry, tree functions will get a little more complicated later on What's gonna come next is Binary Search Tree Where there're lots more constrains Right now we just have these nodes, top nodes connected to the bottom nodes So recursion seems to be a little simple because we don't need to be worry, we just traversing  Last call, any questions? You feel like you can write this now? OK, good There's one really interesting recursion: kinda like this You have 3 lines, you print the node, then preoreder the left and preorder the right. You really should have put an if to check if it's NULL but I'm just showing the outline
What this is gonna do, is, it's gonna visit every single node in the tree but in a certain order.  It will look at the current node, it will print out it's data, and then it will visit everything on the left side, and visit everything on the right side. This is called a pre-order traversal, and it has an interesting property.  So, this particular node, how many times is this function going to be active, while this node...while it's thinking about this node. It actually will happen three times.  You'll come, you'll call this function on a node, and you'll say okay, print out this data", so it's one visit.  Then youâll go down here, go down the left side, and do whatever, and then youâre going to return.  So thatâs the second time this function has control over the node.  After that the function is going to call the right side, do all that recursion, thatâs gonna return, and so then the third time, this function has control over the node. So this kind of traversal pattern you have three opportunities to do something with the tree, the data of the tree at that particular location. So, I made an animation for you. So, hereâs a tree, and I want to traverse it.  So, I call pre-order on the root, which is a 12 here, and Iâm gonna put one dot for every time, the function has examined the node.   And down here, Iâm gonna print out, the nodes in the order that I visit them.  Okay, because, in the order that theyâre printed. So, I do twelve, then eighty one, then seventy three, so, because it keeps calling, and it calls print, then it calls on the left side.  Now when it hits the seventy three itâs going to go down the left side, and thatâs a null  And itâs gonna come back and go down the right side, thatâs also a null. So now itâs gonna return back to the eighty one.  So whatâs gonna happen now? Itâs gonna go the eighty four, right?  So it goes there, left is null, right is null, itâs gonna go back to eighty one, and itâs gonna go back to twelve.   And then itâs gonna go to seventy three. Is this pattern working working for you?  So, to speed things up... then finally we return all the way back to the root.  So, this is called preorder traversal. There are languages which use this exclusively.  All the Lisp dialogue languages, so Clojure, Lisp, Scheme, Bracket, they all use preorder notation for everything.  So if you take the honors section, you get tons of preorder goodness.  Uhh, soâ¦we can also takeâ¦what happened here?  Yes, this is what I want. So I call the preorder yet, itâs actually post order. Right, because now, Iâm printing at the very end. So on my third visit of a node, I do the printing out.  So, here, twelveâ¦because after I visit all the children, then I come back, thatâs when I print the thing out.  Fifty three, then twenty nine, then seventy three, and twelve. This is post order.  Now, when I was a student, everyone in engineering had an HP calculator that used reverse polish notation, is that still true? Or have they gone soft and switched algebraic? Theyâve gone soft?  Oh, thatâs disappointing. Alright, so this reverse polish notation, its called.   Itâs because you type in the roots first, then you type in the parent. And there are languages which use this, so if you ever get the chance to learn a language called Fourth, pick it up and play with it.   Spend an hour with it, itâs kinda cool, because to add something, you have two numbers, youâll type the first number, so ten plus twelve, you type ten hit enter, you type twelve hit enter, then type plus.  So basically, itâs using a stack. You push the two numbers on the stack, and plus pops two numbers off, adds them, pushes it back on. So it has this kind of traversal pattern. Alright. Why did it double all of these traversals? This is weird. Part three. 
d Slides are wrong. This slides show preorder instead. Explaining inorder traversal (slides are wrong) You can reconstruct the original tree if given the preor You can reconstruct the original tree if given the preorder, postorder, or inorder printout Preorder traversal: + * 2 4 - 9 3 Postorder traversal: 2 4 * 9 3 - + Inorder traversal:  2 * 4 + 9 - 3 Explaining process of traversing tree See powerpoint slide for the example
Professor is figuring out why the slides are messed up Going over the example First you want to build the original tree. Did everyone get that tree? What's the preorder for this: yell it out [student answers] I will post the pdf of the slides to piazza. I will post the code and the slides to piazza answer: 2 3 * 9 9 * * This lecture had over a hund this lecture had over a hundred slides, i'm crazy
[Video playing] Alright, we'll see ya monday!
Try to go to, how do you register online as a grad student? normally, umm... Okay, and the link didn't work? Okay, What link do you use when you sign up for courses? So you're a grad student, right? So whatever link you use to sign up for courses as a graduate student, try that one? Do you have a my cs account? Do you have a webpage my.cs.illinois.edu. Does that work for grad students? okay um,  oh, okay okay alright um You can audit if you want. here's what you need to do to. Go to the academic office in Siebel Center Tell them that you're a graduate student in statistics You need a paper form because you're not in the engineering college. Siebel, the first floor there's a big office called academic office, yeah go in there and they can help you. they're very nice people What's your name? Hi
[Video Playing]W What's your name Nova I am Cinda. You got it. Oh, that make me uncomfortable. Ok, Nova said is time to work.  Time to play school. You guys had nothing back there right? Can you hear? My laptop is connected, everything is connected. OK, how about this one? This one is going. Ok, I apparently can't the volume or anything. And, this is one had not bug at all. You know, there are could have many million ways the day could had gone wrong. Given how prepared it was. I was't expecting this one. So, here is the deal. You have a guess lecture, and I heard went very well. And so grateful. I got to spread the day on the lake in the mid of fall in northern of Wisconsin. It was the trees, you know what? The trees were not upside down. It's a bad joke, I don't even know. I'm just going to like use all the mics. Ok, Alright, here is the deal. Mattox what he cover would have been cover what I cover today Mattox what I am going to cover today was we would had done in last Friday. So, the topic are little bit switch in order. But I don't think it matters. In fact, if you could in fact you could argue that there are benefits to have not seen the implementation haven't seen these thing in action. And then returning to something of the sort of the mathematical notion and representation of them.
We'll see...You can let me know afterwards it did work for you. Let us know because it's our class. All right. So ..um.. I don't know. I don't know what's gonna happen with the MIC. All right !Oh..not that. I have no packets.It's not funny.I'm not...I really... OK.Here's what I need. I'm gonna send really close . What I want you to try to do is take this class out of here and put it on that one, okay? Oh but wait a second. If this makes you uncomfortable you can pass the test to..... Okay. All right so we're gonna talk about binary trees. I'll catch up later if you want.  Remember we're not talking about binary trees, we're talking about rooted, directed, ordered binary trees. And I'm never gonna say that again I'm just gonna say binary tree. Because most of the, actually it's the equivalent facts that most of the function we're going to write are on this structure because this structure is recursively defined. So I want to give you some of the symbolism that typically used with recursively defined structure. Thank you. And that can be turned off. All right. So the question is how is this thing recursively described? Okay, now I'm not writing code. But the way I described this thing is going to inform the way that I write code about it. OK. So binary tree T is either empty ...... please things work....Oh no.... I cannot believe this. Okay. It's either empty and the way we're gonna represent the symbolically is to say T equal empty dragon brackets. Or, it is a root together with two subtrees. Or T is a root together with subtrees and I'm call this root r subtrees Tl and Tr. What's the L and R stand for? Very good. And the way that I'm gonna write it symbolically is T is equal to R with Tl and Tr. So I'm gonna make a tuple out of this. And write it like that. Okay. Any question about that? While the first thing means a root, the first thing has type root, and the second two things are binary trees. And that's the recursive part of this definition. So we say and Tl and Tr are also binary trees. Okay. Any questions about that at all. Now notice how this shapes the code that we write for any function on binary trees. What is the base case? What's the base case of any recursive function we write on binary trees? It's empty! right? Or however we represent that empty tree. We think it might be NULL. Good idea. Then we're gonna do some action on the root and then call the function itself on Tl and Tr. So this definition informs how we write code for this structure. Any question about it ? Now I have a question for you that is does this definition work? Think about the right subtree here. Think about the right subtree. It kind of unroll the recursive definition in your mind. Does it work? Yeah, okay. How that right subtree... is it empty?  No. So we say root together with..
The trees, TL and TR, and are they binary trees? Yes! Because they are empty, right? Look. It's there's like an empty tree there and an empty tree there. So this recursion sorta feel sane to us. What if I erased um..This leg. If I erased 5, and asked you to consider this binary tree. Do you like it? Is it ok? Does it feel like a binary tree? Sure, it's a root together with left and right subtrees. The left subtree has some substance and the right subtree is...is empty. So we're OK. Alright, any questions about that recursive definition? OK, well...Uh...Let's see. So we're going to write functions on these structures and these functions can come in lots of different forms and in fact the data contained in this...The data contained in this particular example tells you about one of the functions you can write on binary trees. What does that data look like? What does that data remind you of? Can you imagine? Computation, right. Evaluation of an expression, that's right. So, in fact, you can imagine that every subtree is like a parenthesized phrase, right. So this triangle has parenthesis around it, this one has parenthesis around it. The whole thing has parenthesis. So this is an example of an expression tree and if we know how to get around on this structure, using say...Traversal. Then we may have a good way of evaluating such a structure. But we're not doing that right now. Okay. Alright, so let's write some functions on this structure. The first one we're going to write is height. Now, you guys talked about height last time, right? What's wrong? We didn't...Mattox and I didn't get a chance to talk beforehand and so the definition that he used is a different one then we're going to use. Okay? So, the definition of height that we're going to use in our class is the length of the longest path from the root to a leaf. Okay? So what does that mean about the height of that tree? What's the height of that tree? Height here is 3, good. 1, 2, 3. Okay? Path length is number of steps or number of edges. Okay, that's all good and fine. Uh, what is the height of here's this example. What is the height of this tree? What's the height of that tree? Zero, very good. And what's the height of five's left subtree? This is where there's a problem. We should all be going gulp I don't know. gulp I don't know. Alright, let's talk about it a minute. Alright, so given a height, given a tree T a recursive definition of the height of T. Alright, so this is what I think is true. The height of T is one plus the maximum height. This is what you did last time. H E I G H T of TL and height of TR. Right? Nothing's different than last time. The problem is...The problem is what's the height of an empty tree? So if I draw you a picture of an empty tree, what's it's height? I drew you a picture of an empty tree, see it? It's lovely isn't it, it is both the most beautiful and the ugliest tree you've ever seen. Right? It's an empty tree. So what's the height of the longest path from the root to a leaf? Uh...uhh...What path? What path? OK. So there is no root, there is no leaf, there is no path. It's completely indetermenant. So we can choose any height we want. Now. Because we can have empty trees it makes sense to choose a height for that empty-ness, the absence, to be something that makes sense. Okay? Does something that helps us out mathematically. Well, you were already whispering what helps us out mathematically. It is the solution that gives us a zero for a single node tree. And it is, what is it? Negative one, that's right. So the height of an empty tree is negative one.Â tree? What's the height of that tree? Height here is 3, good. 1, 2, 3. Okay? Path length is number of steps or number of edges. Okay, that's all good and fine. Uh, what is the height of her
I'm making a little table here here's my empty tree I can't draw anything there. The model doesn't allow me to draw anything there Now make sure that you believe that it works. which case applies to that tree which case applies to the node containing 5 there? recursive case or base case? recursive case that's right tempting to say that's just one base case but no the recursive case applies so we're going to look at the height of the subtrees take the maximum one of those and add one to it what are the heights of the subtrees? negative one we add one and we get zero so that works out for us any questions about that? Now what gets us that freedom the freedom to ascribe whatever height we want is the fact of the defiinition the english definition is actually indeterminate on an empty tree so we can choose anything that makes our live convient maybe it was negative 42 but that would screw things up completely any other questions about this? who's yawing? oh did you get it done? i was up late last night driving back from green bay full binary tree i'm gonna tell you some things that are gonna confuse you there are three words that used to describe trees they are full, complete, and perfect three definitions they mean completely different things so this is the problem this is the problem with the language that we choose to describe these things moreover, moreover not unlike height they might have slightly different definitions depending on who you talk to. mathematicians would call what I call perfect trees a complete tree and they don't have this separate notion of a perfect tree in this context it pays when you're having a conversation with somebody about the vocabulary associated with the tree to make sure your definitions are clear i want to point that out before we do the definitions so that you can be confused going into it clarify it in your own way ok so i'll tell you an english definition for a full binary tree it is simply one in which every node has either two or zero children so is this one a full tree? sure is that one a full tree? no of course not that's what the example is for so every node has two or zero children now what i wanted to do is write a recursive definition for this this is sorta to prove that not every recursive definition is elegant unfortunately they are not i will start though with the fact that f is a binary tree which means it's probably going to be the case that we're going to use empty and not empty as the cases for our definition and indeed an empty tree is a full tree now the recursive case is what's interesting so let's talk about this and note that we have Tl and Tr to use in our definition of this full tree so what does that definition look like? what is true about Tl and Tr? right they're either  i'm gonna switch it around a bit he said that both valid or both empty say the empty part first and valid is a term i haven't given a definition to so i'm just gonna say either both empty or both not empty how bout that? so the emphasis is on both right? if i came to you and said 'huh this tree is either empty or not empty' you'll go 'yeah'  but in this case what we're saying is that they are either both empty or both not empty and my definition is not complete
Is this a full binary tree? NO. Ok.  ou agree that it is full but it satisfies my condition, TL and TR are, see? Here is T. Here is TL, itâs not empty. Here is TR, itâs not empty. And, what must I say about TL and TR. T They are both full binary trees. This is a recursive part. Ok?  So,if you think you are writing a definition about trees and you havenât use the vocabulary in the recursive definition then you are not finished.  Ok, any question about it. So I need to put like a big red.  This one is not a full binary tree.  Any questions? Ok. Letâs work on perfect.  I give you the definition here I believeâ¦ And I want you to build for me the first couple of perfect binary trees.Ok? So Iâm defining this thing to be P sub h that is parameterized by the height. Structure is parameterized by the height.  So whatâs P0.  Perfect tree of height zero. What does it look like? Single node. Very good. Now, draw me a perfect tree of height one.   Ok good. Now draw me a perfect tree of height two. Pressures on.   On the fly,  look at that. Good work.  Very good. Ok, any questions about it?  This is just a tree of height H with all the nodes.  All the nodes are there. Any questions about it.  As I say before a mathematician may call this complete tree. Ok, I have a question for you how many nodes in a tree are height h. Think about 30 seconds speculating on it.  There isnât two in the answer. So when I refer to how many nodes Iâm gonna use the vertical bars here  and represent sizeâ¦to represent size.  So these vertical bars are gonna represent the size of the trees are going to be number of nodes. So what is it. Ok, wait, say it again.  Itâs two toâ¦I think itâs two to the h+1 -1. Is that work?  Ok. Ok. Fine. I donât know if that is right or not.  But what I do know is true is that the size of Ph is definitely  s all the nodes in each of sub trees plus the root. Oh and the number of nodes in the tree of height oh I donât know.  Zero is one started there.  This doesnât really matter.
Wait a minute, so... she said this and I can argue combinatorially this, right.  The total number of nodes in the tree is all the nodes in the left subtree + all the nodes in the right subtree + the root. Okay, what is this thing right here?... It's the recurrence. Are these two different things?  No they're different expressions for the same idea. But how do we prove it, using induction. We have a recurrence which is easy to write down and a hypothesized solution and in order to make agreement between the two we could do arduous arithmetic like from calc 1, or we could simply prove that they are the same inductively.Â  fffh Â Â  We're going to do an inductive proof today, just not here though. K, so prove that these two are the same Via induction, and I'll warn you that I didn't really check this, is it actually h+1 or is it h? Â It's h+1. Alright, how about another question, lets talk about a complete binary tree. If you read that english definition it stinks, it isn't recursive, it's like a perfect binary tree except not all the nodes on the bottom level are there, and moreover all the one's that are there are pushed to the left?  What Kind of definition is that? it turns out, that to be extremely useful to us, we're going to pursue making an elegant decision, but first I want to make sure that everyone can draw a picture of a complete binary tree, so please draw me a complete binary tree with one more node than I have, so one with 13 nodes. This is a complete binary tree with 12 nodes, so node #13 has to go right here, otherwise you either mess up the height or you you add a vertex so that everything isn't pushed to the left, leaving one spot for the node, right ... here. Any questions about that? Â Now because we like recursive definitions, we are going to solve the puzzle of expressing this kind of tree recursively.  In this definition you can use your definition for a perfect tree as well. What I want you to do is to figure out what this definition looks like.  My hint is to use the example to craft one of your cases and to think what would happen if this were a tree with ten nodes for the OTHER case, take a fewÂ minutes coming up with this definition.
Wait a minute So she says this and I can argue combinatorioally this right? Do you see that? I can argue this combinatorioally  The total number of nodes in the tree is all the nodes in the left subtree  plus all the nodes in the right subtree oh and they are the same plus the root yes? ok what is this thing right here? How do you describe it? What is it? The recurrence? This is a recurrence are these two different? things same they are different expressions for the same idea different expressions for the same thing oh yeah prove it how would you prove it using induction That discussion that we just had there was a total conversion like dinner conversation We have a recurrsion recurrence which is easy to write down and a hypothesized solution and in order to make agreement between the two we could do ardous arithmetic like you did when you took calc 1 or we can simply prove that they are the same inductively we are not gonna do it here but i just wanted to bring that in this moment ok any question about it>? We are going to do an inductive proof today just not here this ones almost too trivial this should have come from the discrete math alright any questions about it? k so, prove these two are the same via induction and i'll warn you i didn't really check this is it h+1 here or is it just h ok alright fine the other way you can prove it is by asking the class any questions? got another one for you lets talk about a complete binary tree shakin my head, shaking my head i'm shaking my head  if you read that english definition, it stinks it's not recursive, it doesn't evoke recursiveness i mean listen to this it's like a perfect binary tree except not all the nodes on are the bottom level there and moreover the nodes that are there they're all pushed to the left the heck? the heck what kind of definition is that well it turns out it's extremely usefull to us and so we're going to pursue so we're going to actually pursue making an elegant definition of it but before we do so I wanna make sure that you could draw a picture of a complete binary tree so please very quickly draw me a complete binary tree with one more node than i have 7,8,9,10 than i have 13 nodes and you shouldn't start from scratch yeaah right look this is a complete binary tree with 12 nodes where did that 13th one have to go? it has to go right here right? it has to go here otherwise you either mess up the height either mess up the height so you have leaves on a bunch of different levels or you add a vertex so that you that you don't have everything pushed to the left there is really only one place where that 13th node can go and i'll put in here really quickly like this ok any question about that? alright fine now because we like recursive definitions so much we are going to solve the puzzle of expressing this kind of tree recursively in this definition you can use uhh your definition for a perfect tree as well ok and what you want you to do is figure out what this definition looks likew my hint here my hint here is to use the example to craft one of the cases and to think what would happen if this were a, a tree with 10 nodes for the other case the other piece of the definition this part k and go ahead spend a couple of minutes coming up with this definiton the recursive case
Wait a minute, so she said this, and I can argue combinatorially this, right? You see that I can argue this combina You see that I can argue this combinatorially? The total number of nodes in the tree is all the nodes in the left subtree plus all the nodes in the right subtree, oh and they're the same, plus the root, yes? Ok. What is this thing right here? How do you describe it? What is it? The recurrence. This is the recurrence. Are these two different things? Same! They're different expressions for the same idea. Different expressions for the same thing. Oh yeah? Prove it. How would you prove it? Using induction. Ok? That discussion we just had there, that discussion we just had there was the total conversation, ok? Like dinner conversation, right? Do we have it a recursion, recurrence, which is easy to write down. And hypothesized solution, and in order to make agreement between the two, we could do arduous arithmetic like you did when you took calc 1, or we can simply prove that they're the same inductively. We're not gonna do it here, but I just wanted to bring that up in this moment, ok? Any question about it? We're gonna do an inductive proof today, just not here. This one's almost too trivial. Oh, sorry. This should've come from discrete math. Alright, any question about it. K. So, prove these two are the same. via induction. And, I'll warn you you know what? I didn't really, I didn't really check this. Is it h plus 1 here, or is it just h? Ok. Alright, fine. The other way you can prove it is by asking the class. Alright, any questions about it? Alright. Got another one for you. Let's talk about a complete binary tree. I'm just shaking my head. I'm just shaking my head. Because if you read that English definition, it stinks. It's not a recursive, it doesn't evoke recursiveness. It's, I mean listen to this, it's like a perfect binary tree except not all the nodes on the bottom level are there. And moreover, the nodes that are there, they're all pushed to the left. The heck. The heck, what kind of definition is that? Well it turns out to be extremely useful to us and so we're going to pursue. we're gonna actually pursue, making an elegant definition of it, but before we do so, I wanna make sure that you could draw a picture of a complete binary tree, so please very quickly, draw me a complete binary tree with one more node than I have 7,8,9,10,11,12.. thirteen nodes. Complete binary tree of thirteen node, and you shouldn't start from scratch. Yeah. Right. Look, this is complete binary tree 12 nodes. Where does that 13th one have to go? It has to go right here, right? It has to go here. Otherwise, you either mess up the height I believe bunch of different levels, or you add a vertex of the, you don't have everything pushed to the left. Cuz there's really only one place that thirteenth node can go. And I'll put it in here really quickly like this. Okay. Any question about that? Alright, fine. Now, because we like recurrence, recursive definition so much, we're going to solve the puzzle of expressing this kind of tree recursively. In this definition, you can use ahh.. your definition for a perfect tree as well. Okay? And what I want you to do is figure out what this definition looks like. My hint here, my hint here is to use the example to craft one of the cases.  And to think what would happen if this were a tree with ten nodes for the other case, the other piece of the definition. This part. Okay? And go ahead and spend couple minutes coming up with definition, please The recursive case.
Anybody want to write it on my tablet? I will walk around and if you seem to have it I will give it to you. In case you are having a hard getting start it, I am going to ask you a question. What does the left subtree of this example looks like? The left subtree looks like something you seem before, rather than recently. What is it? Anybody want to write it?  um, if somebody over there wants to write I will throw this PC like a frisbee . That is inceptive right there.  No way? Alright, tell me what letter I am going to write next. What does this looks like? What letter I am going to write next? If I am filling in this blank. No. p right? I am going to write p. I have a symbol to represent perfect. P and how tall is it? How tall is it? P of h minus one good and what does the right subtree look like? C of it's height is also h minus one, good. Okay, any question about it? Okay, fine. What if these node doesn't exist? Then the left subtree will look like what? C of , good. How tall? H minus one, good. And then right subtree looks like what? I will give you the h minus two there C or P? Raise your hand if you think c. Raise your hand if you think p. Okay P of h minus two, that's right. There can't be anything there Alright, any question about it? Good. So now, now, if you're trying to do some computation on complete binary tree, this is one way you could arrange your computation if you want. Writing a recursive function on complete binary trees, you just have to defined that function on perfect tree and make a bunch of recursive calls. Okay, alright. So, I wanted to verify for you that my English definitions were even say all nodes are pushed to the left is actually something official.  That is what is this link is about. It comes from nist, the National Institute of Standards and Technology. So, this is nist.gov um, and, I believe the ds here is for data structures. So this is the official defition. What? I know, isn't that sweet? Dev All kind of data structure something, and this is their definition in complete binary tree. There is one vocabulary word in the definition that we have not t talked about.
What word is in my English definition that we have not talked about? Level, very good Level is not defined But suffice to say, here's level 0 There's level 1 There's level 2 There's, in general, is level h Sorry, it's just an index for the path length, effectively From the root, any question about it? This part right here? Okay, so the question is, What the heck am I talking about there? So in this recursive definition, we are admitting that this jump from the bottom level up to the previous level, has to happen somewhere Now, case one is the situation where that jump up happens in the right sub tree And case two here is the case where the jump up to the previous level happens in the left subtree Now, for any opportunity or example where you jump up in the left subtree, that means that the left subtree itself has all the nodes pushed to the left, right? And so it is complete How tall is it? h-1, very good Now, the right subtree in that case has no nodes on the bottom level, so? it's perfect How tall is it? h-2 Any other questions? If you added 3 nodes to the original tree? I see what you're doing Are you asking which of those recursive cases applies? I believe it is this one (circles first case) Applies because both subtrees are height h-1, in that case What does that say about a perfect tree of height h-1 It's also complete, that's right You can untangle it, I believe it will work So the question is, so I gave this teaser, right, I saidÂ  Complete binary trees turn out to be very useful It's gonna be about two weeks before I give the punchline to that one This is a two week cliffhanger I want you to be watching for it Alright, any other questions about it? We good? Okay, is every full tree complete/ No way! No! The one we drew was an example of a full tree that was not complete Is every complete tree full? No! Really? You're right, push on it Is every complete tree full? I'm gonna erase everything here
Is the example a complete tree? Yes it's complete that's what we're talking about. is it full? No, okay because of this guy so no Every complete tree is not full Here's one, that one's complete but not full There's one if I erase all of that Okay, Alright any questions. So now you have working definitions of  Full and perfect and complete If I were you I would make flashcards maybe, I don't know, I know I wouldn't because I would be too disorganized, but you know Alright, so let's touch base for a second with what um Maddix showed you uh last time about implementation of this structure So I believe he did something like I believe he did something like create a tree Uh he might have called it binary tree Uh but, it had an internal structure that we called a node Notice just for a second , step back and look at this. Where have you seen something like this before Besides Friday, where have you seen something like this before A doubly linked list, right, previous, next who cares what they're called The structure is the same, the only thing that's different is how we link things up How we connect things Okay, um so, uh, Maddix gave me his slides where he had hooked things up Kinda like his, kinda like this, is this tree full? Perfect? Complete? Yes okay alright fine And I looked at his drawing and I got all worried I was worried that there were too many null pointers Because we're implementing this thing in such a way that all of the term, all the leaves All of the terminating nodes have null pointers associated with them Now, this is kind of fine if there aren't too many of them How many null pointers would be Well, first of all let me start with a doubly linked list Why was I not worried about this at all in a doubly linkedlist How many null pointers did we have essentially? Essentially two right? If we, yeah  Right, essentially two, one at each end okay So, we had a constant number okay How many null pointers would make me upset How many null pointers would make me go oh that is too much memory" We're using too much memory for n-data items Exponentially would be too many, two to the n would be too many, how many uh anything else? Would log(n) be too many? No? not bad at all because that's fewer than n right? Log(n) smaller than n, it lives in the world smaller than n.  And all that means is that every piece of data is just a little bit fatter Right it has a little bit more actually dwindling amount more Of stuff, memory associated with it. So log(n) wouldn't bother us at all How about linear? A linear number of pointers. Would that bother us?  On the edge right?  It doesn't , a linear number of pointers some constant factor of n number of null pointers would not bother us Because again, it just means we got some overhead associated with our data We're just a little less efficient  Representing the integer contained in the data node  Okay So, no big deal to have a linear number How about a quadratic number of null pointers Quadratic number of null pointers , yeah that's bad I have a little picture for that, what that would mean is that our  What that would mean if we had n pieces of data Then we would have this much memory associated just with the null pointers Right, that's too much. Right n squared of nothing so as a support linear of data that's bad Alright fine, I want you to complete that theorem for me as accurately as you can
I want you to complete that theorem. The theorem itself not to prove, that whole blank page. That's the prove. Hahaha You can do this. Anybody have it? Wanna tell me? Did you raise your hand back there? Or were you waving at me? Gray shirt. Either one. What? Say it together, coordinated. Very good, okay. Good. Do you guys here that? Do it again. Encore, encore. This is what they said. N+1 Null Pointers. That to many nodes it's fine, it just means every piece of data have a little bit more memory associated with this. Okay? No problem. There's big blank splits. Page there. And everyone comfortable doing this? Because that means I'm going to do a lot of the talking. So, well, we'll plunge in.  So I need to prove this. This is a theorem, theorem that's bad for prove. And I'm going to do it by induction on the number of nodes. Which corresponds to the number of data elements. Alright Consider an arbitrary binary tree. with N nodes We'll prove that it has N+1 Null Pointers, okay? And I'm gonna call it T. So this is just set up, right? This is just set up. It's giving us labels to placed on our arguments.  Our labels now are T and N, that's all we've got. There are two cases to consider. Case one, T is empty. The base case of the induction, okay. Well, let's argue it. We represent the empty tree how... how did we represent the empty tree? How do we program it. You guys did it last time. Yah, we represent it in the empty tree with one Null Pointer. So the theorem holds. Yes? Any question about it? Okay let's do case two. T is not empty. So it is a root together with TL and TR. Okay. We'll going to make this argument by counting Null Pointers.
Ok. By an inductive hypothesis that says  for any number less than n,Â  a tree of size, that size, j, has how many node pointers for any j less than n, a binary tree  of j nodes has how many node pointers? j+1 node pointers. Ok? By, we know T(L) has how many node pointers? And I'll give you a hint.  The size of T(L) is that.  How many node pointers does T(L) have?  T(L) has how many?Â   this many? Does it have this many node pointers? This many plus one.  And how many does T(R) have? The number of nodes in T(R) plus one.  So, T has the size of T(L) plus one plus the size of T(R) plus one nodes. Tell me something interesting about this.  Some of time to.......Oh it is time to go. I need only one more thing. Tell me something interesting about this sum.  Yes? It's the size of T. Look at this. This is the number of nodes in the left subtree, the number of nodes in the right subtree,  and the root, right? This is n. So this is n plus one. Done. Magical. Ok. Bye. Sorry keep you over. 
Um... back row, can you hear me? You guys are not in back row... OK... OK...UM... Let's see I have an announcement. Guess what it is...Midterms coming back in sections this week  It's coming back in your section, yeah I know I'm sorry. We try something new. Shame on us. Haven't forbid we actually make some changes. um...okay, so um... your midterms are coming back to you in section this week. Um.. I have here... the data, on the midterm, you can kinda see the... it's a normal curve...sort of which I like to see, um.. the median is 75, it's a perfect exam! It's a perfect exam. OMG and the average is 72 so...a perfect exam will have them be the same, but what I'm thinking is that there were few of you just sort of hunting. They got exam and they said Oh yeah I have to drop this class...  and that's what brings typically brings the average down lower than the median. ok.. so I should've write all that down... I think...um... mean of your exam was 75,.... no no no...72, median was 75. YES!!! PERFECT!!! One life is perfect ok... can you tell what happens really... alright umm what that mean so there unlikely to be a curve umm... a curve on this exam, or any kind of accommodation for .. ummmm.... the difficulty of the exam...yes?
So what I warm the lab TA will happen is the few people will have to come up to my office and get the exam from my office. You could probably get them to bring it to in that lab section if you let you let them know I had the time.  But, if it is all possible I guess I would like to ask your cooperation in actually going to your lab for your are register just for this week. Because that's where your exam will be. Here is real motivation, ok? So yes, the Lab TA will help you get your exam. ok yes, the Lab TA will help you get your exam. but after the class, if you go to the different lab section, but it will be grumpy about it and they will know who you are because you have to ask them for your exam So if you want course assistant are happy with you, don't make them make that the extra trip to my office. We ask you, ask your kindly. Okay, let's see. Don't think I haven't......Oh yeah. So if your score, this is not too many people, but if your score is below  So if your score, this is not too many people, but if your score is below 52, I think it is about 51, you probably want to consider what you need from the class. It is the way I gonna say it, so if your midterm score didn't make you happy, and it was below a certain score you might wanna think carefully what you want from the class. We are going to offer, we are going to be sending out invitations to the people whose score is low on the test to participate in, and to drop CS225 to participate in auxiliary course that will be a programing fluency course. With the intention of getting people up to speed, ready to go, and confident for CS225 next semester. So that opportunity will be afforded to people who are particularly unhappy with their score.  And if I m unhappy, if you got above 50, I think you know, there are other thing you can do to get yourself ready for future exam.  Yes, speaking  a future exam, when it is the second midterm. I believe it is schedule for November 2. We will going to, yeah, so here is the thing. We will be going to get rid of the second exam and instead of asking to do a bunch of little exams But we hear mixed messages on the testing center, we don't have the class time to do these little class, the little exams in class like they do in 173. And I am afraid now of doing anything differently than we ever done before because you know, this exam took two weeks to get back to you. which I am not, I just on a custom to. So I think we are not gonna make that that sort of  (moderate) change this semester, we are going to instead a exam like we always have. I think of it as tree exam, so it will largely be focused on trees, the topics that related to tree, dictionary. And there you go, is that okay with you? This kind of keep you normal. It is in November 3, did I... You know why, because 2 sounds like 2 and Tuseday sounds like two, and then it did that. But I didn't write it down, so you have no proof. Oh wait, there is whole transcription thing. Okay, globe substitute Tuseday with, I mean no, 2 with 3. I don't know. Alright, let's work. Let's play school. Any other administrated question, so I don't wanna cut you off. As it is a good touch point. Alright, when I was gone last Friday.... So I actually have a confession. I was kind of (b..) yesterday, cause I only have like half a cup of coffee. And I think people in my life recognize that because this is actually the second coffee gifts I've gotten today. So thank you so much .. So when I was gone on Friday, you guys wrote code for traversal. I wanna step back and have conversations about traversal.Â Enâ¦ and you will notice in the absence of code. So what I want you to do is to write down for me. And you know it, in the absence of code. So, what I want you to do is to write down for me.
Youre guessing right. A traversal. But heres what I want you think about What I think about if you had this structure in front of you And your're talking on the phone to somebody How could you tell them the data, not the connectivity, necessarily, but how you would tell them the data that is arranged in the structure in front of you? Okay? So, write down a traversal of this data In a way that you would tell it, tell that data to someone who was sitting on the other line I know nobody talks on the phone okay. The order you would put it in a text message Does that make sense? You have to tell you aunt rosie about this super cool set of data contained in this tree How would you do it? After all, that's what a traversal is. Right? Go ahead and write it down Write down some traversal of this tree  Oh and do it in silence Oh you already are  Its very polite of you to let me drink my coffee  Okay, got it done? Raise your hand if you have it done Some traversal of the structure take a couple more seconds then  No just write down these nodes in some order. I dont care what order Not the code. Just write the data in some order I'm sorry Write down the data in some order No code This is not a code day Until later No no code! Write down the data. The order in which you are going to tell it to your aunt Okay got it? In some orde Now what I want you to do is turn to the person next to you Hi.  Turn to the person next to you and share your traversal of yours and raise your hands if theyre the same Oh now youre talking to each other Pair of you Raise your hands if theyre the same I wish I had a prize. You guys did the same one   Okay Okay. Lets pull it in So, the pairs of you that had the same ones raise your hand Raise your hands so Imma have littler conversations with you You had the same ones as yourself Very good Alright what traversal did you use What name would you put on the name of traversal that you used? Post order traversal? You both happened to use a post order traversal Raise you hand if you both happened to use a post order traversal and tell me what that order is here is a post order traversal of this tree Tell me those entries 
Good Very good Ok Any question about it? Ok, this is the reason we were doing this in exhaustion to its limit. So you can go back and check and make sure that mechanically you can see how these trees traversal go. There is a pair up here. You guys have same one, what kind of traversal did you do? you did a level order traversal, what the hack is that mean? Anybody want to guess what the hack they are talking about? Do you want to say it, you say what you think is on their pages. yes, yes... no way? no, it doesn't matter. do it really quickly, we don't expect you to get this one right? This is golden here, what is it? oh you want, ok which way? you said c, b, d, e slash  Do you see what I am doing? I am saying from what you saying in opposite order, alright Then, what you going to say? star, minus  plus Alright, yes, so a level order traversal you know what? if I would talking to my grandme, this is the order which I just describe the data. because, it is so easy to look and go the level by level and explain what data is there, alright. Now, do we need an algorithm to this yet? NOO, wonder what we are doing today. ok, another pair that had the same one. another pair? Which kind did you guys use? You have a name for it? a pre-order my power and my machines is out, so I can't carry around with me. so I'm going to be running with coffee. How do you do a pre-order? dash, slash, b, c star, d, e is that right? plus slash, b, c, star, d, plus, e Good alright, and there is one last, what's it? It's there any pair did it in order, any pair pair did it in order? You guys didn't? no pair that did it in order. ok, fine, I'm going to leave it. You can go figure what that is. here what I want to, you guys did it? you have one? you want to tell me? fine what is an in-order traversal? b, slash, c, plus, d, star, e good alright, there is that in reference for you ask you going back just another example of traversal to make sure you have the mechanic of it. I have a reason that believe you do. now, the next question is how expense is a traversal in term of time that is what the running time of a traversal. what would be in term of the amount data it containing? what would be if somebody came to you and said, I have traversal code that run in constant. what would you do? you are out of the street and there is an algorithm truck. and they sell algorithms and they have one in there menu constant traversal algorithm, eight bucks. what do you said? it's a scam, why it is a scam? it can't exist, if you have any piece of data and your objective is to look at all of them? you can't do it in constant time for any constant time algorithm there is an example of data size that will run long than its you just kind of increase the data sizes until it bigger. it just can't happen so, the time it take print it out takes longer that constant, what ever they said it is. Do you all see that? that's a reasonable to thing thing about every single time everybody tells you the running time of an algorithm, is that even make sense? what if you went to a different truck? so, this is. I'm in a different algorithm truck, this is rock and algorithm. the other is crack, clearly, crack algorithm. and they have to assign that said i'm totally.. here you guys is not right? I don't what I am talking about. they had assign this said traversal algorithm that run in quadratic time, five dollar. what would you said? ording n square what would you said?
Not worth it right? At that point you i'm opening up my own truck.  I'm going to go get a truck. okay? alright so, what would be reasonable. what would be a reasonable -- okay I'll buy that algorithm. running time of that algorithm for a traversal.  That's right, Big O of n You've got n pieces of data. all you're doing is writing it down. so if a traversal algorithm runs in time n.  That's good. that's what you want to have happen.  Okay let's see. I have some other questions about this.  So, I'm gonna do kind of a traversal that mimics the code for the traversal. This traversal is going to really be a walk around the outside of the structure. A walk around the outside of the structure. How much time did that take me?  How much time did that walk around the outside of the structure take me in terms of the data size?  How much time did it take me in terms of the data size?  All the way around. How are we going to think about this, okay.  So the magnitude, so the magnitude of the structure is order n.  There are order n nodes.  How many edges are there? There are not 16 edges, no way. how many edges are there in general? Big O of...?  N. edges. it's a tree. This is a discrete math result. There are big o of N edges My walk around spends a constant amount of time,  adjacent to each edge and a constant  and do you see what i'm doing here? so i'm adjacent   to each edge twice. right? so it spends a constant amount of time adjacent to each edge. So the amount of time I'm spending kind of going between vertices is big o of N and notice how much time do i spend at each vertex?  How much time do I spend at each vertex? How many visits are there, essentially? Three, right? There is the first time. wait where is a good one to do.  There is the first time I'm close to a vertex, there is the second time i'm close to a vertex and there is the third time i'm close to a vertex. right? now in a vertex like this,  the first and the second times kind of occur simultaneously and the third time is way out here. But that isn't really what matters. But certainly there are no more than three visits per vertex, right? we never go back to one or anything.  Now let's count this up in terms of the amount of work that is done. Big O of N for the edges because there are N of them. Big O of N for the vertices. Right? Big o of N for the vertices because there are N of them  and we visit them each three times. Okay so now let's look at the code and see if that understand of what we have done.  That understanding fits with the code that we wrote. Geez it feels really different here.  There are two things that represent edge activity here.  There is the. 
The reference to a parameter for the recursive call, right that's like the start of an edge in this picture. The passing of a parameter is like the path past this edge going forward. Yes, do you buy it? So when I do cRoot->right, it's like I'm walking down that edge, kind of. And the actual visit of a vertex corresponds to this moment or this moment or this moment. So those three red dots correspond to actually being inside this program code here or here or here.  The evaluation of this conditional is constant time. So we're actually not going to worry about it very much. But now what we observe, is thinking about the vertices and the edges actually corresponds to exactly the code that sits here. It corresponds to at least accounting for what happens in the code that sits here. I forgot the other side of the edge. I forgot this part of my little walkaround. That corresponds to passing control back to the call function. What's the punch line here? The punch line is that the amount of work that we do per data element is constant. It's three little visits, a function call, a return, a function call, a return. That's it, that's constant. But we do that for every vertex. If it's constant per vertex, then what's the running time? Linear. So constant O(1) per node implies O(n) for the algorithm. Ok, any question about that? Now notice that this is different than the way we evaluate running times for a iterative algorithm. Usually, when you see a for loop, you think oh that's a factor of n. At least that's where you start in your reasoning. When you evaluate things recursively, things get very messy. Especially when you don't know the size of the recursive call. It's easy if you know the size of the recursive call is n-1, right. That makes it easy. But the problem setting up a recurrence here, is we don't really even know how big to make this. We don't know what the size of the recursive call is here. Because we don't know the size of the other one was. Another way of evaluating how this algorithm works is to look at what happens for each vertex. Similarly, if you had a vertex, and for every vertex, you travelled to the root and back. For each one, a good place to start the analysis, is woah, at every vertex I go all the way back up the tree. that would be one way of approaching it. Alright, any questions about all that? The punch line is, traversals run in linear time. If they don't, something else is going on. And it's not good. Traversals should run in time proportional to the size of the data. It fits your instinct. And anything that smells really does smell for a reason. OK, I have one more question about this. So, all traversals should run in size proportional to the data. Is this piece of code which I believe was similar to what you wrote last Friday, is it public or private in the binary tree class?
Is it public? Did you guys make your subclass tree node public or private? Hey Mattox, was the tree node class public or private? The node class. Ok. Ahaha. Ahaoh. Gotcha. Meheheheheh. Gotcha. Alright, so, because the tree node class was private this cannot be a public function alright? So what you do if you have reason to believe that the user of your class is going to need to preorder, um, that is, if their going to need to say T dot preorder of where T is binary tree, then, you just make a public wrapper. Ok, and what I mean by that is a public version of preorder, that simply calls this private version with parameters... root. Which is private inside the class. I want to give you an application So suppose I give you binary tree and I want you to make a copy of it for me. The copy constructor the assignment operator So we're going to make a copy of the binary tree and notice again that for this one again we're making a private helper function So copy constructor and assignment operator are going to use this If I want to make a copy of this tree, then what am I going to do for an empty tree? Just return NULL right? And otherwise my algorithm is going to do what? Otherwise, I'm going to make a new node and who's left subtree is a copy of that one's  And whose right subtree is a copy of that one Th If this is A then this is a copy of A if this is B this is a copy of B Any questions about that Kinda makes sense right? Okay, so lets do everything that I just said We admit no matter what that we are going to need to return a tree node pointer thats what this thing is asking for  returns a tree node pointer so I'm going to declare that thing from the start  treeNode * t and I'm going to give it a default value that makes my life easy I'm going to give it default value NULL because the next thing I'm going to do is check to see whether my parameters is NULL Going to use next moment to differentiate between the base case and the recursive case of this recursively defined structure So what does that mean?  It means the next letter I'm going to write is an 'I' if (croot !  if (croot != NULL) then I'm going to do some stuff What did we do? We built a root so tee equals new tree node 
T's data should become what? Croot's data, good. And if I'm building that root node I have to do the data, I have to do the left subtree and the right subtree and then the node is built. What is the left subtree? T left is what? Copy of croot's left. Okay I' Okay I'll race you for the last line.  And then what I'm gonna do is return T. You like it? Seems okay, right? What's the running time? Waitwhat? What's the running time of that algorithm? Big O of N You did that fast! How did you do that? Okay so I'm going to write running time right here. How do you know it's big o of n anything else would make you mad anything else would be like ridiculous or ridiulous Either way Alright if you squint your eyes It looks a lot like what? Pre order traversal That's right It's an if statement it's a fat if statement there's a constant amount of decoration around it but it's an if statement with a constant amount of work and 2 recursive calls so it's just like preorder so I'm gonna say that the running time is big o of n teh same as preorder by analogu Can yo ualwayus just make a guess like that? Big o of n by analogy to traversal The same amount of work this is just a traversal where instead of yellling out your data you do something else you make a new node and copy some data okay any questions about that/ okay fine so it probably doesn't suprise yuou taht the next application of traversal that we are gonna see is the clear function I I've got a tree and want to clear out its memeory so take a look and see if the code does this What i think the code should do is clear out the left, clear out the right, and free the memory associated with the root so i think it should do this then this and then this okay does the code dod taht? oh, yeah i forgot this is the buggy slide I could fix it the other wayu the other way would be a little bit better in terms of you know in my binary tree class the root is called really this is the root something okay so now does the code dodthat? sorta this code has a big bug waht is it? Nope Here's the root r this one uses root as r What's the bug?
So if the root is equal to NULL, we do nothing there's nothing to be done, there's no memory associated with the thing So that seems to be OK Otherwise we clear out....Oh wait I'm doing something wrong already. What is root here Yea Root is a copy of r. It's a parameter. It's a copy of the original root. k? So what this code does is it clears out the left it clear out the right. It frees this memory. Right? That's what this delete does. And then it says this guy equal to null. Is that what we wanted? No. So how do we fix it? Pass by reference is the answer, that's right. So we need to pass by reference there and then this code works fine. And what is the running time of it? Big O of n. Which traversal does it happen to look most like... post order, that's right. To recursive calls and then a little bit of work. So by analogy, to post order traversal. OK, good? Alright, let's keep going. Alright, here we go. This is ...Grammy moment... Alright, something totally different. I think level order traversal is a perfectly reasonable way of expressing the content of a tree like this. The problem is that level order traversal does not use the connectivity of the structure in any way.  You jump from sub-tree to sub-tree. And so the approach to writing this algorithm is not a recursive  approach. Because we can't express the lever order of the main tree elegantly using recursive expression of the level orders of their sub-tree. Ok? Alright. So here's how the algorithm goes for a level order traversal. So the first thing we're gonna do is we going to create a queue and put the root on it. And here's my queue I'm gonna put the root on it. Root node. Probably root node, probably root node pointer.OK? Alright, so this is make a queue and add root. K? And then until the queue is empty,  do the following, remove elements from the queue yell the value and add it's children on queue OK So that means I remove plus from the queue, yell it's value and Onqueue its children, by conventionally do that left to right. By convention I'm going to add minus and asterisk to the queue. Ok? Can I keep going here? I'm going to take queue, yell, and add children It's an empty tree and the slash. Would you rather I put a NULL there? I don't know what does a NULL looks like. It's a little box with a slash in it, right?
We'll do that Alright, and then I'm going to remove asterisk yell it's value onto its children: d, e I'm going to dequeue the null Oh, if it's null, I'm not going to do anything, so just fly it away Let it go away Alright, dequeue, yell the value, enqueue the children: b, c Dequeue, yell the value, oh I hope this is working right You'll tell me in the end Enqueue the children: null, null Haha, yeah I know you don't like it, but you'll be okay Okay, dequeue, yell the value, enqueue the children I don't know what I'm doing wrong here No you're not Dequeue, yell the value, enqueue the children Oh boy I really have a point Dequeue, yell the value, enqueue the children And then dequeue, dequeue, dequeue, dequeue, dequeue, dequeue, dequeue, dequeue Done And there is a level ordered traversal, did it work?  Oh yes, it did. Yay, fine. Okay Let's write the code that does that And then talk about why you hate it so much Let's write the code that does that and then talk about why you hate it Alright So, I want to declare queue. I'm going to assume the existence of a queue class at this point. And into that queue, I'm going to put tree node pointers I'm going to call it Q Like the archvillain in the next generation Q.enqueue(root) And now I've done step one Alright, while it's not the case that Q is empty, notice I know that I can check that I'm going to do the following. I'm going to dequeue, so I need to grab the value, treeNode pointer t equals q,dequeue() I'm going to yell the data associated with t And then I'm going to Q.enqueue t's left, and Q.enqueue t's right Any questions about that? And then I'm done So, this code exactly reflects the English description of what we do I assert that you have actually written this code before, or if you haven't done it yet, you will do it very soon  What does this look like? It looks exactly like MP 4.2, that's right especially the breadth first part of it So using the queue to do this, this is what gets us this sort of breadth first thing This is going to be a reoccurring theme So you see it here You see it in MP4 and you will see it again when we talk about graphs Yes? Yeah okay let's do that point So, I assert that that should not bother you That putting all of these Nulls up there should not bother you Why can I say that? Why can I say it shouldn't bother you And the answer lies in how many of them there are There are order n of them There are n+1 of them we proved it We proved there are n+1 of those things Which means that burden of dealing with the nulls is no worse than the burden of dealing with the data So, in a traversal, that's not going to affect the running time per data element It's just like each piece of data is a data plus a null kind of, okay? So, we're not going to let it bother us Now, why did I do it this way? Why did I enqueue Nulls at all? And the answer is because if I did so, I would have to make a special case out of the original thing being Null, and I just didn't want to do that I didn't want an additional if statement here and an if statement here [Student talking] Oh yeah, there's a problem here, I'll fix it next time Yeah, this is broken Right here is broken [Student speaking]
[Video Playing] Happy friday! Barndance! Alright let's work. Okay you're not going to the barndance because you have an mp due tonight And I'm not going to the barndance because I don' have my boots on Okay so let's see Your mP is due tonight. Is that too loud? You good people in the back? Alright so last time we talked about level order traversal and i wrote a bunch of code for you and i did it wrong  do you remember this? It was bad in lots of different ways oh no it's gonna be one of those days okay so the execution of the algorithm on the tree was fine. I am going to consider this partial subtree only and pretend like it is the example of the day. So level order works like this. You can trace the code that we wrote and understand the algorithm it matches the steps in the algorithm except when I wrote that code I made a mistake. Okay let's see, so I have this queue that's what this line is intended to be. And I am going to enqueue the root, so this is review this should be reiview And I will try to do it quikcly. Ok so I enqueued the root remember now this is the root croot i believe it is called. Alright then now the queue is not empty we have already put something on it now while the queue is not empty we are going to grab hold of the dequeued value so i'm going todequque the minus the node containing the minus and then this is where I made the mistake If it is not null, so if T is not equal to null, then I am going to do the following. 
 The reason that broke before was because if it was equal to NULL, I get a segfault. That's right. OK?  So I have to check for NULL in that case. Umm...I have to check for NULL anyway in order to protect myself from dereferencing a NULL pointer. And moreover, you know, this things I really want to do if it's not NULL, it doesn't make any sense to try to enqueue a chlid when it does not exist. OK? So then, if we continue that execution, it looks like this. T was not equal to NULL, so we yelled T's data, that's a minus, and then we enqueue T's left, which is a NULL. I think I will write NULL like this because it looks confusing. OK? And enqueue T's right, which looks like this. But no containing the slash, OK? Now do you like that? Do you like it? Now you already don't like it, I know it. Getting in touch with your inner feeling about this. Why don't you like it? Somebody who doesn't like it raise their hands. Why? What's right exactly? What's the point was putting the NULL on the queue, right? That feels like a waste of time. It feels like a waste of time I'm going to articulate the difference in the code in just a minute. But I wanna continue this way just to finish the example for those of you who happened not to be here last time. And then we'll talk about what the alternative code would look like, OK? What the alternative code would look like. OK! So I'm enqueueing T's left, enqueuing T's right, and then I iterate. I moved the next iteration of the while loop Queue is not empty, so I dequeue. My dequeued value is NULL so I ignore it. And so the next iteration says dequeue again. Yell the value, enqueue the children. And just in case you missed it, by convention we enqueue left to right. OK. and Then continues Queue NULL know it's not so we dequeue it's not NULL so we yell its value, enqueue the children. Oh you hate that! The children... OK? Dequeue, Â yells the value, enqueue the children, And then we dequeue*4 And we what we end up with is a level order traversal of the example subtree. OK? Alright. So let's talk about all those NULLs Let's have a conversation about nothing. Raise your hands if you get the reference. OK. If you don't get the reference, you should go to watch Sci-field, all the old episodes. Show about nothing, right? OK So we need to have a conversation about nothing. So what's the alternative here? How could we protect against this process of populating our queue with all these NULLs Yeah? Right. So you want me. I'm gonna put it in red. Does that look scary, or it's just too scary? OK I wanna put it in red. It's not that it's wrong. It's just scary So maybe orange is better because we're close to Halloween. I should really just stop talking and work. OK So if T left is not equal to NULL, then do that, and I better do it  for the next one, too. Right? If T right is not equal to NULL, OK Do you guys remember how I feel if statements. you remember that? So I don't them right? Because it increases the number of test cases that I need to make and I hate writing test cases. you might love it I hate it So, if I put these if statements here in addition to what already exists, then it mean that I have to write a test case for if T left is NULL and T left is not equal to NULL Similarly, for right. That seems sort of silly to me. Moreover, in terms of the the running time of this function. Think about what happens as you process it These two lines of code First of all, how much time does it take to enqueue something? constant time, right? it takes constant time Let's say 4. I don't know for what, but it takes 4 this just adds to that value, say 6 ,right? Whatever, it adds some constant value to the time it takes to enqueue. Right? So what ends up being faster, if we add these. If we add these, what ends up being faster in the end. The...what ends up.. how do we save time. How do we save time in the end.
Fewer iterations the while loop, right. Because we don't put as many things on the queue. So you're all worried about the number of iterations in the while loop. Ok now, I argue that as it is, and you're willing to pay for fewer iterations of the while loop, you're willing to pay a little bit of time here to decrease the total number of iterations in the while loop. That's dollar, this is your currency. Time is your currency. Now, I argue it just doesn't matter. Why? How many fewer iterations do you get? How many few iterations do you get? n+1, that's right You don't put nulls on. so the total number of fewer iterations you get is constant per data element. So you are, order in total, which implies constant per data element. So that means you are willing to pay constant per element in order to save constant per element. So it's a wash. And it's a wash in terms of running time. Overall in terms of asymptotic running time. I fully intended to go implement it both ways, with the conditionals there, and without them. But I just never did. Now, I also want to point out that actually putting these here mean you don't need this one, right? You see that? You actually do save a little bit there, but it just makes the code uglier, and increases the number of test cases. So the upshot is kind of you want to push your if statement up, so that lots of work is done in either case. It's more of a software engineering class type question. Ok, let's see. Oh! The other complexity is that when you start the algorithm you have to be careful. This as it's written, with these red guys here doesn't work on an initially empty tree. So what you have to do is that you adopt the principle that every time you ever do an enqueue in this algorithm you check first, and that means you also have to check here. [Writing]. I have a question for you, so I'm going to blurr my eyes so it's not personal. But i'm just kind of curious how you feel about this. I want to know whether you're sold on my story. I think it's very intuitive that putting those nulls on there bugs you. Bugs us. So I want to know if my argument has been convincing, and the way I want to judge whether it's been convincing is whether you feel like if you went to implement this code yourself, whether you would use the blue or red stategy. So I'm trying to tap into your inner feeling about code writing. Are you prepared to answer? Raise your hand if you would chose the blue strategy for writing this code, and raise your hand if you're not buying it, you would prefer the red strategy. Because it just makes sense. They're asymptotically the same, it's almost an issue of elegance. Is it black and blue or gold and white? Why you need the if statement on the top? The question is about the if statement on the top Oh well it's not empty so I'm lying you're telling me? Because it is empty already. I'm wrong, good catch. You don't need this.
Because this works, because we.  This that right? Yes, we didn't do a dereference there, yeah, yeah, sorry.  Yes we do, yes we do. Oh, no we don't.  No, cause it is not empty, we didn't change...Oh, yes we do, absolutely we do.  I'm confusing my empties with my NULLs. We absolutely do need it, because what you are thinking what I was thinking is that by putting a NULL there, the tree is still empty.  But it is not.  So, on that, oh...on that first iteration, on that first iteration here, the queue is not empty, right?  It's not, it has a NULL on it, cause we put it there. Croot, yeah that's true.  Right, right, right, right, right, that's the right correction.  You still need to do it, it's just the wrong test case, sorry. Okey, have I completely wrong with it?  You can save for like first 10 minutes of the next hour and then it will be like all smooth, but there will be no jokes, because when I like accidentally make a joke in here and try to tell it in the second hour, total flat.  Like the whole algorithm's track thing, I thought that was kind of cute, right?  Second hour? Totally fell flat, totally.  Alright, I'm done.  So the question is about how quickly these things evaluate?  How do you know that enqueue and dequeue doesn't happen super quickly?  Right? So we are talking about the difference between constant factors here, and asymptotic analysis.  Eh, the actual difference between running time on these thing depends on you know, whether you are running this in a cloud, whether you have implemented your queue as an array or linkedlist, it depends on lots of different things.  But what we are arguing over is constant factors.  So I'm saying that the inherit value of the algorithm which we measure ignoring constant factors is not different one way or the other.  It's always reasonable when you have two asymptotically equivalent algorithms, it's always reasonable to gave them a head-to-head run, simulated run in your context if it real matters how fast, how concretely fast they are.  Okey, if you are, em... yes, right.  But here, we are mostly talking about asymptotic performance.  Okey, does that, is that good? Okey.  Alright, any questions about this?  Did I clarify that first thing, so you do have to have a conditional, and the conditional should be around whatever you put in the queue, and I just leave an auto pilot, sorry.  Alright, any question about it? Okey, em... I don't remember what comes next, let's see.  Oh! The conversation we just had about binary trees and about traversals, was really more one of implementing an algorithm.  We are going step back for a second and talk about an abstract data type.  I think I am coming to believe, or coming to feel perhaps, that this abstract data type is the most important one that we use as sort of day-to-day programmers.  And the genesis of my feeling about this dictionary comes from my affection for python in getting things done, okey?  So I can not say necessarily that it will be apparent how powerful these things are in the context to be applications we do, but there is classic understanding that we will play into it that when you are programming in other languages, you will go oh, I'm so glad I know this staff", okey?  Alright, so the abstract data type that we are going to be interested in is a dictionary, okey?  The interface to a dictionary is at the bottom, we are gonna insert, remove and find by a unique identifier called that we commonly refer to as a key, okey?  So, the abstract data type itself is consists of these, the data looks like key value pairs, and the interface, the functionality of the ADT is insert, remove and find by the unique identifier, okey?  So, I want to speculate for a second just cause it's kind of fun to do so on if I have the following data, how would be, how would seem reasonable to implement a dictionary?  Okey, so my data here is a locker number, this is my ops, you don't have to be afraid of it anymore.  This is my key, and the values that I'm going to put into the dictionary or attach to each identifier, I'm gonna refer to here as my data though it's commonly refer to it's value. 
Because this works. Because, is that right? Yes, we didn't do a dereference there. Sorry.  Yes, we do. Yes, we do. Oh no we don't. No cause it's while it's not empty we didn't change, Oh yes we do, and absolutely do.  I'm confusing my empties with my NULLs We absolutely do need it. Because, what you are thinking what I was thinking is it by putting in NULL there, the trees still empty but it's not  So, on that first iteration here the Q is not empty, right? It's not. It has a NULL on it. Cause we put it there. croot, yeah that's true. Right, that's the right correction.  You still need to do it. It just wrong test case. Sorry. Okay. Have I completely wrong wrote it? You can stay for like first ten minutes of the next hour and then there will be like all smooth. But there will be no jokes. Because when I, like accidentally make a joke here and try to tell it in the second hour, total flat The whole algorithm truck thing, I thought that was kind of cute, right? Second hour, totally fall flat Totally. All right,  So the question is about how quickly this things evaluated. How do you know it that enqueuing and dequeuing doesn't happen super quickly Right? So we are talking about the difference between constant factors here and the asymptotic analysis   Um, the actual difference between empirical running time on this thing, depends on, you know, whether you run this in the cloud, whether you've implement your clue, Q,     your clue, as an array or a link list. It depends on lots of difference things But what are we arguing over is constant factors and so, I'm saying that the inhering value of the algorithm, which we measure, ignoring constant factors, is not different oneway or the other   It's always reasonable. When you have two equivalent asymptoticly equivalent algorithms   It's always reasonable to give them a head to head run, simulated run in your context If it really matters. How fast, how concretely fast they are. Okay? If your, um, yes, right. But here we are mostly talking about asymptotic performance. Okay, it that good?  All right, any questions about this? Did I clarify that the first thing, so, you do have to have a conditional and the conditional should be around whatever you put in the Q and I just, was on autopilot. Sorry All right, any questions about it? Okay, I don't remember what comes next. Let's see. Oh, uh, the conversation we just had about binary trees and about traversals    was really more one of implementing in algorithm. We are gonna step back for a second and talk about an abstract data type  I think, I'm coming to believe, or coming to feel perhaps, that this abstract data type is the most important one  that we use as sort of day to day programmers. And the genesis of my feeling about these dictionaries comes from my affection for Python and getting things done   Okay? So I cannot say necessarily that it will be readily apparent how powerful these things are and contacts to be applications, we do. But there is classic understanding it will play into it  that, when you are programming in other languages, you will go, Oh I'm so glad I know this stuff. Okay? All right, so the abstract data type we are going to be interested in, is a dictionary. The interface to a dictionary is the bottom. We are gonna insert, remove and find by a unique identifier. Call that we commonly refer to as a key. Okay? So the abstract data type itself is consist of these.    The data looks like, key/value pairs and the interface, the functionality of the ADT is insert, remove and find. By the unique identifier. Okay?  So I want to speculate for a second, just because it's kind of fun to do so.  On, if I have the following data, how would it be, how would it seem reasonable to implement a dictionary. So, uh, my data here, is a locker number. This is my, oops, this is my key.  And the values I'm going to put into the dictionary, or attach to each identifier I'm gonna refer to here as my data, though it's commonly refer to as value
Um.. is going to be the people who's stuff is in the locker. ok? Now, I have a question for you. Given data that looks like this, what would be kinda of a reasonable implementaion for a dictionary What would be a reasonable implementaion for a dictionary And I'll give you a hint ... That the, uh, particular example suggests an implementation The particular example suggests an implementation What did you say? No? Suggestion was string and I said no? Yeah? A list of pairs no? Yeah? An array why? (silence) Because, say it louder Nathan. Yeah, very good, so we're indexing by an integer value moreover these values are pretty small And do not even tell me that you didn't walk through your high school locker room and go.. Oh look I'm inside and array! (disappointing laughter) You didn't? Ugh... You will now! Next time you're in the locker room Ok, so, perfectly reasonable, perfectly reasonable, implementation of the dictionary Think how easy it would be to implement insert  If we had a private member called a" you could say a[k] equales The name Right? D here For example, whoo hoo, that's cool The problem is we're not always so lucky We're not always so lucky that our keys are smallish integers so the thing that makes this possible is that these are smallish integers Ok? Rather we're going to be faced with situations where our keys come in arbitrary types, like, oh, camera models Or colors or Fight numbers, they've got, or URL's for heaven's sakes Right? These are not numerical values Now, we could convert them, probably, to integers, but that's a different, but that's a different question Because then, converting, them to an integer that's small enough to use an array for is a whole nother puzzle So, here's what we're going to do We're going to use a binary tree as a dictionary Ok? So I want to say... Oh, and here's how to intrepret this binary tree The contents in the nodes are keys So, this 8 right here is the key And behind every vertex there's like a bubble Ok? Say, it's space in memory, we can think of it as a bubble, where the data dwells. Or the value dwells. Ok? So, the data associated with every key is accessible if you find the key. Moreover, we're going to assume, that key's are unique. Ok? Alright. And the datas are.. datas are associated The data is ... datas are ... ugh.. data is available Given a key We don't care how We don't care how, it's the data in the array For example So we're going to implement these things, we're going to implement these things using a binary tree. Maybe it's that the node contains the node class contains a data field That's what you need to hear Ok So, here's what I want I want you to do a find" of 4, returning the node associated with key value "4" What's your algorithm look like? Traversal? Very good. I heard somebody say traversal. So, we're going to go looking for a 4" (Cinda dropping beats) I don't see any fours Oh there it is! Here it is!
If we're going to do this, why not store our data linearly? It's possible that if were traversing the entire structure, if we have the potential for traversing the whole structure, we might as well be storing our data linearly. This is a bad idea. Let's do this instead. Take a look at this tree and tell me everything you can that's interesting about it. In what sense is it sorted? Someone describe to me how is it sorted? The smaller values are on the left and the larger values on the right. If things are set up appropriately, you kind of move left to right and you're essentially moving in increasing value over the nodes in the structure. Given the careful drawing of these things, that will always be true. Any questions about the observation of the order of this structure? This thing is called a binary search tree. We're going to use it as the implementation of our next implementation of a dictionary. A binary search tree, AKA BST is a binary tree and T is either empty or T is not empty. These are almost always cases for definitions of particular binary trees or specifications of binary trees The constraint is that X is an element of T L. If x is in the left subtree, then every element in the left subtree has value less than the key of r. You can complete the other line. A node in a right subtree has greater than key R. Where does the equal to case go? It has to be r. Because these are unique values. If x is equal to r, it is the root because they're unique values in the structure. You can choose arbituarily otherwise as long as you do consistently Futhermore, here's an example of something that satisfies that condition, but is not a binary search tree.  This satisfies that definition, but it is not a binary search tree.
How do we finish the definition? Do you see there does, satisfy the definition? Everything here is less than 37, DUH. Everything here is greater than 37. But clearly this is not a binary search tree so what's missing here? Must be true recursively. So Tâ and Táµ£ are binary search trees. Okay any question about it? Alrigh so umm Last time, uh oh we're in trouble because you're flipping your page and we're like... Oh it's perfect, we're going to finish today Last time, when we talked about binary trees, I actually gave you a slide that just looked like this except there was no data in the TreeNode structure. So I pretty much gave you this slide but right before talked implementation, but I didn't talk about it, the reason was because in a general binary tree insert, and remove are ill-defined. We don't have a prescription for where our data can be. For our general binary tree we can just put it anywhere we want and when we go looking for it we have to employ a traversal. So find, as we saw in the previous part of the today was just traversal. So but now now the world changes. Because now if I give you a piece of data. Say I give you I don't know 22. If I give you 22, and say: where should I put this in the tree?" You can go you can start with the root and go "I don't know where 22 goes"  but I do know it has to go in 38's left subtree. And then we can do that again. Here is another tree the problem is the same I need to insert 22 into this tree and you go okay 22 can't go here because I already have a node here. I don't know where 22 goes but it has to go in 13's right subtree. Oh, there is no room there. So again, I don't know where 22 goes but it has to go in 25's left subtree and look we've got room for it. There is nobody it's like goldilocks and the three bears there is no nobody... Wait no not quite like that. There is nobody in my spot... Wait, thank you. There is room there so we might as well put it there  Alright, any question about that? Now look what we've just experienced. Well Well, we've experienced a prescription for where a piece of data goes in a binary search tree. So you've got a given structure, and the new piece of data comes along, it's a well-defined process for figuring out where that value goes. Moreover, the same thing is true for finding the value. I'm going to look for, well, you tell me what we look for. Somebody raise their hand and give us a number. What would be interesting? Oh, I know, I got a quiz for you. Tell me something we should look for that would require three comparisons.
65, okay, let's try it, and count. Okay, we are go off on search node that gonna require more But we'll try, we'll prove him wrong. Can you handle being wrong about 3? So we gonna go on a search for 65, okay? Now is 38 65? This one is easy, you can now say no, okay? Fine, we haven't found it yet. We know where it must be. Where must it be? To the right Have we found it? No, so that's another comparision Where must it be? To the right, good. Have we found it? No, so that's another comparision Where must it be? To the left. Have we found it? No, that's a comparison. Where must it be? To the left. But there is nothing to the left. So, find 65 gonna returns NULL. Cause it will return what's there Alright, any question about that? So the same kind of reasoning that we apply to insert can be applied to find as well. Now, here is a a little foreshadowing for you. I am going to spend whole lecture on remove  Did you have question? Oh, good question. You are two lecture ahead. So she is worried about the fact that it might not be the case the tree is beautiful Well, it actually isn't quite beautiful Because we have approximately the same substructure on the left as on the right.   Do you see that? We have approximately the same, and we are pretty lucky. She is already thinking about what happens if those are not approximately the same substructure Does the world get ugly? It does. Okay, but we are not there yet, we are gonna do the simple stuff first Okay, what's the running time for traversal. Big of n still. That's right Alright, I want to return a treenode pointer. I'm writing a function called find for the BST class and it takes as two values  the root of the tree and some key to find okay? so here's root and I'm gonna call this version of find like this. Find on root and then whatever the key I'm trying to find. Let's find 40 in this example. So, if croot is equal to... we are gonna think about this recursively. And the way to do that is to break down the trees that you consider to two kinds. The first of which is null so if you original tree is NULL, what should you return so, return null We could actually return croot here, because it is null Alright, otherwise, the tree is not empty, so now we are actually in the recursive case. We are in the general case. if we are in the general case, we still have something to consider. Those 3 things to consider in this general case are: If the root is equal to the key. What should we do in that case? return the root. Otherwise, if our input key is less than croot's key. Is that a safe deference? Yes, because we know croot is not equal to null. That's the other case. If key is less than croot key, then what? return, good. what are we going to return? We gonna go looking for in croot left. So we gonna return find on croot left
65 okay let's try it and count. Okay we are going to go off on search no that's going to require more. But we'll try, we'll prove him wrong I think he can handle it. Can you handle being wrong about 3? Alright, thank you. So, we're going to go on a search for 65. Now, is 38, 65, that's one comparison. Is 36, 65? This one's easy. You can all say no. Alright, so we haven't found it yet, but we know where it must be. Where must it be? To the right, good. Have we found it? No, so that's another comparison. Where must it be? To the right, good. Have we found it? No, that's another comparison. Where must if be? To the left. Have we found it? No, that's a comparison. Where must it be? To the left. oh, but there's nothing to the left.  So, Find of 65 is going to return. Well, I don't know what the interface looks like exactly. We'll say it returns null. okay, because it will return what's there the tree node pointer. Alright, because it's not there Any question about that So the same kind of reason we applied to insert can be applied to find as well Now, here is a little foreshadowing for you I'm going to spend a whole lecture on remove Did you have a question Good question you are two lectures ahead of the game. okay So, she's worried about the fact that it might not be the case that the tree is so beautiful. This tree is beautiful. It actually isn't quite beautiful. What the heck is she talking about, right? Because we have approximately the same substructure on the right as on the left. Do you see that? We have approximately the same and we're pretty lucky. She's already thinking about what happens if those are not approximately the same substructure. Does the world get ugly and it does. But we're not there yet. We're going to do the simple stuff first. Okay. What's the running time for traversal? Big O of n still, that's good that's a review question alright, so let's right some code. I want to return a tree node pointer and I'm writing a function called find for the bst class. and it takes as two values the root of the tree and some key to find Okay so, here's root and I'm going to call this version of find like this. Find on root and then whatever key I'm trying to find. Let's find forty in this example. I'm not actually going to do it If cRoot is... we're going to think about this recursively and the way to do that is to break down the trees that you consider into two kinds. The first of which is Null. So, if your original tree is Null what should you return. okay so return null. we could actually return croot here it would hurt anything because it is null We just tested that it's null. Alright, find if so otherwise otherwise the tree is not empty. so now we are actually in the recursive case. We are actually in the case where we're not null. We're in the general case okay. If we're in the general case we still have some things to consider. Those three things to consider in this general case are if the root is equal to the key. What should we do in that case? return the root. otherwise, if croot's key wait I want to do it this way. If our input key is less than cRoot's key is that a safety reference? Yes because we know cRoot is not equal to null. That's the other case. If key is less than cRoot's key then what? Return. What are we going to return? We are going to looking for it. Right? We're going to go look for it in cRoot's left. So we are going to return the find on cRoot's left.
65 okay let's try it and count. Okay we're going to go off on search node that's going to require more. But we'll try. We'll prove him wrong. I think he can handle it. Can you handle being wrong about 3? Okay, alright, thank you. Okay, so we're going to go on a search for 65. Okay? Now is 38 65? That's one comparison. Is 38 65? This one's easy. You can all say no. Okay? Alright so finally we haven't found it yet but we know where it must be. Where must it be? To the right, good. Have we found it? No, so that's another comparison. Where must it be? To the right, good. Have we found it? No, that's another comparison. Where must it be? To the left? Have we found it? No. That's a comparison. Where must it be? To the left, ohhhh, but there's nothing to the left. So Find 65 is gonna return. Well, i don't know what the interface looks like exactly. We'll say it returns NULL, cause it'll return what's there Okay, alright because it's not there. Alright, any questions about that? Okay so the same kind of reasoning that we apply to insert can be applied to find as well. Now, here's a little foreshadowing for you. I'm going to spend a whole lecture on remove.  Yeah, okay. Did you have a question? Oh, good question. You are two lectures ahead of the game. Okay? So she's worried about the fact, she's worried about the fact that it might not be the case that the tree is so beautiful. This tree is beautiful. Well, it's almost, it's actually isn't quite beautiful. What the heck is she talking about, right? Because we have approximately the same sub-structure on the right as on the elft Do you see that? We have approximately the same and we're pretty lucky She's already thinking about what if those are not approximately the same sub-structure.  Does the world get ugly, and it does. Okay, but we're not there yet. We're going to do the simple stuff first. Okay, what's the running time for traversal? Big O of n still, that's right. Good. That's a review question Okay, alright, so let's write the code. Okay, I want to return a treeNode pointer. And I'm writing a function called find for the BST class And it takes as a two values: the root of the tree and some key to find. Okay? So here's root and I'm going to call this version of find like this. Find on root and then whatever key I'm trying to find. Let's find for you and example I'm not actually going to do it. Okay, so, if cRoot, we're going to think about this recursively, okay? We're going to think about this recursively and the way to do this is to break the tree that you consider into two kinds The first of which is NULL, okay? So if your reasonable tree is NULL, what should you return? Okay, so return NULL We could actually return cRoot here. It wouldn't hurt anything, okay? Cause it is NULL. We just tested that it's NULL. Alright, fine, if so otherwise, otherwise the tree is not empty, so now we are actually in the recursive case. We are actually in the case where we're not NULL. We're in the general case. If we're in the general case, we still have some things to consider. Those three things to consider in this general case are: If the root is equal to the key, what should we do in that case? Return the root Otherwise if cRoot key, wait, if our key, I want to do it this way. I don't know, it's easier for me to think about it if our input key is less than cRoot's key, is that a safety reference? Yes, because we know cRoot is not equal to NULL. That's the other case. Okay, if key is less than cRoot's key, then uhhh, what? Return, good. What are we going to return? We're going to go looking for it, right? We're going to going looking for it in cRoot's left. So we're going to return the find on cRoot's left
Otherwise, do we need to write down this final conditional? No, because we cover all possible other cases. Right? Otherwise, we are going to return the find of cRoot. right? Yes, what's your question? Oh, very good. Sorry, So, I messed up the arguments here. [blank] Any question about that it? Alright, I'm ask you to about the running time of this, and then let you answer. So, the running time of this algorithm depend on what characteristic of the tree. The running time of this part of algorithm depend what characteristic of the tree? The height of this tree, that's right. Now, we don't know necessarily what the height of the tree is at any given instance. We don't know whether it's an almost nice looking tree, like this one. Where the about the same height on either side. We don't know whether is like that, whether is dramatic spill. So, we are going to for now report the running time in term of this parameter whose value we don't yet totally understand. So, the running time here is big-O of h, where h is the height.  And notice that the reflecting running time this way does capture accent of the algorithm It does capture the fact the algorithm start at the top and works way down until it find a leaf perhaps  Or, in the worst case it find a leaf. It does't in contrast, it does't explore the whole structure. That is little bit different than traversal we saw before. Any question about that? Ok, fine. I think the future semester I'll change the order of this because I'll actually like for you to written some code. But, this one it a little dicer. So, it would be better to have switch them. Alright, so, we were going write code for insert.  And, this one return nothing. Again, it's a binary search tree member function.  Now, keep in mind that we might be use BST to actually implement the dictionary. So, we still got this responsibility to deal with dictionary kind of things. It's name is insert. And the parameter include the key in data together with a root to the structure. So, cRoot insert might be call on root and might be I am inserting number 0. I don't know 65 was not there, might be we should put it there. And, data.... I don't know, d. can be clever there. Alright, any question about that? So, this is how would look? I have a question really quickly before we write the code. Is insert public or private? Private because refer to the root, the tree node pointer right. It refers to the root, it has root as the parameter. And, you can't expect the client code necessarily know that. But, it does not said it couldn't insert root, it just have to build a public wrapper for its. Like we did last time. Ok, so, it's cRoot is equal to null. don't think about anything else other than if the root is equal to null, and I want to insert something  What do I do?
And I'm gonna do this by reference also. That helps. Blank Okay?So that means we can actually change it So croot is equal to NULL. There is nothing there. OK, nothing there Croot is equal NULL. Don't look at the picture There is no picture Croot is equal to NULL. And I've got data I wanna insert. Where does it go?  Here! right? All I have to do is? Make a new node to put the data in So I can say if croot is equal to NULL, then croot is  new, good. New tree node and I gonna assume the right constructer exist cuz I don't wanna spend time on it Ok? Don't sneaker. That is. That's ok Ok? Alright Any question about that All right. Fine. What if croot's key so now so now we are in the case for croot is not equal to NULL. Now we are in the case for croot is not equal to NULL So what if you are looking for a key and you find it you have the value already in your tree What should you do So this is the matter of design Here we are going to do nothing here we are going to do nothing. we are going to let the tree take a unique value. What you might do is  changing the data associated with that key Em.. but for this example we gonna go a look. Key have to be unique  and that key is already there So we're gonna ignore this case. So I am gonna in fact write do nothing here And we're gonna talk about it in a second Okay? Otherwise, if the key is less than croot's key. What are we gonna to do Hum? I don't know what are we gonna to do But I do know that I should. Because we are not putting it in here. we are not, we are not putting the node in this current  Subtree. I don't know where it goes. But I know it goes in the current node's left subtree So if the key if less than the croot's key than we are going to insert  croot's left in I am sorry insert into croot's left key and data Otherwise, we are going to insert into croot's right key and data blank And you what I am gonna do. I am gonna go ahead and clarify this  So if key is greater than croot's key. So here clarify that case In comple get rid of this one Because we want to do nothing so we should just let the execuation proceeds Through this conditional never satisfy any of them. That's a good way to do nothing  ALL right any question about it? What's yeah? we are never gonna connect the node. The question is when are we gonna connect the node and I'm gonna say You already did Cause it is passed by reference Okay? So we are already operating on the node that is passed in  I take it from you that is time to go  I wanna know the running time first blank Big O h right good That's good enough for me Alright Bye Have a great weekend Class is ended
I will do this by reference also, that helps. 0:00 - 0:01 : I will do this by reference also, that helps. That means we can actually change it. So, croot is equal to null and there's nothing there. Croot is equal to NULL. Don't look at the picture. There is no picture. Croot is equal to NULL And I've got data I want insert. Where is it go? Here, right? All I have to do is? Make a new node and throw the data in. So I can say if croot is equal to null then croot is new treenode. And I'm gonna assume the right constructors exist. Cause I just don't want to spend time on it, okay? Alright, any question about that? Alright, fine, what if croot's key, so now we are in the case for the croot is not equal to null. Now we are in the case for the croot is not equal to null. So, what if you looking for a key, and you find you have the value that already in your tree, what do you do? So this is the matter of design, here we are going to nothing We are going to let the tree take you need values. What you might do is change the data associated with that key. But for this example, we are gonna oh look keys have to unique and that key is already there, so we gonna ignore this case.  In fact, write do nothing here, and I will talk about it in a second. Okay, otherwise if the key less than croot key, what we gonna do? I don't know what we gonna do But I do know that I should because we are not putting in here. We are not putting the node in this current subtree. I don't know where it goes, but I know it goes in the current node's left subtree So if the key is less than croot's key, then we are going to insert croot's left Insert into croot's left key and data. Otherwise, we are going to insert into croot right. key, and data And you know what I'm gonna to, I'm gonna go ahead and clarify this. So if key is greater than croot's key So clarify that case and completely get rid of this one because we want to do nothing and so we should execution proceed through the conditional never satisfying any of them. That's a good way to do nothing Alright, any question about it? The question is when are we going to connect the node I'm gonna say you already did. Cause it pass by reference Okay, so we are already operating on the node that is passed in I take it from you that it is time to go But I want to know the running time first. Big O of H Right, good, that good enough for me 
Ok we should work Ok can you hear this if I talk like this? Yes you can Mute? No. Hey Tim, can you come here a sec So I feel like my fingers are not capacitive. Can you push on this arrow and see if it will interact with you? Alright I hear the echo Alright, so MP5 is out. MP 5 is my favorite MP because the bang for the buck of all of the MPs - the bang for the buck for the code that you write is the highest That is you can write extremely elegant code that ends up not being very long and when you write code like this Your de-bug cycle is shorter So a lot of your time spent preparing to finish up MP5 A lot of your time spent working on MP5 is going to be design time Like, what the heck is a quad-tree? And what the heck does it have to do with a collection of pixels? So you're gonna spend a lot of time working on it from that perspective. And once you gain that understanding, the code that you end up writing is quite elegant. Ok, I want to get us to a common point today, and then we are gonna try to do something new Oh, I know one thing -- I'm gonna announce Exam 2 on Wednesday. So I'm not going to write it up here now - there's no room! Well, I'm not going to write it up here now, but remind me to formally announce the  second exam on our next meeting. Ok, Mike, yeah? Oh yeah - MP5 is recursion. It's a tree MP - so duh! Ok Um Let's get started. So we were implementing an abstract data type called a ...
An abstract data type called a...there's a hint on the screen...dictionary. The Abstract data type that we were interested in was called a dictionary. Here is the functionality of a dictionary we need to be able to insert into it given a key. Insert into it given a key and data. We need to be able to remove elements from it given a key Find elements given a key and returning probably the key-data pair Probably that. And then of course we want to be able to see what things we have in a dictionary. Though this is a gift This is a gift not necessarily part of the original abstract data type.  This is by convention is really nice when a dictionary gives you the ability to get all of your data out of it in some efficient way. So we are talking about implementing dictionaries. What was the particular implementation we were working on? what was the particular structure we were using to implement dictionaries?  Binary search trees that's right. Here's an example of one and I think a quick glance will remind you of that thing, okay? Now, inside this class dictionary, which is templated to accept a key type and a data type.  I have sort of spelled out the necessary components that we needed to implement the dictionary using the binary search tree.  But, oh and going along with that, I asked you to just please accept that the contents of each node were keys, and that the data is hiding somewhere behind the node.  Then our focus became manipulating the structure based on their keys, okay? And we got most of the way through this little list of functionality here.  We did traversal a few days ago, we did inserting and finding in the structure.  And today we are gonna focus on remove it. Now at this moment I'm gonna stop talking about dictionaries per se.  And focus on the implementation. The rest of the code you are gonna see today, instead of being class dictionary,  is going to be class BST. And I'm not gonna focus on the data.  But suffice to say what we do in forms what might be actually a private member of a dictionary class.  So you might say that the dictionary contains, or has a binary search tree at the root of its implementation. Okay it's just a slightly different design. Another motivating factor for this was that I forgot to templatize the data in all the code that I wrote for the rest of the day.  And we don't need it for what we are talking about so I got rid of it and we are gonna focus on the keys.  That's all.  Alright, I want to do a little bit of review, and this is actually one of my very favorite moments.  If I can pull it together here. So this is a web page but it might be just an image of one, apparently.  Let me see if I can get it.  (trying to open up the web page)
You're going to love this as much as I do. So, this applet as a teaching device is extra awesome because it has sound. Alright, so, is this a binary search tree?  How did you check?  What was it that you checked, somebody raise their hand and tell me how they checked, there are a couple right answers here. Okay excellent, so taking a quick glance and making sure that the ordering property held, that particular strategy worked because the way that the tree was drawn was good. Â Whoever laid out this tree didn't happen to missplace their nodes, which they could have done, so how else could we check? Good, so an in order traversal of a binary search tree gives you the elements in order.  If you do an in order traversal of this thing they will be laid out in order. That is something that is a tying together of your experience with isOrdered from the lab from last week. Â Also it's binary search tree day and it'd be crazy for me to pull up a tree that wasn't a binary search tree. Okay so I'm going to insert into that tree a value that is 74's left sub tree. I want a node there, how many different unique values could I put there? Raise your hand with the answer... I should be seeing a bunch of bunnies (2). Okay, somebody tell me one of them. 73, okay... and insert... (animation plays).. YAH!  I'm telling you the sound really matters doesn't it? Okay fine here's another question for you, I want to know how many nodes will be looked at, that is how many bounces will occur in the search for key 40? k so I'm going to do a find of 40 and I want to know how many nodes will be looked at. Okay, so let's do a find on 40
Find one two three oh there it is yeah It was there right? Ok, three  So notice this is pretty cool it did have to examine the entire tree in order to determine whether or not it is already in the structure Ok? All right all question? about it? Ok, so whisper to ur neighbor   em..a value that could be 48's right child 48's right child Whisper to your neighbor Ok blank All right fine Done? Good, all right any questions about this I am gonna come back to this applet in a minute Ok ok Ok present Noooo Please What if I say please good Ok All right Ok So the only one of the major function associated with the dictionary class and with binary search tree implementation of the dictionary class we talked about is removal And I wanna spend a little bit time in fact all of the day, the entire day talking about removal Who knew it was so hard because actually inserted find pice of case Ok well I gonna go head and write the code for remove And I did so by cutting and pasting by cutting and pasting from insert And what I take from it , well, only, I only took recursive sub structure of the problem itself right?  I only took the piece of the code. I essentially took the piece of code that rises an artifact  of the definition of a binary search tree that is a base case we can argue a little about what that should be but the base case I guess it is more like fine not em.. insert.. em what to do if we are if the thing we are looking for the thing we are trying to remove is less than the key that is  key in the current node Or what to do if it is greater than the key in the current node Okay? Any question about that So we got equal to less than and greater than here any question about it? equal d That can't be right. right? I don't know what I mean I think this is supposed to..Let's see I should fix it. this is d, there Now, fixed I don't know Ok Why? I just call the key d instead of K That variable naming but at least now it is consistent all right fine This is what you want K, K, K K Is that make you happier cause kkk, key, instead of kkk k fine, whatever all right do I have a right now? yes ok thank you there are no brains ten feet twenty feet maybe here no brains at all all right so what is so hard about this this can't be hard. look it just inline of codes. we have seen those code before the issue is what the hack do we do when we do the removal Okay? So, I don't wanna think about exactly how to make the remove right now how to make the remove happen right now. So I am gonna push it off into some other function to be thought about latter now notice what this does from a software development perspective  If I write a scalaren function do removal that is if I have stub and have a a return. whatever I want   Then I can then I can pass this function without yet ever even have to implement this one Ok, so this idea of decomposing our you know seemingly maybe difficult task into this you know separated function   is something that gonna actually improve our quality of life our debugging processes which related to our quality of life Ok, why is this so hard why is this one linear kind of like find is  Em well
I look at this tree and something that are super easy to remove. what are the keys that are easy to remove. the leaf that's right the keys are easy to remove because..the leaves are easy to remove because wÂ how to find .e know..walk down the tree we can find something and if it is a leaf we simply snip off,right? ok so lets...well we will do that in a minute. so this one is easy any questions about that? we look at both code and example to see how this work in a second. which one is a kind of easy. what could be a node that does not seem to be that hard. discuss with some person sits next to you really quickly. leave nodes that are easy what is also not terribly diffi ok out of you discussion somebody raise your hand and explain to me why removing 25 will not be too difficult. why would we remove... very good notice that this string right here this sort of pieces of trees this is just looks like a linked list, right? because there is no branches to deal with in that context you already know how to remove things from a linked list. so removing 25 or 10 or any other nodes with that many children it is pretty easy so this one is  kinda easy but different  it is a different process on the other hand the heck all right what i wanna do is how do i switch apps like can i get back to my browser right now  swap from left side screen so like this one finger to three ten hoo hoo ok i think i can get back  one finger i am gonna show you how to do this two child removes i want you to watch closely i am gonna do it fast first and then i want you watch closely to what happens to see if you could articulate what  going on . but before we .... do this it must drive real windows uses crazy how like in particularly with the whole thing 71I want to remove yeah right 71 and delete it are you ready it is going pretty quickly i will slow it down in a minute but i want you ti see it  we found it what happened could we put something back there? we are gonna to insert...it does not have sound i am gonna plug in that i cannot help it it is full sensory experience ok now just to give you the feeling for you know what i am gonna do really radical  here. next we are gonna insert ...oh  it turn out i am gonna insert 41
Oh...I don't know....okay.  Okay?  And now I'm going to...keep in mind, I'm gonna say something first, before I actually...oh, does that mean it's working now? I dunno.  Ok I'm gonna do this.  Alright just a minute...soo keep in mind that what were... Im gonna remove 48, but this could just be any two child nodes in some larger tree, right? Like this is just some subtree. So I'm gonna not remove 26 for example and I'm gonna not remove 74 because I want you to have a bigger context in which to see what's happening, But I want you to remember that it might just be above 48 there's this humongous binary search tree of which this is just a little part. Alright, so I'm going to, I'm just gonna do this once and then Ill turn it off I promise....ok nevermind sorry I didn't have you sign the auditory stimulation waiver today, so I cant be too mean to you. Alright, 48...delete. Are you ready? Maybe I should slow it down. I cant read it...More options????? The interface needs to be better. Animation speed???? Go down....Kay, and bound type is fine, node size fine...tree size? I'm gonna make the tree bigger. No...reset...NO? No ok this is dumb....Alright close?? Alright now?? AUGHGHG of course.....Im sorry, sometimes a keyboard would just really be nice. 48....and delete. You ready??? Got it? Did you see what happened?? Okay!  Soooo what would happen if I did delete 36? What would happen? 32 would come up, that's right! Very good! What would happen if I deleted 74?? 73 would come up. What determines which one comes...which one swaps in? Its in the left side and it is...its the biggest one on the left side.    Okay we have a special name for it, its called the in order predecessor. Now all of the convers....I'll write it down in just a second, Any questions about it do you want to see it one more time?? yes??? YES!!!  you want to tell me what that other way is???  Yea sure we have a name for that too, its called the in order successor.   Yeah? Is your question too yes. it was an arbitrary choice to choose the biggest one in the left subtree to swap up there we could have chosen the one in the right subtree instead. The key observation is when you do an in order traversal of this tree, the order is not ruined. The order of the tree is not ruined, but by removing an element and replacing it with the one whose value comes just before it, the question is where in the structure does that occur?  So let's go back...okay. Look at this....oh I don't have to I don't think...I can do this right??? haha there.  This is kinda easy...Alright! So remove 13. We have seen the idea of in order predecessor, it is the max element in the left subtree. 
and we commonly refer to it as the IOP, OK we also have a notion of in-Order successorÂ which we refer to as the IOS and it is the min element in the right subtree now I have a very very subtle question for you OK, we're talking about removing, we're talking about the algorithm for removing a node with two children OK. We're talking about the algorithm for removing a node with two children. Do I have to worry that the in-Order predecessor does not exist? Do I have to worry that the in-Order predecessor does not exist No! Because I am always removing a node with two children, OK. So I don't have to be kinda crazy with my error checking, right? My task defines my tas..  my task as it is defined makes it so I don't have to worry about that they are not being an in-Order predecessor I wouldn't be doing a two-child remove if they weren't one OK. Alright, any question about that? OK. So what is this code going to look like, it's going to find the in-Order predecessor it's going to actually swap keys which we don't like very much, but we're gonna do it anyway. Keys aren't that expensive, they are not usually that huge of data items. So, we're going to swap keys. So one, find IOP. Two, swap keys.  Three, remove IOP OK, snip it off. Any question about it? Do you guys ready to write some code? Alght write some code OK, so notice that the function that I wanna write is doRemoval. OK, and that's what I refer to in a recursive skeleton Am..  and it assumes that I am passing in the node in the tree that I wish to remove and moreover, I handle on it that exists in the tree. So, for example , if I'm doing a two-child remove of 38, croot is not a copy of the pointer holding on to node 38. It is a name, another name for the node... the pointer to the node containing 38, OK. Similarly, if I do a two-child remove of 13, and I make a change to croot, I am changing 38's left child. And that is accomplished because I am passing the whole thing by reference. That's the intention here. OK. Ahh... one, no, one, two. The blanks contain the values no, one, two. You fill them in. Real quick, take a look at the code, you fill them in. What you get? I would hand you my thing, but I want you to have sounds so I am not wireless today. What did you get? What's the first blank? No child remove, very good. Because that says both of the children are NULL What's the second one? Two, good! And the other one? One, good. OK, why did I do that? Why did I do that? It doesn't go one, two, zero, one, two. Ahhhh... Why would I do that? Yeah?
Yeah, look, think about how messy the boolean would be, it would have 2 cases, for testing just for 1 child. Screw this, this is all the other cases, and those 2 are super easy. So when you're doing this, when you're evaluating a collection of booleans whose union is all the possibilities, take your most complex one and make it the else.    That's the easiest way to go about it. Any questions about that? Now look what I did here. I took due removal, and said oh my gosh", this is a huge task In fact it's a task that I don't want to think about all at one time. I'm going to break it down into these 3 little things. The first two I'm going to think about are these two. Because both of them are easy and kind of easy. So let's write the code for them real quick. So here's no child removed, and I'll just trace the code. I'm going to do a no child removed on this pointer, is that okay with you? I'm going to remove 12 and illustrate what the code does. It grabs hold of this, with temp, it sets cRoot = null, so this pointer is now gone and there's a null sitting here, and then deletes temp. So the end result is a null sitting where that whole thing used to be. Any questions at all about that? If I just said delete cRoot, cRoot = null, oh I probably could huh? Delete cRoot, cRoot = null Oh yeah that would be fine. I was probably on auto pilot here, which says grab ahold of something for deletion. I was probably on auto pilot here, which says grab ahold of something for deletion, that's all. I hate it when people come up with more elegant code than I do, I hate it. Alright, any question about it? Let's do 1 child removed, and maybe the same issue will exist here. So where is a 1 child we can remove? Looks like 25 is good, I'll do this one in green so we can illustrate it. So here is cRoot coming in, and we're going to remove 25. So the thing is that I don't have to, that I will already have found it back here, because cRoot = key here, and then I'm going to pass that through to here. So I will already have a hold on exactly the one I want to remove, and I have it by reference, so I can kind of be changing the parent as I go. Now, we could argue a bit about whether this is good style. What is does do is it keeps an empty tree from being a special case, that's why I'm going to leave that right there. So let's do this 1 child remove. Oh, again! It's not a lot of code, let's see if it does what we think it should do. So the first thing I'm going to do is grab hold of the node that I'm eventually going to remove. And then, I'm going to either reset this pointer, the 13's right child, effectively to be 25's right child or 25's left child, which ever one exists. That's what that conditional is doing. And in this case, it happens to be this assignment statement that goes. Because 25's left child is null. That means that in the end this one points there, or 37 gets kind of drawn up, and now I do delete temp.  You like it, does it seem good? Well that was easy. It was even better than kind of easy. Alright, you ready for 2 child remove? Don't peak, how many lines of code is 2 child remove? It must be really hard. Because, you got to do all this stuff, and you got to do all that stuff.
Three lines of code. Yeah? OH maybe. It might.. I don't know. Do you want me to go back and actually pursue that? I don't know if I believe that. I will look at it. Alright, fine So what's going on here? I'll give you a hint -- this code has a big bug. But it's not one of algorithm. It's one of implementation The algorithm does exactly what we said We are going to call the right-most tile of cRoot's left We are going to call it the IOP We are going to grab hold of it, as the IOP Then, we're going to swap the key from there up into the root So that seems okay. And then we are going to snip off the IOP And I know how to snip things off You just call doRemoval doRemoval will figure out whether it is a one child or a no child, and will do the right thing I already have a function to take care of that part Any questions about this? Yeah? No, doRemoval doesn't. doRemoval only looks to see how many children there are It just looks at the pointers - the left and right pointers. Ok? If you look, you have it on there Or I could go back. It's three slides ago Yeah? Where do I move the data. Oh yeah, so that was my initial thing We were talking about dictionarys, we're now talking about dictionaries We're focusing on the keys. We would move the data at the same time Hopefully we have a reasonable way of referring to the data so it doesn't incur a huge cost. It's a valid concern, but not a bug Ok, what's the bug here? Ready? Yeah? Good So what he said was, since you're passing by reference Since doRemoval takes something by reference It's gonna change exactly the pointer IOP But that's a local variable. Who the heck cares what IOP is It's a local variable, It's gonna go out of scope So I am going to change IOP, but then the effect of that change is really just going to break my tree So I'm gonna trace through that with you carefully in just a minute But I want to ask you one question first How do I know that this isn't going to incur an infinite loop? With the doRemoval.. Look how did I get to this function It was via doRemoval. How do I know I will not get into an infinite loop with twoChildRemove, doRemoval, Yeah? It doesn't have to be a leaf node -- That's not quite true It's almost true, and in the right ballpark Yeah You know IOP doesn't have a right child. It might have a left child Because those values are less. But it can not have a right child, because a right child would be bigger. And we're getting the biggest key in the left subtree Alright, so we don't have to worry about infinite loops doRemoval is going to end up taking us into no-child or one-child remove And I'm letting it diagnose which one, because I don't want to think about it I don't want to write anymore code to do it So now, let's trace this through and track down the bug Ok, sooooo I'll put  We're going to remove 13 and I'm going to put node 11 off here Just so that you believe me that the IOP isn't necessarily a leaf And, I'm going to do a removal of 13 TwoChildRemove of 13 So what does this code do? It goes and it assigns to variable IOP The rightmost child of cRoot's left. I don't know what that does But, it better give me IOP pointing here Do you see the problem? IOP is just a variable and I'm assigning to it a value It's not another name for something in the tree Now, when I do doRemoval of the IOP This thing right here is going to point to 11
This one is not, it's still gonna be hanging off clinging to memory we have deleted So That's the bug, do you see it, and it's all because IOP does not refer to one of the pointers in the tree, there's a couple ways of fixing this, we could rightmost child again here, uh c root's left but that feels wasteful right We could find it again and pass by the reference to it so we're holding on to it or this is something new, this is a new thing, but it won't surprise you, we can declare something  to be a reference variable. And i'll put this in a different color ink. We can declare something to be reference variable and if we do that then it becomes another name for whatever it was  that we assigned to it so then in that case, IOP would be a name for that variable in the tree So reference variables behave exactly the same way as reference parameters do okay yes, yeah Oh I don't have to swap, I don't have to do the swap 'cause I'm just gonna cut the other one off Right That's fine though because do removal takes, it doesn't care about key value At that point, it just says it just concerned with structure We've already said I want to remove you, we've already done all key evaluations That happened here, way out here Do removal is after we've already identified which one we want to remove okay does that make sense  Okay, alright, any other questions about this Okay, fine Uhh, what slide number is that, so second to last one Okay I have a question for you, what's the running time of this function of remove What's the running time of remove  And as you reflect on this answer Oh it isn't oh there's one more right okay We're not quite done, not quite done there's one more function right We need to write the code that gives up the rightmost child of the left subtree. How many lines of code is this one gonna be Uh, my question for you is is it code that contains a keyword that has a w"? Like while? so raise your hand if you automatically would think to write this thing recursively Okay, yeah me too the people always yell at me for it Uh so if the right subtree is already to null, then we found what we're looking for Otherwise, we're just gonna keep walking down the tree okay So, there you go, and what you should notice from this is that we are returning it by reference so that The thing that came in is actually going to be the handle on the thing that came out That's why it's okay to assign IOP to it It's not a copy to begin with it's actually in the tree And I'll leave that to you to untangle and goodbye  Oh what is the run time? Big O of h, big O of the height of the tree, we'll talk about it next time Uh let's see so you wanna know
Ok, so Mike described what Mike described was that oh please let me write on my screen. no it won't let me. Ok. what mike described was that 36 would be swapped up in place of 35 and the order of the values would not change. so so we had this small local set of data. so if i wrote down all the data in the tree in order, it would have looked like this. 23 35 36 54 74 etc. so if I had written down all the keys in the tree they would've looked something like this. now our goal was to remove 35. what we're saying is ok fine, go ahead and remove 35. we can do that if we either sort of let 23 or 36 take its place. ok. now we have special names for these things. the name we have for 23 is the in order predecessor. and the name we have for 36 is the in order successor. and these are in the slides from last time. now, you can't read this I'm sure because I can't. if you look at this applet and you go look at the menu you can choose whether or not you want to do a removal using the in order predecessor or in order successor. so this is recognized as a design decision that you're going to make. now I made the design decision to use in order predecessor because the textbook I used to use used in order predecessor. textbooks on data structures are about evenly split between IOP and IOS. but both of them are kind of wrong. because the consequence of always using one or the other if you're doing a lot of removals is that you get a tree that's kind of lopsided. if removals always happen from the left then the trees going to be heavier in general on the right. so you end up inducing an imbalance in the structure just by virtue of the mechanism you use for removal. real algorithms to do this would probably swap back and forth between in order predecessor and in order successor. yes, quickly. maybe. maybe. some definition of balance would come into play. it might be the height of the other subtrees and there are other metrics on trees you can use to assess the size of a subtree. k. balance almost always means that the sizes of subtrees are approximately the same. the question is how is size defined. is it height, is it number of nodes, is it some other metric on the size of the tree? that's for discussion and um. ok how is it? is it one finger if I do this? no. huh, yes. ok look. this is great. k. but I don't know why, ok fine. whoo, whoo, ok, fine, whatever. ok, any questions about all that? so I just wanted to remind that you that applet exists. i think i find it particularly useful. we'll use it again. ok, um, running times so we're talking about implementing dictionaries using binary search trees. so far any time we talk about implementations we're responsible for arguing about the efficiency of that design choice. that implementation choice. right now, this moment, the only thing we have right now to argue the running times of these algorithms are we we know they all use the height of the tree. they all traverse the height of the tree. they all walk down in the worst case. in the worst case the height of the tree is going to determine the running time. any question about that? alright, and then traversal of course just by way of reminder is big o(n) the amount of data in the structure. so, let's see. i want to know, this is just a little bit of practice. i want to know what this tree looks like. so really quickly declare my t to be a binary search tree. and go ahead and on paper, as quickly as you can implement that sequence of inserts. ok. will you do yours on my tablet? it doesn't matter you can make as many mistakes as you want. ok. so everybody do this, just build the tree really quickly. insert into the binary tree several times.
OK so what mike describe was that
Okay how do you feel about this. What does that look like, especially if you do okay so, look at the screen and rotate your head in the horizontal plane by 45 degrees. What does that look like? A link list? That's right. This thing is a linked list. Which means that, there are binary search trees whose performances really no better than a linked list. What was it about our data, that made this happen? Yeah Nathan? Yes, the data was already in. The insertions happened, now... this is a cautionary tale because a very common way of creating these structures from the start is to build them up incrementally, take data one at a time form some data source and build them up. It's also very common to store data in a sorted fashion so it's very possible that if you were to say to somebody, give me your data, I'll build you a binary search tree, and employ this algorithm, you would end up with a poorly behaved tree just because your friend happened to be helping you by giving you the data in order already sorted....does that make sense? SO, one thing you might do then, is anytime anybody gives you data, jumble it up. Mess it up. Create disorder. How many times in your life, has anybody in your life that it will help if you create disorder. Almost never right! Well, maybe it would here. We'll quantify that, but so here's the thing. It's easy to look at data and tell if it's in order, but these are not the only bad trees it's not just you know, either an increasing sequence, or a decreasing sequence, of numbers, that create a long skinny tree like this. Here's a tree, binary search tree, who knew!? Can you see it? There's the root, right child, left child... What I want from you, but this is a little harder, is a sequence of inserts that result in a tree that looks like this. Who would like to do it on my table... I want a sequence of inserts that create a tree like this, I'll assume they are in order. Can you all see this sequence of numbers results in..
A tree that looks like this? Now, when I look at that, it's a little harder to distinguish the fact, sorry, that there have been some sort of-- that there is structure to the numbers themselves, right? This isn't, you know, uhhh, I guess there's an increasing sequence, but it's very-- it requires a very particular decreasing sequence going the other way, kind of. Right? So, it's easy to say, yo, do not give me data in sorted order. But it's a little harder to say, make sure not to give me data that looks like this, cause I don't even now necessarily how to describe that. And yet, it made what looks like, kind of a bad tree, right? Like this linked list-y kind of tree. Any question about that? So now I have a question for you and this is a harder puzzle yet. I wanna know, how many bad n-item trees are there? K, so we agree these are bad trees, or at least they're no better than linked-lists. Um, I wanna know, if I have n pieces of data how many of those-- how many trees are there that look like this? [gibberish] We could do this remotely-- like a remote control thing, right? Like, I could say, and you can write, and... Are you working on this? My hint is to draw a few of other bad trees, and maybe to just kinda start counting them and think about it combinatorially with a picture. Yeah? Uh-huh. Oh yeah, sorry I'll do that. It's one, six, two, five, three, four. Does that make sense? So you insert one, that becomes the root. You insert six, it goes to the right. You insert two, it goes-- it's greater than one but less than six. Does that make sense? Yeah? And then you insert five. It is greater than one. Five, we're talking about five, k? Now where does five go? I don't know, but it has to go greater than one, it has to go less than six, it has to go greater than two, right? It would probably help if I drew this more like this, right? Like... right, like if this-- here's one, here's six, here's two, here's five. Okay. I should have-- I should have done it... Should have been more careful. Okay, anybody have any ideas for how many BAD n-item trees are there-- there are? So, I've got n pieces of data, I don't really care what they are. say they're the numbers one through n. I wanna know how many of these long straight trees there are. Yeah? 2^n?! Where did you come up with that? That was pulled out of the air! ...Was it? [laugh] Now where'd you come up with that? It's correct, I wrote it down. It's correct. So, where did that come from? Yeah? Oh, actually it might be 2^n-1. Ohhhhhhh! [laughs] Okay, where does that come from? Yeah? Yeah? Uh-huh.
A tree that look like this, now when I look at that, It is a little hard to distinguish the fact that there has been some sort of, there is structure to the number themselves, right? This is a, I guess, an increasing sequence. But it requires very particular decreasing sequence going the other way. So it is easy to say, you, do not give me data in sorted order. It is a little harder to say, make sure not to give me data that looks like this. Because I don't even know necessary how to describe that. And yes, it made what looks like bad tree, right? Like this linked-list kind of tree. Now I have a question for you. This is a harder puzzle yet I want to know how many bad item tree are there. We agree this is a bad tree because it is no better than linked list. I want to know if I have N pieces of data, how many trees are there are there that look like this? My hint is to draw a few of other bad trees. And may you would just start counting them. Think about the combinatorial of the picture. One, six, two, five, three, four. Make sense? You insert one, that becomes the root, you insert six, goes to the right. Insert two, goes left. Then, you insert five, greater than 1, less than 6, greater than 2. It would probably help if I draw like this. I should be more careful. Anybody have the ideas for how many bad items three there are? I got N pieces of data. I don't really care what they are. There are number one through N. I want to know how many long string tree there are. Where do you come up with that? It is correct. I wrote it down. Where does that comes from? Actually, might be 2 times N minus one. Where does that come from?
A tree looks like this. Now, when I look at that it's a little to harder distinguish the fact, sorry, that there has been some sort that there is structure to the numbers themselves right? This isn't, you know, uhhhhhhhh, I guess there is an increasing sequence, but it's very, it requires very particular decreasing sequence going the other way kinda right? So it's easy to say yo do not give me data in sorted order. But it's a little harder to say make sure to not give me data that looks like this, because I don't even know necessarily how to describe that, and yet and made what looks like kind of a bad tree right? Like this linked listy kind of tree. Any questions about that? So now I have a question for you, and this is a harder puzzle yet. I want to know how many bad n-item trees are there? So we agree that these are bad tree, that are no better than linked list. I want to know if I have n-pieces of data, how many of those how many trees are there that look like this? Ok, I take it back. We can do this remotely like a remote control thing. Right? Like I can say and you can write. Are you working on this? My hint is to draw a few other bad trees and maybe to just start counting them and think about combinatorial with the picture. Yeah? uh-huh, oh yes, sorry. It's one six two five three four. Does that make sense? So you insert one that becomes the root. You insert six and it goes to the right. You insert two it goes it's greater than one but less than six. Does that make sense? Yeah? And then you insert five it is greater than one. five. We're talking about five. Now where does five go? I don't know but it has to go greater than one. It has to go less than six. It has to go greater than two. Right? It would probably help if I drew this more like this. Right? Like this here's one here's six here's two here's five. Ok. I should have should have been more careful. Hey, anybody have any ideas for how many bad n-item trees there. So I got n-pieces of data, I don't really care what they are. Say they are the numbers one through n. I want to know how many of these long straight trees there are. Yeah? two to the n? Where did you come up with that? That was pulled out of the air. Was it? hehehe. Now where did you come up with that? It's correct. I wrote it down. It's correct. Where did that come from? Yeah? Oh, actually it might be two to the n minus one. OHHHHHHHHHHHHHHHHHHHHHHHHHH. HAHAHAHAHAHAHA. Ok, where does that come from? Yeah? Yeah? Uh-huh.
Ohhhhhhhhhhhhhhhh. Ok. So notice when you're building these trees that you are making a sequence of left-right decisions. You are making sequence of left-right decisions, right? The first thing is always going to be the root and then you're going to decide whether the tree is going to have the, uh, whether your next data element is going to be something smaller in which case you go to the left, or something larger in which case you go right. So, it's simply each one of these tree is simply a, uhh, a sequence of decisions of whether you go left or right. To re-enforce that, I can write down right left left right right right left. I can write down n of these and it prescribes a tree. How many choices are there? Well there are n minus one choices. There's one for each edge here. There are n data elements n minus one edges, and there is a choice of right or left for each of those. And so in total it's two to the two time two times two times two to the n minus one times. Yeah? Because, uhmmm, here's how I really do it. For data equal to if n equals two, how many trees are there? How many trees are there for n equal two. two right? So this is how I really do it. I go oh gosh if it were two to the n that would be four. HMMMM. It must be n minus one and I check that out. I'm serious. Simplify your problems. Always simplify your problems. Ok, so two to the n minus one. Also, recognize that the data is the number of nodes, but the decisions for where the tree goes are edges and there are one fewer edge there's one fewer edge than yes. Mike? Oh yeah, this is a tree. oh yes, this is definitely a tree, no cycles here. Oh what is it? Rooted. hehe. A connected, acyclic graph that is rooted and ordered and binary. Ok, Alright did you have another comment? ok. Alright, anything else here about this? Alright. I didn't know I didn't plan. Alright. Is this a big number or a little number? A LOT. This is a lot of bad tree. Which means that it means that we really can't count on the order in which the data comes at us to use as a criteria for building these structures. Right. If we just build this structure using this strategy, but okay I'll just enter into it whenever you give me data. It's possible. It's possible that you know that we're gonna get a bad tree, and that height that the algorithm insert remove and find will take us a long time, because we have this tall tree. Ok? Alright. Well, uh. We should quantify this. We should quantify this.Ok. Alright. So, here's what we're going to do. We're not happy with Big O of h for running time, because people who listen to you argue about the efficacy of your algorithm always want to hear about there running times in terms of the amount of data your structure contains. So the analysis, whoops, the analysis
The analysis or the argument about how good the algorithm is should be in terms of N, so we can make these arguments if we understand if we keep completely understand the functional relationship between H and N. Now here what we are going to do. H in this context represents the running times of our algorithms, so H is a running time, it is a stand in proxy for the running time, we recognize that it is you know, is some constant factor of H. We don't know what the coefficient in front of H is. But what we are going to do is we are going to argue that H is at least this much. As a function of N um, uhh, for running time, the running time is at least this much as a function of N. Now what does that mean we are doing, we are in official terms putting a lower bound on the running time of an algorithm and we are saying that if someone comes to you and says they have a better algorithm. That is, they say they have an algorithm that is less than whatever we come up with for f(n) you go NO! Thats not possible, you're algorithm must not work. Because no such algorithm exists, thats what a lower bound gets us. Lets see. No algorithm can do better. Can have better worst case performance, alright but at the same time, at the same time, we need to argue about the relationship of the running time on the top end. That is we want an upper bound on the running time, because that, in fact we say a tight upper bound. Because thats actually the currency we use to argue, which algorithm is better, ohhh I've got a structure that implements a dictionary in constant time, that means an upper bound, in the worst case it is constant time. I have an algorithm that ok, yea. We'll talk more about that in a minute. K any questions about that. Alright so um, as a reminder because we are going to be arguing about height, and because our argument is going to be recursive and need this. Um I want you to remind me what the height of an empty tree is. Do you remember? What we have defined the height of an empty tree to be. Zero. Negative 1. thats right. If that bothers you, if that bothers you remember that the english definition of height is the length of the longest path from a root to a leaf. The english definition longest path root leaf. An empty tree has no root, so this is sort of an indeterminate question in the context of our understanding of heights, so we get to make it anything we want. Its indeterminate, we can make it anything we want, so we chose something thats convenient, that makes this recurrence work well for us. Alright any questions about that? All of that. Ok uhh lets see. So it turns out, it turns out we're gonna do this one first and this one second. It turns out that this is kind of a complex, tends to be a complex argument. And if instead we equivalently argue this.
Now you're allowed to tell me the +1/-1 stuff. 2^(h+1)-1. Should I believe him? And that's for h>=-1? Ohh, yeah, look at that, it works. Should I believe him? No, we should not believe him. How do we prove it? Yes, this is like day one induction. This right here, this is day one induction. Super easy! In fact, I'm going to call it Back of the Envelope" induction. Ok? Um, I already eye-balled it to check to see if the base case worked. Did you see what I did? I eye-balled the base case by plugging in h=-1. There, ok, eye-balled, check. Did it break? No, 2^(0-1)=0 m(h)=0 whew! Ok, now what is my Back of the Envelope, super quick, evaluation of the recurrence (the recursive case)? m(h)=1+2* what goes in that box? (2^((h-1)+1)-1) all in parentheses [m(h)=1+2(2^((h-1)+1)-1)]. Ok, what did we do there? We applied the inductive hypothesis, but I didn't write it down; and that's okay. [Gasp!] Don't tell Margaret. [laughter]. Ok, so what went on there, the inductive hypothesis was applied. Ok, any question about it? Is that okay? Raise your hand if you no that's not nice. Tell the person sitting next to you if that's not okay and I won't watch, if that freaks you out a little bit. So, I'm assuming you can be candid with your friends. So, have a minute of discussion, have a minute of discussion, please, like okay, not okay, I can't believe we're doing this, feels revolutionary but okay. Yeah, is Margaret still watching? Oh my gosh! I just asked for class transcription too, shoot! Ok, so, alright, any questions about it? I won't actually get the polls of the class. This is how grown-ups do induction. Ok. Oh, sometimes when it's this straight forward. Okay, any question about it? And it all works out, right, you do the math and it all works out, oh look! I did all that arithmetic in my head. Aren't you impressed? (kidding) Okay, but we're not done. Here's what we know. We know that I'm going to say this in English and write it in math, ok, we know that the number of nodes in any tree of height h is less than or equal to is no more that 2^(h+1)-1. The domain is greater than uh-oh! ok, but that's not what that doesn't say anything at all about our algorithm. Right, that's not what we want to say, h represents our algorithm, the running time of our algorithm so, all we have to do is invert this function. okay, I'll race you. So it looks to me like this one goes to n+1 oh I'd better take the log of that and then subtract 1 from the whole thing and I have h>=log(n+1) a constant here. ok, now how do we say this, how do we say this using the discrete math that we know? We say that h is big omega of log(n). Ok, now do we have all of the pieces? H is at least some constant factor of log(n) right? two of them.
Greater than half a point probably. Yeah, its a lower bound. So you know how big O is like a less than an equal to, big O if you go back and you look at the definition from 173, prerequisite, you look at the definition, big O is like less than or equal to, big omega is like greater than or equal to. And their definitions are symmetric in almost every possible way. Any question about that? Alright. Any other questions about this? So now this says no algorithm, if somebody comes to you and says they have a binary search tree where the key functions work in time less than log (n) say they run in constant time, you go ah then its not a binary search tree, you might be doing something else, it might be a dictionary but if you're using a binary search tree those functions cannot run in time better than log n. Okay. This falls in our world of how tall is the binary search tree in general, hows that logn. Like that is where that conversation goes. Okay, so we did this one we did this one, lets do the other one as well. Now were trying to argue is that h is less than or equal to some function of n. Okay, no matter what. What we what to do is go big here. Okay fine whats the very largest tree we can make out of n nodes. Because the height has to be less than that. Whats the tallest tree we can make with n nodes? I don't wanna ask this question its stupid. Okay. Whats the tallest tree we can make with n nodes. N-1, right. N-1. Tallest tree is N-1 so in general if you have n nodes, the height is always going to be less than or equal to n-1. Okay so if you take n nodes and you look at all the possible trees you can, none of them is going to have height greater than n-1. So look, again we got a close to something that looks like a definition from cs173 in this less than or equal to. So instead of less than or equal to, we are going to write it is big o of n. Where we ignore constant factors and we roll the less than or equal to card into that symbol, into the definition. Alright so is this good news or bad news. Bad news right. What if we did this same argument about linked lists? We did the same argument about linked lists, we'd have the same result, so we should all be sitting here thinking we should all be sitting here thinking well binary search trees really aren't all that good then, shoot we had so much fun, and its not important to us. Okay well it turns out the following is true. If you consider
of n keys. Again this is 173. Most people say 173 is a reasonable prerequisite. Alright but here is the cool thing. here is the result. you're ready for the result. If you take all the n factorial arrangement and you builds trees from a tree from each of them and then quanitify the heights so this is one would be 1 2 3 4 5. This is one has 5 and this one has height 2 and you take the average over all of those, you get a result that is bounded by. What do you hope by right here? log(n). you get a result that is bounded by log(n) and so that's good. it means that random trees are good trees. if you have a reason to believe that you data is inserted in an arbitrary order then you have hope bigger height of your trees not too bad so that's good news. we could fill in this table but I'm going to leave it to you to do that because i want to talk about something else that's more interesting. you can do that offline you can do it on piazza if you want because I want to talk about this. i want to talk about desert. I have here two trees that contain the same data. two trees that contain same set of keys. which one do you like better? the one on the right. right? okay so the way we're going to describe this as we go forward is we prefer trees that look like mountain to trees that look like sticks. so that now though we can rely on our affection for mountains or sticks, instead we have to quantify. we have to give our selves a way of differentiating between things that we like and things that we don't like. so we gonna define a metric on a the root of subtree so this the height balance of a tree so tree is any. it could be a subtree as well so this is true recursively. so its the definition at any root at any subtree, we gonna take the difference between the height of the left subtree and the height of the right subtree and call that the balance. okay? so this is just the difference between subtree heights. okay? so T tree has balance if its an empty tree or tree T is equal to T not empty then its height balanced b that is the balance that it holds is. what do you think this will be? 0 right, that would be perfectly balanced but guess what? we gonna let be a little bit not zero. yeah we gonna let trees a little bit out of balance. every good life has a good balance and not good balance and its this definition then that. this is an example of a definition that differentiates between this tree and this tree. OH! its a recursive definition and TL and TR are height balanced. and that's where we will start next time is figuring out what this balance gets us
of n keys. Again, this is 173 right? All these people that say that 173 isn't a reasonable prerequisite. ukh. I dont know. Alright. umm but here's the cool thing, here's the result, you ready for the result? If you take all of those n factorial arrangements and you build trees a tree from each of them and then quantify the heights so this one would be one two three four five this one would have height 5 and this one would have height 2 and you take the average over all of those you get a result that is bounded by what do you hope I right here? log(n). good you get a result that is bounded by log n. okay so that's good news it means that random trees are good trees that if you have reason to believe that your data is inserted in an arbitrary order then you have hope that the height of your tree is not bad. so that's good news. umm this is a point at which we could fill in this table but I'm going to leave it to you to do that because I want to talk about something else that is more interesting. Okay so this is busy work you can do that offline you can do it on the piazza if you want cause I want to talk about this. I want to talk about dessert, okay? I have here two trees that contain the same data. two trees that contain the same data same set of keys okay. which one do you like better? the one on the right right? okay so the way we're gonna describe this as we go forward is we prefer trees that look like mountains to trees that look like sticks okay that just looks like a stick to me okay like a branch on a tree okay alright so now though we cant rely on our affection for mountains or sticks instead we have to quantify we have to give ourselves a way of differentiating between things that we like and things that we don't like. so we're gonna define a metric on umm on uhh the root of a sub tree so this is umm a height balance of a tree so tree is any it could be a subtree as well so this true recursively its just the definition at every umm root of every sub tree we're gonna take the difference between the height of the left sub tree and the height of the right sub tree and call that the balance. okay so this is just the difference between sub tree heights. okay so a tree t is height balanced if well if its an empty tree..empty trees are height balanced okay or if t is equal to if tree is not empty then it's height balanced if b that is the balance that it holds is what do you think this would be what do you think this would say. zero right that would be perfectly balanced at the same height but guess what we're gonna let it be a little bit not zero yeah we're gonna let trees be a little bit out of balance huuh. every good life has balance and not balance okay and it is this definition then that different this is an example of a definition that differentiates between this tree and this tree. OH its a recursive definition so tl and tr are height balanced okay and thats where we'll start out next time is figuring out what this balance gets us
Count down to the game. Ok I'm gonna start because I have some stuff to talk about first. Ok so raise your hand if you knew this was homecoming weekend. Ok not bad, its homecoming weekend that means there is a parade this afternoon at 5:00 its kinda ohhh I don't know what time. Does anybody know what time the homecoming parade is 5:00 Ok. Every time I've ever gone its a blast. Um its just i don't know its a great day, um if you're gonna go to a football game this season, this is a good one to go to. The teams are evenly matched, at this point at least in terms of record. And it promises to be a pretty festive affair, um yea. So the problem with this is that I hear that our lab dict is um more challenging than it has been in the past, is that true. So here is what I want to say about that laugh, Um I think it is important because I think dealing with an unfamiliar interface is what you will do authentically everyday in your programming life, dealing with new specifications and how pieces of software tools talk to each other. thats a profoundly important skill. Um its also important to understand how to apply dictionaries and to see them as a tool and a resource for solving problems where you might be kind of surprised that they apply. So those two things together make this actually yes a more challenging lab, but also quiet a more important lab. Now all of that said it is not inconsistent that I am encouraging you to go to the football game and talking about how important this lab is, because you can go to the game and work, no no thats not what I meant. No. No. What I want to do is remind you that our labs are designed to be collaborative, so don't try to do this lab by yourself, don't sit in your dorm room or wherever you chose to work by yourself, trying to crank through this lab, find a white board and a friend and go get it done. Okay, that amount of code you have to write is not a lot, so find a white board and a friend and work together and talk out this lab, because that is when learning, thats when learning happens. Alright any questions about all that. I am going to the football game because we have to go to out of town this weekend, but otherwise we would. Okay. Alright okay, at this point we are into the second half of MP 5, i think nothing about the announcements here surprises you. Ohh the second exam is coming up but still almost two weeks away. So it'll be on Tuesday night November third. Okay. I'll put that here, exam two and I'll put it in red, because you know thats what we do with exams. Okay. And it may 7:30 to 10:30 I don't remember the room reservations, if we don't get the room till 7, we won't start the exam till 730 ish. Okay so last time we were talking about binary search trees and, we sort of have this emotional journey between kind of being disappointed in binary search trees worst case performance. And being encourages by the fact that, on average, though, if you average over all possible binary search trees, that you can build from a collection of data, that result is not so bad. That in fact the average height of a binary search tree is logarithmic, alright so we started of on this new um, uh, avenue of investigation, one which gave us a measurement of how balanced a tree was, now lets talk about this term balanced. It could mean a whole bunch of different things it could mean the number of nodes on each subtree of a binary search tree, it could mean something that we referred to as a rank of a binary search tree, which is sort of like the largest imbedded perfect tree. The rank, yea the the height of the largest imbedded perfect tree. Just another metric, that will not be on the test, probably. Ohhh. Um, but the one that we are focussing on for now, is balancing via height. So making sure that our search algorithms um, traverse subtrees that are approximately equal in height. Okay, so we define this measurement on a tree, um, which is just the difference in the heights of the subtrees, okay no mystery there. Um, I'm not really, I never remember whether this is L-R or R-L it sort of a matter of low level detail, but you can kind of debug when you need to but, uh, so so if you ask me I'll probably look at you empty, with empty eyes uhhhhh. Its the difference that matters, the absolute value of the difference. Okay, so this is a measurement on a tree, this is a characterization of a tree. Ok so, this is a measurement I'll fix that
Countdowns the game. Okay, I'm gonna start cause I have some staff to talk about first. Okay, so raise your hand if you knew this was home coming weekend. Okay, not bad. It's home coming weekend. That means there is a [gibberish] on this afternoon at five o' clock, it's kind of... oh, I don't know what time. Does anybody know what time the home coming [gibberish] is? Five o' clock, okay. So every time I've ever gone it's a blast, em..it's just... I don't know. It feels good. It's a... it's a great day. Em... If you gonna go to a football game this season, this is a good one to go to, em the teams are evenly matched at this point at least in terms of record, and it promises to be a very festive affair. Em... yeah. So, the problem with this is that I hear that out lab dict is, em... more challenging that it has been in the past. Is that true? Okay, so here's what I wanna say about that lab. Em... I think it's important, because I think dealing with unfamiliar interface is what you will do authentically every day in your programming life, right? Like dealing with... em... dealing with new specifications and how pieces of software tools talk to each other. That's a profoundly important skill. Em... it's also important to understand how to apply dictionaries and to see them as a tool and a resource for solving problems where you might be kind of surprise they apply. So those two things together make this actually maybe as a more challenging lab but also quite a important lab. Now, all of that said, it is not inconsistent that I'm encouraging you to go to the football game, and talking how import this lab is, because you can go to the game and work... no no, that's not what I mean. No no, what I want to do is remind you that our labs are designed to be collaborative, so, don;t try to do this lab by your self. Don't seat in your dorm room wherever you choose to work by yourself, trying to [gibberish] through this lab. Find a whiteboard and a friend, and go get it done, okay? The amount of code you have to write isn't a lot. So find a whiteboard and a friend, and work together, and talk out this lab, cause that's when learning, that's when learning happens. Alright, any questions about all that? I'm not going to football game cause we have out of time this weekend, but otherwise we would. Okay. Alright, so this point we are into the second half of mp5, I think nothing about the announcement here surprises you. Oh... the second exam is coming up, but still almost two weeks away. So it'll be on Tuesday night, November 3rd. Okay, I'll put that here. Exam 2...and I'll put it in red, because... you know, that's we do on exams. Okay. Maybe 7:30 to 10:30, I don't remember the room reservation, cause we don't get the room until 7, we won't start the exam until 7:30. So, yes. Okay, so last time we are talking about binary search trees, and we have a sort of emotional journey between kind of been disappointed in a binary search tree worst case performance and been encouraged by the fact that on average, though if you average all possible binary search trees that you can built from a collection of data, the result is not so bad. That in fact, the average height of a binary search tree is logarithmic, okay? Alright, so we start it of on this new... em... em... avenue of investigation one which gave us a measurement of how balanced a tree was. Now let's talk for second about this term, balance. I could mean a whole bunch of whole different things. It could mean the number of nodes on each subtree of a binary search tree. I could mean something we have refer to as the rank of a binary search tree which is [gibberish] like the largest imbalanced perfect tree, the rank, the height of the large imbalanced perfect tree. Just another [gibberish], you don't... that will not be on the test, probably. No! Em... but the one that we are focusing on for now is balancing the height. So making sure that a search algorithm, em... traverse subtrees that are approximately equivalent height. Okay, so we defined this measurement on a tree, em... which is just a difference in the height of the subtrees, no mystery there. Em... I'm not really, I never remember whether this is L minus R or R minus L, it's sort of a matter of low level detail, but you can kinda debug when you need to. But, em... so If you ask me I'll probably look at you empty, with empty eyes. It's the different matters, the absolute values are different. Okay, so this is a measurement on a tree. This is a characterization of a tree. So this is a measurement... I'll fix that.
At this point we are into the second half of mp5. We have this sort of emotional journey to be kind of disappointed in binary search tree's worst case performance, and being encouraged by the fact on average though, that if you average all possible binary search tree that you scan build from a collection of data, the result is not so bad, that in fact, the average height of a BST is algorithmic. So we started off on this new avenue of investigation which will give us a measurement of how balance a tree was, now, let's talk about the term balance, it could be the number of node of each sub-tree of a BST, it could mean something that we refer to as the rank of a BST that is sort of like the largest imbedded perfect tree. That will not be on the test probably, but the one we are focusing on for now, is balancing via height so making sure that our search algorithm traverse sub-tree that is equal height. Okay, so we define this measurement on a tree, which is just the difference of the height of the sub-trees. I never remember whether this is L-R or R-L is a low-level detail. So this a measurement on a tree, this is a characterization of a tree.
On a tree... and this one is a characterization... of a tree... that uses that measurement. Okay? So, the... um... the vocabulary is the same, but there's a subtle difference in their application. Alright, so we say that a tree is height balanced if... uhh..if it's an empty tree, an empty tree is height balanced. Umm... or if it's not empty, then, you know, the recursive the recursive nature of this definition says that whatever is true for the entire tree must be true of the subtrees. And, I think, what you wanted me to write here is b=0, but I didn't. I wrote the absolute value of b is less than or equal to 1. So, rather than demanding... rather than demanding that a binary search tree be perfectly balanced, and all it's subtrees, we allow a little wishy-washyness, we allow a little bit of imbalance. And the question is whether that's a big sacrifice or whether it kinda gets us where we want. Uh, any questions about that before we go on? Okay, so... is the tree on the left, ignore the little trees, is the tree on the left height balanced? Okay... I'll say no it's not. It is not height balanced. Now, I want you to find me this sub-the subtree that is not balanced. The subtree rooted at...51, very good! So take a look at 51, at that node. And what you observe is that, you know, the height of the left subtree is 0 and the height of the right subtree is 2. You know, I don't ever really think about the heights of those trees. I kinda eyeball it and look at the difference in the levels. Oh, look! There is a subtree where the left and the right different by 2. So, hence, this tree is not height balanced. Okay? Alright... uh... let's see..So what we're going to do what we're going to do moving forward is... um... take our earlier observation take our earlier observation that we prefer mountains to sticks. And we're going to view the change we're going to view it as an operation on the tree to go from a piece of a tree that looks like this to a piece of a tree that looks like this. Okay? And the piece of the tree that looks like this is going to be based on the observation that this example tree is out of balance. And, by doing some little operation on the very same data, we create a tree that is very nicely balanced, thank you very much. So now let's apply that thought that impression to this tree. Where is the stick in this tree? Where is the stick that we might want to change? Where is the string of nodes all of which play into what might be con- what is an imbalance. Why there it is! Okay? So starting at the tre- node that is out of balance, the lowest node in the tree that's out of balance, because it's possible that there was another node out of balance. But starting at the lowest node in the tree that's out of balance, we're going to observe that anything that looks like this... if we applied this magic operation and just changed that portion of the tree, we could actually change the structure of the tree in a way that... um... reduces the height. Okay? And we're going to talk about how to do that in just a second. Alright, any questions about that? No, there are no technical details. By the end of the next slide, you will know how to do all the pointer assignments necessary in a pointer based tree to make that happen. So, if it feels technically a little mysterious right now... that's perfectly fine. Okay, i have another question for you... um... How would we asses... How would we find 51 and determine that it was out of balance. What would be an algorithm Just kind of a loose description of an algorithm to figure out whether or not 51 is out of balance? Eww, that's a hard problem, right?
measurement on a tree. And this one is a characterization of a tree that uses that measurement. Okay, so the vocabulary is the same, but there are some of the difference in their application. So the tree is height balanced if it is a empty tree. An empty tree is height balanced. Or if it is not empty, then you know the recursive nature of this definition says whatever is true for this entire tree must be true of the subtrees. And I think what you wanted me to write here was b equal 0, but I didn't. I wrote the absolute value of b is less than or equal to one. So rather than demanding that a binary search tree be perfectly balanced and all of its subtrees, we allow a little bit of imbalance. And the question is whether that's a big sacrifice or whether it can get us what we want. Any questions about that before we go on? Okay, so, is the tree on the left height balanced? OK, I'll say no, it's not. Now I'll need you to find me some subtrees that are not balanced. The subtree is rooted at 41. Take a look at 41,that node. And what you observe is that the height of the left subtree is zero and the height of the right subtree is 2. And I don't ever really think about the heights of those trees. I cannot eyeball it and look at the difference in the levels. Look there is a subtree where the left and right is different by 2. So hint this tree is not height balanced. Let's see. So what we are going to do moving forward is, take our earlier observation that we prefer mountains to sticks. And we're going to view the change, an operation on the tree to go from a piece of the tree that looks like this (middle) to a piece of the tree that looks like this (right). And the piece the tree that looks like this is going to be based on the observation that this example tree is auto-balanced. Ant by doing some little operation on the very same data, we create a tree that is very nicely balanced. Thank you very much. So let's apply that thought, that impression to this tree. Where is the stick in this tree? where is the stick that we might want to change? Where is the string of nodes, all of which play into? What is an imbalance? Right there, it is? So starting at the node that is out of balance, the lowest node in the tree that is out of balance, because it is possible that there are other nodes out of balance. But starting at the lowest node in the tree that is out of balance, we are going to observe that anything that looks like this, if we want to apply this magical operation and just change that portion of the tree, we could actually change the structure of the tree in a way that reduces the height. Okay, we'll talk about how to that in just a second. All right, any questions about that? No, there is no technical details. By the end of next slide, you will know how to use all the pointer assignments necessary in a pointer based tree to make that happen. So if it feels technically a little mysterious right now, that's perfectly fine. Okay, I have another question for you. How would we assess, how would we find 51 and determine that it is out of balance? What would be an algorithm, just kind of loose description of the algorithm to figure you out whether 51 is out of balance? That's a hard problem, right?
What? Who's talking to me? Is that you? Ok yes, what's your suggestion, thank you. Ah, okay so you want to write a recursive function to do this right? So write a recursive function that checks to see if these are out of balance, so the code that can check for balance is almost gonna look like a traversal. You can write the recursive code that says, okay, I'm gonna look and make sure my left subtree is balanced and my right subtree is balanced, AND, what else are you gonna check? Because, look, for 51, the left subtree is balanced, right? And the right subtree is balanced? so what else are you going to check? What are you gonna check? If you're sitting at 51, and you've made a recursive call, that came back, oh yep, your left subtree, perfectly balanced, no problem. Your subtree, balanced, no problem. So then what are you gonna do. Yeah? Check if its balanced. At that node what information do you need to do that? Yes, very good. You need the height of this subtree, and the height of this subtree. Okay, so here's what we're gonna do. We're going to augment the information stored in every node with the height of that node. And we're going to maintain that as we do insertions into the structure. Okay, so one of the, a little asterisk about what we're going to do, by way of foreshadowing, is: it would be helpful to store height in each node. We'll talk about exactly how to do that in a minute. This is all intuition. Okay, so, let's do some mechanics here. Um, I wanna change this since I don't like this tree very much. I wanna change the structure of it. I noticed that the whole tree is out of balance right at 50. 50 is the root of the tree that is out of balance. Yes? Is that true? Did I eyeball that correctly? Okay. But, so is 80. So i'm gonna actually focus the code we are gonna write together, the algorithm that we're going to employ, is going to focus on the lowest node in the tree that's out of balance. So here's what I'm gonna do. I'm gonna take this stick, and change it into a mountain. So that means, for that subtree, I'm going to change 90. I'm going to change that subtree to 90, 80, and 99. Okay and now we have to hook things back together. Now where do things go? I don't know for sure but here are my observations. I have one, two, three, four places I can hook subtrees into the original tree. And I have, one, two, three, four places I can hook subtrees into the new structure. That's good. If that were different we'd have a problem. So four places in the old structures, four places in the new structure. And if you notice, in the old structure, we have the following, we can make the following observation. Everything in this subtree labeled A here, is going to be less than everything in this subtree, which we're labeling B, because of the binary search tree property. Which is less than everything in this subtree, which is less than everything in this subtree. And furthermore, the relationships to their parent nodes correspond, and that will be true over here, and furthermore, the relationship to the parent nodes will be preserved if we only put A and B and C and D. Hook them up right here. Okay, so I'm gonna do this. I'm gonna put A here, whatever is in A I'm gonna put there. I'm gonna put B here, I'm gonna put C here, and I'm gonna put D here. Alright, so what is that? I'll do that in a different color so it's easier to see. So 80's left looks like this. B will now be 80's right, so that looks like this. C will now be 99's left, and D is empty. So there's nothing to do. So notice that this actually, for that subtree, for the subtree for 50's right child, we've actually reduced the height of 50's right child. Woohoo! Right, it used to have height 3, and now it has height 2. So that's cool. Now we just build the rest of the tree, just like it was before. We don't even have to think about it very much. 50 is still the root of the tree. 30 is still its left child, and 30 is still the parent of 20 and 40.
What? Who's talking to me? Is that you? Okay, yes, what's your suggestion? Thank you for.. Ahh, okay so you want to write a recursive function to do this, right? Okay, so write a recursive function that... write a recursive function that checks to see if these are out of balance, right? So, the code that can check for balance is, you know, its almost gonna look like a traversal. You can write the recursive code that says Okay, I'm going to look and make sure my left subtree is out of balance, or balanced, and my right subtree is balanced, and what else are you gonna check? Because, look, for 51, the left subtree is balanced and the right subtree is balanced. So what else are you going to check? What else are you gonna check? If you're sitting at 51 and you've made a recursive call that came back, oh yeah, your left subtree perfectly balanced, no problem. Your right subtree balanced, no problem. So then what are you gonna do? yeah? check if its balanced at that node what information do you need to do that? Yes, very good, you need the height this subtree and the height of this subtree, okay? So, here's what we're gonna do. We're going to augment the information stored in every node with the height of that node and we're going to maintain that as we do insertions into the structure. Okay, so [gibberish] a little asterisk about what we're going to do by way of foreshadowing is... it would be helpful to store height in each node. We'll talk about exactly how to do that in a minute, this is all intuition. Okay, so lets do some mechanics here. I wanna change this, I don't like this tree very much. I wanna change the structure of it. Notice that the whole tree is out of balance, right? 50, is the root of the tree that is out of balance. Yes? Is that true? Did I eyeball that correctly? Okay, but so is 80. So I'm actually going to focus the code that we're going to write together, the algorithm that we're going to employ is going to focus on the lowest node in the tree that's out of balance. Okay? So here's what I'm gonna do. I'm going to take this stick and change it into a mountain. So that mean, for that subtree I'm going to change 90, I'm going to change that subtree to 90, 80 and 99. Okay and now we have to hook things back together. Now where do things go? I don't know for sure but here are my observations. I have one, two, three, four places I can hook subtrees into the original tree. And I have one, two, three, four places I can hook subtrees in to the new structure. Thats good, if that were different we'd have a problem. So four places in the old structure, four places in the new structure and if you notice in the old structure we can make the following observation. Everything in this subtree labeled A here is going to be less than everything in this subtree, which we're labelling B, because of the binary search tree property, which is less than everything in this subtree, which is less than everything in this subtree. And furthermore the relationships to their parent nodes are... are correspond to... and that will be true over here. And furthermore, the relationship to the parent nodes will be preserved if we only put A and B and C and D, hook them up right here. Okay so I'm gonna do this, I'm gonna put A here, whatever is in A I'm gonna put there, i'm gonna put B here, I'm gonna put C here, and I'm gonna put D here. Okay? Alright, so what is that? I'll do that in a different color so its easier to see. Alright, so 80's left looks like this. B will now be 80's right so that looks like this. C will now be 99's left and D is empty so there's nothing to do. Okay? So notice that this, actually, for that subtree, for the subtree for 50's right child, we've actually reduced the height of 50's right child. Woohoo! Right? It used to have height 3 and now it has height 2, so that's cool. Now we just build the rest of the tree just like it was before, we don't even have to think about it very much. 50 is still the root of the tree, 30 is still its left child, and 30 is still the parent of 20 and 40.
Circular assignment of pointers. And this particular rotation is one that take the length of the tree and kinda moves it up around ninety for the new root. And because of this dance move, because it's like this and then up it is a left rotation. OK got that? Because it went from this side and moved the bulk of the tree left, and it's shadow dancing. OK so this is a left rotation. So this example is a left rotation. So the way I emphasized that sort of implies there is a symmetric operation called a right rotation where everything. Every left here is replaced with right, every right here is replaced with left and of course having a swap variable before you do that. Um but that the operation itself would be... would... the operations itself would be in that... Operation itself would be analogous. OK. Any question about this? Yes. Ah, very good. When we uh. Well you tell oh this is the perfect time to talk about this actually. I don't usually but this is really good. So I wanna know, in this structure whose heights changed? In fact you can kinda shade it with your pencil, as you're doing it sort of just do a little sketch over the heights in the structure that change in the rotation from this tree to this one. Which ones change? I'm gonna do it like this. OK, so eighty's height changed yeah? Ninety's height changed. Anybody else's? Height is the longest path from a root to a leaf in a subtree. Did we change A? Did we change A at all? We changed where it's located but did we change any of the nodes inside A? Take a look at A. Did we change A? Nothing's different about A at all, so none of the heights of its nodes can change. Yeah. No, yeah we are answering it with the whole tree, I'm not done here. Yeah. Yeah, so did A change? Did B change? Yeah so none of these subtrees had any heights that changed. Uh what about over here, twenty, thirty, fourty, any of that change at all? Absolutely not even participating in this, the rotation, right? OK what else changed? Yeah? Yeah. Oh it happened not to. Yeah, yeah, OK. It's true. Ninety's happens to not be different but might have if the tree had been shaped differently. OK so here's the deal. When you deal
Circular, assignment of pointers. And this particular rotation is one that takes the link of the tree and kinda moves it up around 90 for the new root. And because of this dance move, because it's like this, and then up. It is a left rotation. Ok, got that? Cauz it went from this side and move the book of the tree left. And it shadowed dancing. Ok, so this is a left rotation. So this example is a left rotation. So the way I emphasize that sort of implies that there is a symmetric operation called a right rotation where every every left here is replaced with right. And every right here is replaced with left, of course having the swap variable, or do that. But, that the operation itself would be. The operation itself would be an elegance. Okay? Any question about this? Yes? Em, very good. When we, emm... Well you tell. Oh this is a perfect time to talk about it actually. I don't usually, but this is really good. So I want to know, in this structure, whose heights changed. Okay, and in fact, you can kinda shade it, with your pencil. As you're doing it, sort of, just do a little sketch over the heights in the structure that changed in the rotation from this tree to this one. Which one's changed? I'm gonna do it like this. Sooo, 80's height changed, yeah? 90's height changed. Anybody else is? Height is the longest path from a root to a leaf, in a subtree. Do we change a? Do we change a at all? Do we change any of the nodes inside a? Take a look at a. Do we change a? Nothing's different about a, at all. So none of the heights of its nodes can change. Yeah? No, yeah, we're inserting with the whole tree. I'm not done here. Yeah. Yeah, so did they change? Did v change? Yeah, so none of these subtrees had any heights changed. Um, what about, over here? 20, 30, 40, any that changed at all? Absolutely not, even participating in this rotation, right? Ok, what else changed? Yeah? Yep? Oh, happened not to? Yeah, ye, ok. That's true. 90 happens to not be different, but it might have, if the tree had been shaped differently. Ok, so here's the deal: when you deal
When you write the code, the nodes choose the heights you need to update. The nodes choose the heights you need to examine are 80 and 90, the ones... the upper one in this stick. Because it's easier to do so, we also happen to update 99, but it will never change. So we can use same helper function for left and right rotation, I think, if I recall correctly. So 80 and 90 and every node on the way up the tree. Okay? Including in this case, 50. They might change. Okay? Any question about that? Yep? What is the height of 60 here? Heights go down, heights are measurement, so A is the subtree whose root is 60. A is the subtree whose root is 60. Height is measured as the distance to a leap. So when you looking at A, you are only looking it down the tree. Yes, I agree A's level changed, But not its height. Okay? So again this is an example of vocabulary that is very easily swapped, right? Make sure you see the difference a description of tree's level and a tree's height. They are kind of, almost inverses of one another. So it makes sense? It's totally clarified? Ok, anything else about this? Alright, so when we write real code for this beyond just assignment, we are going to do 2 things: we are going to assume each node stores its height and then we are going to update its height as we walk off the tree. Alright, so let's get some practice. Let's get some practice. And, as I said, the right rotation is symmetric. I looked at this tree and I go, oh ,it's kind a long on the left. So I am gonna take it and do a right rotation and fix it. Okay? So what's the first thing you do. You find... oh that's cool. Okay. And you have fixed it... Okay. Is it better really? I don't know. I need to be able to adjust it quickly. Alright, so find the stick, I need to change it into a mountain. I will raise you. You don't have to remember the code we already did, but I will raise you in changing this one into a mountain. Okay? So, I know how to do this... 40, 20, 70, and then I've got A and B and C and D. This was an easy one because a lot of them marked empty. And I am gonna hook those on here. A and B. C is 50 and 60. And 70 is right tail. It's 80. Okay! Got it, yep? To get the same tree? Okay, check the neighbor, haha. Put your nose on your neighbor's paper. How they do? Rough them out if they didn't do any work. Just kidding. Oh, hi ,what's up? Oh nice. Okay. So we have a beautiful new tree huh? What you think? Shot. It didn't help anything. So can you see why? Can you see what kind of happened here? You see what kind of happened? Why didn't this work? What happened? Nobody wants to articulate?
To a right rotation, I think, if I recall correctly. Um, And eighty so eighty and ninety and, every node on the the way up the tree. ok including in this case, fifty, might change. ok? Any question about that? yeah? Whats the height of 60 here? heights go down. heights are measurements so a is the subtree whose root is sixty. A is the subtree whose root is sixty, height is measured as the distance to a leaf, so when you're looking at A, you're only looking down the tree. Yes I agree A's level changed but not it's height, ok. So again this is an example of vocabulary that is very swapped, make sure you see the difference a description of a tree's level and a tree's height. Ok they're kinda almost inverses of one another. Does that makes sense, Does that totally clarify. Ok anything else about this? alright, so when we write real code for this beyond just these assignments, we;re going to do two things, we're going do two things, we're gonna assume each node stores it's height, and then we're going to update the height as we walk up the tree. Alright, so lets get some practice, lets get some practice. And, as I said, the right rotation is symmetric. I look at this tree and I go its kinda long on the left, so i'm gonna take it and do a right rotation and fix it. Ok? so whats the first thing you do? you find whoa that's cool. Ok? I know how to fix it. ok. Is it better like that, I don't know, I need to be able to adjust it quickly. Alright, so you find the stick, and you change it into a mountain. Ok, I will race you. You don't have to write the code, we already did, but I will race you in changing this one into a mountain. Ok, so I know how to do this its... forty twenty, seventy, and then I've got A and B and C and D. This was an easy one because a lot of them are empty, Then, I'm gonna hook them on here, A and B and C is fifty and sixty and seventy's right child is eighty. Ok. Got it? yeah did you get the same tree? Ok check your neighbor. haha put your notes over in neighbor's paper. How did they do. rat them out if they didn't do any work heh heh heh. just kidding oh hi whats up. Oh nice. sorry. thank you for listening Ok, so we have a beautiful new tree. huh what do you think. shoot. ugh darn it. it didn't help anything. So can you see why, can you see what kinda happened here? can you see what kinda happened? Why didn't this work? what happened. Anybody want to articulate it?
When you write the code the node whose heights you need to update the nodes whose heights you need to examine are 80 and 90, the upper ones in this stick because it's easier to do so. We also happen to update 99 but it will never change just so we can use the same little helper function for left and right rotation, I think, if I recall correctly. And 80 and 90 AAAND every node on the way of the tree. Including, in this case, 50. They might change. Any questions about that? Yeah? What's the height of 60 here? Heights go down. Heights are measurements so A is a subtree whose root is 60. A is a subtree whose root is 60, height is measured as a distance to a leaf. So when you're looking at A, you're only looking down the tree. Yes, I agree A's level changed but not its height. So again, this is an example of vocabulary that's very easily swapped. Make sure you see the difference between the description of a tree's level and a tree's height. They're kind of almost inverses of one another. Does that make sense, totally clarified? Anything else about this? Alright, so when we write real code for this beyond just these assignments, we're going to do two things, we're going to assume each node stores its height and then we're going to update the heights as we walk up the tree. Alright, so let's get some practice. Let's get some practice. And as I said, the right rotation is symmetric, I look at this tree and I go oh, it's kinda long on the left, so I'm gonna take it and do a right rotation and fix it. So what's the first thing you do? You find- woah that's cool. K. I know how to fix it... Is it better like that? I don't know I need to be able to dust it quickly. Alright so you find the stick, and you change it into a mountain. K, I will race you. You don't have to write the code we already did. But I will race you in changing this one to a mountain, k? So I know how to do this it's... 40, 20, 70, and then I've got A and B and C and D. This was an easy one because a lot of them are empty. And I'm going to hook those on here. A and B, C is 50 and 60 and 70's the right child of this 80. Ok! Got it? Yeah? Did you get the same tree? Okay. Check your neighbor. Put your nose over your neighbor's paper. How'd they do? Rat them out if they didn't do any work! Just kidding. Oh hi, what's up? Oh nice! (K sorry! Thank you for listening) Okay. So, we have a beautiful new tree. What do you think? (Cute!) It didn't help anything. So can you see why- can you see what kinda happened here? Can you see what kind of happened? Why didn't this work? What happened? Anybody want to articulate it?
Ok, I'm going to do this kind of loosely at first, and then we'll talk- we'll kind of gradually edge toward more official discussion on it ok? The part of the tree that made this long, made this tall and stringy is in the middle of the tree. And the rotation just took that thing that's making it long and moved it over. K, so the solution to this is to do the following. Do- first do a left rotation, so that we change the balance of the left subtree, so we're going to make it- we're going to take the 50, 60 and kinda move it over so the stringiness is all in one direction, and then we're going to do a right rotation. So this tree requires a double rotation in order to fix it. Alright, so let me- let me draw that all out, and we'll do the rotations and then we'll talk about what has happened here. So, the observation here is that we don't actually have a stick. We have a bent stick. K, the stick is bent. So what we're going to do is first, a rotation around 40, and then a right rotation- a left rotation around 40 and then a right rotation around 70. K, so ok I can do this. Ummm... Left rotation around 40 means that this is my stick for the moment. K, so I'm going to 50, 40, 60 and then I have to put 20 in the right spot on 40, and the rest of the tree still looks like this. And this was a- oh, sorry, yeah a left rotation about 40. Left rotation. K? And now, when you look at this tree, oh it's very sticky. Now, it's a simple right rotation around that stick. So again, I'll race you. 50, 40, 70, and then I attach 20, and I attach 60, and I attach 80. So this is to get to the next one is right about 70. Okay. I have questions for you. How long does it take to do a single left rotation? Constant time, good. Constant time. Because of those assignment statements. What about updating the heights? Hmm... It's also constant time, because you're storing the heights in the subtree. You don't have to do any- uh, you don't have to do any traversals to get those heights. So we're storing the heights in the subtrees so readjusting heights within a rotated subtree is a matter of within the stick, is a matter of just looking at the nodes in the subtrees. Kay, so rotations are constant time so what if we do two of them? It's still constant time, very good. Just a bigger constant. Where'd my machine go? Alright, so, rotations are constant time..
Okay I am gonna do this kind of loosely force, then we will kind gradually edge toward more officially discussion of it Okay? The part of the tree that made this long, made this tall and stringy is in the middle of the tree. And the rotation just took that thing. It's making it long and move did over. Okay. So the solution to this is to do the following. First, do a left rotation so that we change the balance of the left subtree. So we are gonna take the 55,60, kind of move it over so the stringiness is all in one direction. And then we are gonna do our right rotation. So this tree requires a double rotation in order to fix it. Alright, so let me draw that all out. And we will do the rotations and then we will talk about what has happened here. Okay? So your observation here is we don't actually have a stick. We have a bent stick. Okay? The stick is bent. So what we are gonna do is first a left rotation around 40. And then a right rotation on 70. Okay? So okay I can do this. Left rotation around 40 means that this is my stick for the moment. Okay, so I'm going to... 50, 40, 60, then I have to put 20 in right's bottom of 40. And the rest tree still looks like this. And this was a, oh, sorry, yeah, a left rotation about 40. Left rotation. Okay. And now, when you look at this tree, oh it's very sticky. Now, it's a simple right rotation around that. So again, I all raise you 50, 40, 70. And then I attach 20 and I attach 60 and I attach 80. So this is, to get to the next one, is right about 70. Okay. I have questions for you. How long does it take to do a single left rotation. Constant time, good. Constant time, because of these assignment statements. What about updating the height. It's also constant time, because you are storing the heights of subtree. You don't have to do any, you don't have to do any traversal to get those heights. So we are storing the heights in the subtrees. So readjusting heights within a rotated subtree is a matter of, within a stick, is a matter of just looking the nodes in the subtree. Okay? So, rotation is constant time so what if we do 2 of them? It's still constant time, just a bigger constant. Alright, So rotation is constant time.
and that's a really good news cause it means we can adjust the structure of tree by spending a little bit more time on our insertion and removals just quite complex but satisfying nonetheless yes! (students asking) so right very good so we are going to look at this but I am answering the question right now so we will wait a minute when you go back up the tree adjusting the height that is cost you time and the answer to that is that you will do that in the context of insertion right? like all of this is happening in the context of some other manuplation on our tree like insertion so we've already spending the time navigating the height so yes we are going to spend a bit more time but not more time in the insertion would taken anyway ok? so at each stage in the worst case we just gonna to do a rotation but it will still be only at every level of the tree in the worst case actually insertion there proves you to do at only once ok any question so far? yes! (students asking) oh very good so the question is how to I choose seventy, forty and fifty? so there is a mystery here and I consider it to be diagnosing the need of the rotation ok and it is exactly the right question right like I don't know why I could observe that it is the bent thing instead of the straight thing except right now you do have the intuition that is too long in the middle ok we are gonna actually I think I have slide in two slides that help you to diagnosing exactly how you figure out which rotation to do ok so this is the exactly the right question to do alright so here is the summary here's we know so far there four kinds of rotations this one I should say this is an example of double rotation called a left-right rotation so left is like an left modifies right ok still a right rotation it just say lefty right rotation ok there are four kinds: the singles in each direction left-right and right-left ok they are all symmetric so that means that currently we are already know how to write the code for one of them they are local operation that is ABC and D and also all subtrees on the other side of the imbalanced subtree none of those are affected em and we are just readjusting the structure of binary search tree we are not breaking a binary search tree in any way ok? alright. so our goal is to use these rotations to maintain the balance of a binary search tree em this particular height balanced tree these are called AVL trees where AVL they are a collection of initials for these guys whose name I always forget Adelson-Velsky and Landis two people and this was done in 1962 ok? alright so here's I am gonna say about that so this is two people who did this there are particularly kind of tree there are other balanced trees you will see the references to red-black trees if an interview or if you are reading an research paper or somebody refers to red-black trees kind of quizzes about it you say in our discrete structure classes we did an AVL tree instead and oh you can get red-black trees if you know AVL trees when I took the theory classes when I took what's now 374 here decades ago they did red-black trees there and they may still I don't know for sure alright and the thing I'd like to point out is look this is not all that long ago this is a relatively short time ago it's kind of weird right? like this is when your grandparents when they are in their height of career properly about
And that's really good news because it means we can adjust the structure of the tree by spending a little more time on our insertions and on our removals which is quite complex but satisfying nonetheless. Yes? So right very good. We're gonna look at this but I'm going to answer the question right now. Wait a minute. When you go back up the tree adjusting the height that is costing you time. And the answer to that is that you're doing that in the context of the insertion. Right? All of this is happening in the context of some other manipulation on our tree like insertion. So we're already spending the time navigating the height so yes we're gonna spend a little bit more time but not more time than the insertion would have taken anyway. So at each stage in the worst case we're just gonna do the rotation but it will still be only at every level of the tree in the worst case. Actually in insertion there's proofs you only do it once. Ok any questions so far? Yes? Oh very good. So the question is how did I choose 70, 40, and 50? So there's a mystery here and I consider it to be diagnosing the need for a rotation. Ok? And it's exactly the right question. Right? I don't know why I could observe that it was this bent thing instead of this straight thing except right now you do have the intuition that it was too long in the middle. We're going to actually... I think I have slides we have two slides that it help you diagnosing exactly how you figure out which rotation to do. So that's exactly the right question. Alright. So here's a summary. Here's what we know so far. There are four kinds of rotations. This one I should say this is an example of a double rotation called a left-right rotation. So left modifies right. Still a right rotation it's just a leftishly right rotation. Ok so there are four kinds. The singles in each direction and left-right and right-left. And they're all symmetric. So that means that our code we already know how to write the code for one of them. They are local operations that is A B C and D and also all subtrees on the other side of the imbalanced subtree none of those are affected. And we are just readjusting the structure of the binary search tree we are not breaking the binary search tree in any way. Alright so our goal is to use these rotations to maintain the balance of binary search trees. These particular height balanced trees are called AVL trees. Where AVL they are a collection of initials for these guys whose names I always forget: Adelson Velski and Landis. Two people. And this was done in 1962. Alright so here's what I want to say about that. So this is two people who did this. There are this particular kind of tree. There are other balanced trees you will see references to red-black trees. So if an interviewer or if you're reading a research paper or if somebody refers to red-black trees and kind of quizzes you about it you say in our Discrete Structures classes we did AVL trees instead and they're go oh oh oh you can get red-black trees if you know AVL trees. When I took the theory class when I took what is now 374 here decades ago they did red-black trees there and they may still. I don't know for sure. Alright. And then the thing I like to point out is look this is not all that long ago. This is relatively short time ago. This is weird like this is when you're grandparents were at the height of their career probably... about.
So It kind of makes it like it's not calculus. The reason we choose this height balanced tree, I strongly believe, that if you got a friend in white board, you could figure out how to do this yourself. You can just as easily has your names on it as these people who happen to be interested at that time. It makes feel very accessible to me. We are moving toward implementation. You know the mechanics of doing a rotation but how to deploy it at all. That's OK. We are going to talk about that. We need to be carefully how to maintain the height and we need to detect the imbalance. So this one I feel like you already know. You understand the need for the second one and the third one we haven't talked about at all. OK, we already kind of talked about this. I forgot that I had a slide for it. Is this tree height balanced? What's the lowest node in the tree that is out of balance? Five? Good. And what kind of rotation would you expect to restore the rotation? This is intuition right now there is no algorithm for you to apply. So this is all you intuition for what we have done so far. What kind of rotation? A right rotation. Yeah, a right rotation. Do you think it's single or double? Single, because it is not right here that is long. Good. The only thing I want you to observe is that the height of this one is going to change, the height of this one is going to change, and in fact the height of this one is going to change on the way. It is a recursive call on the whole structure. Keep in mind that this piece might be a subtree of some much larger structure whose height may also change. Because this is the root of the longest path and the height of the structure further up would change as well. Alright, any questions? We already did this. OK, this is the moment when we have to identify the need of a rotation. Here is the thing. Last night, I puzzled over this slide for a while because I never like it. I never like how this slide goes. Here is why. It's starts with the assumption that you have inserted into a particular place. The thing is that's true. That's what determines the rotation that we do. So I couldn't think of another way to do this. So, it the insertion was in subtree t3 or t4 and the imbalance is detected at t, that's the setup. Now, what determines whether the insertion was in subtrees t3 or t4? We were doing an insertion. What would that have meant? It meant that it was greater that t's right. So insertion in subtrees t3 or t4 means it was greater or equal to the key of t's right subtree. So this is sort of an equivalent. t is greater or equal to t's right. Any questions? That's what it means. And the imbalance the insert is detected at t. Remember that's just look at the height of the left and right of the subtree. So that's looking at the left and right of the subtree. And imbalance means that it's heavier on the right that imbalance is two then, the height difference is 2. Then what do you think I'm going to write here? What kind of rotation do you think is going to fix this? Left, good. Left rotation about r rebalances the tree. I think it's easier to gage this if we judge the insertion position by greater or equal to t's right. But actually we can also observe that the balance factor at t's right actually has to be one.
So it kind of makes it like this is not calculus, right? The people were not wearing togas when they did this. And the reason we choose this kind of height balance tree is I really strongly believe that if you've got a friend and a whiteboard, you could figure out how to do this yourself. It could just as easily have your names on it as these people who happen to be interested at that time. So, it makes it feel very accessible to me. Alright, so we're going to move toward implementation. You know the mechanics of doing a rotation but not how to deploy it at all, and that's okay. We're going to talk about that. We need to see; we need to think carefully about how to maintain the height, and we need to be careful about detecting the imbalance. So this one I feel like you already know. You understand the need for the second one. And the third one we haven't talked about at all. Okay, we already kind of talked about this. I forgot I had a slide for it. Is this tree height balanced? What's the lowest node in the tree that's out of balance? Five. Good. What kind of rotation would you expect to restore the balance? So this is intuition right now. There is no algorithm for you to apply. So this all just your intuition for what we've done so far. What kind of rotation? A right rotation. It would delight me to no end to see just somebody do like this during an exam. That would, like, be so fun. Alright, so yeah, a right rotation. Do you think it's single or double? Single, right. Because It's not right here that's long. It's already the weight is pushed way left. So good, your instinct is really good here. And the only thing I wanted to observe is that the height of this one was going to change. The height of this one was going to change, and in fact, the height of this one was going to change on the way up. It was a recursive call on the whole structure. Keep in mind that this piece might be a subtree of some much larger structure with who's height may also change because maybe this was the longest path, and so the height of that structure further up would change as well. Alright, any question about it? We already did this material on the previous slide. Okay, yay! It's the moment when we are going to identify the need for a rotation. Now, here's the thing. Last night, I puzzled over this slide for a while because I never like it. I never like how this slide goes. Here's why. It starts with the assumption that you have inserted into a particular place. The thing is that that's true. That is what is going to determine the rotation that we do. So I couldn't think of another way to do this. So if an insertion was in subtrees t3 or t4 and imbalance is detected at t, that's the setup. What determines whether an insertion was in subtrees t3 or t4? We were an insertion. What would that have meant? It meant that it was greater than t's right, right? So an insertion in subtrees t3 or t4 means it was greater than or equal to the key of t's right subtree. Fine, so those are sort of equivalent. Key is greater than or equal to t's right, the key that you're inserting. Alright, any question about that? That's what it means. They mean the same thing. Okay, and an imbalance is detected at t. Now remember that's just looking at the heights of the left and right subtree. That's looking at the heights of the left and right subtree. An imbalance means that it's heavier on the right, that imbalance is 2 then. The height difference is 2. Then, what do you think I'm gonna write here? What kind of rotation do you expect to fix this? Left. Good. Left rotation about t rebalances the tree. We gauge this so I actually think its easier to gauge this if we judge, if we judge the insertion position by the key greater than or equal to t's right. But actually we can also observe that the balance factor at t's right actually has to be 1.
So they kinda makes it like this is not calculus, right? These people will not wearing togges when they did this.
Class is at 11 o'clock. Umm, let's see. All right. So umm, this is what I'm talking about. So raise your hand if you went to football game. Ok. So e, a student section was full. A student section was like more full than the stadium. Yes! Way to go. Umm, I wasn't there, cause it was my mother in law's 80 years' birthday parties. So you know, call it family politics. Umm, but this is what it was like in the pre game. It was a big party. So somebody who went, somebody raise your hand again if you went to the football game. Was it blast? Yeah, and we won't talk about the outcome. I will tell you though, I will tell you that my mother in law's 80 years' birthday party was in Wisconsin. So I was hearing, you know, I was hearing the game updates from the wrong side. The whole time my husband was looking at me like hahaha. So, you know, family, family complexitiies. All right, so, let's go to school. Let's play school, ok. Umm. So you'll have an exam a week from tomorrow. Umm, we are gonna do it, you know, all of our good attentions have gone a waste here. We are going to do a big exam. This is known as the tree exam. So all the questions on this, almost all the questions on this exam will be related to trees in one way or another. Umm, though it will also include maybe a little bit more series treatment of stacks and queues. You should notice that Level Order Traversals, Level Order Traversal is a great way for me to ask you both about queues and about some related to trees and about MP4. So make sure you really, make sure you see the connections betweeen, umm, queues and stacks as well actually. And traversal of trees and MP4. Cause that is a sort of very rich set of topics around which we can build questions. Now, I don't say that with any knowedge of what the exam looks like. I don't even writing the exams. So I'm just saying that if I were you, that would be one area of sort of integrated learning you might take pretty seriously. And then on this end of things that's the beginning, the stacks and queues was the kind of the beginning. We also have not yet test you on iterators in any reasonable way. So I would expect multiple choice question or something related to iteration and generic programming in c++. Umm, also let's see, umm, oh on this end of things, all the way through Friday's lecture on this week will be on the exam. So we'll finish up B trees on Friday. We are finishing AVL trees today. We are gonna do B trees Wednesday and Friday. And then there will be this kind of queen break away from trees. Ok. Umm let's see. And we'll be providing you opportunities for review. And we usually do an MP5 solution party right, you know, in those few days between MP5 and exam. Umm, what else, you can do your own MP4 solution party if you like. It's not as complex as MP5. All right, umm, I'm gonna save playing around with the [o no heck]. Let's just do it. Slide this, hoho, and go here, and go here. Oh, yeah it's this. And now I'm actually going to turn on AVL. Ok. So last time we talked about fondamental algorithms for, fondamental algorithms for maintaining balance in a tree. Today we are gonna actually write the code or I'm gonna show you the written code for [insortion], Am I believe removal happens in labs. I believe you write the code for removal in lab. Umm, but ohh hey. look. ok. I can recover. like this. Oh and we are good to sound this light. ok. Come on everybody. Everybody's happy. Everything is awsome.
classes is at eleven o clock alright so this what I'm talking about so raises your hand you would supporting ok so ah the student section was full the student section was more full than stadium yes! a long ago I was not there cause it was my mother birthday party so you know probably family politics but this is what was like a pregame it is a big party so somebody who went somebody raises your hand if you went the ball game? was it a blast? yea and we won't talk about the outcome I will tell you thought I will tell you that my mother birthday party was in Wisconsin so I was hearing you know I was hearing the game updates from the wrong side the whole time my husband loos at me is like HAHAHA so you know family family complexities ok so let's go to school lets play school ok em you have an exam a week from tomorrow em we are going to do it you know all of our intentions is gonna waste here em we are going to do a big exam this is known as the tree exam so all the questions on this almost all the question on this exam will be related to the trees in one way or another though we will also include maybe a little bit more serious stacks and queues you should notice that level-order traversal is a great way for me to ask you about both queues and about something it related to tree and about MP4 so make sure you see the connections between queues and stacks as well actually and traversal of the trees and MP4 cause there not be sort of very rich set of topics around that we can build questions now I don't say any knowledge what is exam looks like about and I am not even writing the exam I am just saying if I were you that would be one area of sort of integrated learning you might take it very seriously and on this end of thing that is the beginning stacks and queues are kind of the beginning we also have not yet tested you on iterators in any reasonable way so I would expect multiple choice question or something related to iterations and generic programming in C++ em also let's see em on this end of thing all the way through Friday's lecture this week will be on exam so we will finish up B-trees on Friday we are finishing up AVL trees today we are gonna do B-trees Wednesday and Friday and then there will be this kind of clean break away from trees ok let's see we will provide you opportunities for review and we usually do MP5 solution party right you know in those few days between MP5 and the exam em what else I don't know you know you can do your own MP4 solution party if you'd like it's not quite complex as MP5 alright em I am gonna save playing around with the all node hack let's just do it slide this and go here and go here oh yea! it's this and now I am actually turn on the AVL ok so last time we've talk about the fundamental algorithms for maintaining the balance of an tree today we are going to actually write the code or I will show you the written code for insertion and I believe removal happens in labs I believe you will write the code for removal in the lab em but oh hey ha look em a-o ok I can recover brand this oh and look at the sound ok come on everybody everybody is happy everything is awesome
[silence] May you never have this feeling that I have right now. This feeling that I have may you never have it in your life. Don't take a job where whether or not you're happy depends on whether your screen rotates. I think I got it yeah. But thank you. Thanks. You could sit right there just in case I'm lying. YAY!!! Thank you Ian. Okay. [gibberish]... input... this... no... Alright. Okay, so let's play around a little with this a little bit. Umm, if you recall, we use this fundamental operation called a Rotation to maintain balance in a tree. A rotation is simply a reordering of the nodes well a restructuring of the nodes in such a way that the heights of the tree are changed, but the order of the keys in the tree are not changed. So, my question for you is first of all is this a balanced tree? Is this a balanced, a height balanced, tree? Yes it is. The difference in no subtree in no pair of subtrees is greater than 1. So this is a height balanced tree. Alright I want you to tell me a key I can enter that will unbalance this tree. Somebody raise their hand. This is a good one. This a good opportunity to be brave to speak in class because there are lots of keys that will work here. Yes, what key could I enter that would unbalance this tree? 85. Okay, everybody make sure they see where 85 would go in a binary search tree. Umm, insert. You see it? Where it would go? Okay, now walk up the tree and look from 85 and look for the first node that is out of balance an unbalanced subtree. That key is... 36. Good, 74 is still fine, because in that case right left would be 1. We put up with that. But 36 would then be out of balance. Now, my question is intuitively, instinctively, what kind of rotation would you expect to fix it? A left rotation. Good. Now, make a guess, an instinctive guess, whether or not it is a double or a single rotation. Whether it is a rightLeft or just simply a left. Single rotation is correct. Okay, so let's watch that happen. Do this... Do this... 85... Insert are you ready? K... Insert... Boink... Come one... Insert... Okay laptop, VGA... Happy, happy, happy... K... Insert... No, come on... Nothing is working I got nothing from my stylus... Refresh the page, them 85 goes away. I think what I need to do is reboot my machine and let microsoft do its work, but that's sad. [Groans]. Oh, watch this. I can do... 40. Remove... delete... [silence]...
May you never have this feeling that I have right now. This feeling that I have, may you never have it in your life. Don't take a job where whether or not you're happy depends on whether your screen rotates. I think I got it. Thank you. You can sit right there just in case I'm lying. Yay! OK. Pen... input... alright. OK, so let's play a round with this a little bit. If you recall, we used this fundamental operation called the rotation to maintain balance in a tree. A rotation is simply a reordering of the nodes, well, a restructuring of the nodes in such a way that the heights of the tree are changed, but the order of the keys in the tree are not changed. So, my question for you is, first of all, is this a height-balanced tree? Yes, it is! The difference in no pair of subtrees is greater than one, so this is a height-balanced tree. Alright, I want you to tell me a key I can enter that will unbalance this tree. Somebody raise their hand this is a good opportunity to be brave and speak in class, because there are a lot of keys that well work here. Yes, what key could I enter that would imbalance this tree? Eighty-five. OK, everybody, make sure they see where eighty-five would go in a binary search tree. Do you see where it would go? OK, now, walk up the tree and look from eighty-five and look for the first node that is out of balance the root of an unbalanced subtree. That key is... thirty-six, good, seventy-four is still fine because in that case, right minus left would be one, we put up with that, but thirty-six would then be out of balance. Now, my question is, intuitively, instinctively, what kind of rotation would you expect to fix it? A left rotation, good! And now, make a guess, an instinctive guess, whether or not it is a double or a single rotation. Whether it's a right-left or just simply a left. Single rotation is correct. OK, so let's watch that happen. This... do this... eighty-five... insert... are you ready? OK, go! Insert... boink... c'mon... insert... OK, laptop VGA... happy happy happy... OK, insert... c'mon... nothing's working. There, I've got nothing from my stylus. Refresh the page, then eighty-five goes away... I think I need to reboot my machine and let Microsoft do its work, but that's sad. Oh, watch this, I can do... forty... remove... delete.
may you never have this feeling that i have right now, this feeling that i have, may you never have it in your life. Don't take a job where whether or not you're happy depends on whether your screen rotates. Ok, so lets play around with this a little bit, if you recall we used this fundamental operation called rotation to maintain balance in a tree. a rotation is simply a reordering of the nodes, well a restructuring of a nodes in such a way that the heights of the tree are changed but the order of the keys in the tree are not changed. so my question for you is first of all, is this a balanced tree? A height balanced tree? Yes it is. The difference in no pair of subtrees is greater than 1 so this is a height balanced tree. Alright, i want you to tell me a key i can enter that will unbalance this tree. Somebody raise their hand.This is a good one. This is a good opportunity to be brave and to speak in class there are a lot of keys i could enter. yeas what key could i enter that would imbalance this tree? 85. ok everybody make sure they see where 85 would go in a binary search tree insert. you see where it would go? ok now walk up the tree and look for the first node that is out of balance, that iis the root of an unbalanced subtree.That key is 36 good. 74 is still fine right? In that case right minus left would be 1, we put up with that, but 36 would then be out of balance. Now my question is, intuitively, instinctively, what kind of rotation would you expect to fix it? A left rotation good. And now make an instinctive guess on whether or not it is a double or a single rotation. whether its a right left or simply a left. single rotation is correct, ok so lets watch that happen. do this, do do this, 85. insert. are you ready. ok insert. boink. come on. insert. ok laptop. vga. happy happy happy. insert. no! come on. nothing is working. i've got nothing from the stylus. refresh the page then 85 goes away. i think what i need to do is reboot my machine and let microsoft do its work. but thats sad. awww. oh watch this. i can do. remove delete.
okay so so its working, alright, proof of concept, now I'm going to plug it in because i like it, okay alright, now I'm going to do 40 again, sorry, you know, delete, boink, muted anyways, who cares, oh, okay, so that was fine, and then I'm going to insert, I'm going to make it look like it was before, oh no, don't mess with me. 76. Insert, boink, boink, boink, boink, and oh okay, and now we are going to be inserting 85. didn't expect that part to take 5 minute. Okay ready? ready? are you sure you are ready? they do it a lot faster than we do. lets try, alright, so now what i want is something that you can insert, lets take 85 out, okay? Sorry I'm keeping it in for one time. Okay. Deleting 85. Oh its not working. Ill save you. Nothing is out of bounce, now I want to know some key that will inserted will result in right rotation. 62 will do it. Anything bigger than 36 or less than 75 right? anything inside 75's left subtree will result in a right subtree, is that true? Yes. And anything in 75's left subtree can contain keys between 35 and 75 so somebody raise their hand, you get to speak here. Yea what number do you want? 45, okay. 45 and inserting, okay, boink boink, boink, boink. Oh, thats not out of balance, oh. Okay right rotation. Okay any question about that? What happens when I insert 17? Nothing special right? Finding the spot for 17 and checking to make sure that everything is okay on the way up. Yea Mike? Oh, uhm, so, going up is sort of like yelling out a value after you processed the rest of the tree in a post order traversal, okay so I'm going to do this post order after the recursive call is made. Okay? Does that make sense? And when you look at the code, ill be sure to point it out, so all of this evaluation assumes that the insert actually happens. Okay I want now a key that will result in a double right rotation, in a right rotation, but a double one. A double right rotation, I believe that there is only one key that will result in a double right rotation. It's a power of 2.
Oh, okay, so it's working alright. Now I'm gonna plug it in because I like it. Now Im gonna do 40 again, sorry. Delete. Boink. Oh okay. So that was fine. And then I'm gonna insert 76. I'm gonna make it look like it was before. Oh no. Don't mess with me. 76. Insert. boink. boink. boink. boink. And now, we're gonna insert 85. didn't expect that part to take five minutes. Okay ready? ready? are you sure you're ready? Okay we're okay, oh oh woah. They do it a lot faster than we do. Okay. Let's try... so now what I want is something you could insert, let's take 85 out okay? Sorry I'm keeping it in for one time. Deleting 85. Nothing's out of balance. Perfectly fine. Now I want to know a key some key that when inserted will result in a right rotation. 62 would do it. Anything bigger than 36 or less than 75 right? anything in 75's left subtree would result in a right rotation is that true? Yes? and anything in 75's left subtree can contain keys between 35 and 75. So, Somebody raise their hand you get to speak here. Yeah what number you want? 45. Okay. 45. And inserting boink boink boink boink. Oh that's not out of balance, that's not out..ohh. uh oh. right rotation. what happens if i insert 17? Nothing special right? 17 finding the spot for 17 and checking to make sure that everything's okay on the way up. yeah Mike? Oh, going up is sort of like yelling out a value after you've processed the rest of the tree in a post order traversal. So I am actually doing this post order after the recursive call is made. and when you look at the code I'll be sure to point that out. So all of this, all of the valuation assumes the insert has happened. okay. let's I want now a key that will result in a double right rotation. In a right rotation, but a double one. a double right rotation. I believe there's only one key that will result in a double right rotation. and it's a power of two.
[gibberish] yes sixteen, lets try sixteen and see what happens, okay see where sixteen is going to go, whats the lowest key out of balance when i insert sixteen, fifteen very good fifteen is the lowest one and its the root of this sort of dog leggy thing so lets do this see what happens, sixteen there oh uh oh broken uh oh got it, see it, alright um i wanna do a double one. i mean one where its not quite so obvious. im gonna remove sixteen, im sorry fifteen, well eh remove 15, oh, i dont know what i wrote, there is no fourty eight are you tired of this? does anybody have any specific questions about it, the applet itself is on your handout, you can play with it a little bit yourself and we'll probably talk about it a little more when we talk about removals so you can see the removal process in action, but i wanna get to work. okay, so last time we were right smack in the middle of diagnosing the correct rotation. this processing is one that we're using to inform the code that we write and there is the easy way to understand whats happening mechanism for writing the code and then there is the thinking a little bit farther so that youre code looks beautiful part of writing the code so im gonna sort of start with the easy way of looking at it and argue for the um argue for the more elegant code in this slide okay so pretend your tree looks like this and we have t, t is where we're going to first detect an imbalance and furthermore im gonna tell you that insertion has happened somewhere over here. okay, so, insertion has happened somewhere over here for now and we've kind of walked up in this postorder mechanism after the actual insert has taken place and we get to t we evaluate the balance and we go whoa whoa whoa the balance equals what, theres in an imbalance there what is that balance have to be if the insertion has happened over here, that is we've increase the height over here, then and t is out of balance, so what is the new balance have to be at t, balance is right minus left how about that. does that help, height of right minus height of left, two is correct cant be anything else, if it were three that would mean we have done several insert without rebalancing and we're not gonna do that okay so the balance factor at t is two we can check that with a little function that checks that and some kind of what is your instinct say here some kind of what kind of what kind of rotation, left rotation will rebalance the tree thats all we know right now, further i will tell you that the insertion occurs here, now when i first wrote this code, i said look i can tell if the insertion happens over here, because it just means that the key that we're inserting is bigger than the key in t's right okay so saying this statement insertion occurs in t or t3 or t4 is equivalent to saying the key we are inserting is bigger than t's right key.
[gibberish] yeah, 16, lets try 16, see what happens. Okay, see where 16 is gonna go? Whats the lowest key out of balance when I insert 16? 15. Very good. 15 is the lowest one and its the root of this sort of dog leggy thing. So lets do this. See what happens. 16, there. Oh! uh oh! Broken, uh oh. Got it? See it? Alright, um. I wanna do a double one. I mean uh, one where its not quite so obvious. I'm gonna remove 16, I'm sorry, 15. Oh well, ha. I removed 15.Oh. I don't know what I wrote. There is no 48. Okay, are you tired of this? Is anybody have any specific questions about it? The applet itself, the name or URL is on your handouts so you can play with it a little bit yourself. And we'll probably talk about it a little more when we do removals. So you can see the removal process in action. So for now, I wanna get to work. Okay. So last time, umm, last time we were right smack in the middle of diagnosing the correct rotation. Now, this process is one that we're using to inform the code that we write. And, there is the easy way to understand whats happening" mechanism for writing the code, and then there is the um,"thinking a little bit farther so that your code looks beautiful" part of writing the code. So, I'm gonna sort of start with the easy way of looking at it, and argue for the more elegant code in this slide. Okay, so. Pretend our tree looks like this. And we have T. T is where we're going to first detect an imbalance, and furthermore I'm gonna tell you that insertion has happened somewhere over here, okay? So, insertion has happened somewhere over here for now, AND, we've kind of walked up in this postorder mechanism after the actual insert has taken place. And we get T, we evaluate the balance and go Woah The balance equals what? There's an imbalance there, what does that balance have to be if the insertion has happened over here? That is, we've increased the height over here, and T is out of balance So what does the new balance have to be at T? Balance is right minus left. How about that. Does that help? Height of right minus height of left. 2 is correct, cant be anything else. If it were 3, that would mean we have done several inserts without rebalancing. And we're not gonna do that. So balance factor T is 2, you can check that with random function that checks that. And some kind of, what does your instinct say here. Some kind of, what kind of rotation? Left rotation will rebalance the tree. Thats all we know right now. Further, I will tell you that the insertion occurs here. Okay? Now, when I first wrote this code, I said look, I can tell if the insertion happens over here. Because it just means that the key that we;re inserting is bigger than the key in T's right. OkaY So, saying this statement insertion occurs in T3 or T4" is equivalent to saying "the key that we're inserting is bigger than T's right key".
32 is already there. Yes, 16, let's try 16 and see what happens. See where 16 is gonna go? What's the lowest key out of balance when I insert 16? 15, very good. 15 is the lowest one and it is the root of the sort of dog leggy thing. So let's do this, see what happens. Uh-oh, broken. Got it? See it? Alright, I wanna do a double one. I mean, one where it's not quite so obvious. I'm gonna remove 16, insert 15.
we still havent found the right spot found the right spot but this is null when this guy is null all we have to do is make a new node and return we make a new node and return to the black calling box the function corresponding to the black triangle where this blue one is the root we are going to do these steps is it out of balance in the black triangle is there an imbalance no okay we do not need to rotate this should be indented does its height need to be updated yes so we update its height so now the height of that guy is one ill just put it in there now we have computed we have accurate height height of subtrees pass back to green calling function recursion at green level and we follow those stpes is there an imbalance no so no rotation necesarry do we have a new height? how do we compute new height its the maximum of those two plus 1 that becomes 2 fine pass control back is there an imbalance here no so no rotation we should update height is there new height yes this becomes three one two three its a comparison of height of subtrees pass control to the blue pass control to the blue and what do the steps say check for imbalance it is out of balance and where have we done the insertion it is out of balance and where have we done the insertion in the left right subtree so what we have here is this so we think a double rotation a left right will fix and then we update the height it may not need a new height i think its height will be three after that rotation and then we pass control back and the heights are updated again any questions i dont want to do the rotation here the point is that we can do these things after we insert the node in its correct place lets look at some code yuck too much code for one function so lets take a tiny piece of it and examine that in fact you know what describe what is going on in this code you can even start with the function signature sure in fact you can probably fill in the blanks if you look at this code you can fill in the blanks and i should point out that there is no right right and left left rotations
we still haven't found the right spot. we still haven't quite found the right spot, but this is null when this guy is null all we have to do is make a new node and return. so we make a new node and return to the black calling box. the function corresponding to the black triangle. where this blue one is the root. now were gonna do these steps. is it out of balance in the black triangle. is there an imbalance? ok so we don't need to rotate. this should be indented probably. And now does its height need to be updated? yes, so we update its height. right. so now the height of that guy is one. I'll just put it in there, why not i've never really done that before. and now we've computed execution, we have accurate heights of subtrees. and now we pass control back to the green calling function, the recursion at the green level. ok and we follow those steps. is there an imbalance? no so no rotation necessary. do we have a new height? how do we compute that new height. it's the maximum of those 2 plus 1, so that becomes 2. there is a 2 written in there, i'm just gonna go with it. Alright fine, and then we pass control back. Is there an imbalance here? no, so no rotation necessary, but we should update the height, is there a new height? yes, this one becomes three. right, 1, 2, 3. and again its just a comparison of heights and sub nodes and subtrees. and then we pass control back out to the blue.pass control back out to the blue, and what do the steps say. check for imbalance. is it out of balance? yes ok. its out of balance and where have we done the insertion? its out of balance and where have we done the insertion. in the lefts right subtree so what we have here is this. right so we think a double rotation. a left right rotation will fix. and then we update the heights. it may not need a new height but i think its height will be 3 after that rotation, and then we pass control back. ok and then heights are updated again. ok any question about that? i dont want to make the mess of doing the rotation here its not the point. The point is that we can do these things after we insert the node in its correct place. ok lets look at some code. yuck! yuck! this is way too much code for any one function. its way too complex. ok so lets just take a little teeny tiny piece of it and examine that. oh in fact you know what id like you to look at it with your neighbor, and just sort of describe to each other whats going on in this code, you can even stat with the whole function signature if you like. in fact you can probably fill in the blanks. if you look at this code you can probably fill in the blanks. And i should point out that there are no right right and left left rotations.
We still haven't found the right spot, right? Still haven't quite found the right spot But this is null. when this guy is NULL, all we have to do is to make a new node, and return So we make a new node, and return to the black calling box, the function corresponding the black triangle, where this blue one is the root now we gonna do these steps Is it out of balance? In the black box, in the black triangle Is there inbalance? No, ok So we don't need to rotate, this should be indented, probably And now, does it height need to be updated? Yes, so we update its height, right So now, the height of that guy is 1 I will just put it in there, why not And now we have computed execution, we have accurate heights of subtrees, and now we pass control back to the green calling function, the recursion at the green level And we follow the steps, is there inbalance? No, so no rotation is necessary Do we have a new height? How do we compute the new height? It's the maximum of those two plus 1 right? So that becomes 2 There is a 2 written in there, I will just go with it Alright, fine, and then we pass control back. Is there inbalance here? No, so no rotation is necessary, but we should update the height. Is there a new height? Yes, this one becomes 3, right? One, two, three And again its just a comparison of heights in subnodes, subtrees Alright, and then we pass control back to the blue Pass control back to the blue And does the steps say? Check for inbalance. Is it out of balance? Yes, ok It's out of balance, and where have we done the insertion? It's out of balance, and where have we done the insertion? In the last right subtree. So what we have here is this right? So we think double rotation, a left-right rotation will fix And then we update the height, it may not need a new height, but I think the height will be 3 after the rotation And then we pass control back Ok then the heights are updated again Any question about that? I can't really, I can't really make a mess of doing the rotation here, it's not the point The point is that we can do these things after we insert the node in its correct place Ok, let's look at some code YUK, YUK, this is way too much code for any one function Ok, it's way too complex So let's just take a little teeny tiny piece of it and examine that And in fact, you know what, I'd like you to look at it with your neighbour and just sort of describe with each other what is going on in this code You can even start with the whole function signature if you like In fact you can probably fill in the blanks, if you look at this code you can probably fill in the blanks And I should point out that there is no right-right and left-left rotation
Alright, should we chat? Okay, first let's make sure this sort of things that we thought it should do from the step on the previous slides. so notice that this is, well, if I ask you to describe what this is, what would you say? Base case, good. That's the base of recursion. It's simply create the node. Huh, The reason this works to just set t equal to the new tree node is because we have t pass by reference in the parameter. Okay, there some. I did. Is that cool? Magical. Alright, any question about that? So that creates the yellow node. Okay. Then the rest of this, if you hide this conditional, it looks just like a recursion insertion into a binary search tree. And in fact, that's what happens first. In each of these cases, the first thing happens is the recursive call. So everything follows the recursive call. So, there is inserting into the proper place from previous slide, here check for imbalance. Wait. There is an imbalance, do the right kind of rotation. This is diagnose thing what kind of rotation you need. And after all of that is done, before you move up, before you cast control out of the calling function, you recompute height. You may have to look at your own paper for that. You update the height of the parameter node. Any question about that? My desire to answer your question what has to happen or how would it happen we do things after the insert or walking of the tree? Any other questions about that? I guess we should fill in the blanks. Huh, so, what goes in this blank? It's easiest one. Okay, it's out of balance, and longer on the right. So we need a left-rotation. This one is a right-left, because this has to be some kind of left-rotation. Imbalance has to be some kind of left-rotation. And then up to the top boy, everything look symmetric, and I write this code without thinking about it, and, hope that I can catch any problem in the test. Any questions about it? So this is kind of code that I would write this part with some thought and do some substitution there. Now, I don't like this code. I particular don't like the fact that this and that are kind of the same. So I might refactor this a little bit, and make some helper function. But this is a little tough, I'm not really sure pass a little flag parameter that help you diagnose right and left. Be clever you name your variable. I'm not sure how I would refactor this. I know this is quite readable here, maybe I wouldn't at all. Because she know what? Height is always going to be the maximum of the height of my two children, which I have updated plus one. No, No. This parentheses closes this one. And notice here that I got a helper function that deal with the case that one of them is null, because I don't deal with that here. Same thing true here. Balance factor gonna deal with the case where t->right is null or left is null. I don't. Alright. Any other question about this?
Yup, yeah yeah. So he's asking about how many helper functions you need for this. I need one for height, I need one for balance factor, I need one.. I need four for the, uh.. four for the rotation cases. Yeah, that's a lot but yeah. I need those constructors and you know, this is.. this is what we're good at this point. This is what's gonna get you a gazillion dollars, but not me. Okay... Alright, AVL tree removal. What happens if I remove nine? Oh...... [gibberish]. Oh yeah okay. First of all, is this tree in balance? Is this a balanced tree? Yes it is. Okay, there is nothing obviously out of balance I don't think. You can pretty much eyeball it here. What happens if I remove nine? It's even better, I got a better one. What happens if I remove ten? Ha ha. Yeah. Alright. Alright. So lets trace this a second. This is just an example. I wanna remove, I'll remove nine. Ten is structurally the same. Okay. So we remove nine and we have every reason to believe, we have every reason to believe the process for removal mimics that of insert, that is that we can kind of test after we change the structure of the tree wether or not a rotation is necessary. Now what's interesting about this of course, is that binary search tree removal invokes an in order predecessor, which invokes.. may invoke further cutting off of the tree and so actually it's not even just in the um removal where you need this checking of height but also um in the.. in order predecessor evaluation portion. So, but, we're not gonna do those details here, that's for lab. For now, we're just gonna remove nine. So now my question is what kind of rotation fixes this tree? Some kind of left rotation, correct? Some kind of left rotation. Which kind of left rotation? Single or double? Double, that's right! Because at that point the balance factor here, the balance factor here would be two, the balance factor here would be negative one. And so its a left right rotation that's necessary. Oh that's why. Because here you can use the same balance factor function ha ha I see. So in the end, after we do this, I'm gonna put this in red because you'll be able to see it, you'll be able to see what happens. In the end, I'm going to have eleven here, ten there, and twelve here, still. Okay. And this will be gone because the rotation will result in this. And then we will complete execution of that recursive call and come here and what happens? Oh..... Now it's out of balance. Okay, you see that? Because it's long on this side, we've shortened one that was barely long enough right? This side was barely long enough and we've shortened it. So that creates another imbalance. So what kind of rotation is gonna fix it? A right rotation, right! Yes. Very good. And what do you think? A right... or a double or a single? Single, I think either one of them works in this case but.. we might as well go single here, right? So, it's going to result in a right rotation about eight. Now, think about it. This tree rooted at 8 might barely have been long enough and we shortened it. Okay, it might be a subtree. This.. this tree that I have painted here might be a subtree in some larger structure and it might barely have been long enough, tall enough and we just shortened it. So it's possible that actually fixing things at eight would cause the need for rotation farther up the structure. So it is possible in fact that when you do a removal, you may have to do rotations all the way up the tree. Okay, any question about that? You see how that's possible? Okay... uhh.. let's move on. We'll see how far we get here. Just a little bit. So....
The good news would be O(n). Otherwise you know we might just as well let the binary search tree to run them their way, do what they are going to do anyway, okay? So the next few minutes are going to be spend arguing that AVL trees, by, using their definitions, AVL trees resulting trees whose height are worse case O(lg(n)). Now, I can't make this argument very cleanly without first reviewing the definition of Big-O from CS173. Okay? Anybody need some [gibberish] points? You wanna refresh me of the idea, refresh me of the ide of the definition? What is the definition of Big-O? Yes, it is the worst case running time, it is the an upper bound on the running time. Okay? But, what is the definition of it? I will give you a hint, you will need that symbol. Okay? Oh What? Yeah ready Nathon? Yeah a function of Big-O of n, is a function of g(n), if and only if, okay good. Exist a constant c so that......Good.....Very good.......So i am going to take that for sufficient large n and turn it into that some other that [gibberish] variable k and make it when n is greater than k. Alright oh what the heck? That was impressive. That was a [gibberish] a environment that I might like to give you a hint, that is very good. Okay, there exist constant c and k so that the function is less than some factor of this other em....this function, when n is big enough. Okay? So now, here is the deal. This function that we are going to argue about is we think logrithimic. Okay? f of n. We think it is logrithmic, but we don't know for sure. We don't know, we don't know that it is like for sure, but we do know that the one that we are going to compare against is logrithmic. So I am going to put that on here also, okay? So maybe here. g of n is equal to log of n. And pretend that this is increasing. I kinda dipped it down, I shouldn't have. Now alright we are not going to make the argument that our function is less that g of n. But we are going to take some constant factor of g of n and maybe this goes like this, [Gibberish]. And we are going to make the argument that our function is less than that one, when n is greater than some value k. Is that make sense. You've probably seen this graph before right? Alright, this is what big-O of n means, this is what it is means for a function to be big-O of another function. Here is the problem with it, i can't do the problem. I will tell you the problem with this next time. The start of next time.
ok.let's work. So i wanna talk for a minute about for the exam coming up. So i wanna make sure you hear there was the exam on Tuesday, not Wednesday. Wednesday is the pain in the ass. We didn't like it very much. So we are moving it back to Tuesday. I'll leave that in red for you. And the conflict exam should you need it? It's the following morning, so that would be Wednesday morning. I like to get all these taken before class meet, but we can be a little bit flexible inside the morning window, larger morning window. Let's see, there will be review session this weekend, I'm still waiting to hear from course staff when they would like to do them, and for room reservation, we will make the room reservation then we will let you know. So, if you are not yet connected to the class on the piazza, now is a good time to do so, because thats where we will announce it, where we will announce the review session this weekends. We talked about this morning in the format for the exam will be very similar to the past exam, which means multiple choice, lots of running time questions, so we will paint a little scenario for you and ask how long will this take, how long will this take. And, let's see, and a couple of programming questions or did you understand for the work you did for the mps type questions. One thing that would be different is there will be an exam booklet decoupled from the exam solution papers, so it doesn't surprise you, you will be writing the solution on the page we will then scan for improve efficiency in grading. So, don't let us surprise you when you get there and your exam booklet is separate from your long solution paper even. Bubble sheet does well of course. i think thats all i wanna say about the exam today. Like i said, we will keep you price of opportunity for review. Are there administrative question before i start,do you have anything you wanna ask about it? I haven't really told you anything so The material to be covered is everything from stacks and queues, through Friday. And if i don't start on the material, you miss out the chance to be test over Btrees, so i better get started. Last time we sort of refresh our memory for the definition of Big O, the key observation here is that we are looking at, we are trying to access an upper bound on the running time of our algorithms. So in this definition, f(n) represents the true running time of our algorithm and g(n) is some function that we use to communicate its quality, the quality of the algorithm or the speed of the algorithm. Now, thats said, this inequality allows us to make g as big as possible, but smaller is better when you are talking about the quality of an algorithm. So typically when we talk about big o, we have a function here and we want the lowest possible version of that function, the lowest possible function that we could put in there. So we say we want a tight bound, tight upper bound on the running time, and that is, just to iterate because we use this big o to reflect the quality of our algorithm. Nobody who can run a four-minute mile goes around saying I can run a mile in less than eight minutes. Thats what I'm talking about here. They say oh yeah I can run a mile in less than four minutes. Like they get down as low as possible.
Ok let's work. So I wanna talked for a minute about the exam coming up. Tuesday. So I wanna make sure you hear these words, the exam is on Tuesday, not Wednesday. Wednesday was pain in the ass we did like it very much. So we are moving it back to Tuesday. I'll leave it in red for you. Umm and the conflict exam should you needed is the following morning, so that will be Wednesday morning. Like to get all those taken before, umm, class meet. But we can be a little bit flexible inside the morning window, the larger morning window. Umm, let's see there will be reduce sessions this weekend and still waiting to hear from course staff when they would like to do them. Umm, and from room reservations actually with them we need to make the room reservations. Then we will let you know. So umm if you are not yet connected to the class on the piazza. Now it is the good time to do so. Because that's where we will announce it, that's where we will announce the review sessions this weekend. Umm, we talked about this moring in the format for the exams gonna be very similar to those of the pasting exams. Umm which means multiple choice, lots of running time questions. So we will paint a little scenario for you and ask how long will this take, how long will this take. Umm and let's see, and then a couple of programming questions or, you know, did understand the work you did for the MPs type questions. One thing that will be different is that there will be an exam booklet decoupled from the exam solution paper. So just sort doesn't surprise you. You will be writing your solutions on a page that we will been scaned for improve the effeciency in gradings. So don't let it surprise you when you get there and you exam booklet is seperate from your long solution paper even. Bubble sheet does well of course. Ok, I think that's all I'm wanna say about the exam today. Like I said, we will keep your priced of oppotunities for review. Are there administrative questions before I start? Do you have anything you wanna ask about it? I really told you anything so. The material to be covered is everything from stacks and queues through Friday and if I don't start on the material you'll miss out on the chance to be tested over B trees. So I'd better get started. Umm, last time we sort of refreshed our memory for the definition of big O. The key observation here is that we are looking at, we are trying to assess and upper bound on the running times of algorithms. So in this definition, f(n) represents the true running time of our algorithm. Ok? Represents the true running time of our algorithm. And g(n) is some function that we use to communicate its quality, the quality of the algorithm or the speed of the algorithm. Quality. Now, that's said, that's said, this inequality, this inequality allows us to make g as big as possible. Right? But, smaller is better when you talking about the quality of a running of an algorithm. So typically when we talked about the big O. And we have a function here. We want the lowest possible version of that function, the lowest possible of function that we can put in there. Ok? So we want, we say we want a tight bound, tight upper bound on the running time. Umm that is, again just re-iterate because we use this big O to reflect the quality of our algorithm. Nobody who can run a four-minute mile goes around saying Oh yeah, I can run a mile in less than eight minutes", right? That's what I'm talking about here. They say Oh yeah, I can run a mile in less than four minutes." right? Like they get down as low as possible.
Any question about that? So, if we forget to say it, we will always mean the least bigO possible. You could probably recognize that I could put a 2^n and that will hold in almost everything we do. Alright let's get started. I'm going to draw last time's picture very quickly. I tried to do it in powerpoint and I'm not a powerpoint user. So I failed. So here is running time of our function. Here is the running time of our algorithm. This is the function reflect it. We don't necessarily know how it's characterized. We don't know it has to do with all kinds of things that are not necessary. We don't know necessarily what kind of function it looks like. But we have a feeling that there is this other function somewhere that we can use to reflect the running time of our function. We also don't know what this function looks like. It might look like something like that. In fact this one is what we do know what it looks like. In the case of this particular example, we are going to argue that the running time is log in the size of the data. The reason we suspect that's appropriate running time is because of the structure of our tree. Because the heights of the balanced binary trees. We didn't just pull this out of the air. It was sort of a good guess based on the way our tree split our data in half. In fact, for regular binary trees we couldn't say this. We couldn't say logn here for regular binary search trees. We couldn't guess logn. We couldn't prove it. But in the definition here, we allow for some. We allow for some function, whatever it is, to be pushed up by some constant scale factor. Positive scale factor whose intention is to push that function up for a little bit. We also allow for some muss at the start. I'm going to draw some c times g of n in kind of exaggerate because there is something I want to illustrate very concretely on this picture. So I'm going to draw the c times g of n sort of like this. So this is c times g of n. Maybe I have g of n drawn poorly. Doesn't matter much. OK. So now is f of n greater than c times g of n? Sorry, is f of n greater than c times g of n? Like we want in this inequality is that f of n less than c times g of n. Sometimes it's the right answer. Sometimes it's forever less than eventually forever less than... yes. So we have a bound here right? Here. Beyond which f of n is forever less than c times g of n. If I to label this right here, this on the x axis, what would it be? That's right, that's k. Any questions about that? I'm doing this carefully here. I'm actually think this should be done carefully in 173 I don't know if it is or not. I'm doing it here carefully because we are going to it turns out that making this less than or equal to argument isa pain in the neck. OK. There is all kinds of like, potential for all rounding and floors and ceiling and I don't want to deal with that kind of stuff. I don't know about you. So what we are going to do instead is to invert the argument completely. So we are going to completely invert this picture. I haven't practiced it for a while. It has been four years since I drawn this picture. So let's see if I can do it. So where is f of n go now? In the inverted picture. It goes like this, right? Is that what f of n looks like? g of n as I have drawn here. It goes a little bit farther from the axis and stays forever on the back side of the f of n. So g of n looks like this. Right? And c times g of n now looks like this. Yes? Did I do it right?
Okay and now this is gonna... and the line for k is here, okay. all right so now what we're going to do, so, now these are actually these are no longer the right labels right? This is if this is N and this is H. Then these are now f inverse of H and G inverse of H(s) and this is now a slightly different C and this is G inverse of H. and now what we're going to be looking for is a diffrent k as well. K prime and this'll be a c prime, but we're gonna make the argument that f(n) is now, the inverse argument that f(n) is now bigger than, f inverse of h is now bigger than c prime, g inverse of h, okay. It's exactly the same picture though, its just the labeling that's different. I didn't draw the graphs differently though, right? yes, uh huh. Ya because i still want it to be a function, i still want this to be the domain, in fact that's exactly what i am doing, is changing the domain of the function, to one that is dependent on h instead. Yeah I have g inverse of h there. But f and g still live there. so what we're gonna do is take f(n) switch it over to f inverse or g(n) switch it over to g inverse and then switch it back, so we can make the argument that we want. It;s just that this argument is much easier to make because it says that the number of nodes in a tree of height h is at least this much, its lower bounded by this much. And that turns out to a super easy argument. Alright so an upper bound, im gonna read this out loud i know how you love when professors read their power points. an upper bound on the height for a tree of n nodes, thats that picture, is the same as a lower bound on the number of nodes in a tree of height h, and this is whats going on mathematically this inversion, any questions about that? is it okay? alright, its a little trick it should be in your toolbox of proving things about commontorial structures. proving the inverse about the inverse. But im not sure anybody ever really talks about it explicitly its one of those things that my math professors used to do and i went how did you know to do that? Now i know. okay so here's how we're going to do this, we're going to uh, talk a lot about this red function we're gonna talk about this red function, sort of the green one as well they end up being pretty much the same in this example. okay so, n is what we're gonna use to communicate the true number of nodes in an AVL tree of height H, so n is the true number of nodes in an AVL tree. okay, so n you don't know what it is for sure, but if the tree has height h we're going to use n(h) to be the smallest possible maybe ill put a little h here. So we're paramaterizing it by h sort of. But N(h) because it may have various values. N(h) is the smallest such tree, so N(h) is the smallest AVL tree and when i say smallest i mean by the number of nodes.
Hello. Ok and now this is, oh and the line for k is here. Ok? Alright, so now what were gonna do, oh so now these are actually, these are no longer the right labels right? This is if this is n and this is h then these are now f inverse of h and g inverse of h yes? And this is now a slightly different c and this is g inverse of h ok? Alright is that clear? And now what were going to be looking for is a different k as well, ok. K prime and this will be a c prime, but were gonna make the argument that f of n is now. F, yeah. The inverse argument that f of n is now bigger than c times. F inverse of h is now bigger than c prime g inverse of h, ok? It's exactly the same picture though it's just the labeling that's different. Yeah *Audience question*. Uh huh, I didn't draw the graphs differently though right? Yes, uh huh. Yeah because I still want it to be a function, I still want this to be the domain, in fact that's exactly what I am doing is changing the domain of the function to one that's dependent on h instead. Yeah I have g inverse of h there, ok? But there's still f and g still live there. So what were going to do is take f of n, switch it over to f inverse or g of n or switch it over to g inverse and then switch it back so that we can make the argument that we want, ok? It's just that this argument is much much much much much easier to make, because it says that the number of nodes in a tree of height h is at least this much it's lower bounded by this much and that turns out to be super easy argument, ok? Alright so an upper bound, I'm going to read this out loud. I know how you love it when professors read their PowerPoints an upper bound on the height of a tree with n nodes that's that picture is the same as a lower bound on the number of nodes in a tree of height h. And this is what's going on mathematically, this inversion. Ok, any question about that? Is it ok? Alright, it's a little trick, it should sort of be in your toolbox of proving things about common structures just proving the inverse about the inverse. Uh but I'm not sure anybody ever really talked about explicitly it's one of those things that my math professors used to do and I went how did you know to do that? Now I know. Ok, so here's how we're going to do this, we're going to talk a lot about this red function here. We're going to talk about this red function. Sort of the green one as well, they end up being pretty much the same in this example. Ok, so n is what were going to use to communicate the true number of nodes in an AVL tree of height h so n is the true number of nodes in an AVL tree, ok? And you don't know what it is for sure, but if the tree has height h we're going to use n of h to be the smallest possible, maybe I'll put a little h here so we're parameterizing it by h sort of, but n of h is not a function because it may have various values. N of h is the smallest such tree, so n of h is the smallest AVL tree, and when I say smallest here I mean in number of nodes.
Hello, okay, and now, this is O and the line for K is here. Ok. Alright. So now what we're gonna do. So now these are actually, these are no longer the right labels, right. This is, if this is N and this is H, then these are now F inverse of H, and G inverse of H, yes. And this is now a slightly different C, and this is G inverse of H. Ok, alright, is it clear? And now what we're gonna be looking for is a different K, as well. Ok. K prime and this will be a C prime, but we're gonna make the argument that F of N is now.. or F yeah, the inverse argument that F of N is now bigger than C times.. I'm sorry, F inverse of H is now bigger than C prime G inverse of H. It's exactly the same picture though, it's just the labeling that's different. Yeah. Uh huh. I didn't draw the graphs' differently though, right. Yes, uh-huh. Yeah, because I still want it to be, I still want it to be a function. I still want this to be the domain. In fact, that's exactly what I am doing: is changing the domain of the function, to one that's dependent on H, instead. Yeah, at G inverse of H, there. Ok, but there's still F and G still live there. So what we're gonna do is take F of N, switch it over to F inverse or G of N, switch it over to G inverse, and then switch it back. So that we can make the argument that we want, ok. It's just that, this argument, is much much much much easier to make because it says that the number of nodes of a tree of height H is at least this much. It's lower bounded by this much. And that turns out to be a super easy argument. Alright, so, an upper bound... (I'm gonna read this out-loud. I know how you love when professors read their power-points). An upper bound on the height for a tree of N nodes (that's that picture) is the same as a lower bound on the number of nodes in a tree of height H. And this is what's going on mathematically. This inversion, okay. Any question about that? Is it okay. Alright. It's a little trick. It's sorta, it should sort of be in your toolbox of proving things about combinatorial structures. Just, proving the inverse about the inverse. But I'm not sure anybody ever really talks about it explicitly. It's one of those things my math professors used to do and I went how did you know to do that", now I know. Ok so, here's how we're gonna do this. We're going to talk a lot about this red function here. We're gonna talk about this red function. Sort of the green one as well, they end up being pretty much the same in this example. Ok, so N is what we're gonna use to communicate the true number of nodes in an AVL tree of height H. So, N is the true number of nodes in an AVL tree. Ok, so N, you don't know what it is for sure, but if the tree has height H, we're going to use N of H to be the smallest possible. Maybe I'll put a little H here. So we're parameterizing it by H, sort of. But N of H is not a function, because it may have various values. N of H is the smallest such tree. So N of H is the smallest AVL tree. and when I say smallest here mean in number of nodes.
OK, let me question about that
good? ok. classic balanced but we have already talked a little bit AVL trees are not the only balanced trees.red black trees are another.there are a gazillion slight variations of each.each corresponding to the phd thesis of somebody in the 70'S. Maybe the 60's.Alright so ugh so there are probably variations thereof but these are classic and any adaptation is probably you know an addition of record key things or some constant time access to part of it things like this.so here are the key contrasts to all of them. Red black trees actually allow for a little strings of red and black parents so the overall height is bounded by a a factor 2logn. we proved 2 logn for avl trees but infact if you solve that recurrence more exactly you could get it down to 1.44 max height but in either case they are log heights.The main difference is that red black trees will only have upto 2 rotations upto each operations but avl trees you might need to rotate upon remove all the way up to the tree.avl tree have no rotations along find but i feel red black trees might. Why are we doing this? why are these such great structures?They are kinda cool because we can always give a worse case bound of log n. That is good news.we don't have to worry about the order in which our data comes in.we are gonna build one of these and the rotations will keep the tree short even for ordered data. umm so that is an improvement over linked lists,arrays and also plain old binary search trees.The other thing the absolute best thing about avl trees is that you can use them to solve other harder problems. The type of problems that they can solve are called range finding that is find 2 values be in the tree in which some query value falls for example or find all the values within a range of numbers that can be done very efficiently and nearest neighbor is a big one so imagine your favorite its your dream moment.Imagine your favorite avl tree, it has got keys in it and it is balanced.And i come to you with keys and i dont really care if the key is in the tree i want the key closest to this one. AVL trees can be used to to do that whereas other faster dictionary structures cant. MP6 is actually a k nearest neighbor search in it in a slightly different structure. Here is the problem.Turns out its possible if you are only looking for a particular key and you know what your keyset is it is possible to search for faster than log n time.That is foreshadowing. And then the other drawback is that we really can only build these avl tree if all our data fits in memory coz we are poking around in ram for these memory addresses for these keys and our data might be so big that infact doesn't even fit in memory.These 2 observations define the next two structures that we are gonna look at and we are gonna go bottom to top and later actually after your exam we are gonna address this issue. So that's the setup if the data is so big that it doesn't fit in main memory where we are gonna put it? Okay so I have got data oh i had this very cool weird experience about i dont know 5 years ago or so so you wouldn't years ago i was sitting in dan roth's office and we were talking about doing some research on some data that involved calling the web and i was like oh my gosh the web is so big and he looks at me and like i am crazy because the web is sitting in those 4 hard drives behind you. it was early of bunch of terabytes drives sitting there but it still was sort of cosmic moment where this this i thought was so huge actually fit on dan roth's desk. it was a little strange for me but nonetheless that entire web no matter what fraction of the web at the time that web wouldnt fit into the ram. so we couldn't build an avl tree out of all urls for example. We just couldnt do it Okay so the answer here is no
Classic balanced but we've already talked about a little bit, a little bit about this. AVL trees are not the only cool balanced trees. Red black trees are another. there are probably a gazillion slight variations of each. each corresponding to a PhD thesis of somebody in the 70s. maybe the 60s. alright? so.. so there are probably variations thereof but these are classic and any adaptation is probably, you know, an addition of record keeping or some constant time access to part of it. things like this. okay. so here are the key contrast to them. red black trees actually allow for, uh, little strings of red and black parent so the overall height is bounded by a factor of 2logn. umm. we proved 2logn for avl trees, but in fact if you solve that recurrence more exactly, you could get it down to 1.44 maximum height but in either case they're logarithmic height. the main difference is that red-black trees only will have up to two rotations per each operation but for avl trees you might need to.. umm.. rotate upon removal with the tree. umm. avl trees have no rotation on find and I believe red-black trees might. I can't remember for sure. okay. why are we doing this? why are these such great structures? umm they're kinda cool because we can always give worse case bound of logn. okay that's good news. we don't have to worry about, you know, the ordering which our data comes in. we're gonna build one of these and the rotations will keep, uhh, the tree short, even for ordered data. umm so that's an improvement over linked-lists, arrays, and also plain old binary search trees. the other thing, the absolute best thing about avl trees is that we can use them to solve other harder problems. the type of problems that they can solve are called range-finding, that is find a, uhh, find two values be in the tree in which some query value falls, for example. or find all the values within a range of numbers. that could be done very efficiently. and nearest neighbor is a big one. nearest neighbor is a big one. so imagine your favorite, it's your dream moment. imagine your favorite avl tree. its got keys in it, it's kind of balanced. and I come to you with a key and I say, I don't really care if this key is in the tree, I want the key closest to this one" avl trees can be used to do that whereas other faster dictionary searches cannot necessarily. so this is a big one for avl trees. umm mp6 is actually a k-nearest neighbor, has a nearest neighbor search in it. it has a slightly different structure. okay. so define some problem. let me show you. here's a problem. turns out it's possible if you're only looking for a particular key and you know what your key set is, it's possible to search for it faster than logn time. *gasp*. that's foreshadowing. dun dun dun. and the other drawback is that we really can only build these avl trees if all of our data fits in memory. coz we're poking around in ram, right? for these memory addresses for these keys, and they, our data might be so big that it in fact doesn't even fit in memory. we're gonna, these two observations define the next two structures that we're gonna look at. and we're gonna go bottom to top. so we're gonna do this one first and then later actually after your exam we're gonna address this issue. okay so that's the setup. if data is so big that it doesn't fit in main memory, where are we gonna put it? okay, so i've got data. oh, I had this very cool, weird experience about, I don't know, five years ago or so. So it wouldn't, I don't even know. Five years ago or so, I was sitting in Dan Roth's office and we were talking about doing some research on some data that involved crawling the web. And I was like, oh my gosh the web is so big". he looks at me like I'm crazy coz, web is sitting in these 4 hardrives right behind you. like, it, he had this, it was kinda early for, to have a bunch of terabyte drives sitting there but he had a bunch of terabyte drives sitting there and, you know, it wasn't all of the web but it was still this sort of cosmic moment that this thing that I thought was so huge actually fitted on Dan Roth's desk. That was a little, a little strange for me. But nonetheless, that entire web, no matter what fraction of the web it was at the time, that web would not fit into ram. so we couldn't build an avl tree out of all the URLs, for example. we just couldn't do it. umm.. okay so the answer here is no.
not going to do this slow, ssds are about three hundred megabytes per second, yea both of these are slow compared to the number of instructions you can do, it's weird, I can do some things in the front of the room but like basic arithmetic no no. Oh no don't ask me that, alright fine, so let's think about an AVL tree that sorts what i consider to be lots of data, okay? consider the US driving records so lots of data, how many records do you think there are? make a guess, this is one of those questions google is going to ask you, how many drivers are there in the US, three million is certainly an upper bound, that's about how many people there are, i think i read last night there's like a hundred and sixty million current US driving records so over time it's increasing of course like twenty years ago only half the adults drove, really? but the cool thing is in twenty years it will go back down again right. we didn't let our teenager get a driver's licence because he didn't want one either because google cars are going to be real. he'll be riding in an autonomous vehicle, he will never have to drive,its cool. Okay yeah tesla is going to beat him okay so lots of records, let's say three hundred million, okay how much data, oh my gosh. how much per record, i don't know. three hundred million times three megs each so if you have a picture there a meg each. i don't know what is that. it's like gig. that's not alot. okay here's the point, i'm sweating so badly, this is too deep okay. sorry i didn't look at notes before class ok i can't remember, okay let's say AVL tree is thirty deep which means that you may have to look for records ,you have to do thirty comparisons down an AVL tree to get to your data now that's all fine if you're AVL tree is sitting in memory because you can access that memory super fast, those operations are quick, thirty comparisons who cares but here's what really is happening, here's a cartoon version of what is really happening. so suppose this is the AVL tree of US driving records okay and suppose it does not fit into ram so you do a find, i want to find US driving record number sixty six, okay I need some records, my disk is way out there, you have to go all the way out say mr AVL tree give me a key, bring it all the way back, i should even walk slower right, all the way back and you go sixty eight, bigger or smaller? you compare the two. okay? and that happens super fast,okay i need the other part of the tree.
not going to do this slow ssds are about 300 MB per sec both are slow compared to the number of instructions you can do its weird i can do somethings in the front of the room but not basic artithmetic 4+8 is i dont know lets think about an avl tree that is considered to be lots of data consider the us driving records how many records do you think there are make a guess this is a question google will ask you how many drivers in the us 300 million is an upper bound how many people there are 160 million current us driving records increasing 20 years only half adults drove the cool thing is in 20 years it will go back down we didnt let our teenager get a driving licence because google cars are going to be real he will ride in an autonomous vehicle tesla will beat him how much data how much per record 300 million 3 megs each so uhh you have a picture there i dont know what is that its only a gig thats not a lot okay heres the point i am sweating so badly this is like this is too deep its about 28 tall i did this once i didnt prepare today i didnt look at notes i cant remember lets say the avl tree is 30 deep what that means is you may have to look for you may have to do 30 comparisons down an avl tree to get to your data thats all fine if your avl tree is sitting in memory because you can acess that super fast 30 comparison who cares heres what is really happening a cartoon version of whats really happening suppose this is the avl tree of us driving record and suppose it doesnt fit in ram you do a find i want to find number 66 heres what happens i need some driving record my disk is way out there you have to go all the way out mr or ms avl tree give me a key bring it all the way back walk slower bring all the way back 68 bigger or smaller than 66 that happens supper fast i need the other part of the tree
And you go out, and you get the part containing 51, and you bring it back. So, there is this big trip that happens from your conceptual notion of the AVL tree to the disk, and this is very slow. And you bring the data back, and the comparison is quick, and we say okay, we need this." And again, you know you go out, and you get this [vocalizing, ohh]. Ok, and then you say you need this, and you go out and you get it from another spot on your disk. And finally you go out and you get it and you go, Oh yay, 66, that took a long time." Ok, so this is bad. So shallow trees are basically imperative. Because, they minimize the number of trips that you have to take to the disk. Here's the other thing, here's the secret, here's the secret I didn't tell you: Back when I was over here, getting the key off the disk, over here, way over here, I didn't just pick up one key, what's transferred back is actually a block of data. A whole block of data, ok that's the bandwidth of the interaction with your disk. Now, it would be great if a lot of searching could happen in all of that. So, we want a structure that has a shallow tree, and takes advantage of relevant data in the nodes, in a block. So, my picture of what's really happening is you get a bunch of data from your disk, even if you're only interested in part of it. Ok, any question about that? Alright, I have something fun to show you. This is a b tree, this is what we call a b tree, so I read about it a little bit, I don't know what b tree stands for, but the speculation is that it stands for block, ok, because this is a one node, b tree. Ok? Now, in fact, it's the root of one. Um, it corresponds to an entire block of data brought back. Usually they have uh um a thousand keys in them. We have only eight keys. Um, and we'll describe what m is in just a minute. So, what do you notice about those pieces of data? They're in order, that's right! So, and it's a node of a b tree, so a node of a b tree is a essentially a vector or an array of ordered keys, ok? Um, and these are the principles: Build a tree that uses one disk block per node, uh the nodes will have more than one key, and they key will be or the tree will be balanced and shallow. We'll start next time looking at an illustration of these, because they're really quite cool.
I have a question. Thank you, uhm, so i knew that this was going to happen some day, uhm but i forgot my stylus. Does anyone have a surface pro 3 stylus. May i use it? okay i owe you. Thank you, good answer. Okay, so let's work uhm, there's an MP due tonight, uhh, surprise, surprise, and there's an exam next week, we are really close to coming up with the room assignments, but we're not quite there yet, because we're trying to move, they assigned us rooms on south campus and we're trying to move everything up here so we're hoping to find rooms. Yea, yea, yea, okay you're telling me this. okay, so uhm, no body's available on Halloween to do an exam review it's just too, uhm, cob to do that. so i cant quite get anybody to do and Roahn is out of town, so his normal pen and paper, i know, he didnt ask my permission. uhm, uhh, let's see, so here, this is all up in the air, but, what i know id that we have siebel 1404 for both of those times. and i know that i have a staff person who can do one or the other but i prefer that he not do both, just because i dont wanna burn him out, and i think that he wants to do the solution party, i just dont know which night is gonna go which each event, and which sytaff people are gonna be in which ones but both of those will happen on those two nights at that time. Im just not sure whether it will be the review or the mp5 solution on which date, okay? is that clear enough? oh no in fact its totally not clear. we will keep you posted on uhh, the piazza, okay so. Raise your hand if you would like us to also send you email with the details. okay fine, okay so somebody needs to send an email reminding me that im gonna send you, just kidding. no, okay, uhm. This exam is gonna be fine youre gonna be fine. its the tree exam, you know, if you get this stuff youre gonna be fine. Okay uhh, lets work a little bit, uhh. I'm sorry i was in meetings all day and have not entirely gotten into teaching mode, okay so. we're talking about a new data structure whose interface is really that of a dictionary but whose utility applies specifically when we have ginormas data, now what constitutes ginormas data. It means data that won't fit in RAM, how big is that data? Well how big is RAM typically? When you buy RAM for your machine, how big is it?
4 to 8 gigs? Is that about it? Okay, assume you can only use half of that for, I mean at most, assume you can use a fourth of that for computation of any one given program, that's probably even an overestimate, you realize that any data set larger than a couple gigs really merits some other storage. I'm not going to analyze driving records, that's whatever, it's kind of a fake application I think. Maybe it isn't, I've never really looked into it. So, not gonna look at this. The point is, the point of it is this: If you cant fit an entire AVL tree into this immediately accessible piece of memory, this RAM, this heap memory which is part of RAM, then your only alternative is to store it someplace else. Now, I'm gonna talk about that some place else, as if it is a hard drive. But, all of the conversation applies anyway. So here's where we were last time. We observed that if we have some balanced structure, this one wasn't balanced so I better make it balanced, if we have some balanced structure which we think is a reasonable way of accessing our data, but our data isn't close to us, that is that balanced structure doesn't fit in memory that is fast, then if we are going to do this sort of search for thirty eight, thirty eight may be out in some place where the communication cost is high, whether it is the disk or the cloud or whatever. Is that clear? Is that clear enough? This is high communication cost. That says high communication in the font that this pen chooses to write in. But what is also true about all of this sort of remote data is that you don't get just one piece of data at a time, you get a block of data. So even if you are only looking for key thirty eight on the moon, when you go to the moon and you come back, you come back with a whole bunch of stuff. It's just the unit of transfer that happens either via remote communication or via communication with your hard drive, or your solid state drive. So, here's the thing, you want to make sure that piece of data you get is relevant to your search, relevant to your application. And that's kind of where we were. So we're gonna define this structure called a B tree and into the B tree, into a B tree node, we are gonna throw not one key, but a bunch of keys. So you can imagine that this whole thing is a B tree node. And it corresponds to some linear function, it is some fraction of a transfer block from your disk, from remote storage. So this is some fraction of a block in remote storage. And the reason I say that it is some fraction, like a fourth or a third, the reason I say it is some fraction is because when you get the block you also need some other information too. Just like when you get a binary search tree node, you also get pointers to children, in this case you also get a collection of keys together with some other redirection. Okay, main goal, we want to minimize the number of reads from a disk or any other remote storage. Okay, I want to show you how these things work before we do a formal description and the way I'm going to show you how they work is by hopefully pushing on this link. Gnarley trees, that's new. What am I doing? That's not the one I want, I want that person but I want the big, and we just hope it exists at this point.
4-8 gig. Ok assume you can only use half of that for or a fourth of that for computation on any one given program. That's probably even an overestimate. Good morning! Heheh. And you realize that any data set that is larger than you know a couple gig, really merits some other storage OK. Um in yeah alright. So I'm not going to analyze driving records, that's kind of a fake application. Maybe it isnt. Not gonna look at this. The point is, is this. If you cant fit an entire AVL tree into this immediately accessable piece of memory, this RAM, this heap memory which is part of RAM, then your only alternative is to store it elsewhere. Now, I'm gonna talk about this someplace else, as if it is a hard drive. But, all of the conversation applies anyway. So here's where we were last time. We observed that if we have some balanced, and this one wasn't balanced, which we think is a reasonable way of accessing our data, but our data isnt close to us. That balanced structure doesnt fit in memory that is fast, then if we're going to do this sort of search for 38, 38 may be out in someplace where the communication cost is high. Whether a disk or the cloud or whatever. Ok. Now, the other piece, [tangent about pen stylus], all of this sort of remote data is that you dont get just one piece of data at a time. You get a block of data. Ok so even if you're only looking for key 38 on the moon, when you go to the moon and you come back, you come back with a whole bunch of stuff. It's just the unit of transfer that happens either via remote communication or with your hard drive or SSD. You want to make sure that that piece of data that you get is relevant to your search, application. And that's kind of where we were. So we're gonna define this structure called a b tree, and into the b tree, into a b tree node, not 1 key but a bunch of keys. So you can imagine that this whole thing is a b tree node. It corresponds to some linear function. Some fraction of a transfer block from your disk. Remote storage. [repeating]. [pause]. And the reason that I say it is some fraction, is because when you get the block you also need other information too. Just like when you get a BST node, you also get pointers to children. In this case you get your collection of keys with some other redirection. Some other information. Main goal. We want to minimize the number of reads from a disk or any other remote storage. Ok. Alright. I want to show you how these things work before we do a formal description. Hopefully show you by pushing on this link. It worked! Oh. Gnarly trees. That's new. What am I doing? Ok. Alright. This is my ok. that's not the one I want. I want that person, but I want the big ok. We just hope it exists at this point.
4 to 8 gig? Is that about it? Okay, assume you can only use half of that. Or at most, assume you can use a fourth of that for, uh, computation on any one given program. That's probably even an overestimate. And, and you realize that any data set that's larger than, you know, a couple gig really merits some other storage, okay? Um, in, yeah, I'm not going to analyze driving records. That's, you know, whatever. That's kind of a fake application I think. I don't know, maybe it isn't, I never really looked into it. So, not going to look at this, okay? The point is, the point of it is this: if you can't fit an entire AVL tree into this immediately accessible piece of memory, this RAM, this heap memory which is part of RAM, then your only alternative is to store it someplace else. Now, I'm going to talk about that someplace else as if it is a hard drive, okay? But, all of the conversation applies anyway. So here's where we were last time. We observed that if we have some balanced structure, and this one wasn't balanced so I better make it balanced, if we have a balanced structure that we think is a reasonable way of accessing our data, but our data isn't close to us, that is, that balanced structure doesn't fit in memory that is fast, then, if we're going to do this sort of search for 38, 28 may be out in some place where the communication cost is high, whether it's a disk or the cloud or whatever, okay? Now, the other piece of- is that clear? Is that clear enough? This is high communication cost. Your pen is different than mine, it's kind of cool. I didn't know a pen was like a personal piece of electronics... a stylus. Okay. That says high communication... in the font that this pen chooses to write in. Okay, but what is also true about all of this sort of remote data is that you don't get just one piece of data at a time. You get a block of data. So even if you're only looking for key 38 on the moon, when you go to the moon and come back, you come back with a whole bunch of stuff. It's just the unit of transfer that happens either via remote communication or via communication with your hard drive or your solid state drive. Okay? So, here's the thing. You want to make sure that piece of data that you get is relevant to your search. Relevant to your application. Okay? Alright, and that's kind of where we were. So we're gonna define this structure called a b-tree, and into a b-tree, into a b-tree node, we're gonna throw, not one key, but a bunch of keys. So you can imagine that this whole thing is a b-tree node. And it corresponds to some linear function. It is some fraction of a transfer block from your disk, from remote storage. So this is some fraction of a block in remote storage. And the reason I say that it's some fraction, like a fourth or a third, the reason I say it's some fraction is because when you get the block, you need some other information, just like when you get a binary search tree node, you also get pointers to children. In this case you're gonna get your collection of keys together with some other redirection. Okay? Together with some other information. Okay, main goal. We want to minimize the number of reads from disk or any other remote storage. Okay? Alright. I wanna show you how these things work before we do a formal description, and the way I'm gonna show you how they work is by hopefully pushing on this link. Oh, it worked! (joyous exclamation). Oh. Gnarley Trees. That's new. What am I doing? Okay. Alright. This is my... okay. That's not the one I want. I want that person, but I want the big, okay? And we just hope it exists at this point. Union find ordered dictionaries. I don't know. Ack.
Oh no! It really wants me to use their interface. Oh no! No! Oh no! Oh no! Alright. Alright, here's a random one. I'm on a random one. Sorry guys, I think I've seen this one before. Alright. Alright. So... need you to start telling me numbers, insert. Can you read that? Okay. Yes you can. This is not a good applet. Sigh. Sorry but you need this. Okay! So I'm building up a B-Tree and you notice right now that I'm basically just inserting things into the root. It's fundamentally implemented dictionary just like the AVL tree did, it's an alternative to the AVL tree. You can't see that at all. Oh my god, it's 25 and 28, okay? So maybe draw this down. They're both in the same box. Okay? I'm gonna put in 35, so I put in 35. Where did it go? Where do you think it went? So the right of 25 and 38, and then I'm gonna put in 14. Where do you think it's gonna go? To the left, still in the root node. Good. Okay! Now, I have chosen a max degree of 4. That's one of the parameters to this applet. You should be sitting there thinking what the heck is all that about? A max degree of 5! Okay? What it means is that a node can have 5 children and it has a child between every piece of data and at each end. Okay? Yes, it has a child between every key and at each end. So we now have the maximum potential degree, because we have 4 pieces of data and you know, there's no room for any more in that node. So, let me add another one and see what happens. I'm adding 52. I don't remember what our other pieces of data were. Oh! Oh! I know you cant see it, you saw what happened structurally. You want to speculate on what happened? What happened to change the shape in that way. We have 5 pieces of data, they were in order, they were ordered pieces of data, and now the structure looks like that. What happened? No speculation at all? No way?
oh no, it really wants me to use their interface, oh no. oh no.oh no. oh no. alright, alright where's a random one. I want a random one.sorry guys, i think i've seen this one before, alright. so, i need you to start telling me numbers, insert, can you read that? okay, yes you can. this is not a good applet, i'm so sorry but you need this. okay, so i'm building up a btree and you notice right now that i'm basically just inserting things into the root, it fundamentally implements a dictionary just like the AVL tree did, it's an alternative to the AVL tree, you can't see that at all, oh my gosh it's twenty five and twenty eight, they're both in the same box. Okay. um. I'm going to put in thirty five so i put in thirty five where did it go, where do you think it went, to the right of twenty five and thirty eight okay, and i'm going to put in fourteen, where do you think it's going to go? to the left, still in the root node good okay now I have chosen a max degree of four okay that's one of the parameters to this applet you should be sitting there thinking what the heck is that all about, a max degree of five okay? what it means is that a node can have five children and it has a child between every piece of data and at each end, okay? yes so it has a child between every key and at each end so we now have the maximum potential degree because we have four piece of data and you know there's no room for any more in that node, okay so let me add another one and see what happens. i'm adding fifty two i don't remember what our other pieces of data was. oh! oh. i know you can't see it but you saw what happened structurally, you want to speculate on what happened? what happened to change the shape in that way we have five pieces of data they were in order they were ordered pieces of data and now the structure look's like that, what happened? no speculation at all? no way?
Ohhh, heh, sorry. Use your technology! Ohh! Ohh! Gnarly, woah. That's cool. Ok. My child for his english class asked me for eighties idioms. Like, Mom, you were a child in the eighties, what or you were in high school in the eighties, what uh, what were some of the phrases that you ever used?" Gnarly was one of them that I told him. Yeah, heheh. How did I get, oh, forward! [gibberish] Ok, that's better, how do I, raise the thing to full screen? Ohh, it's Windows, right, it's on the other side. Ok, alright, we're gonna survive this. Ok, what does somebody want to insert? What should we insert? Three. Ok fine, three. Insert. Oh, we should watch. Three, oh where did three go? Why? Yeah it was less than 28. Ooh, this feels binary search tree ish. Right? And, it went into the other node, and furthermore, it went in its right place in order. Right? Ok I have a question for you: if I insert 36, where is it gonna go? I want you all to speculate in your own minds: where does 36 go? Right at 35, right? Ok, ok! Alright, see how it's working a little bit? Alright, somebody want to insert something into this tree? What are you curious about? Yeah? 27. Alright let's oooh, insert 27. Everbody speculate, on where you think it will go. Ok, we're gonna do this for a while, cause this is actually fun, and it's not working too horribly. I have to do this fast though. Ok, did you see that? That was cool. Alright, does anybody have something they'd like to insert into this tree? 1. 1, who said 1? Ohhhh living on the edge. [inaudible] Do you see why one is a scary thing to insert? How big can these nodes be? They can only have four things in them. If you try to put five things in them, the world is a broken place. Ok. So, let's try, ahhh, I think I can hit enter here. Ok, are you ready? Alright, what do you think is gonna happen? Alright, I'm asking that rhetorically so you all get a little picture. Ok, you ready? I hope it, oh, it wants me to push insert. Ok, fine, can I get em both on? Insert. [Cinda gasps, screams of both terror and amazement ensue from the class] I call this a vomit tree. Because it throws up the middle value. [audible laughter from the crowd] You get it? You see? Where was 14 before? So 14 lived, there was one node, and 14 was right between these two values, ok. We made that node too big, so it took the middle value and threw it up, right? Now, look at this tree and make a key observation about the relative magnitudes of they keys. The word between might occur in your response. Ok, so every node still has this ordered characteristic, right? Every node has increasing keys. And what is true about this node? Yeah? Very good, that's right. Did you all hear that? Both of they keys in this node are between the two corresponding keys in the parent node. Ok? Any question about that? Alright, yeah? [inaudible question]
oh, sorry. use your technology. thats cool. okay. my child for his english class asked me for 80s idioms. like mom, youre a child in the 80s, what are your high school in the 80s what were some of the phrases you ever used. narly was one of them that i told him. yeah. hmm. hmm. how do they get. oh! forward. i am so... okay. that's better. how do i raise the thing to full screen. oh its windows! right! on the other side. okay alright. we are going to survive this. okay. what does somebody want to insert. what should we insert. alright fine, 3. insert. we should watch 3. oh where did 3 go! why? yeah it was less than 28. oh this feels binary search tree-ish right? and it went into the other node and further more, it went into its right place in order. okay i have a question for you. if i insert 36, where is it going to go? i want all of you to speculate in your own mind where does 36 go. right of 35 right? okay. alright. see how its working a little bit? alright, lets. somebody want to insert something to this tree? what are you curious about. alright lets... oh... insert 27 everybody speculate where you think it would go. we are going to do this for a while. cuz this is actually fun and its not working too horribly. i have to do this fast though. okay did you see that? that was cool! does anybody have anything they want to insert into this tree? 1! who said 1? ohhhh living on the edge! do you see why 1 is a scary thing to insert? how big can these nodes be? they can only have 4 things in them. if you try to put 5 things in them, the world is a broken place. kay? so lets try errr i think i can hit enter here. are you ready? alright what do you think is going to happen? alright i just want to ask it rhetorically so you all get a little picture. you ready? i hope it oh. it wants me to push insert. okay fine. get them both. insert. oh! i call this a vomit tree because it throws up the middle value. you get it? you see? where was 14 before? so 14 lived there was one node and 14 was right between these 2 values. we made that node too big so it took the middle value and threw it up. right? now. look at this tree and make a key observation about the relative magnitude of the keys. the word between might occur in your response okay so every node still has this ordered characteristic right? every node has increasing keys and what is true about this node? yeah? very good. thats right. did you all hear that? both of the keys in this node are between the two corresponding keys in the parent node. okay? any questions about that?alright yeah?
Um that degree is the number of children they can have, degree is the number of edges coming out. Okay? Okay? So where is the four value? Four is the number of the keys that you have because its one less than the number of nodes coming out. So you can have five coming out. Let's fill one up and you'll see it. Well, Oh, this is so much fun. Okay, We need to insert a few values, okay? And I think you will be good if we insert a whole bunch of values over here for now, okay? Just cause I want to you see it again and then I actually want you see what happens when we throw up. I love saying that, throw up to the root when there's no room, okay? All right, so I am gonna insert a button here, maybe shrink it just a little. Oh, there! Perfect! Insert 30, umm, insert, I don't know, 40. Make sure that you are following where all these go, okay? Follow alone. You all have the speculation. Insert 40. Oh, what happened? A threw up. Threw one up. All right, fine. Now notice the degree of the root, the degree of the root is 4, right? The degree of the root is 4, it has four edges coming out of that and it has three things in it. As I said, there is a child node between every pair of this and one at each end. Notice if I hide all this, if I hide this center thing, you'll have a binary tree, pretty much a binary search tree, right? If I hide, you know, if you have one node and two things on the side, a binary search tree, right? It just behaves differently. I think I want to do something like enter 5, 7. Now what? 8? Okay? 8. Oh, Okay? Got it? We got do do this one more time. We must. It's awesome. All right, I think this middle child is feel little neglected. So, let's insert 16. That's a joke, middle child neglected, you know. I I hate it when you miss my jokes, especially when they are bad. You are ready? I am inserting 20. All right. Oh. Dung dung dung. Are you ready? Are you ready? Yes? Okay, I wish I can slow it down. All right, I am putting in 26. All right. Okay. Insert, you know, insert 26. Oh! It threw up twice. It's stupid, stupid. Okay, got it? Yes. This is a good question. It miss a giggle every time. All right so the question is if I chose a maximum degree which was odd, in fact when we talk about btree, that's called the order of that btree, the order of this btree is 5, the question is how can we deal with even order? Would you like speculate any idea? The design moment, right? How can we deal with even degree, or even orders? What do you think? You want to answer you own question with a guess?
No, a max degree is the number of children you have. Degree is the number of edges coming out. okay? Four is the number of keys that you have, because it's one less than the number of nodes coming out. So you can have five coming out. Let's fill one up and you'll see it. Well, oh this is so much fun. We need to insert a few values. I think it would be good if we insert a whole bunch of values over here for now. Just cause I want you to see it again, and then I actually want you to see what happens when we throw up. I love saying that. Throw up to the root when there's no room. Alright, I'm going to insert [gibberish]. Maybe shrink it just a little. Oh, there. Perfect. Insert thirty, insert i don't know, forty. Make sure that you are following where all these go, okay? Follow along. You all have the speculation. Insert forty. Oh, what happened? It threw up, that's right. Threw one up. Alright, fine. Now notice the degree of the root is four. Right? The degree of the root is four. It has four edges coming out of it and it has three things in it. So as I said, there is a child node between every pair of keys and one at each end. Notice that if I hide all this. If I hide this center thing, you pretty much have a binary search tree right? Or if I hide, you know if you have one node and two things on the side [gibberish] right? It just behaves differently. Alright, I think I want to do something like insert five, seven. Now what? Eight, okay, eight. Oh. Okay, got it? We gotta do this one more time right? We must. It's awesome. Alright, I think that middle child is feeling a little neglected. So, let's insert sixteen. That's a joke. Little child neglected, you know? I hate it when you miss my jokes. Especially when they're bad. Okay ready? I'm entering in twenty. Alright. Dun dun dun. Are you ready? Are you ready? Yes? Okay. I wish I could slow it down. Alright, I'm putting in twenty six. Alright. Okay. Insert twenty six. Oh. It threw up twice. Stupid, stupid. Okay, got it? Yes? This is a good question. It makes you giggle every time huh? Okay. Alright, so the question is, so I chose a maximum degree which was odd. In fact, when we talk about B-trees, it's called the order of the B-trees. The order of this B-tree is five. The question is, how do we deal with even orders. Would you like to speculate any ideas? This is a design moment. How can we deal with even degrees, or even orders? What do you think? Do you want to answer your own question with a guess?
There isn't wrong answer here. Oh introducing new key that's radical. All right, so here is, here is what you will do. There are actually structures that will do that, but not ours. Our implementation will be treat doesn't do that. Umm, so what you will do is you just chose median of whichever you want. You can choose though the less median, median or the greater median, ok, of the values. Right? It doesn't really matter. Umm, it creates a little bit of inaccurately and terms of number of keys of each one. But, umm, it just doesn't matter, all right? Does it make sense? So you still take as close as you can to the center value you use it to split the node at all. All right, any other questions about it, About this process? Ok, so, here is what I know to be true. Umm, we are gonna do analysis of this things and argue about their utility to us. Umm, excuse me as a data structure. Umm. And you are responsible for knowing about that analysis on your exam coming up. But, you won't be inplementing this untill next week and I believe you only implementing [insir]. I actually have never even played around with the lead. I don't know how you suck them back together after you remove from them. Will you waiting for that? All right, so, umm, so I I haven't even played around with that at all. All right, any questions about it? I suspected actually might be a process of you just go ahead and remove untill they get too small and then you reformat the tree sort of like resizing in arrays, sort of like when we use a linear structure we resize upward and downward. And I wanna say that in actualilty the implementation of this which isn't really cover the real implementation as an out of course structure, has to do fire lay out. How you lay out your data in a file. And that's more the subject of data base class than it is this class. I want you to know the system, I want you to know the structure exists that not all data. It's in memory and I want you to have the experience with the analysis of it. But the actual nitty gritty making this things perform, not so much for this class. Any question about that. All right, now I think if I do. Is [deeding] but if you have any queation about this structure it takes long time to change things now. Yeah? Delete 25? What you think will happen. Oh you know what, this is actually a reasonable thing. 25. I'm gonna shrink it just a little bit so we can see it as it goes. Ready? I don't know what's gonna happen here. What you think? 20 is gonna come up? Then this [famil] as 1 I don't know, I don't even know. Delete! It was a two child remove right? To put it back in? I can do this all day. I'm sorry if this is boring you. Oh see, it doesn't. No. Here. I got it I got this. I got this. Opps. And.
There isn't a wrong answer here. Oh if you insert a new key, that is radical. So what you do is you just choose a median whichever one you want, you can choose the lessor median or the greater median, of the values. It doesn't really matter. It creates a little bit of an iniquity in terms of the number of keys in each one. But uh, it just doesn't really matter. Does that make sense? So, still take as close as you can to the center value to split the node. That's all. Alright, any other questions about it? About this process? okay so here is what i know to be true. We are going to do analysis of these things and argue about their utilities to us. Excuse me, as a data structure. Um, And you are responsible for knowing about that analysis on your exam coming up. But, you won't be implementing this until next week. And I believe you only implement insert. I actually never played around with all these, I don't know how you can suck them back together after you removing from them. Where you waiting for that? Alright. So i have never play around with that at all. Any questions about it? I suspect there might be a process of you just go ahead and remove until they get too small and then you reformat the tree sort of like resizing an array. Sort of like when we use a linear structure and we we resize upward and downward. And i wanna say that in actuality the implement of this. The real implementation as out of course structure has to do with file layout. How you layout your data in a file. And that is more of a subject to the databases class than it is to this class. I want you to know the structure exists that not all data fits in memory and I want you to have the experience with the analysis of it. But the actual nitty griddy performant, not so much for this class. Any question about that? Did anybody have any question about this structure? Delete 25? What do you think will happen? Oh you know what. This is actually a reasonable thing. 25 and I am going to shrink it a little bit so we can see it as it goes. Ready? I don't know what is gonna happen here. What do you think? 20 is gonna come up. Then this one is gonna have.. I don't know. I don't even know. Delete. It was a two child remove right? Should put it back in? I can do this all day. I am sorry if this is boring you. Oh see, it doesn't. No. Here I got it. I got this.
Okay. Got it? Okay. So what we did see is that 16 came up right? If you remove 20, 16, the inorder predecessor will come up. But that one is too small. So I think it grabs one from... I just didn't see it. Should we do it? Alright. Last time, this is the last time, we should do analysis. 20, taking 16 up, okay throwing things down. Theres a lot of throwing down. So this one's quite. This one's quite combative. It's a throwdown. Okay. Alright. Can we go on? Please? Who said please? I love that you feel comfortable enough to admit that you said please. Okay. So here's the more formal description of what these things, the constraints on these nodes. And there are some key parts. So an internal node is a non-leaf node. Internal means non-leaf. Non-leaf. The number of keys in the node is the number of children 1. And, m-way tree, a b-tree of order m is an m-way tree. So maximum of m-way. You MIGHT have m children. All leaves are always on the same level, so this is new for us. All leaves hold no more than m-1 keys. So that's when throwing up happens. But the thing we didn't see very much, is that all non-root internal nodes have between, and this is the hm, ceiling of m/2, and m children, I believe. Let's see if that's written, is that right? Here? On your sheet it has it? Okay, good. That didn't make it through the various file transformations. Okay. So what does that mean about the number of keys? It's one less than ceiling of m/2. Right? The number of keys is then one less than ceiling of m/2 and m-1. Now, roots can be a leaf, so a single node, or it can have between 2 and m children. It's the only one that can have that few children. And the keys in the node are ordered. So, this is actually a key point. This piece right here, says that no node is very empty. So if this is as big as a node can be, notice that that says, that it is at least, one less than half full. Okay, so you can think of this, you can think of these nodes as being at least half full, about. It might be one less than that, but that's all. Okay, so all nodes, key observation is, that no node is very empty. No node, they changed the font, I don't know, is very empty. Except the root. Because we need some place to keep this [cuts off] Yeah? No! Aha! This is good. So let's reinforce that. This always confuses me too, I don't know why. Okay, it says here, the root can have between 2 and m children. There is a difference between the number of keys it holds and the number of children it has. How many children does this have. One, two. Even though it has one key. Oh yeah! There's this minus one thing. Okay, any questions about all of this? Of course, I have a question for you. I want you to infer, from this picture, the order of this tree. No, it's not four. Has to be bigger than four, why? Yeah, because this one has four keys in this. Right? If four where the order of this tree, we would've had vomited three. Five? Why not six? This is actually a hard question. Why not six?
Okey. Got it? What we didn't see is 16 not 20. If you remove 20, the in order predecessor will come up, but then that one is too small, so I'm thinking: grab... Should we do it? ok, there's a lot of throwing things down. This one is quite combative row down. Okay, right can we go on? Who said please? I love that you feel comfortable enough to admit that you said please. So here is a more formal description of the constraints of the nodes of some key part. So the internal node is the non leaf node, internal means non-leaf. Note that the number of keys in that node is the number of children minus 1. And a b-tree of order m is a m way tree. so maximum m way. so you might have m children. All leaves hold no more than (m-1) keys. That's why throwing up happened. But the thing we didn't see very much is this piece right here says that no node is very empty. so if this is as big a node can be, notice that that says it's at least 1 minus less than half full. So you can think of these nodes as at least half full, it might be 1 less than that but that's all. So the key observation is no node is very empty. except the root because we need some place to keep this structure. So let's reinforce that. This always confuses me too i don't know why. so it says here that the root can have between 2 and m children. How many children does this have? one, two! Even though it has one key. Oh yeah there is this minus 1 thing. Okay! Any questions? of course I have question for you. I want you to infer from this picture the order of this tree. no it's not four, has to be bigger than four why? yea? because this one has four keys in it. if four is the order of this tree we would have no more than three. five? why not six? this is actually a hard question. why not six?
Good, if you had 6, then these would all still live in the same node. Alright, let's see... Let's see what's I'm gonna ask... Oh, why not 7? This leaf implies not 4; this structure implies not 6. Why not 7? Same reason but also, these are 2 small. Any node with only 2 keys that's less than you can have for 7. 7 will have to have the ceiling of 7/2 4 children. So we need to have at least 4 children or 3 keys. So this is too small to be 7. I didn't look at the test, so I don't know if the instinct about this is good enough. Oh, how much detail we need to know about that definition. I think knowing that definition is reasonable. OK, here's B-tree search. Here's some code, represents B-tree search. I think it's kind of pseudo-code. It assumes some functions we have been articulated. In particular, it assumes a discrete function. So that we have access to some functions that when given a particular child we can find it. Now we are looking inside of B-tree node which you can sort of think of as an array. For a particular key, inside the array, x were looking for a key. Now, take a look at this code. And suggest any sufficiency, you'll find something that bugs you about this code. ...Pseudocode, I should say. What's it doing there? What's that while loop's goal? I'm asking all of you, I'm in conversation with [who?] but I'm asking all of you, what's that while loop's goal? [student answering] What's the efficient fashion. Look, we've made a big point, good job. So we have made a big deal about the fact that the keys in these nodes are ordered, right? You should never search through an ordered structure, especially an ordered array linearly. You should just use binary search, that's what you get for this. Here's the thing now. I don't care, and here's why. These are all.. each one of those is a super fast operation. They're super fast. These all happens in the CPU. The data is all sitting right there. It's this discrete that determines the running time of the algorithm. Very long running time.
Ok if you have six then these will all still live in the same. If you could have six then these will still live in the same node. Alright let's see. Will be shaped a little bit differently. Why not seven. This is implies not for these structure implies this structure not six. Why not seven will same reason these are too small any node within two key. That 's less than you can have for seven seven will have to have. The ceiling of seven over two will just have four children. or three keys. so this is too small. Too small to be seven. Okay any question about it. Alright, I am didn't look at the test. Instinct of this is good enough. I think knowing that definition is reasonable. Here is btree search. Here is some code that represent btree search. i think is kind fo pseudo code. It assume some function we haven't articulated. it assume some discrete function. We haven't access some function he can find data. we are looking insider a btree node. We can think of as an array. For a particular. So in inside array x we are looking for a key. Now take a look at this code for just a minute and suggest efficiency. You will find something that bugs you about this code. I should say. you will find something that bugs you about this pseudo code. What is doing there. I am asking all of you. What's that while loop goal. What's a more efficient point. We make a big point. We make big deal. These nodes are order. you should never search thought an ordered structure. That you should get for this. These are all. Each one of those is a super fast operation. These are super fast. These all happens very quick in the CPU the data is all sitting right there. It is statement. This discrete that determine the running the time of this algorithm very long running time.
Very long running is good enough, I think. All right, any question about that. So it doesn't really matter in the performance whether we do binary search in that case. Of course you could. And in fact, hack, these nodes, each one of them, they can be an avl tree if you want it and instead of keep your array. So you can build them into an avl if you want it, or whatever, right? Like the nodes themselves can be different structures, it's just an an array of data, just the question of how much it can hold. Okay, any question about this? All right, the height of btree determines this sort of the introduction to the analysis of this thing. Probably gonna do the analysis really quickly cause they only have 5 minutes. The height of btree determines the number of disk seeks and it's the number of the disk seeks that determines the running time. That's what we want to minimize and what we want to analyze here. We want to be able to say the height of the structure and thus the number of the disk seeks is no more that, How tall do you think these things are? How tall do you think these things are for n pieces of data? Log, did you say log, yeah, good. Log of the size of the size of the data. Now what the base of the log? M, good. Cause the each level basically allowing for dividing our data into, dividing our data by m. Okay. As we saw a case of avl tree finding an upper bound on the height is same as finding a lower bound for the keys. So that's what we are gonna do, again. Um, and we are gonna find the relationship. And this is what we are trying to prove here. All right, any question about this? Okay, fine. Um, we are going to look at, we are gonna look at this level by level. We are not gonna think recursively about this because I haven't actually define a btree recursively. Could, but I haven't define a btree recursively so we are not gonna look at it recursively. Okay, so n of h is again, we are going to say the minimum number of nodes in each level of a btree of order m. Now this is nodes in a level, not keys in a level, okay? Nodes in a level, not keys in a level. n of h is min number of keys in level h. Okay, so what's the minimum, oh, for your convenience, this will help you. Ah, yeah, this helps. We are gonna let t equals the celling over 2. So this is the number of children, the minimum number of children a node can have. We are gonna let t equal the ceiling over 2. Okay, what's the minimum of nodes, not keys, in a, uh, in the root? Minimum number of nodes, not keys, what's, what is it? How many nodes are there ever in a root. Thank you. Okay, now things get interesting, a little more interesting, what's the minimum number of nodes in the second level of the tree. If I got one in the root, how many nodes do I have? Not keys, nodes. Okay, now I lied, now things get interesting. okay? Okay, here's the root, here its children, here's the nodes, how many children might becoming off of here. Notice the degree of each of this is the number of nodes in the next level. What's the smallest value?
Very Long running time is good enough I think. Alright, any question about that? So, it doe not really matter in the performance weather we do binary search in that case. Of course, you could and in fact, hack! These nodes, each one of them, they can be a AVL tree if you want it instead of keeping you array sorted you could build them into an AVL Tree if you want it or what ever right? The nodes of themselves can be different structures, its just an array of data. Just a question of how much it can hold. Ok, any questions about this? Alright, the height of B trees determined the these sort of the introduction into the analysis of this thing. Prabobly gonna do these analysis really quickly because we only have 5 min.So the height the B tree determines the number of disk seeks determines the running time.That's what we want to minimize and that's what we want to analyze here. We want to be able the say the height of the structure and thus the number of disks seeks is no more than, how tall do you think these things are?how tall do you think these things are for n pieces of data? Log? Did you say Log? Log of the size of the data. Now, what's the base of the log? M, good Cause at each level basically we are allowing for dividing our data into, dividing our data by M. As we saw a case in AVL tree, finding the upper bound of the height is the same as finding the lower bound for the number of keys. So that's what we gonna do, again, Um and we are gonna find that relationship. And this is what we are trying to prove here. Alright, any questions about this? OK fine. Um, we are going to look at, we are going to look at this,first level by level. We are not gonna think recursively about this because I haven't defined a B tree recursively. Could but I haven't defined a B tree recursively so we are not gonna look at it recursively. OK, so, N of h, so again, we are going to say that the minimum number of nodes in each level of a B tree order m, now this is a node in a level, not a key in a level. OK Nodes in a level, not keys in a level. Ok, n of h is number of keys in level h. So what's the minimum? For your convenience, this will help you. Uh, this helps ok. We are gonna let T= the celling m/2, and so this is the number of children, the minimum number of children a node can have, so we are gonna let T= m/2/ Ok, so what's the minimum number of nodes, not keys in a root? Minimum number of nodes, not keys, what is it? How many nodes are there ever in a root?Thank you! Now things are getting interesting, what's the minimum number of nodes in the second level of the tree? If I've got one in the root, how many nodes do I have? Not keys, nodes. Now things get interesting. Ok, here is the root, and here its children, here are some nodes. How many children might be coming off here? Notice that the degree of each of these is the number of nodes in the next level. What's the smallest value?
t, good, t, thats right. the least number of nodes you should be flipping back your definition one more than the least number of t that can hold, so this is now two t, now lets do number three, note that for each node in level two, you might have these many children right? so how many are there in level three? two t squared, now we are gonna add all those up, how about level h, two t to the h minus one good, now i add those up, I'm gonna do it like this, I'm say that sum is one plus two times t to the k, remember k goes from zero to h minus one. thats my phrase of the day apparently. what is the sum, what is this. anybody know it just from top of their head, is t to the h minus one over t minus one. two times that. how many t s can be in each one of the nodes? so we counted nodes and how many t s was the smallest number of t s that can be in the root one right? but the rest of them can have how many t s do in terms of t, cause its lovely. so the totally number of t is then the number of nodes which is two t to the h minus one over t minus one, times the number of t in each node, which is t minus one. watch this. gone. gone. i love it when it works out like that, and we end out with two t square minus one plus one minus two plus minus one. two k h, two t h. any question about it? what are we gonna do next what's this results say. so this means n is at least that. is that what we want? no we want to argue about the height right? so how do we do that. Invert it. invert that inequality so the least totally number of t is t to the h minus one times two, two t to the h minus 1. write that as an inequality as I just did. rewrite that as an inequality about h, so i will race you. that means, we gotta do n over two plus one, wait, n plus one over two, log base what? log base t of that. and then i get is greater than or equal to h. so h is less than or equal to log base t of this thing. now all logs can be any other logs, right? so we have h is less as all logs are constant factors of one another, so we have h is less than or equal to log base t of some function n, so h is big o of log of n. m is considered fixed. you will go back and look at this. it doesn't tell you anything different than we already analyzed. there you go.
T, good, T, that's right, the least number of nodes you should have been flipping back to your definitions one more than the least number of keys it can hold. So, this is now to T, let's do level 3. Now, notice that, for each node in level 2, for each node in level 2, you might have this many children, right? So, how many are there in level 3? 2 t squared, okay, now, we're going to add all those up. How about level h? two t to the h minus one. Now let's add those up. I'm going to do it like this, I'm going to say that sum is one plus two times t to the k where k goes from zero to h minus one. Dun, dun, dunnnnn. It's my phrase of the day apparently, one plus, what is this sum? Oh my gosh, what is this? Does anybody know it, just off the top of their head? It's t to the h minus one over t minus one. We good? Two times that, good. Catch, good catch. Okay, how many keys can be in each one of the nodes? How many keys can be in each one of the nodes? Okay, so we counted nodes, we counted nodes, and how many keys were the smallest number of keys that could be in the root? One, right, but the rest of them can have how many keys? Do it in terms of t, because it is lovely. Okay, so the total number of keys, is then, the number of nodes, which is two t to the h minus one over t minus one times the number of keys in each node. Which is? t minus one. Watch this, gone! Gone! Ahhh, I love it when stuff works out like that! And we end up with two t squared minus one plus one? minus two plus minus one, okay. Two k h, two to the h. okay, sorry.Any question about it? What are we going to do next? What does this result say? So this means, n is at least that. So, is that what we want? No, we want to argue about the height, right? So how do we do that? Invert it, that's right, invert that inequality. So the least total number of keys is t to the h minus one times two, two t to the h minus one. Write that as an inequality, I just did, rewrite that as an inequality about h, so I will race you. So that means, okay, we gotta do, n over two plus one, wait, geez, ughhhh. n plus one over two, log base what? log base t of that and then I get is greater than or equal to h. So h, is less then or equal to log base t of this thing. Okay? Now all logs, can be any other log, right? And so we have h is, all logs are constant factors of one another, so we have h is less then or equal to log base t of some function of n, so h is big O of log of n. Okay, ummm. m is considered fixed. You will go back and look at this, it doesn't tell you anything different than we have already analyzed. Okay, right, there you go.
Okay, so we are gonna work today, I'm going to remain silent about the test because there are people still taking it so you can ask me about it all you want and I will look at you with blank eyes, like I'm not going to respond. So I think we are gonna focus on things going forward, on Friday I'll have a better grip on what the grading process is going to be like, but I just don't want to talk about it today. So MP6 is on your plate, I have a couple things to say about this point in your semester. I think yesterday was your worst day for this class for this semester because the exam was pending, MP6 was out, b trees lab, so you might not have known that yesterday was the worst day but yesterday was the worst day. And this week is kind of the hardest week. So the b trees lab is this week, and it is known to be the hardest lab. Rather than simplify it, I'm going to make it worth double credit, so if you are willing to invest the time into it, you are going to get a little bit of a bump for having done so. Okay so I don't want to shorten the lab, I think it is a good experience, worth the investment, but I'll give you credit for the extra time that it takes. So one of the points will be extra credit, so now instead of having fourteen points associated with the labs for the class, now we have fifteen so ten of those we are counting on you to get to get the A, now there are five extra credit points. So you won't be penalized for your decision making process, your just making a choice not to go for some extra credit. So finally today, we are done with trees, we are going to move onto hash tables. Probably, at least from my perspective, as somebody who likes to get things done using python, probably hash tables are the most important data structure, for the kind of things I do. Now if I were a scientist, if I were doing a different kind of computing day to day, I might be interested in being able to search regions of things, hash tables dont give you that we'll talk about that later, but suffice to say this stuff is important. Alright so, what does it mean when we talk about hashing? Well it simply means that we are going to use a data structure called a hash table to implement abstract data type dictionary.
okay. erm. yeah. we are going to talk about it. erm. so. we are going to work today. erm. im going to remain silent about the test because there are people still taking it so you can ask me all you want and i will look at you with blank eyes. like im not going to respond. erm. yeah. so er i want to focus on things going forward on friday i will ahve a better grip on what the grading process is going to be like. and but i just dont want to talk about it today. so i guess i ask for that courtesy. lets see, so MP6 is on your plate. i have a couple of things to say about about this point in the semester. erm i think yesterday was your worst day for this class this semester because the exam was pending mp6 was out its b-tree lab week you might not have known yesterday was the worst day but yesterday WAS the worst day okay and this week is kinda the hardest week so erm here's so the b-tree lab is this week and it is known to be the hardest lab. rather than simplify it, im going to make it worth double credit so if you are willing to invest the time in it so you get a little bit of a bump for having done so. i dont want to shorten the lab i think its still a good experience worth the investment but erm i give you credit for the extra time it takes. so one of the points on the lab is extra credit basically it contrivutes. instead of having 14 points associated for the lab the class we have 15 points assiciated with the labs for the class so that 10 of
Okay! Umm Yeah. We're gonna talk here of it. Ummm so we're gonna work today. Umm I'm going to remain silent about the test because there are people still taking it. So you can ask me all you want and I will look at you with blank eyes. I'm not going to respond. Yeah, so. So I think we're gonna focus on things going forward. On Friday I'll have a better grip on what the grading process is going to be like, but I just don't want to talk about it today. So I guess I asked for that courtesy. So MP6 is on your plate. I've a couple of things to say about this point in the semester. I think yesterday was your worst day for this class this semester because the exam was pending, MP6 was out, BTrees lab. You might have not known that yesterday was the worst day, but yesterday was the worst day. The BTrees lab is this week and it is known to be the hardest lab. Rather than simplify it, I'm going to make it worth double credit. So if you decide to invest the time in it, you get a little bit of a bump for having done so. I'm don't want to shorten the lab, I still think it's a good experience, worth the investment, but I'm going to give extra credit for the time you invest in it. So, one of the points on the lab is extra credit, basically. So now instead of having 14 points associated with the labs for the class, we have 15 points associated with the labs in the class. So that 10 of those we're counting on you in order to get your A, now there are 5 potential extra credit points. Does that clarify it? So you won't be penalized for your decision making process any more than if you decide not to go for some extra credit. Yes! It'll still be due on Sunday. Mike! Yup! That's right. Which is like almost up half a letter grade. This class is so cake. Hahahaha! Just kidding. Alright. We should work. Let's play school. Oh yeah! Ok. Alright, finally today is the day we're done with trees. We're gonna move on to hash tables. Probably atleast for my perspective as somebody who likes to get things done in python, probably hash tables are sort of the most important data structure. For the kinds of things that I do. Now if I were a scientist and I was doing a different kind of computing day to day, then this might not be true. I might be more interested in being able to search regions of things. Hash tables don't give you that. But suffice to say that this stuff is important. So, what does it mean when we talk about hashing. It simply means that we're going to use this data structure called hash tables to implement abstract data type dictionary. Okay? Let's see if we can get anything to work at all today.
I'm gonna say it like this, implement ADT dictionary, okay so, the minute I say that, you know already what the interface is. You need to be able to, given a key, find the key in the structure, and return it's value. You should be able to insert key value pairs and remove based on keys from the structure. So it's sort of a key-centric structure and all we do is put stuff in and take stuff out. Particular application beyond that is up to you. Okay, so I think we might have talked about this before, suppose this is what our data looks like. We have a student and a locker, how can I, where this is the key, and this is the value, or the data associated with the key, how can I implement insert, remove, and find, efficiently, if what I want out of the structures is names? Given this particular data set, what would be an efficient implementation of a dictionary? Yes!? A tree? Sure, we could do that, but it would take me a long time to like figure that out? What is this asking for? Ya, an array, look! These locker numbers, if you squint your eyes a little bit, or maybe you don't even have to do so. They look like array indices, right? They happen to not be in order, but they could be. So, it's perfectly reasonable to exploit the fact that our keys are smallish integers, and to place the values in the array entries. Okay, so, this implies use an array. Okay, any questions or comments about that? Okay, fine. But we know at this point that keys and values don't necessarily come so conveniently posed, that in fact our keys might be things that are more interesting. Okay? Wouldn't it be kind of cool, if we could take a key, that is say a flight number, and think of it as an array index. Hello? Wasn't going to smile today, I have no smiles in me today. Wouldn't it be cool, if we didn't constrain the indices, the kinds of things we use for indices, to integer? Wouldn't it be cool if we could use strings, or whatever else, objects of any particular type? Okay, any question about that? Well that's kind of what we are going to do. We are going to that among other things. A color you know as a key, that's usually a triple, you know an RGB value, especially for us, but maybe it's HSB we don't necessarily know what a color looks like, what it's representation is, but you should think of it as an arbitrary type kind of, it is an arbitrary type, a user defined type. So any questions about that, so wouldn't it be cool? The answer is, ya it would be cool. So let's see what we could do. So here is a dictionary, you are familiar with that, we are going to define this new interface, that mostly implements a dictionary, called an associative array. Now, all an associative array does, is that it overloads the square brackets, you can barely see it. There is like a one pixel space there, between those square brackets. So it overloads the square brackets, so that you can use them as if they were array indicators. So, for example, we could define a dictionary to be this associative array, which we are going to give a different name to in a minute, and use as a key, some string and store the data, and conceptually what you might have going on is that you have this array who's indices are like string and who's values, it looks like are ages and what conceptually what's going on is
The age of Miquel is 22. Any question about that? So that's kind of what the usage that you want. All right so what does return here what does value d? What's the value d? 22. That's right. Any time you refer to this thing. Any time you refer to your structure with square brackets you get the value out of the structure just as if it were an array. Now this is a model. This picture right here, this rectangle, this table is a model for what's going on. This is a programatic representation of your interface to your data, but it lives at the application level. So the question is? How do we implement this. That is what does this thing look like. What does the overloaded brackets look like? And we are kind of gonna go there. Okay. So we are gonna use a hash table to implement this thing. So I wanna talk broadly about hashing. So there a couple little definitions. I'm sorry you can take a nap during definitions if you dare. Alright, so what's a keyspace. It's simply a mathematical description for the keys for a set of data. It might be strings, like you might be able to say it is the union of characters or something like that. But it is usually defined over a set. A way to think about the keyspace here is as the domain of some function. So in any way you can articulate a domain effectively. You are articulating a keyspace. A potential keyspace. So whatever kind of thing a domain can be you can use it for keyspace. All right. So here is what we are gonna do. We are gonna use a function to map the keyspace onto a small set of integers and then we are gonna inturn use those as array indices. Now, what is this function. I mean a mathematical function. Some mathematical function.So you are accustomed to seeing denoted like this. F maps the key to, I'm gonna do it, what's the, is integers, small positive integers, is like this right? That's an I. That's a Z. There now it looks like a Z and it's small. So maybe this isn't so robust mathematically. It's a small set of positive integers. There will be no jokes today. Alright, so what's funny about this goal? What's fuzzy about is, we don't know how big small is. It's smallish. And what function are we talking about. What is that function? Well I don't know? It's just some function. Okay. What's the behavior of the function overall. So what's fuzzy about this goal is f is not obvious and this small set of positive integers is not well defined. Now here is where we are gonna use that small set of positive integers for. Array indices. Well how big is, well it depends on how much memory you have available to build this array, which depends on what your system looks like at execution. Now for the purpose of this course, we are not gonna think very hard about that. Now I encourage you to write a piece of code that allocates incrementally bigger dynamic arrays in see how big you can get Z positive to be. It will be big. You will be amazed at how big it is. But, now we don't care. We are gonna deal with that symbolically. Now, because you know any conversation we have about that right now, in two years that number will be obsolete. Probably next month that number will be obsolete. So this just means the size of an array. So this is reasonable array size.
The age of Miguel is 22. OK, any question about that? So, that's kind of what the usage that you want. Alright, so what is return here? What is the value of d? 22, that's right. Any time you refer to this thing, anytime you refer to your structure with square brackets, you get the value out of the structure just as if it were an array. Now, this is a model, this picture right here, this table is a model for what is going on. This is a programmatic representation of the interface to your data. But, it lives at the application level. So the question is: how do we implement this? That is, what does this thing look like? What does the overloaded bracket look like? And we're kinda going to go there. Ok, so we're going to use a hash table to implement this thing. And I want to talk broadly about hashing. So there are a couple of definitions. So what is a keyspace? It's simply a mathematical description of the keys or set of data. Now, it might be strings. You might be able to say it's the union of characters" or something like that. But it is usually defined over a set. The way to think about keyspace here is as the domain of some function. So any way you can articulate a domain effectively you are articulating a keyspace. So whatever kind of thing domain can be, you can use for keyspace. So, here's what we're going to do. We're going to use a function to map the keyspace onto a small set of integers, and we're in turn going to use those as array indices. Now, what is this function? I mean, a mathematical function, some mathematical function. So, you are accustomed to seeing it denoted like this. F maps the key to small positive integers. Ok, looks like a Z. And it's small. Maybe this isn't so robust mathematically. It's a small set of positive integers. Alright, let's see. What's fuzzy about this goal? We don't know big small is. And, what function are we talking about here? What is that function. I don't know, it's just some function. So, what's the behavior of the function overall. So, what's fuzzy about this goal is F is not obvious, and this small set of positive integers is not well defined. Now, here's what we're going to use the small set of positive integers for. Array indices. How big is it? It depends on the amount of memory you have available in which to build this array, which depends on how your system looks like at execution. For purposes of this course, we're not going to think very hard about that. I encourage you to write a little piece of code that allocates incrementally bigger dynamic arrays and see how big you can get Z positive to be. It will be big, you'll be amazed at how big it is. But, we don't care. We're gonna deal with that symbolically now. Because any conversation we have about it now, in two years, that number will be obsolete. So this just means the size of an array. So this is reasonable array size.
Okay. Alright, so this is what we are gonna do. We are going to create, so first of all we are going to call this f, a hash function. And we are going to take a value k from our key space. Feed it into this hash function h(k). We are going to define h(k). Please look at the characteristic of h(k). Out of that, is going to come some small index, i, and in that location, i, in some table, we are going to store some data. So this is for a k v pair. Okay, any question about that? This is our plan but it's still ambiguous because we don't know what this thing has to look like. So that is kinda what we are going. Alright, any question before we start. This is all set up. This is all leading us to the interesting part. Let me make sure I wasn't suppose to say something else. Yes? No, not necessarily, so the question is, are we assuming the value. Were you asking about the values? This is a plain O array. Good I am glad you asked. This is an array. This are the indicies and these are the values. So yes, this is 0 1 2 up to you know however big that array is. Okay and these are the indicies for that array. Alright, is that clearify it? Yes, it is a one-dimensional array. Good. Okay. okay, hmm so I wanna talk about just a second about this h (k) function. So your key might be you know whatever, a camera model or a flight, an airline flight or whatever. And what h(k) has to do is it has to take that thing that type of thing as input and produce a small value that you can use as an array index. Well this is what commonly done. it is very common to set up h(k) as the composition of two functions. Like this. h(1) of h(2) of okay where h 1 of k just make sure that your key fits into the array. So where h(1) of k h(1) of sorry, it is going to be an integer. So it equals x mod n where n is the table size, so it is very very common, take your key and map it to some integer whose value you are not worry about. And take that and shrink it, the mod so it fits into your table. So this is an example. These are the children in my neighborhood and their Halloween customs.
Okay. Alright. So here's we could do. We are going to call.. Okay so first of all, we are going to call this F a hash function. And we are going to take our value k from our key space. Fit it into this hash function. H of K. We are going to define h of k at least look at the characteristics of h of k. Out of that is going to come some small index i. And in that location i in some table we are gonna store our data. So this is for a k-v pair. Okay, any question about that? So this is our plan. But it's still ambiguous because we don't what this thing has to look like so that's kind of where we are going. Alright, any questions before we start. This is all set-up. This is all leading us to the interesting part. Let me make sure I wasn't supposed to say anything else. Yeah? No, not necessary. So the question is are we assuming that the value for you asking about the values? This is a plain old array. Good I am glad you ask. This is an array, where these are the indices and these are the values. So yes, this is zero, one, two, up to you know however big that array is. Okay, these are the indices for the array. Does that clarify it? Yeah, it's a one dimensional array. Yes. Good. Okay. Okay. Hmm. So I wanna just talk for just a second about this h of k function. So your key might be you know whatever, a camera model, or a flight.. an airline flight whatever. And what h of k has to do is it has to take that thing, that type of thing as input and produce a small value that you can use as an array index. Here is what commonly done. It's very common to set up h of k as the composition of two functions, like this, h1 of h2 of k. Okay. where h1 of k just makes sure that you keep fits into the array. So where h1 of k, h1 of, sorry, it's gonna be an integer. It equals x mod n, where n equals table size. So it's very very common to take your key and map it to some integers whose value, whose magnitude you don't, you are not worried about. And then take that, and shrink it via mod so it fits your table. Alright, so here's an example. These are the children in my neighborhood and their halloween costumes.
Okay, when you say when you see HP, raise your if you first think of Happy Potter. Raise your hand if you first think of Hewlett-Packard. What a phenomenon, right? What did you think of? Yeah! Right? Weirdest thing. The rest of the world, again, is what makes us unique. The rest of the world is very clearly Harry Potter, but not us. Nuh-uh. Embrace you geek-dom. I don't know what it means to dress as a Hewlett-Packard for Halloween, but I bet you guys could figure it out. It's a little scary these days. I wasn't gonna make any jokes today! Darn it! Alright. So these are the keys I'll change this back these are the keys and these are the values. Oh, I have a fun thing! So this slide was made when my seven, or six years ago probably. When my eighteen-year-old was twelve, okay, and he was the cereal-killer." Okay? And that was the perfect twelve year old costume. His name is Isaac and I didn't want to, like, tell everybody's name. Oh wait. Darn it! No jokes today! I'm telling you! Okay. And this year our smallest child wanted to be the cereal killer so it was like this our smallest child who is now eight it was like this legacy that you have to be hot gluing mini-wheats to a t-shirt the night before Halloween. I dunno. So anyway, so this is our data. They keys are people's names. You can think of them, generally as strings if you want, but I think it would be kinda crazy to call somebody a, I dunno, ice cream." "Hey Ice Cream Cone, come over here!" So we're not talking about general strings here. Presumably, for names we might have some, uh, type which is a name type and the elements of that set would be prescribed by some, uh, look-up table or something. Okay, so even though these look like strings. They look like strings. In fact, they may not be implemented to be such. Okay? Just as a, that's an aside, doesn't really apply to this example but it's something to think about. Okay, so our goal is to take my data including the keys and values and map them in some reasonable way so that the costumes live inside this table. Okay? So what's a good hash function for this? What's a good-- how can we take this key and create some function on it that maps each one of these things to a small integer value? Yes? Yeah, right. Okay. For just a sec we were super lucky. Right? We were super lucky because the people in my neighborhood happen ti have first letters that all go in order and so our hash function, the thing that can take the key that looks like this and map it to that is simply, uhm, k[0] minus capital A works. So this will be interpreted as values and that difference will return some small integer. Okay? Any question about that? And then that means we're gonna get black cat here, and HP here and spy and basketball player Oh, when you saw bball, did you think basketball or baseball?
Okay. When you see HP. Raise your hand if you first think of harry potter.Raise your hand if you first thing of hewlett packard. What a phenomenon right? What did you think of? Yeah right? Weirdest thing. To the rest of the world it's harry potter, but not us. Embrace your geek-dom. I don't know what it means to dress as a hewlett packard for Halloween. But I bet you guys could figure it out. I wasn't going to make any jokes today, darn it. Alright so these are keys, and these are the values. So this slide was made when my 18 year old was 12 and he was the serial killer. That was the perfect 12 year old costume. His name is Issac. I had to change his name because I didn't want to tell everyone his name. Oh wait. Darn it, not jokes today. Okay and this year our smallest child wanted to be the serial killer. Its this legacy in our family, that you have to be hot gluing mini-wheats to a t-shirt at 2 o'clock in the morning the night before halloween. Alright. So this our data. The keys are peoples names. You can think of them generally as strings if you want. It would be crazy to call somebody ice cream cone. So were not talking about general strings here. Presumably for names we might have some type, which is a name type and the elements of that set would be prescribed by some lookup table. Even though these look like strings, they may in fact not be implemented to be such. Okay so our goal is to take my data including the keys and values and map them in some reasonable way so that the costumes live inside this table. So whats a good hash function for this? How can we take this key and create some function on it that maps each one of these things to a small integer value? For this just this set we were super lucky, right? Because, the people in my neighborhood happened to have first letters that all go in order. And so our hash function, the thing that can take the key that looks like this and map it to that, is simply k[0] 'A'. This will interpreted as values and that difference will return some small integer. Any questions about that? That means were going to get black cat here and HP here and spy and basketball player. When you saw bball, did you think basketball or baseball?
K, raise your hand basketball? Raise your hand baseball? K, weird huh? I don't know. like, ok. butterfly, oh, here's another one! butterly, best friend, or boyfriend, I don't know. Cereal killer, etc. Alright, so, these keys have a fabulous hash function. In two different ways: there was no ambiguity; we did not have both harry and harmony in our neighborhood, right? K, moreover, our table was used efficiently. Now, what I want to know from you is the mathematical term that describes those two phenomena. K, so each one, each key hashes to a different integer by our hash function, and the collection of keys that we use, they hash to a consecutive sequence of integers that we happen to be able to use as a table. So what's the name for such a function? It is a perfect hash function, but there's a mathematical name too. What is it? One to one gets you this one, but what gets you this one? Onto, that's right. So, this hash function is one-to-one and onto, aka, a bijection. When such a function exists, we say, Oh, I've got a perfect hash function." Perfect hash function is a bijection (keys to table, k elements). Any question about that? So we're not usually so lucky as that, umm I want to know about this hash function. I haven't done this in this room before, so I'm not sure how this is going to work. I have another hash function that I want you to see. Let's see if it's this easy. If it's not super easy we just won't do it, it doesn't matter that much. Document camera, please make sure the document camera is powered on (talking to computer). Ok, so what we're going to do, our key space is a roll of five dice, k? A roll of five dice, like a yatzee roll, I've got them in my hand right here. And, uhh, here's how my hash function works. Now your puzzle is to figure out what my hash function is and then together we'll figure out whether it's a good one or not, k? And, let's see, we're probably going to want a way of writing this down. So for this dice roll, my hash function gives eight. So you might want to write that down. It's one two two five five, maps to eight. And your puzzle right now is to figure out what my hash function is. This is actually a parlor game. This is a I learned this at a puzzle party. Oh this one is two two two three four, that dice roll by my has function is mapped to two. Yes? K. Ready? two two two three four maps to two. Oh, this one one four four six six maps to zero.
Raise your hand basketball, raise your hand baseball. Okay weird huh? I don't know. Okay butterfly best friend or boyfriend, I don't know. Serial Killer etc. Alright, so these keys have a fabulous hash function. In two different ways, there was no ambiguity, we did not have both harry and harmony in our neighborhood. Moreover, our table was used efficiently. Now I want to know the mathematical terms that describes the two phenomena. So each one, each key, hashes to a different integer, by our hash function and the collection of keys that we use they hash to a consecutive sequence of integers. That we happen to use as a table. So what's the name for such a function. It is a perfect hash function but there a mathematical name too. What is it? One to one gets your this one. And what gets you this one? Onto, thats right. So this hash function is one to one and onto aka a bijection. When such a function exists, we say oh we have a perfect hash function. A perfect hash function is a bijection. So we're not usually so lucky, as that. I wanna know about this hash function. I have another hash function that I want you to see. If it's not super easy we just won't do it, it's not that big of a deal. Document camera, please make sure the camera is powered on. So what we're gonna do is our key space is a roll of five dice, it's like a Yahtzee roll. I got them in my hand right here, and here's how my hash function works. Now your puzzle is to figure is to figure out what my hash function is and then together we'll figure whether it's a good one or not. And let's see. So we're probably gonna want a way of writing this down. So for this dice roll, my hash function give 8. Okay so you might wanna right that. You're puzzle right now is to figure out what my hash function is. This is actually parlor game. I learned this at a puzzle party, okay. So this one is, 2 ,2 ,2 3, 4, that dice roll by my hash function is mapped to 2. Ready? 2,2,2,3,4 maps to 2. This one 1, 4, 4, 6, 6, maps to 0.
Okay Raise your hand basketball Raise your hand baseball Okay wierd huh I dont know, like Okay. Butterfly, oh here's another one Butterfly best friend or boyfriend right I dont know Uhhhhh Cereal Killer etc. Alright, so these keys have a fabulous hash function. In two different ways. in two different ways. There was no ambiguity, we did not have both hairy and harmony in our neighborhood. Right? Kay, moreover, the.. our table was used efficiently- our table was used efficiently. now, what I want to know from you is the mathematical term that describes the two phenomena. Kay, so each one, each key hashes to a different integer, via our hash function and the collection of keys that we use they hash a to consecutive sequence of integers that we happen to be able to use as a table. So whats the name for such a function? Ya? [Student], it is a perfect hash function, but there's a mathematical name too. What is it? one to one gets you this one. And, what gets you this one? onto, thats right. So this hash function, is one to one and onto a k[a] bijection. when such a function exists, we say oh we got a perfect hash function. a perfect hash function is a bijection. Keys... two table... elements... any question about that? We're not usually so lucky, we're not usually so lucky as that.um, I wanna know about this hash function, I haven't done this in this room before, so I'm not sure how this is gonna work. I have another hash function. That I want you to see. See if its this easy, if it's not super easy we just wont do it, it doesnt matter that much. Please make sure Document camera is powered on. okay, what we're gonna do is our key, our key, our keyspace is a roll of five dice. Kay? A roll of five dice, got it? Like a yahtzee roll, I have them in my hand right here. And, uhhh, here's how my has function works. Now you're puzzle is to figure out what my hash function is, and then together we will figure out if it's a good one or not. And let's see. So, we're probably going to want a way of writing this down. SO... so for this roll, my hash function gives 8. So you might want to right that down. It's 1, 2, 2, 5, 5, maps to eight. and you're puzzle right now is to figure out what my hash function is. this is actually a parlor game. Like this a.. I learned this at a puzzle party- a party. Uh.. so this one is 2234, that dice roll, by my hash function is mapped to tow. Yes? Okay? Ready? [Dice Roll]. 22234 maps to two. Oh. This one 1, 4, 4, 6, 6, maps to 0.
Okay, ready? you go one more time, you think you have a pattern, k, would somebody like to guess what this one maps to? who's saying two? two is correct. maps to two. should I do it again? are you intrigued? any guess what this maps to? yeah? it does map to four. yep. hold on to your thoughts a little bit. k. raise your hand if you see how it maps to four, I'm just kinda curious where we are with this. k. brownie points for you! ohhhh, what does this one map to? [gibberish] is right. no, it doesn't matter where I put them, doesn't matter where I put them in the end. This roll is two ones, a three, and two fives, that's what that roll is, not in any particular order. okay ready, wanna play again? okay. I have a hint for you. This one is six. This one maps to six. any observations about the keys or about all the hashes? any observations? they're always even. is that good news or bad news? bad news! it means that we're not ever, if we're using this as a hash function we're never gonna map to the odd numbers. we're wasting our table already. I've one more hint for you about this: the game itself is called petals around the rose. okay so this is called petals around the rose. This one is six, i'm gonna do it again. Okay this is called petals around the rose and this one hashes to two. do you see it? I could do this all day so you're gonna have to stop me. This one's eight. Petals around the rose; I get eight. raise your hand if you think you have it at this point. okay, half, right? raise your hand if you've given up and you don't care anymore. The other half! okay, I think you know it's a party game, you kinda gotta know when to give it up, right? alright, who would like to explain it? anybody? you got it? STUDENT: if it's an odd number, you see how many digits you have around it. if it's an even, there's nothing in between, so petals around the rose. good, so all the odd ones have a center pip; they're called pips the marks on dice are called pips. Odd ones have a center one and the hash function is simply the number of petals (or pips) around any center. Any question about that? Alright, so let's go back and evaluate whether or not this is a good hash function. alright, so is it a good hash function? no. why not? It's not 1-to-1 (one to one). right, like there are lots of different rolls that produce four. for example, [draws on slide, two threes and three twos] this produces four. but so does [draws on slide, one five and four ones].
K, ready? We'll go one more time... Do you think you have a pattern? K, would somebody like to guess what this one maps to? Who's saying two? Two is correct-- maps to two. Should I do it again? Are you intrigued? Any guesses what this maps to? Yeah? It does map to four! Yup. Hold on to your thoughts a little bit. K, raise your hand if you think you see how it maps to four, I'm just kinda curious where we are with this... K... Brownie points for you! Ohhh... what does this one map to? Ten is right. No, it doesn't matter where I put them, doesn't matter where I put them in the end. This roll is two ones, a three and two fives, that's what that roll is, not in any particular order. K, ready? Wanna play again? K. I have a hint for you-- this one is six, it maps to six-- any observations about all the keys, er, about all the hashes? Any observations? They're always even, right, is that good news or bad news? Bad news, right? It means that we're not ever-- if we're using this as a hash function, we're never gonna map to... uh... the odd numbers, we're wasting half of our table already. Um, I have one more hint for you about this. The game itself is called Petals Around the Rose. K, so this is called Petals Around the Rose. Should I do it again? This one is six, I'm gonna do it again. K, this is called Petals Around the Rose, and this one hashes to... two is correct. K, you see it? K... I could do this all day, so, you know, you're gonna have to stop me. This one's eight. Petals Around the Rose, I get eight. K, raise your hand if you think you have it at this point. K, half, right? Raise your hand if you've given up and you don't care anymore. The other half! Okay, you know, it's a party game, right? So you gotta, you kinda gotta know when to give it up, right? Okay, who would like to explain it? You ready? You got it? If it's an odd number you see how many digits you have around it. Yeah! And if it's even there's nothing in between, so, Petals Around the Rose. Yeah. Good. So, all the odd ones have a center pip, they're called pips-- the marks on dice are called pips. Um, odd ones have a center one, and the hash function is simply the number of petals, or pips, around any center. Okay? Any questions about that? Alright, so let's go back, and evaluate whether or not this is a good hash function. Alright, so is it? Is it a good hash function? No. Why not? Okay. It's not one-to-one, for one thing. Right? Like there are lots of different rolls that produce four. For example, uhh, umm, and then the rest of them might be even right? Here-- this produces four, but so does this.
you can change this right. like i can make that even, there is lots of them. Alright, it is not one to one, and it's now on to. ok? meaning that the table is not used efficiently. so this is paddles around the rose you can go show this to your roomates alright you have any questions? you need five dice though. You life will not be complete this is a college lesson, you life will not be complete unless you have a store of dice. You need a box into which you are going to keep dice because you are going to need them for you dice. For your life, you need a laptop and a bunches of dice. i don't know what else, compete lost, I don't know. ok? is this a good hash function. Are there any questions about this? Alright, I have a question for you. How big do you think is this keyspace, paddles around the rose for rolling 5 dice. big big! keyspace is huge. if you are going to figure this out, combinitorily, the counting lesson you want to look up is the start and bars displacements, if you are going to figure this out. Displacement. for stars and bars. Let me actually start with that next time with that, because it is kinda fun and we already have these life, we are going to figure this out how big is the keyspace. Alright, any questions about all this. yes? em... sure......one one one one five is the same as one one one one five, where i switched the first two. that is the same. yeah. [gibberish] right right yeah. alright we are going to count it right now. if we are going to do this next time, alright we are gonna do it right em.....i can't do it now. alright I have room. okay. keyspace. ok. so here is how we are gonna do this. we are going to transform a dice roll, a roll of different dice into a different model, ok? into a different model that is communicated in a way that it is easy to count. So we are going to take a dice roll like one, idk, give me a dice roll, somebody give me a dice roll. someone tell me, what you want this dice to be. the next die on my roll. ok three. what is the next one? six ok. what's the next one. don't say 7. okay that is 1 since mod six right. whatever. And then the next one? that's six. Yeah yeah you could use.......
And you can change this, theres lots of em, k? Alright so its not one to one. Umm and its not onto, meaning that the table is not used efficiently. So this is petals around the rose. You can go show this to your roommate. Any questions about it? You need 5 dice though. Your life will not be complete unless you have a store of dice. You need a box into which you're gonna keep dice because you're gonna need them for your life. For your life You need a laptop and a bunch of dice. I don't know what else, some flip flops. Is it a good function? Any questions about this? Alright, I have a question for u. How big is the keyspace of rolling 5 dice? Its biggggg!! Keyspace is huugeee. If you are going to figure this out combinatorially the counting lesson you want to look up is I believe stars and bars if you're going to figure this out. Displacement or stars and bars, and I'm actually going to start next time with that because its fun. We're going to figure out how big is the keyspace. Any questions about this? Umm sure. 1 1 1 1 1 5 is the same as 1 1 1 1 1 5, where i switched the first 2 dice. I hate this day! Okay we're going to count it. We either do it now or next time. Alright I have room, okay, keyspace. Okay, so here's how we're going to do this. We're going to transform a roll of 5 dice into a different model that is umm is communicative in a way that is easy to count. We're going to take 3. What's the next one? 6, okay! What's the next one? Okay 1! And the next one? AHhahahaha thats six. Yeah yeah you could do that.
and you change this. I can make this even. There is lots of them. Ok, alright, so it's not one to one, and it's not onto, meaning the table is not using efficiently. So, this is petals around the rose. You can go show this to your roommate. Alright, any questions about it? You need five dice though. Your life will not be complete unless you have a store of dice. You need a box into which you are gonna keep dice because you are gonna need them for your life. For your life you need a laptop and a bunch of dice. I don't know what else. Alright, any questions about this? I have a question for you. How big is the key space in petals around the rose? How big is the key space of rolling five dice? It's big. Key space is huge. If you are going to figure this out, combinatoriay. The counting list you wanna look up is, I believe starts and bars or displacement. I am actually start next time with that just because it's fun. We are going to figure out how big is the keyspace. Alright, any questions about all this? 11115 is the same as 11115. Ok, we are going to count it right now. Alright, I have room. Ok, here is how we are gonna do this. We are going to transform a dice roll, a roll of five dice into a model, into a different model that is communicative in a way that is easy to count. So we are gonna take a dice roll like 1 3 6 1 6.
Alright so there's a dice roll, it's kind of random right? Here's how we're going to transform any dice roll. We're going to give yourselves bins for each number. We're going to give ourselves bins for each number, so here are all the ones, here are all the twos, here are all the threes, here are all the fours, fives, and sixes. K, and then we're going to take the five dice and put them into one of the bins. So in this example, we're going to have two dice in the ones, uh, one die in the threes, and two dice in the sixes. OK? now, I assert that if I give you an encoding like this, you can tell me what the dice roll is, and if I give you any dice roll, you can give me the encoding for it, Yes? and so counting the number of encodings is the same as counting the number of dice rolls, Yes? just nod your head if you buy that. Alright, now how do we count the encodings? well how many different things are there to lay out in an encoding like this? There are... five dice and five divisions between dice, right? So there are ten positions in the encoding, half of them are going to be divisions between, and half of them are going to be dice. So how many different ways are there of creating such an arrangement? Ten choose five, very good. So it's ten choose five, k, is the size of the key space. Any question about that? I needed to do it quickly. So for example, I'm going to lay down a random one of these that contains five divisions and five dice. You want this one to be a division or a die? Yah ok, division. Die die division division division die division die. That corresponds to zero ones, two twos, zero threes, zero fours, one five, and two sixes. That make sense? See that? K. You're not going to be tested on this, this is for fun. So how big is this number, ten choose five? Ten times nine times eight times seven times six, you know, divided by a little bit but not by a lot, so about ten to the third, thank you. It's around a thousand, I'm guessing. Ok, ten choose five is only two hundred fifty two? Ok fine. Alright, so what we just figured out is that there are two hundred fifty two different dice rolls we can have, how many different mappings are there? How many different targets are there that they map to? Ten, right? you can have ten different values, so actually I have a slide for this, in this case, your key space is huge. Your key space is large relative to your table size. Alright, relative to, or the range of your hash table. So there must be collisions, there must be a lack of one-to-onedness. Alright, so let's talk about this, let's go backwards now. So what's a hash table? Let's go way back, let's forget pedals around the rows, this was all meant to give you a domain in which to think, but now let's go way back to the definition of a hash table. We need to create a hash table. Here's what we're going to need. We're going to need an array; that's kind of obvious. That's the table where in an implementation level, we're actually going to be storing our data. We need some hash function. You've seen a perfect one, a super-good one, and you've seen a bad one, and what we know right now is that this idea of a bijection is a good one, k? Mathematicians still to this day spend time thinking about good hash functions. Creating a good hash function is not a solved problem. So we're going to be using hash functions that other people create, largely. And then finally, we're going to need what we're going to call a collision a collision resolution strategy, and this is simply a true confession that most hash functions will not be one-to-one. so what do you do if two things do map to the same cell? Hash functions are not generally one-to-one.
Alright. There is a dice roll, kind of random, right. Here is how we gonna transform any dice roll. We are going to give ourselves bins for each number. Hey we are going to give ourselves bins for each number so here are all the ones, here are all the twos, here are all the threes, here are all the fourths, fives, and sixes. Okay. And then we are going to take the five dices and put them into one of the bins. So in this example, we are going to have two dices in the ones, hmm, one dice in the threes, and two dices in the sixes. Okay, now I assert that if I give you an encoding like this and you can tell me what the dice roll is. And if I give a dice roll, you can give me the encoding for it, yes. So counting the number of encoding is the same as the counting of dice rolls. Yes? Just nod your head if you buy that, okay? Alright, now how do we count the encodings? How many different things are there to lay out an encoding like this? There are five dices and one two three four five division between dices. So there are ten positions in the encodings, one two three four five six seven eight nine ten. Half of them are going to be divisions between, and half of them are going to be dice. So how many different ways are there of creating such an arrangement? Ten choose five. Very good. So it's ten choose five, is the number of the size of the key space. Any questions about that? I need to do it quickly. Hmm, so for example, I am gonna lay down a random one of these that contains five divisions and five dies. You want this one to be a division or a die. Yeah, okay, division, die, die, division, division, division, die, division, die, and this one has to be a die. That corresponds to 0 ones, 2 twos, 0 threes, 0 fours, 1 five, and 2 sixes. Does it make sense? See that? Okay, you are not gonna be tested on this. This is for fun. So how big the number, ten choose five? Ten times nine times eight times eleven times six divided by a little bit but not by a lot. So about, ten to the third, thank you, its around a thousand, I am guessing. Okay, 252, ten choose five is 252. Okay, fine. Alright, what we just figured out is there are 252 different dice rolls you can have. How many different mappings are there? How many different targets are there, keys, that they map to? Ten! Right? You can have ten different values. So. Actually, it's a slide for this. In this Ks, your key space is huge, your key space is large, relative to your table size. Relative to all the arrange of your keys, of your hash table, so there must be a lack of one to one there. So let's talk about this, let's go backwards for now. So what's the hash table? Let's go way back. Forgive tails around the rolls. This is all meant to give you some like a domain to which think. But now let's go way back, to the definition of a hash table, we need to create a hash table. Here is what we gonna need. We're gonna need an array, okay, it's kind of obvious, that's the tables where the implementation level where actually going to store our data. We need some hash functions. You've seen a perfect one, a super good one and you've seen a bad one. And we all know right now is that this idea of bijection is a good one. Okay? Mathematicians still to these days spend time thinking about good hash function. Creating a good hash function is not a solved problem. So we are going to be using hash function that other people create largely. And then finally, we are going to need, what we gonna call a collision resolution strategy. And this is simply a true confession that most hash functions will not be one to one. What you do is if two things do map the same cell. Hash functions are not generally one to one.
We need to be able to deal that. Okay, so. Uh. So lets me explain that last one a little bit. um, if you're keyspace is about the size of your table, then you can take elements from your keyspace and just give them a value in your table. Sometimes when I do this, like if I'm programming in python, and I know I'm gonna wanna-- I'm going to want to put data into this... an array. I'll append an index value, or some kind of identifier, on the front of my data. Just because i know I can; the table will be big enough, I'm kind of finding a hacky way of identifying a key with a particular location in the table. This is a perfectly reasonable thing to do if you're keyspace is about the same size as your table. That is if all your data, all the data that you could possibly have will fit in your table. But here's what hashing generally means. Here's what hashing generally looks like. Usually we will have a huge keyspace.Kay? Some huge mathematical description what keys could be. And we're gonna draw some sample from that keyspace. We 're gonna draw some reasonably sized sample from the keyspace. Kay? And what our hash function has to do is take this data and map it to some cell locations. Kay? In the table. And the table has to be big enough to hold this subset. But here's the thing. A general hash table, should work independent of what subset is drawn from the keyspace. So maybe the case, that instead of that circle, we draw a sample from our keyspace that looks like this. And the hash function needs to map those nicely into our table. Lets put them somewhere else. Now what we want to avoid is... what we hope to avoid is some sample from our keyspace, some sample from our keyspace, where all of the keys map to the same location. Because that would be bad. Right? That would be not using our table effectively, and we wouldn't know where our keys were really. Cuz they would be all in the same place. Any question about that? this is again more general how to think about hashing. This is a much harder problem. Okay, finding a general purpose hash function. It's where we're gonna start next time.
we need to be able to deal with that. okay. so uhh let me explain that last one a little bit. if your key space is about the size of your table then you can take elements from your key space and just give them a value in your table sometimes sometimes when I do this like when I'm programming in python and I know you know that I'm gonna wanna im going to want to put data into this into an array I'll append an index value or some kind of identifier on the front of my data just because I know I can the table will be big enough i'm kind of finding a uhh a hacky way of identifying a key with a particular location in the table. This is a perfectly reasonable thing to do if your key space is about the same size as your table. That is if all of your data if all the data you can possibly have will fit in your table. But here's what hashing generally means. Here's what hashing generally looks like. Usually we will have a huge key space some huge mathematical description of what keys could be and we're gonna draw some sample from that key space we're gonna draw some reasonably sized sample from the key space okay. and what our hash function has to do is take this data and map it to you know some cell locations in the table and the table has to be big enough to hold this subset but here's the thing. A general hash table should work independent of what subset is drawn from the key space so it may be the case that instead of that circle we draw a sample from our our uhh key space that looks like this and the has function needs to map those nicely into our table we'll put them somewhere else. okay. now what we want to avoid is what we hoped to avoid is some sample from our key space. some sample from our key space where all of the keys map to the same location that would be bad right that would be not using our table effectively and we wouldn't know where our keys were really cause they'd all be in the same place. alright any question about that? so again this is more of a general how do I think about hashing. This is a much harder problem okay finding a general purpose hash function and it's where we're gonna start next time.
Okay, Im going to start talking, because it is officially time to start while this gets going. I cant change it yet, it might be because the system is still initializing. Okay, I will yell for, woahhh, turn it off. Okay, we are for the first time scanning all of your exams and grading them online, so we dont know how exactly that process is going to go, we are working on it. Our intention is to get them to you by next week, so more in a practical time, now, if i were you my question would be, lets find for exam 2 when will exam 1 be finalized? Yeah, it shouldnt be funny right, thats so sad. There are still, we think the regrades are done, but we havent uploaded the scores to chara yet, so its a race, midterm 1 and midterm 2 are in a race to see who will actually be completely finished before next wednesday. Alright, I wanted to give you further clarification, so that was a non answer by me on midterm 1, Sorry. I wanted to give you a more complete explanation about how we are going to handle the b tree lab, because I told you last time that it will have a point of extra credit in it. We are going to score you as usual, so it will be out of 1 whole point and third of which is attendance and then we are going to double that score, so if you didnt go then the number of points you can get potentially is a little bit lower, but if you go to the lab then it is extra in the absolute sense, though the same relatively. Okay so any other administrative questions you would like me to address in this public forum? I can address the fact that it is friday. Yay!! Is that administrative? So the final is posted publicly. I haven't gone to look, but i got the little announcement saying that the final exam schedule is up for the combined exam, so you should be able to go to the registrar page and we will at some point also post it and make it loud, but I think the information is available to you. Actually, does anybody know the answer to that? When is the final? This is, I am giving you this with 80%, you know you should back it up, but, go ahead, Monday 7pm, the 14th. Did you want to say something? You were going to replicate that, was he right?
Okay, I'm gonna start talking because it is officially time to start, while this gets going, um... I can't change it yet. It might because the system is still initializing. Okay, I will yell- woah... turn it off- Okay we are- now you can whisper and you can still hear me. We're for the first time scanning all of your exams, um and grading them online. So we don't know exactly how that process is gonna go. Um, we're working on it. So, our intention is to get them to you, um, by next week, so more in a practical time. Now, if I were you, if I were you, my question would be: well that's fine for exam two, when will exam one be finalized? Yeah, it shouldn't be funny right? That's so sad, um... There are still, we think three grades are done, but we haven't uploaded the scores to chara yet, so it's a race. Midterm one and midterm two are in a race to see who will actually be completely finished before next Wednesday, so... I'm hoping, I'm hoping... Alright, I wanted to give you further clarification, so that was a non-answer by me on midterm one. Sorry. I wanted to give you a more complete explanation about how we're gonna handle the b-tree lab, because, uh, the, I told you last time that it will have a point of extra credit in it, um, and the way we're gonna do that, we're just gonna score you like usual. So, it will be out of one whole point, a third of which is attendance, and then we're gonna double that score. So, if you didn't go, the number of points you can get potentially is a little bit lower, but if you go to lab, then it's worth kind of extra in an absolute sense, though the same relatively. Okay, any other administrative questions you would me to address in this public forum? I can address the fact that it's Friday, yay. Is that administrative? Yeah? So the final is posted publicly, I haven't gone to look but I got the little announcement saying the final exam schedule is up for combined exams. So you should be able to go to the registrar's page and we will at some point also post it and make it loud, but I think the information is available to you. Actually does anybody know the answer to that? Alright, when is the final? This is, I'm giving you this with oh... 80%, you know, you should back it up, but, go ahead. Monday, 7 pm. The 14th, he thinks. Arman did you want to say something, you were going to replicate that, was he right?
We can talk about that later. So, the question is about the conflict exam and my understanding is that there are university rules for qualifying for the conflict exam and of course we are going to follow the university rules. So you probably either have a conflict or you don't, so I dont know where the fuzziness is. Oh, I, you know, our exams at this point are so consistent distribution wise. They're consistent over semesters even. In fact, I'm kind of anxious to see, so this semester is the first time in a very long time where i'm not writing the exams. So i'm really interested to see at the end of the semester whether the grade distributions over individual exams when we look at the whole semester if they deviate. I think they won't very much. You know, the first exam, from my perspective, had a pretty perfect distribution. So, you shouldn't expect wild differences in averages. Okay, should we work? Yes, let's get it over with, right? Okay, I'm going to ask you on Monday what you did this weekend that gave you joy, okay? So, I'm just going to ask you so I just want you to think about that for this weekend a little bit. Alright, so we were talking about hashing and I wanted to kind of clarify the perspective on hashing. I wanted to paint a picture for you. We were using these structures called hash tables to implement a dictionary, okay? Now, when we implement a dictionary it means we are providing to the client, that's this code, the users of the dictionary, particular functions. Now in a dictionary all those functions are key value centric, like they depend on having a unique key and they are a way of accessing values or data associated with that key. Okay, that should all have been review, you should practically be falling asleep in that particular discussion. Now, what needs to be clarified I believe is that a common interface to a dictionary is via an associative array kind of like this. Where we treat the key type as the type of thing that can be an index. Okay? Is that clear? Make sense? Alright so that's very very common so that an associative array is a particular interface to a dictionary. Now, all the stuff that we talked about last time is concerned primarily with the implementation of this ADT and its interface. And that implementation itself is referred to as a hash table. So this is the picture that we have. Here is the client code and here is what they know, they can do dictionary type things here. But here is what is what's going on behind the scenes. Behind the scenes we have a class Dict that receives via the functions, it receives a key and a value. Hold on, let me get there. It receives a key and a value. So input into the function, the member functions of this class, are k and v. Okay? So here is what happens, k is sent off to this hash function where a small integer is created and that integer is used to denote a place in the array that into which you're going to store the value. Okay? Yeah okay fine. Better? Yeah. Alright any question about that? Now the problem that we began to talk about last time, what happens if your hash function is not a perfect hash function, that is especially if it is not one-to-one, so we might ask a question, what if H(k) is not one-to-one? We are going to handle that and talk about that later today, this is foreshadowing. By coming up with a collision resolution strategy, that is what do we do when the lack of one-to-one-edness in our hash function appears, or is manifest by the particular set of data that we get. That is the stuff today, what do we do?
We can talk about that later. the question is about the conflict exam and my understanding is that there are university rules for qualifying for the conflict exam and of course we're going to follow those university rules, so you probably either have a conflict or you don't so i don't know where the fuzziness is. our exams at this point are so consistent distribution wise, they're consistent over semesters even. in fact, i'm kind of anxious to see. this semester is the first time in a very long time where i'm not writing the exams, so i'm really interested to see at the end of the semester whether the grade distribution over individual exams when we look at the whole semester if they deviate, i think they won't very much, you know, the first exam from my perspective had a pretty perfect distribution, so you shouldn't expect wild differences in averages. okay shall we work? yes, let's get it over with, right. okay, i'm going to ask you on monday what you did this weekend that gave you joy. so i'm just gonna ask you, and i want you to think about that for this weekend a little bit. alright, so we were talking about hashing, and i wanted to kind of clarify the perspective on hashing, i wanted to kind of paint a picture for you. We were using these structures called hash tables to implement a dictionary. now when we implement a dictionary, it means we're providing to the client that's this code, the users of the dictionary particular functions. now in a dictionary, all those functions are key value centric; they depend on having a unique key, and they are a way of accessing values or data associated with that key; that should all have been review, you should be like practically falling asleep in that particular discussion. now, what needs to be clarified, i believe, is that a common interface to a dictionary is via an associative array, kind of like this, where we treat the key type as the type of thing that can be an index. okay? is that clear? makes sense. alright, and that's very very common. so that associative array is a particular interface to a dictionary. now all the stuff we talked about last time is concerned primarily with the implementation of this ADT and its interface, and that implementation itself is referred to as a hash table. so this is the picture that we have. Here's the client code, here's what they know, they can do dictionary-type things here; but here's what's going on behind the scenes. Behind the scenes, we have a class Dict that receives via the functions; it receives a key and a value. It receives a key and a value, so input into the member functions of this class are K and V. So here's what happens. K is sent off to this hash function where a small integer is created and that integer is used to denote a place in the array, into which you're going to store the value. Now the problem that we began to talk about last time was what happens if your hash function is not a perfect hash function? That is, especially if it does not, if it is not one-to-one. So we might ask a question, what if h(k) is not 1-1?" we're going to handle that and talk about that later today this is foreshadowing by coming up with a collision-resolution strategy. that is, what do we do when the lack of 1-1'edness in our hash function appears, or is manifest by the particular set of data that we get? and that's the stuff today.
If two keys map to same small index, and by map to I mean via the hash function. Ok, any question about all of that? Alright. So the first part of our focus is gonna center on the hash function itself, the second part will talk about collision resolution strategies on Friday. Alright, any questions about all theres? Alright, so hash functions, this is the story on hash functions as I know it. It's going to necessarily be an incomplete story because guess what? There are people working on all kinds of different large entities spending their entire lives working on good hash functions. So in this hour, we are not going to touch on all of the complexities involved with creating good hash functions. So it's people who are interested in topographys are doing hash functions, mathematicians, people who deal with big data want really good hash functions with great characteristics. So this is just a glimpse to their world, there's a whole career there waiting for you centered on this material if you would like. I 'm intrigued by especially big data aspects of it. Alright, let's see. What is a hash function look like? Typically, consists of two parts: a hash which takes the key and finds some integer return some integer together with something that shrinks that integer down into a space small enough that we can store it. So a compression which is a function mapping that larger integer into the array, so zero to n-1, and this is almost always and it it will always be for our class just the mod function. This is mod N where N is the table size. Any question about that? OK, so turns out that choosing hash function is tricky, it's hard to choose good ones. and I will talk a little bit about it on the next slide. There's again a whole lecture of what our some classic bad hash functions that have been created over time and as the next greatest things for hash functions and then found to contain periodicity that actually results in very bad behavior, we will talk a little bit about that in a minute. So we don't want you to create your own. The yet is not really well stated. It should really be unless Where the unless is that you understand your key pace and it is small enough that you can create a bijection. unless you can create a bijection in which case you should make your own hash function. unless you know your data, well enough, to create a bijection. and notice that really means also that your data has to be small enough that you could create this bijection. Alright, so what characterizes a good hash function? So these are the characteristics of a good hash function. Computing how much time we are gonna give the function to run on the key? Constant time, that's right, very good. It must be computed in constant time. It must be deterministic. What's the opposite of deterministic? Probablistic", or another word for that is random, tight? So the opposite of deterministic in this case is random. Now think about what this means. What this means here is if i==j, then it must be the case h(i)==h(j). there is no dice roll that says what the hash of the index should be. We plug in 4, we are gonna get the same value out every time. We'll talk about what would happen if that was broken in just a minute. good hash functions also satisfy the SUHA. I like saying it, and so I will say it again and I will tell you what it means SUHA. simple uniform hashing assumption.
Um, if you're data is in a linked, if your data all maps to the same array cell, um, you have several different ways of handling it, which we'll talk about, all of which imply you have to search for your data within that cell. Okay? And so, you might as well just to put 'em in a big bucket or a list, or whatever. Okay? Yes, right, that's right. Okay, so I want to rehash things again. Is the moment for the hash brown joke? I don't know, it's not right now. Okay, alright. Um, so I wanna revisit a couple things just to convince you that hashing is hard. So this time I drew the same picture but with the key space small in the first example. So, I wanna reinforce the idea that if you happen to know exactly what you're data is going to be, then by all means figure out a way of mapping your data into an array via a bijection. Okay? That's on you. That's on you. You can do that, nobody's telling you, oh don't try to do that on your own. If your data is small enough, it's usually kind of a clever, you know, clever little puzzle to figure out ways of putting your data efficiently into a table. It's, um, it's figuring out identifiers for your keys that allow you to represent those keys using indices from an array. Alright, now why? nuuuuuung Okay. Uh, using indices as the representatives here. So, the punchline is if your key space is small, by all means, make your own bijection. Have fun, it's fun. Okay, on the other hand, if your key space is large or very general, that is you don't really even necessarily know what the key space looks like, which is the case for a lot of general purpose hash functions provided for you by a system, like C++'s hash map, then the puzzle becomes harder. Because, every set of data that you choose from that hash function, it might not be a very big set of data, certainly it should fit in your table, right? Certainly should have memory to contain all of your data, but you cannot control what subset you get. So it might be the case that one subset will spread the data out nicely over the table, but, and maybe that will be the case for couple different subsets that happen to constitute your data for an application, but what you cannot guarantee based on arguments related to the pigeonhole principle is that no hash function can do well on all subsets. There are just too many of them, too many possible subsets, especially of a large key space. You cannot guarantee good behavior from a, over all subsets... from a general purpose
Hash function. So that why it's an interesting problem even now. Ok. yeah. so the entire key space. So the question is what the difference between the entire key space and the sample key space. let's take phone models. cause nobody has a camera anymore. let's take phone model. so most phone model are expressed some numbers and some letters associate with them and some title so that's a key and you can have hundred of those. If I were making an application about phone. I might only draw samples of five of them from that entire keyspace so the key space is what generally describes the possible set of keys and the sample that you choose is the data that happen to appear at your door step asking to be stored. your hash function still has to work on different data. ok I want to show you how easy it is to have bad hash function. what book is this from? This is from huck-finn. It's actually might be from tom sawyer I don't know for sure. I don't remember what this is from. so here this is what I want to start with this. It turns out that it's easy to hash string if they only have 8 characters. You can come up with a bijecture of string to a reasonable size table. I don't want to hash 8 character string. What I want to do is to take a 40-character string and hash it and store the page number. so that I can type a bit of text of tom sawyer and my application would go and said that on page bla. so this is what I came up with. Hashing scheme for long strings. So what we want is a hashing scheme or hash function for longer string. Here this what we are gonna do. We are going to take 40-character string and select 8 positions from it and use that as the 8-character string and use the good hash function of 8-character to take care of it. Let's choose 8 positions and I'm going to this kind of quickly and not carefully. that one and that one and that one and that one 5 6 7 8. ok? Forgive the wavy line there.
Hash function So that's why its an interesting problem even now. So the entire key space so the question is whats the differences between the key space and a sample from the key space. Lets take an application, lets take camera model or phone models. Lets take phone models, okay. So most phone models are expressed as numbers and some letters associated with them and then maybe a title. That is a key and you can have a whole bunch of different one of those probably hundreds, right. But if I were keeping, if I were making an application about phones I might only draw a sample of five of them from that entire key space. Does that make sense? So the key space is what generally describes the possible set of keys and the sample that you happen to choose is the data that you have happen to appear at your door step asking to be stored. Right, and you would get different data next time but your hash function still has to work on it if your application should handle phones, for example. Okay any other questions about this? So I'm glad you asked that. Okay, I want to show you how easy it is to have bad hash functions. What book is this from? Yes, this is from Huck Finn. I once had a student, well ill tell you that anecdote in a minute. So it actually might be from Tom sawyer. So here's where I want to start with this, so it turns out it is easy to hash strings if the have only 8 characters that you can come up with a very nice bijection of 8 character strings to a reasonable sized table and I will leave that to you to go research if you want hashing 8 character strings you'll find a lot of stuff. Now I don't want to hash 8 character strings what I want to be able to do is to take a 40 character string and hash it and store the page number so that I can type a little bit of text from Tom Sawyer, Huckleberry Finn or what ever book this is and my application would go and that's on page blah" and that's my goal, 40 characters instead of 8. Any questions about that? So here's what I came up with for hashing strings or hashing scheme for long strings. So what we want is a hashing scheme for a hash function for longer strings. Here's what we are going to do, we're gonna take our 40 character string and select 8 positions from it and use that as our 8 character string and let the good hash function that we know exists for 8 character strings take care of that. Sounds kinda reasonable, right? So lets choose 8 positions and I'm going to do this kinda quickly and not very carefully. I'm choosing 8 random positions that one and that one and that one and that one [Counts] Forgive the wavy lines there
Cmon, I want you back, Michael Jackson, okay. Alright, and now I'm gonna look and see what characters exist in each of those positions for each of the strings so the first string then is sort of transformed into this character, this character, this character, etc. and it looks like [Leu, hi] and you know lets take this one this one is [Nmh'lser]. And now these are the things that we are going to send through our good hash function. Okay, question about that? And our overall hash function then for long strings, our long string hash function is the composition of these two. Take these eight positions and then apply that... apply the good hash function to that. Any questions about that? Alright, and for this kind of data, for data these long strings that we happen to have drawn from a novel works perfectly fine, right? These look pretty random over strings. There's no reason to believe that these wouldn't be spread out by this good string hash function. [student question, can't hear it]. So it depends on the hash function. So the question is how do you do a general SUHA check in your mind when you're looking at this. What's the intuition behind a SUHA? And I think the way I would approach that problem is to say, Hmm, can I come up with an example for which SUHA would fail? Can I come up with a subset of data from my keyspace that my hash function would do badly on? And that's exactly what we're going to do here. Any question about this? So here's what my hash function does. It takes forty character strings and it hashes it, spreads them out uniformly over a table so I can get them back forty character strings. Well my friend came to me and said, I've got some forty character strings that I would like to hash. Do you have a good hash function? I said, "Sure. I've got a forty character hash function, forty character string hash function. Would you like to use it? And my friend used that hash function on her data. Well let's look at how that hash function works. The first thing you do is you designate eight random spots. One, two, three, four, five, six, seven, eight. Kinda random, right? And then you hash those using this good eight (8) character string hash function. So what do these things look like? You already see the punchline here, right? They look like [h/eiagkC]. This one down here looks like [h/eiagkC]. Look we've got a collision there even. This one looks like [h/eiagka]. So, there was an there is an, in this case, an obvious subset of data of the set of forty character strings that create bad behavior by the hash function. Make sure that you see that this is bad behavior by the hash function. How many different results, how many different cells will our hash function map into? How many different small indicies will our hash function produce approximately? Fifty-ish, hundred-ish maybe depending on how many special characters you have, right? Not very many. Not very many even if you just look at the pages of wikipedia. Mapping all of the wikipedia URLs into eight different spots. I'm sorry, a hundred different spots. Bad. Bad. Bad. Bad. Okay, so good general purpose hash functions are hard to create. Any questions about this? Alright
So it turns out you can not avoid collision. You just can't. They are going to happen and the question is how do you handle them. The results you see here are classic approaches to handling collisions. You will have better ideas, but everybody in your world expect you to know these ideas. Ok, everybody in your world is gonna expect you to know these and in fact all of you better ideas are going to be modificative. Almost all of your better ideas are like to be modifications in some sense of these. So the first one we are gonna talk about is separate chaining. And thats the vocabulary associated with it. There's additional vocabulary. It is know as an open hashing strategy. Now the reason for that is we are not going to put all of our data in table. Ok. Instead we are going to use the table to gain access to the collection of our data. Alright. So here's what this looks like. So here's our particular set. Here's our set of data. We are gonna say in general that the set of data is size n. The size of the data is n. And our hash function is easy in this case. It's just k mod table size. It's the key mod table size. Now if you want to, you can imagine that our key spaces is actually more interesting. And we apply some other hash function to get down to this integers. And now all we are doing is making it fit in the table. Ok. If you want to think of it that way. Ok. So here's what we do. We take a key. We take it mod seven. And that's where we put the data. But we don't put the data in the table. Instead we put it in this various structure associated with the table. In this case, we are gonna use a linked list. So what is sixteen mod seven. Two. Alright. So sixteen goes here. And we are going to put it in the linked list. Tendered at cell two. Ok. Eight. How about eight? Where does eight go? Into the linked list. This is associated with cell one. Good. How about four? Ok. How about thirteen. I can do these easy. Any question about it? Ok. Twenty nine goes where? Where does twenty nine go? One. Good. Should I put it in the end or the front of the list? I wanna do this fast. So where should I put it? Front of list. Right. There's no reason not to put this thing at the front of the list. So forgive me for drawing it like this. Doing little bit of a. Doing a classroom hack here. Ok. How about eleven? Where does eleven go? Even I can take eleven mod seven. And twenty two. Oh brother. Alright any question about this? Make sense? Singly linked list. Alright. Do you like this? Why. What's bad about this? Feels like a doesn't it? I can handle your collision like collied. What could go wrong here? What could go wrong?
Yeah, alright. So, uh, it turns out you cannot avoid collisions, you just can't. They are going to happen and the question is how do you handle them. The results you see here are classic approaches to handling collisions, you will have better ideas but everybody in your world expects you to know these ideas. Okay, everybody in your world is going to expect you to know these. And, in fact, all your better ideas are going to be, almost all your ideas are likely to be modifications in some sense of these. So the first one that we are going to talk about is separate chaining. So that's the vocabulary associated with it. There's additional vocabulary, it is known as an open hashing strategy. Now the reason for that is that we are not going to put all of our data in the table. Okay? Instead we are going to use the table to gain access to the collection of our data. Alright, so here's what this looks like. Here's our particular set. Here's our set of data. we are going to say in general that the set of data is size n, the size the set of data is in and our hash function is easy in this case, its just k table size. It's the key table size. Now if you want to you can imagine that our key space is actually more interesting and we've applied some other hash function to get down to these integers and now all we are doing is making it fit in the table. If you want, if you want to think of it that way. Okay, here's what we do, we take a key, we take it mod seven and that's where we put the data. But we don't put the data in the table. Instead we put it in this auxiliary structure associated with the table and in this case we will use a linked list. So, what is sixteen mod seven? Two. Okay so sixteen goes here and we are going to put in a linked list. Tethered at cell two. How about eight? where does eight go? Into the linked list associated with cell one, good. How about four? Okay, how about thirteen? I can do these easy, okay. Any question about it? You good? okay 29 goes where? Where does 29 go? One, good. Should I put it at the end or the front of the list? I want to do this fast, so where should I put it? the front of the list, right. There is no reason to not put that thing at the front of the list so forgive me for drawing it like this, I'm doing a little bit of uh, oops, I'm doing a classroom hack here. Okay, how about eleven? Where does eleven go? You and I can take eleven mod seven. Okay, and 22? Oh brother. Alright, any question about this? Make sense? Stick them in a linked list. Alright... do you like this? Why? what's bad about it? It feels like a cop out, doesn't it? [gibberish] handle your collisions i'll let you collide. What could go wrong here? what could go wrong? yeah?
Uh, alright. So it turns out you cannot avoid collisions. You just can't. They are going to happen and the question is how do you handle them? The results you see here are classic approaches to handle collisions. You will have better ideas but everybody in your world expect you to know these and in fact all of your better ideas are going to be modificate and almost all of your better ideas are gonna to be modifications of some sense of these. So, the first one thatwe are going to talked about is theseparate Chaining" And that's the vocabulary associated with it. Um, there's additional vocabulary, it is as known as the Open hashing" Strategy. Now the reason for that it, we are not going to put all of our data in a table. Instead, we are gonna use the table to gain access to the collection of our data. Alright, so here's what looks like. So here's a particular set, here's our set of data, um we are gonna say in general, the size of our data is N, and our hash function is easy in this case. It's just k mod the table size. Its the key mod table size. If you could actually imagine that our keyspace is more interesting, and we apply other hash functions to get down these integers and now what we are doing is just making it fitting in the table if you want. If you want to think it that way. Ok, so here's what we do. We take a key, we take a mod 7 and that's where we put the data, but we don't put the data in the table. Instead we put in the obserialy structure associated with the table and in this case we are gonna use a linked list. So, what is 16 mod 7, 2! so alright, 16 goes to here and we are going to put a linked list beside uh titled at tail 2. How about 8, where did 8 go? Into the linked list associated with cell one, how about 4? ok, how about 13, I can do it easy easy! Any questions? good? So 29 goes where? where is 29 go? 1, good. Should I put it at the end or front of the list? I want to do it fast. So where should I put it? From of the list! Right, so there's no reason not to put that thing in the from of the list. So forgive me drawing it like this. I am doing a classroom hack here. OK, how about 11, where does 11 go? Even I can take 11 mod 7, and 22 ohhh brother. Alright, any questions about this? Make sense? Just a series of linked list. You like this? Why? What's bad about it? Feels like cope bat? Does it?Cock it, handle your collisions and I will let you collide, what could go wrong here? Yeah?
Good, very good. So the observation is that if you have a whole bunch of things in the same bucket. If you have a whole bunch of things in the same bucket and you go to get your data out, you have to essentially search that whole thing to get your data. OK you have to search your whole thing to get your data. So the cost here could be a lot. In the worst, we're going to record that observation in the worst case. So insert is always constant time cause we're just gonna plunk it in the front, but in the worst case we might have to travel all the way down the list and if it's true that everything maps to one cell you might have to search it all. Any response to that? Any idea about it? Yeah, it OK. Your agree with it? OK. So that's worst case but how about under SUHA. What does SUHA say is gonna happen here? How many do you expect if these things are uniformly distributed over the table si... over the table. How many do you expect in each chain? Yeah. At most two in the chain in this example but in general if I tell you the table size is n, big N and you sample size is little n. How many do you expect, and that's a probabilistic average, on average how many do you expect in each cell? Right, good so this is in this case little n over big n, and the insert is still constant time. What do you think about this? What do you think about this? This is foreshadowing, this is important foreshadowing. Are these two the same? They're not? Raise your hand if you think these two are asymptotically the same. Raise your hand there's you know this is discussion not competition OK. Um and raise you're hand if you don't think they're the same. The answer is it depends. Here's what I wante... Here's what I want to uh... Here's what I'm gonna use to answer this question OK. We control the table size. You and me we're the boss, we're the boss of that hash. How big that hash table is alright? So we can always make it big enough so that this value is whatever we want it to be yes? Yeah. So these two in this context are not the same because big N is not a constant. We control it and we're gonna change it. I think you might be able, this is foreshadowing. We might be able to image when we might change it. Alright any question about this? Any question about it? OK. Alright so separate chaining, you just plunk them all in and SUHA save you is the short story. Alright here is another one. Uh this is an algorithm that uh general is uh very big simplification of a class of uh hashing strategies. It's sort of the introductory one. It's closed hashing which means all your data will be in the table and here's how it works. Uh, if there's not a collision you just map the key to its position. So sixteen maps to two, eight maps to one, four maps to four, thirteen maps to six. And now life gets interesting, we're gonna hash twenty-nine to one. and it's full there's already something there so we increase our additive, our probe number. This is a probe number, and look at the next spot. Oh look, spot two is full too, but when you increase it again to three there's room and so we can put twenty-nine right there. OK any question about it? So where does eleven go? Into five, good. And how about twenty two? What's twenty-two's life like?
Good very good, so the observation is that if you have a whole bunch of things in the same bucket, if you have a whole bunch of things in the same bucket and you go to get your data out, you have to essentially search that whole thing to get your data. You have to search your whole thing to get your data, so the cost here could be a lot. We're going to record that observation in the worst case, so insert is always constant time because we're just going to plunk it in the front. But in the worst case we might have to travel all the way down the list and if it's true that everything mapped to one cell, you might have to search it all. Any response to that? Any idea about it? You agree with it? OK so that's worst case, but how about under SUHA? What is SUHA say is going to happen here? How many do you expect if these things are uniformly distributed over the table, how many do you expect in each chain? At least two in the chain in this example, but in general if I tell you the table size is N, big N, and the sample size is little n how many do you expect and that's an average. On average how many do you expect in each cell? Right. Good. This is little n over big N and insert is still constant time. What do you think about this? What do you think about this? This is foreshadowing, this is important foreshadowing. Are these two the same? They're not? Raise your hand if you think these two are asymptotically the same. This is discussion, not competition, okay? And raise your hand if you don't think they're the same. Okay. The answer is it depends. Here's what I'm going to use to answer this question, we control the table size. You and me, we're the boss, we're the boss of how big this hash table is. So, we can always make it big enough so that this value is whatever we want it to be, yes? So, these two in this context are not the same because big N is not a constant. We control it and we're going to change it. This is foreshadowing, you might be able to imagine when we might change it. Alright any questions about this? Any question about it? Okay. Alright so seperate chaining you just plunk them all in and SUHA saves you is the short story. Alright here's another one. This is an algorithm that is a very big simplification of a class of hashing strategies, it's sort of the introductory one, it's closed hashing which means all your data will be in the table and here's how it works. If there's not a collision, you just map the key to its position. So sixteen maps to two, eight maps to one, four maps to four and thirteen maps to six and now life gets interesting. We're going to hash twenty nine to one and it's full. There is already something there, so we increase our additive probe number. This is a probe number and look at the next spot. Oh look, spot two is full too, but when you increase it again to three, there is room. So, we can put twenty nine there. Any question about it? So, where does eleven go? Into five, good. And how about twenty two? What is twenty two's life like?
Anybody in this room love their surface pro 3? Not one single person, what does that tell you? Alright, I don't know what to do here. I'll let you share my pain, I'm fairly certain that I can connect. Connecting to class, yay! Nothing, I got nothing. You should quit your slideshow, if all else fails just quit your slideshow. Watch, are you watching? How do you restart it? Just power? It's going to have like 10 minutes of updates because I never restart it. What should we talk about? What did you do this weekend? I'll tell you what I did this weekend, are you interested? I watched Gilmore Girls for the first time with my daughter. I had never seen it before so it was great. Alright, anything else? Anybody want to share. Did anyone eat anything good? Unusual food? [student muttering] Who didn't eat chicken? you have to indulge me here, it's monday. Alright, where are we here? Updates are available, I bet you. [student muttering] Connected ha, ha, that's nice. An update is being installed yes! I'm almost there guys, this was the right advice. [video playing] I'm sorry. Yay! I can't believe you're late geez! Sorry everybody. Um, alright, we don't usually talk about hashing tables, that's the fastest way to get someone to go that person doesn't know what they are talking about". We usually talk about hash tables. Uh, so let's do that. I actually would like to hear what delightful things happened to you this weekend. I stayed overnight in Siebel for a slumber party and it was not the first time I stayed overnight in Siebel but it was the first time I had a pillow. So that was exciting. Alright, hash table consists of what? This is like waking up friday. What the heck is a hash table? By asking you about this, I'm asking you about the implementation. Okay, so how do we implement a hash table. What do we need for sure? Name 1 thing. Somebody raise their hand. Yes, an array, very good! So we need an array and that's just your plain old dynamic array right, indexed by numbers. It's the internals of the interface. This is for implementation purposes. Okay, what else do you need? A hash function. Good. We talked last time about that function's qualities. And what else do you need? Right! A collision resolution strategy.
Anybody in this room love their Surface pro 3? Not one single person, what does that tell ya? Alright well I don't know what to do here, we'll try. I'll let you share my pain. I'm fairly certain I can connect. Connecting to class", yay. Okay. Hahaha. Yeah, nothin' I got nothin'. Absolutely nothin'. So, you should quit your slideshow right if all else fails just quit your slideshow. No? Okay and so watch this. Watch. You watching? You got it? And.. show". Look, it even flashed.Okay, fine. How do you restart it? Just, power? Slide to shut down your PC. It's gonna have like 10 minutes of updates 'cause I never restart it. What should we talk about? Yeah what'd you do this weekend? I'll tell you what I did this weekend, are you interested? Yeah, okay I watched Gilmore Girls for the first time with my daughter. It was awesome. I'd never seen it before so it was great. Alright, anybody, anything else? Anybody wanna share? Oh, I wanna know what you ate. Did anybody eat anything good? Food. Unusual food. No unusual food? Chicken. Who didn't eat chicken? All weekend this weekend. No chicken this weekend? No chicken this weekend? You guys have to indulge me here, okay? This is just... It's Monday. Alright... uhhhh... let's see where are we here? Updates are available, I'll bet you. Welcome, don't even tell me welcome. Yeah, don't tell me good morning" either. Connected. Oh, that's nice. Okay. An update is being installed, YES! Okay. I'm almost there, guys. This was the right advice. I'm sorry. Where's my pen? Yaaaaay! I can't believe you're late. Jeez. Gah. Sorry everybody. Ummm. Alright, we don't usually talk about hashing tables, that'd be like the world's fastest way to get somebody to go Hah, that person doesn't know what they're talking about". We usually talk about hash tables so let's do that. I actually would like to hear what delightful things happened to you this weekend. Ummm. I stayed overnight in Siebel for a slumber party and it was not the first time I've ever stayed overnight in Siebel but it was the first time where I actually had a pillow to do so, so that was exciting. Alright, hash table consists of what? Okay, so this is like pulling stuff... this is like waking up friday or something. So what the heck is a hash table? And by asking you this I'm asking you about the implementation. Okay? So how do we implement a hash table? What do we need for sure? Name one thing. Okay, you gotta raise your hand because I don't know what you said. Somebody raise their hand that just spoke. Yes? An array, very good. We need an array. And that's just your plain old dynamic array, okay, indexed by numbers. Okay? It's the internals of the interface. This is for implementation purposes. Okay, what else do you need? Yeah? A hash function. Good. We talked last time about that function's qualities. And what else do you need? Oh... What did we talk about? Yes? Right, a collision resolution strategy.
Or a prescription for what to do if your hash function is not 1 to 1. Ok we talked about 2 different kinds of uh collision resolution. How did I know that was the 3rd thing you guys were gonna tell me, I don't know. 2 different kinds of collision resolution. One was uh open hashing and the example that we talked about was separate chaining. The other one was closed hashing. And the particular example that we talked about was called linear probing. Now we had just begun to address some problems with linear probing. We talked very briefly about the problems with linear probing um under allowing for removals from the structure and it's kind of a technical issue. You can get over it by augmenting your structure with flags that talk about the fact that data has been removed. It really really is the details of the implementation. The second problem that we're gonna talk about in probe based hashing is fundamental. It affects the idea of probe based hashing profoundly and makes you sort of question whether this is a good strategy for hashing. Ok so my inability to get us started today was not my first issue this morning. My first issue this morning came about when I tried to make sure that this link right there which has worked for 5 years in teaching this class still worked. And of course the internets relationship with java has changed since the last time I taught this class and that no longer works. Yeah, so what this means actually is that I have a project if anybody wants to reimplement this in HTML5 I'm happy to describe to you what this used to do. It was awesome, again, it was awesome. It was perfect but its gone. So you'll just have to take my word for it. Um here's sort of what it did. It loaded up a hash table with a bunch of data. Ok so i'm gonna do that, i'm gonna simulate that in this array here. Imagine that that array has 1000 cells or so and I load it up in such a way that you know these chunks are all filled. And then we've got some individual ones maybe. Ok and then we add more data to it. Ok and then we add more data to it. So say somebody says 200 and asks me to hash it in. I would put it right here. And we would have to wait for this much linear probing to happen to add 200 right? And as we hashed into that region effectively we're going to close up this gap, right? Now what's the probability I hash into this region under SUHA? There's a couple answers that would satisfy....be satisfying here. What's the probability? I understand its a nebulous question there are a couple ways of answering it. You could answer it under SUHA in the context of this table if you like. Or you could answer generally. What's the likelihood that a new hash function or that a new hash a new key gets hashed into that darkly shaded region. Anybody wanna talk about it or have a guess or want to clarify the question? Yeah? 1 over table size would tell you the likelihood of hashing into any 1 cell. Ok? So what is that... so the answer is sitting right there. So if this is a whole bunch of cells, contiguous cells, what's the probability of hashing into that collection?
one over the number of them, right? does that make sense? And, In fact, in the context of this particular example. What fraction of whole table is this about? There is no right answer here. We are winging it at this point. What fraction of whole table is that about? A tenth? So, the probability of hashing into that chunk will say is about a tenth. Okay? This happens with about ten percent probability. But look what happens if it does happen. Eventually, if that happens a few times. This gets all closed up. And in fact, that chunk becomes really big, right? Now what is the probability of hashing into that thing? Much larger. Let's say about 25 percent, right? Imagine what would happen? If we hashed into it. So, let's say we get a value that puts us right here. Okay? we would wait, right? wait wait wait wait wait until finally an open spot would be found. Okay. is there a question about that? And, a minute that an open spot is found. We increase the probability of hashing into that thing because we increase the size of chunk. All right? so this is the problem of primary clustering. It is the problem of primary clustering and the description of it is simply in linear probing. If you are linear probing, increases the size of occupied chunks of occupied cells. The magnitude of clusters of occupied cells, which increases the likelihood that you are going to hash into them in the future. The concrete analysis of this I believe is done in 174. not allowed to assume a probability prerequisite for this course. This is probabilistic argument. That says that in fact this comprises the performance and of linear probing. What are we going to do about this? The answer in stead of taking of steps of size 1 for looking for the next available cell. We are going to take steps of random size. Now, where would we get steps of random size? Where would we get the steps of random size? I think using a another hashing function would be reasonable. The remedy here is to take randomly size steps and I will show you what I mean by that in just a minute because it is not just randomly all over the place. It is controlled chaos. randomly sized steps for probing
one over the number of them, right? does that make sense in fact, in the context of this particular example what fraction of the whole table is this? about? there's no right answer here, we're wining it here at this point? what fraction of the whole table is that? a tenth? so the probabl say is about a tenth ok? so this happens with about ten percent probability but look what happens if it does happen? eventually if that happens a few times, this gets all closed up and in fact, that chunk becomes really big now what's the probability of hashing into that thing much larger, say 25 %now imagnine what would happen if we hash into it. that's say we get a value that puts us right here, we would wait, right? until finally an open spot would be found is there a question about that? and the minute that open spot is found, we increase the porbability of hashing into that thing because we increase the size of the chunk, so this is the problem of primary clustering. The problem of primary clustering and the description of it is simply in linear probing, so if you're using linear probing increases the size of chunk of occupied cells. magnitude of clusters of occupied cells which increases the likelihood that you're gonna hash into it in the future. The concrete analysis of this, i believe is done in 374, we are not allowed a probability prerequisite for this course. In fact, it compromises the performance of linear probing. So what are we going to do about tihs? Instead of taking steps of size 1, for looking the next available cell we are going to take steps of random size. Now, where would we get steps of random size?Where would we get steps of random size? I think using another hash function would be reasonable. So the remedy here is to take randomly sized steps and i'll show you what i mean in a minute. It's a control chaos. Randomly sized steps for probing.
Ok, so this is called, ah, double hashing. And hash function looks something like this. It probe based hashing, so you are going to count, umm, the number of probes that you need to do to find an empty cell. You are gonna count them using this index i. But this time, that number probes is going to have a coefficient which is another hash function. So, I'm gonna do the example with the following two hash functions. Our first hash function is gonna be what it was before h1(k) is just k mod 7. And h2(k) the one that determines the step sizes is going to be umm. Oh what was it. It's 5 minus k mod 5. Ok, and I pull that out here. I understand that I pull that out here. Ok. And that's just the example that we are gonna use. Umm, internally, umm but [reos]. Different hash function are used. But this is actually don't. Ok, so how does this work on our particular example. These are the same numbers as last time. So I know how to hash serval of the first ones of them fairly quickly, umm, that is, they work with i=0. 16 hashes to 2. 8 hashes to 1. 4 hashes to 4. 13 hashes to 6 and now let's look at what happens to 29, ok? I'm gonna show you explicitly the functions. h1(k) is 29 mod 7 which is 1. Ok? So we try hashing to cell 1. Umm, h2(k) here is. Oh no, I forgot that this happens. 5 minus 29 mod 5 which is also 1 shot. So in this case the step sizes are 1. Ok? how can I fix that, I don't know, not on the fly. So this right here the distance is h2(29). Ok? So then we have to, you know, that one is occupied too. So we have to do it again. And in that case we move on to i=2 and there is room so we plump 29 down there. Ok? Maybe we should do another one. Let 5, 11 mod 5, ok this one works. Let's do 11. h1(11)=4. h2(11) is 5 minus 11 mod 5 which is also 4. ok? But this time it's ok. So we attempt to hash 11 here. But we can't, so now where do we go? 1,2,3,4. Our second hash of 11 is here. Ok? Becuase, oh so we need, yeah, yeah there is gonna be a mod of 7 at the end of this. That is we wrap around. And now we do 1,2,3,4. 11 maps here the third time. Ok? Any question about this? Kinda mechanical. Kinda mechanical. Sort of unsatisfying a small example. So again, it will be nice to have that [appli] fixed. Send me an email if you love doing interactive web stuff. All right. Any question about it. Yes, 5 I chose, it works nicely if it's relatively prime to the table size. But those for number theoratically reasons, umm, you know, has to do with the group and the e... Just what happens when you have 2 numbers that is relatively prime in cycles within those numbers. So you will never get on cycle, with 5 in 7 you will always good of one of the numbers. Does that make sense? All right, so the hash function. I pull it out to here. You will not gonna ask you'd come up with that. We'll ask to deal with ones that we give you but we won't ask you to come up with them. Yeah Arman. Ah temporary variable? A variable that only exists only inside the hash function?
He thinks he can get to his data faster if he stores the number of probes it takes. If you could keep track of how many times you have to insert it, then you can save yourself time. You have to maintain it back at the original probe location. The process of that doesn't save you time. Lots of things can hash to the same spot. I can draw you pictures for that later. Double hashing is just adjustment to the step sizes you use for linear probing. So how well do these things do? Here are formulas. Don't memorize. Use analytical skills. Alpha is load factor of the table, equal to number of keys divided by table size. They run in time that depend on this load factor. Here's what they look like. Does your key exist in the table or not? Don't look at them to memorize. Tell me what that function looks like. It's undefined and alpha's limit goes to just more than 0. For less than 1, it's a really huge number. Im going to show you the funcitons in just a minute. As table fills, that expression goes crazy, goes to infinity.
No, no, no, no, no, no 
It's still big, right? Still big... Okay, and... Same here, especially if it doesn't exist. We'll talk about this in a minute. So the key thing to observe here is as alpha goes to 1, these functions are nasty. They go to infinity. These are the running times of these functions, okay? So-- that means we should not let alpha go to 1, which means we should not let the table fill. We should not let the table fill. Mmm, hmmm.... Mmmm... Hm... Alright. Finally, finally, notice that in the context of separate chaining, we are not constrained for alpha to be between 0 and 1. So in these cases, alpha is an element of, you know, 0 to 1. I guess it could be like this, where brackets, but then it's a mess... But here, alpha can be larger than 1, because it's open hashing, right? We can hang as many things off of one individual cell as we want. Alright, but, nonetheless, as alpha increases, those running times increase. Okay, let's look at some functions-- let's look at some functions now. Particularly in the case of probing... This is what those functions look like. So there is this sort-of inflection-- so here's alpha along the bottom; I can read them here better than I can actually read them on my tablet, so I'm gonna refer to these here. There is this inflection point beyond which-- jeez, you know, if alpha-- if the table is really close to full, we're gonna be looking a long time for each one of our data elements. That is the clusters that exist-- the clusters that exist are going to be large, okay? Particularly in the case of linear probing, you know, beyond... (laughs) I don't know, beyond alpha not all that big, the amount/number of probes you have to do to find an empty space is really quite large. Now, here's what I want from you: I want you to make a vertical line somewhere along here, that sorta reflects the, you know, the number of probes you're willing to accept in order to find an empty spot for a piece of data. Okay? So just draw a, you know, draw a line that corresponds to, well, I don't even care, right? You could do a horizontal line if you wanted to. The number of probes you're willing to accept. Just do it-- just sketch it on your paper. We'll do one, for example-- we'll do one for example and I'll do the one I can reach. The same exercise can be done on the other table. And that is-- look, if I say that: you know what? I don't care-- we don't mind looking at 4 different cells for every attempt at storing data, then when I do this, then if my alpha is below, you know, 0.75, I've got it, right? So this suggests-- this suggests that if the table is, you know, less than 75% full, then lookup is quick.
It's still big right? Still big, and same here especially if it doesn't exist. Key thing to observe is as alpha goes to 1, functions are nasty. Go to infinity. That means we shouldn't let alpha go to 1. Shouldn't let table fill. Hmmmmm. Alright, finally notice in context of separate chaining. In these cases, alpha is an element of 0 to 1. Here, alpha can be larger than 1. Because its open hashing, can hang many things. As alpha increases, those running times increase. This is what they look like. There is inflection point beyond here. We're going to be looking for a long time for these clusters that exist since they're large in case of linear probing. Beyond small alpha, number of probes is quite large. I want you to make a vertical line that reflects number of probes willing to accept. Draw a line corresponding to number of probes. Then, when I do this, if my alpha is below .75 Ive got it. This suggests if table is less than 75% full, then lookup is quick.
Even if, even if uh the thing I'm looking for is not in the table. Okay. This one is for successful this one is for unsuccessful. Okay. Uhm up there, that same value, we would have to keep our, for that same number of probes, we have to keep our table only half full. Table only half for example. Any question about that? I'm used to having this discussion in the context of that applet. So I don't pretend this is particularly smooth. Alright. Uhh any questions? Is it good? So the idea is that this, these, probe based strategies work by, if you don't let your table get too full. Yeah, Nathan? No. That was just, you know, four doesn't seem like too many. Four's a constant number, seems like it would be quick right? And I can say to somebody, Oh we'll never have to go further than four." Okay? It's a arbitrary choice. But it turns out, well, I'll save that punchline for a minute. Alright, any questions about this? Yes? So successful is if it's in the table, unsuccessful is if it's not in the table. So if you're looking for key that is actually there somewhere, versus if you're looking for a key that is not there, that's the only difference, okay? I, I question, maybe I shouldn't even break them out. Maybe they should, we should, just look at the unsuccessful numbers. Alright, any other questions about this, alright, any other questions about this? The takeaway is that if your table is not, if your table gets full, look how fast those val- those functions go up. But if your table isn't very full, you're in kind of a good shape for these things. Alright, so, uhh, let's be a little let's think about this a little bit. Alright, so, when we were talking about queues, and I, if I asked you, we've got this queue, what do I do if it fills, what do you say? What's your answer? What if the array fills? I should double the array, and copy the data, very good. Okay, that's what we used to have. Here's what we have now. I'm gonna change it up a little bit. So look, we're not going to let the array fill. We're only going to let the array get up to some alphabet we control, some load factor that we control. In practice, the reasonable load factor that is used is approximately two thirds. K, there's an analytical reason for using this, uhm, load factor but in practice, it's about two thirds. So. What if the array becomes more than two thirds full replaces the questions of what happens if the array fills. What if the array, um, is more than two thirds full? Alpha greater than two thirds. Now we don't exactly double the array and copy the data. We find the first prime greater than twice the array size, find first prime greater than twice array size. Because we like prime numbers, but we're not gonna, I'll explain that if you want. Umm and then, instead of copying the data, we do something a little bit different, okay? So I wanna do this example, so that we see what we need to do. So suppose we have hashed our values into this table, and we this hash function, h of k, is a hash of some kind mod table 5, which is 5. K? And we've hashed these three values into it. And another piece of data comes along. Now we're going to find the first prime bigger than twice the array size, oh look, there it is, and copy the data in, okay? So it's just a straight copy. What's the problem with that? What is our new hash function look like? What is the new hash function look like? It's H 1 of k, mod 11, now. Which means that you will never get these guys back, we changed the hash function. So instead of copying the data, so instead of copying the data, we rehash the data with our new hash function.
Even if-- even if, uhh, the thing I'm looking for is not in the table... This one is for successful, this one is for unsuccessful. Okay. Up there, that same value, we would have to keep our finesse-- same number of probes, we'd have to keep our table only half full. Okay, our table only half full, for example. Any question about that? I'm used to having this discussion in the context of that applet-- I don't pretend that this is particularly smooth. Alright. Any questions? Is it good? So the idea is that these probe based strategies work fine if you don't let your table get too full. Yeah? Nathan? [question being asked]. No, that was just-- four doesn't seem like too many; four is a constant number, and it seems like it'd be pretty quick, right? And I can say to somebody, oh, we'll never have to go further than four." Okay? It was an arbitrary choice. But it turns out-- well, I'll save that punchline for a minute. Alright, any questions about this? Yes? [question being asked]. So, successful is if it's in the table, unsuccessful is if it's not in the table. So if you're looking for a key that is actually there somewhere, versus if you're looking for a key that is not there. That's the only difference, okay? I question... Maybe I shouldn't even break them out. Maybe we should just look at the unsuccessful numbers. Alright, any other questions about this? Any other questions about this? The takeaway is, if your table gets full, look how fast those functions go up. But if your table isn't very full, you're kinda in good shape for these things. Alright, so, uhhh... Let's be a little-- let's think about this a little bit. Alright. So, when we were talking about queues, and if I asked you, you know, I've got this queue, what do I do if it fills-- what do you say? What's your answer? What if the array fills? I should double the array... and....? Copy the data. Very good. Okay, that's what we used to have. Here's what we have now. I'm gonna change it up a little bit. So, look, we're not going to let the array fill. We're only going to let the array get up to some alpha that we control-- some load factor that we control. In practice, the reasonable load factor that is used is approximately 2/3. There's an analytical reason for using this load factor, but in practice, it's about 2/3. So, 'what if the array becomes more than 2/3 full' replaces the question of what happens if the array fills. What if the array is more than 2/3 full? (Alpha greater than 2/3). Now, we don't exactly double the array and copy the data. We... find the first prime greater-than twice the array size. Find first prime greater than twice array size. Because we like prime numbers but we're not gonna-- I'll explain that if you want. And then, instead of copying the data, we do something a little bit different... Okay? So, I wanna do this example so that you see what we need to do. So, suppose we have hashed our values into this table, and this hash function h(k) is a hash of some kind, mod table size, which is five. And we've hashed these three values into it. And another piece of data comes along. Now, we're going to find the first prime bigger-than twice the array size-- oh look, there it is, and copy the data in, okay? So it's just a straight copy. What's the problem with that? What does our new hash function look like? What does the new hash function look like? It's h 1 of k, mod 11 now. Which means that you will never get these guys back-- we changed the hash function. So instead of copying the data, so instead of copying the data, we rehash the data with our new hash function.
so we run each of this though the new hash function and they may end up in a completely different location in a new array. but when we go looking for them we know we can find out. ok, any questions about that? So, of the right, those are exactly parallel. we don't fill the array, we don't exactly double the table size, we don't copy the data. But we have parallel things to do in each of those cases. Alright any questions about it? Process called rehashing. Questions? twice array size. so in my worried about having to find the first prime, greater than twice the table size, we can find a prime in a table very quickly. You can store a lot of primes to look up, you don't have to compute them. Certainly enough to create an array of that size. so the question is where does the two thirds comes from. Does it strictly apply to linear probing in double hashing? It's the load factor that corresponds to probe base hashing strategy generally however they are implemented. In general, you want your table to be two thirds full. It's gives you sort of feeling or what's going on behind the scene when you use hash map as well. Alright, any questions about this? So the question is is there any way of escaping the fact that we are intentionally allocating memory that we are going to use, we admit going in that a third that space is not going to be use. I believe the answer to that is no. You have to allow for data to be mapped in to those cells, otherwise you got a different problem. I mean that to sort of equivalent to get a full array and then you got an issue. So we are we? Without these two collision resolution strategy, one of them just pain out the data. The other one use probing to place it in the table. There are others you might be used. For separate chaining, why not using another hash table?or why not use an avl tree? Why not use something else instead of just singly linked list? so the number of variety in that particular structure is astounding. so these are just sort of basic idea. Now given these basic ideas which one is better? The structure speed is weigh faster for probe based hashing, that is, if you can actually fit all your data into an array, that structure will be much faster. But if your data is big, then you can't create an array that's very big using your memory effectively. And so you want to have the ability to hang your data off your structure. So you have big records, then separate chaining is a better strategy. And of course this is a huge simplification. ok, What's structure do hash table replace for use? What do we use to implement dictionary before?
So we run each of these through the new hash function and they may end up in a completely different location in the new array. But when we go looking for them, we know we can find them. Okay any question about that? Otherwise though its exactly parallel. We don't fill the array, we don't exactly double the table size, we don't copy the data, but we have analogous parallel things to do in each of those cases. That process is called rehashing. Twice the array size. So am I worried about having to find the first prime greater than twice the table size? No, we can find primes in a table really quickly. you can store a lot of primes for lookup, you dont have to compute them. Certainly enough to create an array of that size. So the question is where does the 2/3 come from and does it only strictly apply to linear probing and double hashing? It's the load factor that corresponds to probe based hashing strategies generally, however they are implemented. So probably its a double hashing, in general you'll let your table be 2/3 full. And it gives you sort of a feeling of what's going on behind the scenes when you use a hash map as well. So the question is, is there any way of escaping the fact that we are intentionally allocating memory that we aren't going to use. We admit going in that 1/3 of that space is not going to be used. I believe the answer to that is no. You have to allow for data to be mapped into those cells, otherwise you got a different problem. That's equivalent to having a full array, and then you got issues. So, where are we? We got these two collision resolution strategies, one of them just sort of hangs out the data, the other one uses probing to place it in the table. There are a gazillion others that you might use. For example, for separate chaining, instead of a chain, why not use another hash table, or why not use another AVL tree? Why not use something else instead of just a singly linked list. So the number of variability in that particular structure is astounding. So these are just sort of the basic ideas. Now, given those basic ideas, which one is better? The structure speed is way faster for probe based hashing. That is, if you can actually fit all your data in an array, that structure itself will be much faster. But if your data is big, then you can't create an array that's very big using your memory effectively, and so you'll want to have the ability to hang your data off the structure. So if you have big records, then separate chaining is a better strategy. And of course this is a hugs simplification. What structures do hash tables replace for us? What do we use them to implement? Dictionaries. What did we use to implement dictionaries before?
So we run each of these through the new hash function, and they may end up in a completely different location in the new array. But when we go looking for them we know we can find them. Okay, any question about that? Alright so otherwise though it's exactly parallel. We don't fill the array. We don't exactly double the table size and we don't copy the data but we have analogous, parallel things to do in each of those cases. That process is called re-hashing. Questions? Is it okay? Twice the array size. So am I worried about having to find the first prime? Greater than twice the table size? No. We can find primes in a table really quickly. You can store a lot of primes for lookup, you don't have to compute them. Certainly enough to create an array of that size, yeah? So in practice it's about two thirds. So the question is where did the two thirds come from and does it only strictly apply to linear probing and double hashing? It's the load factor that corresponds to probe based hashing strategies generally however they are implemented. So probably it's a double hashing. In general you let your table be two thirds full. It gives you sort of a feeling for what's going on behind the scenes when you use a hash map as well. So the question is, is there any way of escaping the fact that we are intentionally allocating memory that we aren't going to use we admit, we admit going in that a third of that space is not going to be used, and I believe the answer to that is no". Right? That you have to allow for data to be mapped into those cells otherwise you've got a different problem. That's sorta equivalent to having a full array and then you've got issues. Alright any other questions about this? So, where are we? We got these two collision resolution strategies. One of them just sort of hangs out the data. The other one uses probing to place it in the table. There are a gazillion others that you might use, that might be use.d For example. For separate chaining instead of a chain, why not use another hash table, or why not use an AVL tree? Why not use something else instead of just a singly linked list? So the number of variety, the amount of variability in that particular structure is astounding. Okay, so these are just sort of the basic ideas. Now, given those basic ideas, which one is better? The structure speed is way faster for probe based hashing. That is, if you can actually fit all your data in an array, that structure itself will be much faster. But if your data is big, then you can't create an array that's very big using your memory effectively, and so you'll want to have the ability to hang your data off the structure. So if you have big records then separate chaining is a better strategy. And of course this is a huge simplification. Okay, what structures do hash tables replace for us? What do we use them to implement? Dictionaries. What did we use to implement dictionaries before?
AVL tree,B tree yeah sort of but if our data is so big it doesn't fit in memory it is not going to fit in memory here either.Mostly AVl trees maybe a linked list but those have been bad for a long time.So primarily it replaces an AVL tree. I need to go backwards and reemphasize something.I need to go back here.What is the running time of finding something in a hash table?If alpha is constant,what are these running times? They are constant, that's right.When somebody tells you hash tables have constant time access it's because that load factor is held constant in this strategy.Okay so, this re-sizing strategy is used to hold alpha constant.Which means find is constant,insert is constant. And those are probabilistic results so those are average results.Yeah? Sure. No it calling re-hashing,yeah.Seperate chaining is open hashing where you just hang your data out,we talked about it last time.Okay it is the first collision resolution strategy.Alright lets do a lecture like this today okay.Yeah Mike, umm you are not going to because your table is going to be fairly empty,just over half full or so.Yup.Yes.We are gonna put an upper bound on alpha, alpha is never gonna be worse than 2/3 so the functions are never gonna be worse than whatever that is.What else? the absolute worst case is just ignored.If I were implementing a hash table from scratch I would put fault tolerance in it right? Like use two different hash functions and take the better of them say for example. So the question is if alpha is one one less than tablesize/N, if I still take N-1/n and I keep it there that running time is gonna be constant but really bad. So I am still gonna keep alpha fixed relative to the table size so there is no n in the expressions for running time coz alpha is gonna be constant even if it N-1/n close to 1. I am gonna control alpha.I owe you guys alright. I have a puzzle for you. Lets go to a puzzle. So there is a constraint when we use AVL trees, there is a constraint on key space that does not exist for hash table and I am going to constraint on the keyspace for any BST in our case AVL tree that does not affect hashing. To evoke the idea I am going to do this. And ask you what did I do at every vertex here in an AVL tree. What do you do at every opportunity of branching in an AVL tree, what do you do. You decide it is bigger or smaller, you make a comparison. AVL trees require comparable keys.That constraint doesn't apply to hash tables.So AVL trees, BST in general, require comparable keys.
AVL Tree. Anything else? A b-tree, yeah. Sort of. But, if our data is so big. If our data's so big, it doesn't fit in memory. It's not gonna fit in memory here either. So, mostly AVL trees, maybe a linked list. But those have been bad for a long time. Okay, so, primarily. Primarily it replaces an AVL tree. you know what, I'm sorry. I need to go backwards. I need to reemphasize something. I need to go back to here. What's the running time of finding something in a hash table? If alpha is constant. If alpha is constant, what are these running times? They're constant. That's right. When somebody tells you hash tables have constant time access, it's because that load factor is held constant in this using this strategy. Okay, so, this resizing strategy is used to hold alpha constant. Which means find is constant. Insert is constant. And those are probabilistic results so they're average results. Yeah? Sure. No, it's what we're rehashing. Separate chaining is open hashing where you just hang your data out. We talked about it last time. Okay, it was the first collision resolution strategy. Alright, anything else about this? Let's do a lecture like this today. Let's do this. Yeah, Mike? You're not going to because your table is going to be fairly empty. Your table's just gonna be over half full or so. Yup. Yes. We're never... yes, it gets smaller. So we're gonna put an upper bound on alpha. Alpha's never gonna be worse than 2/3 which means those functions are never gonna be worse than whatever that is. Alright, what else? Yes? The absolute worst case is usually just ignored. Yup, and if I were implementing a hash table from scratch, I'd like put full tolerance into it like use two different hash functions and use the better of them say, for example. Yeah? So the question is if alpha is one less than the table size over capital n. Still, if I take big n over little... I mean if I take n-1 over n and I keep it there, that running time is gonna be constant but really bad. So, I'm still gonna keep alpha fixed relative to the table size. So, there is no n. There's no n in expressions for running time. Because alpha is gonna be constant even if it's n-1 over n. Even if it's really close to one. I'm going to control alpha. Alright, what else? Alright, I have a puzzle for you. Let's go to a puzzle. Puzzles are always safe. So there is the constraint. When we use AVL trees, there is a constraint on the keyspace that does not exist for hash tables. And I'm going to... uh, so there's a constraint on the keyspace for any binary search tree, in our case, BST, that does not affect hashing. And to evoke the idea, I'm going to do this. And ask you what did I do at every vertex here in an AVL tree? What do you do at every vertex, every opportunity of branching in an AVL tree? What do you do? You decide if it's bigger or smaller, you make a comparison. So, AVL trees require comparable keys. That constraint doesn't apply to hash tables. So, AVL trees... BST in general. AVL trees require comparable keys.
And the implication there is less than is defined on heaps and we don't have that constraint on hash tables. So why do we talk about binary search tree at all if hashing is so great? The answer to that is simply that in avl trees get us something else. They get us data nearest neighbor search They give the ability to, if we have distance defined we can evaluate how close we are to a particular key. Where as in hashing, two keys that are close in distance could be way far away from each other in the table BST assures that similar keys are close to each other in the tree. Hashing doesn't give you that. No such assurance. Hashing can make no such assurance. Now, what does this mean? It means that I can saving an AVL tree, okay here's a key, I know its not in the tree, but give me the closest one. You can't do that in a hash table. If I come to a hash table with a key and say I know this isn't here give me the closest one" it will go "what?" and not able to respond efficiently. Alright, ahhhhhhhhhhh! Bleh!
Okay we're in the middle of it. We have no exams coming up. I'm hoping to have the histogram for exam 1 on Friday. You should hear from us about your exam results sometime between now and then. I haven't looked to see the progress of grading, but I do know that one grad student gave us their rubric only yesterday or so. So grading is not done, but it's happening, we'll get there. That's all I have in terms of announcements. Are there any administrative questions or issues that you know of? Finals monday night, 7-10. That might be the ideal final time. So the question is, will there be an MP over the break. And the answer is no, we didn't count break as time you would put towards an MP but there will be one that's assigned. So our intention is you start working on it before you leave, and then take a week off, and then come back and you'll still have plenty of time to work on it. So that's the intention. But it is out there so it's not quite true for me to say there isn't one, there kinda is. So I have a secret mystery data structure today, here it is, here's a picture of it. So that's supposed to be a bag. It doesn't look like a bag. First what I want you to do is experiment and ask me what kinds of things I am willing to put into my bag. I'm not going to put anything in right now, but I want you to query me and say can I put this in your bag? We're thinking of types of things. So here's the yes column and here is the no column. So go ahead, I'm willing to entertain suggestions. Oh can I put... Ohhhhhhh I wish I had a cookie to give to you. thats a really good and deep question. Ohhhh can you give him a cookie? Now I wish I had a kitten to give to you. Whose got a kitten? Alright, a bag, I don't think I can put another bag in my bag. I don't think I can. So this is my bag. That might be the question of the semester right there. Yeah? Fruit, no I can't put fruit in my bag. I'll even generalize, I can't put food in my bag of any kind. Okay? Ask yes? No I don't have a way of putting people in the bag, it's not big enough. Can I put nodes? I can't put nodes in. You guys stink you can't figure out what I can put in my bag. Come on. Yeah? I can put real numbers in my bag. Anything else? that is not the only thing I can put in my bag. Yeah? I can put pointers in my bag yeah. sure. I think i can put strings in my bag yeah. yeah mike? yeah I can put chars. yeah nathan, PNGs? no I don't think I can put PNGs into my bag.
Okay. We're in the middle of it, we have no exams coming up, I'm hoping to have histogram on exam 1 on Friday for you should hear from us about your exam results sometime between now and then. I haven't looked to see what the progress is of grading, but I do know that one grad student gave me their rubric only yesterday. So, I think that they gave us rubric only yesterday or so. So, its grading is not done but it's happening. So, we'll get there. Let's see. That's all I have in the way of announcements. Are there any administrative questions or issues, that you know of, what you wanna ask? Finals on Monday evening, is that right? Monday night. seven to ten. That might be ideal time for final actually. So, the question is, will there be a MP over the break? and the answer is no, we didn't count the break as time that you would put toward MP, but there will be one that's assigned. So, our intention is that you start working on it before you leave and then take a week off, and then come back and you will still have plenty time to work on it. So, that's the intention. But it is out there. So, it's not quite true for me to say there isn't one cuz there kind of is. All right. So, I have a secret mystery data structure today, here it is, here's the picture of it; that's supposed to be a bag. First, what I want you to do is experiment and ask me what kinds of things I am willing to put in my bag. I'm not gonna put anything in right now, but I want you to query me and say can I put this in your bag". We're thinking of types of things. So, here's the yes colum, I'll put these in my bag, and here is the no column; I will not put these in my bag. So, go ahead, I'm willing to entertain suggestions. Oh, I wish I had a cookie to give to you! That's a really good and deep question. Oh, can you give him a cookie? Now I wish I had a kitten to give to you! Who's got a kitten? Alright. A bag, I don't think I can't put another bag in my bag. And I don't think I can't. So this is my bag. Good question. Wow. That might be a question of semester right there. Fruit. No, I can't put fruit in my bag. I'll even generalize I'll not put in food in my bag of any kind. Ask! Yes? No, I don't have a way of putting people in the bag. Yeah? Can I put nodes? I cannot put nodes in. You guys stink! You can't figure out anything I can put in my bag, come on! Yeah? I can put real numbers in my bag. Okay? Anything else? That is not only thing I can put in my bag. I can put pointers in my bag. Yeah! I can put pointers in my bag, sure. I think I can put strings in my bag. I can put chars. What did you say? PNGs? No, I think I can put PNGs in my bag.
Okay. What's different about these lists? These are some good lists, what's different about these lists? What distinguishes one list from another? No, these are more than primitives. Strings are not primitive, we treat them as primitive because we use them so much but they certainly are not primitive to the language. In fact, I could put booleans in there but that wouldn't be very intersting to do so. They have a somewhat obvious ordering. Very good observation. So, the English description that he used was a somewhat obvious ordering and I really like that. The way that we capture that observation using a vocabulary word of our domain is that the keys are comparable. So, this list is consists of key types that are comparable. Any question about that? So what does that mean implementation-wise for something to be comparable? This is a review from last time, I actually said the answer to this question last time. What does it mean for things in keyspace to be comparable? That's right. operator less than is defined. So, comparable means a.. I don't know why... okay. So this means less than operator is defined. You will write will more neatly on your own notes. Anybody need clarification of that? It's not written very well. Don't look at where I wrote it, just think about what I wrote. Less than operator is defined. Now, do you agree with me that the things in No list are not comparable? You agree with me? What do you think? Good. Very good. So, this quick response from me to say nah, those are not comparable, I didn't think deeply about it and you can impose a metric on lots of different types that force them to be comparable. But these just as they stand are not. For example, for PNGs, in fact, this is going to be relevant in MP6, you end up using average color value of PNG to enforce sort of comparability in it. So you use an average over the set of pixels to create color value that you can then evaluate distances with. Alright, any questions about that? So, pick your favorite one of these and start asking me to put them into the bag. Pick your favorite one. Which one you like the best? I know, I'll just add one. How about just numbers. real numbers. We'll just take the first one. So, I'm willing to, at this point, to say that my bag is templatized to contain real numbers. You even wanna do imaginary numbers? We could. We'll do real numbers. So suggest something that I put in my bag. Did somebody say four? Did you say four? Well, I'll put four in because that's what I was thinking, I don't know anybody said that actually. I'm willing to put four into my bag. I'll put two into my bag, sure. Anything else? A thousand, sure. Just reminding you that we're talking about real numbers here. Pi? okay. Pi is real, right? Anything else? Good enough? I'm gonna put negative fourty two, because that's fun. So, it doesn't feel like there's anything I'm not willing to put into bag, right? And it's true. Across the keyspace, I'll put everything into bag that you ask me to do so. Insert is just, here it is, put it in.
Ok. What's different about these lists. These are some, these are some good lists. What's different about these lists. What distinguish one list from another. Yeah. No, these are more than primitives. Strings are not primitive. We treat them as primitives because we use them so much, but they certainly are not primitive to the language. In fact, I could put booleans in there, but it wouldn't be very interesting, wouldn't be very interesting to do so. Yeah. Uh, they have a somewhat obvious ordering. Very good observation. So the English description that he used was a somewhat obvious ordering and I really like that. The way we capture that observation using a vocabulary word in our domain is that the keys are comparable. So this list is consisted of types, key types that are comparable. Ok, any questions about that. So what does that mean in implementation. What does that mean implementation-wise for something to be comparable. This is a review from the last time. I actually said the answer to this question last time. What does that mean for things in the key in a key space to be comparable. Yeah. That's right. Operator less than" is defined. So comparable" means, "comparability" "comparable" means. I don't know why. Ummmmm. OK. So this means less than" operator is defined. You will write it more neatly on your own notes. Ok, anybody need clarification of that. It's not written very well. So don't look where I wrote it. Just think about what I wrote. Less than" operator is defined. Now do you agree with me that the things in the NO" lists are not comparable. Do you agree with me What do you think. I'm sorry. Now you trick me. Now you are in the dog house. Yes, Mike. Good, very good. So this, this quick, quick, quick response from me to say no, those are not comparable. I didn't think deeply about it and you can impose a matrix, you can impose a matrix on lots of different types that force them to be comparable. But these just in standard are not. For example, for PNGs, in fact, this is going to be relevant in MP6. You end up using the average color value of a PNG to enforce a sort of comparability in it. Ok. So you use average, an average over the set of pixels to create a color value who, that you then can valuate the distances. Wow, that wasn't English. Alright, any questions about that. Ok, so pick your favorite one of these and start asking me to put them into the bag. Pick your favorite one. Which one you like the best. I know. I'll just add one. Well, how about numbers, real numbers. Ok, we'll just take the first one. So I'm willing to, at this point, say that my bag is templatized to contain real numbers. OK. Do you even wanna do imaginary numbers. We could. OK. Alright, we'll do real numbers. Alright, so suggest something that I put in my bag. Suggest something. Oh. Did somebody say four. Did you say four. Somebody said four.Well I'll put four in, cuz that's what I was thinking. I don't know anybody said it actually. Alright, I'm willing to put four into my bag. Anybody wanna suggest something else. Two. I'll put two into my bag. Sure. Alright, anything else. A thousand. Sure. I'm just reminding you we are talking about real numbers here. Pi, ok. Pi is real, right. Ok, anything else. Good enough. I'm gonna put negative forty-two, cuz that's fun. Ok, good. You are fine. So it doesn't feel like there's anything I'm not willing to put into the bag, right, and it's true. Cross the key space I'll put everything into the bag that you asked me to do so. Insert is just: here it is, put it in.
ok, what's different about these lists. These are some good lists, what's different about these lists. What distinguishes one list from the another? No these are more than primitives, strings are not primitives. We treat them as primitives, we use them so much but they certainly are not primitives to the language. In fact I could put boolean in there but it wouldn't very interesting to do so. they have a somewhat obvious ordering. Very good observation. So the english description that he use was a somewhat obvious ordering. And i really like that. They way we capture that observation using a vocabulary word is that the keys are comparable. The list is consist of types that are comparable. Any question about that? so what's that mean in an implementation, for something to be comparable? I actually said the answer last time. Operator less than" is defined. You will write it more neatly on your own notes. Anybody need clarification? It's not written very well. Do you agree with me the things in the No list are not comparable? This quick response for me to say, no those are not comparable. I didn't think deeply about it. Now you can impose a matrix on lots of different types that force them to be comparable. But this is not. For PNG, in fact, this is going to be used in MP6, you will use the average color value of the PNG to enforce a kind of comparability. A average of a set of pixels to create a color value that you can then evaluate distance with. So pick your favorite one of these and start ask me to put them into the bag. I'll just add one. How about numbers? So I'm willing to at this point my bag is templatized to contain real numbers. Even wanta do imagery numbers? We could. We'll do the real numbers. So suggest thing that I put in my bag. Did somebody say 4? Well I'll put 4 in. I'll put 2 in my bag. A thousand? sure. Just reminding you we're talking about real numbers number? Pi? Pi is real. A negative 42 is fun. So doesn't feel like there's anything I;m not willing to put into bag. And it's true. I will put anything into the bag that you ask me to do so. Here insert is just here it is, put it in.
OK, so how long does it take to insert an unsorted list? Unsorted list, I just want to be putting values in. How much time should that take? Oh, constant time! look at that! There is a mistake already. This should be constant time. Good. How about removeMin? Is order n correct? I want to find in an unsorted array the minimum value. Yeah? That's fine, right? So, order n is correct. I would have to go on a hunt through the linear collection of data, looking for the minimum. Ok, fine, how about for a linked list? If we implemented this functionality in insert and removeMin, using a singling linked list. How much time would it to take to insert? Constant, but we want to put the new one back here, right? No, no reason to do so. It is unsorted, so when you insert, you would insert at the front. You can do this at constant time. Or, you have a tail pointer you can do it at the rear. Ok, fine. How about removeMin? Still big O of n? We would have to go search for it. OK, fine, let's suppose, we decided that we can fix this, we will fix this by using a sorted array. In that case, how long does it take to do an insertion? A sorted array. 2,3,4,8,13,21, and I want to insert 11. How much time does it take? Log(n) right? How come it is logn? why are we thinking logn? Binary search, very good. You observe the opportunity of binary search. So, we use binary search to determine the 11 goes here, but we have to shift the data. This is not true. Oh gosh! I swore when I came to school, today would be a better lecture than Monday's. That's a low bar. How about a linked list? a sorted linked list. Can you do binary search? No, you cannot do binary search in this case. It is big O of n to find. Ok, this is the moment where oh boy, this is for find and this is for shift. Ugh, how about removeMin? How about removeMin? Are these correct? They constant in both cases? Is this correct? Could this have been correct if I put those differently? So, ok, I should have done 21, 13,8,5,3, and then it would be constant time. Because we always remove frome the end of the chunk of the data. Ok, how about for a singly linked list? Does it take constant time to remove the minimum? Yes, if you keep the minimum where? At the head of the list, right? What if you kept the minimum at the tail pointer? So, I am going to keep the minimum here, and I have a tail pointer. What do you think? Removing that guy. No, because I can get to it in constant time, but resetting this tail pointer while the traversal of the structure. OK, everybody good? Ok, so, take a look at this messy table, and it looks like there is trade-off going on, right? So, we got constant time, for on of the functions, and linear time for the other function. What would be better than this? What would be better? Log(n)? Log(n) would better especially if we were able to replace the linear time functions with Log(n). Well, I am not going to tell you how good it gets, instead, I am going to switch gears, so that's a reasonable goal. The question is, whether we can do log(n) here and constant time here. Just how good can we do using a different structure. Ok? Now. I want to leave this one hanging, OK? Because I want to show you something completely new. This will be more fun for you. If you focus here instead of your paper. Ok, don't look, I know you want to look, right? but don't. Ok? Alright. So, here is a new structure, what I want you to do, is tell me, everything you can about it. Tell me everything you can about it. Everything you might be think interesting, everything you think characterize it.
Okay. So, how long does it take to insert into an unsorted list? unsorted list I just want to be putting values in. How much time should that take? Oh constant time. Look at that. There is mistake already. This should be constant time. Good. How about removemin? is Order(n) correct? I want to find in an unsorted array the minimum value? Yeah? That is fine, right? Okay. So, order(n) is correct. I would have to go on a hunt through the linear collection of data looking for the minimum. Okay. fine. How about for a linked link? if we implemented this functionality, insert and removemin using a singlylinked list? how much would it take to insert? constant? I would put the new one back here right? No, no reason to do so. It is all unsorted. So, when you insert, you would insert at the front. you could do that at constant time. Or, you have a tail pointer, you could do it at the rear. Okay. Fine. How about removemin? Still O(n). we would have to go searching for it. Let's suppose. we decided we can fix this. we will fix it by using a sorted array. In that case, how long does it take to do an insertion into a sorted array. two three five eight thirteen twenty-one. And, I want to insert eleven. How much time does that take? Log(n), right?? Log(n) to. how come is it log(n). Why are we thinking log(n)? Binary search. Very good. You observed the opportunity for binary search. we used binary search to determine that eleven goes here but we have to shift the data. So this is not true. Oh, Gosh. I swore when I came to school. Today would be a better lecture course than Monday's. Of course, that is a low-bar. All right, How about for a linked list? sorted linked list? Can you do binary search? No. Can't do binary search. In this case, it is big O(n) to find. Okay, So this is the moment. This is for find. This is for shift. How about removemin? how about removemin? Are those correct? They are constant both cases? Is this correct? Could it be correct, If I have put those differently? Okay. So, I should have done, twenty one, thirteen. eight, five, three, and then it would be constant time. It would always remove from the end of chunk of data. Okay. And, how about for a singlylinked list? Is it constant time to remove minimum? Yes, if you keep the minimum where? At the head of the list, what if you keep the minimum at the tail and you have the tail pointer? So, I am going to keep the minimum here and have a tail pointer. What do you think? Removing that guy? No, because I can't get to it in constant time. Resetting that tail pointer requires a traversal of structure. Everybody, good?? Okay, so take a look at this messy table. And, it looks like there is some trade-off going on, right? so we got constant time for one of the functions and linear time for the other functions. What would be better than this? What would be better? log(n). log(n) would be better especially if we were able to replace the linear time function, log(n). Well, I am not going to tell you how good it will get. Instead, I am going to switch gears so that is a reasonable goal. The question is whether or not we can do log(n) and constant time here. Just how good can we do? Using a different structure. Now, I want to leave this one hanging because I want to show you something completely new. This will be more fun for you if you focus here instead of on you paper. No. Don't look. Don't look. I know you want to look, right? but don't. All right. So here is a new structure. What I want you to do is tell me everything you can about it. Tell me everything you can about it. Everything you think might be interesting. Everything you think characterizes it
Ok. How long does it take to insert into an unsorted list. Unsorted list. I just want to put values in. How much time should that take? Oh constant time. Look at that. There's a mistake already. Constant time. Good. How about removeMin? Is o(n) correct? I want to find in a unsorted array the minimum value. Thats fine right? Ok. o(n) is correct. I would have to go on a hunt through the linear, a collection of data looking for the minimum. Ok. Fine. How about for a linked list. If we implemented this functionality insert and removeMin using a singly linked list. How much time would it take to insert? Constant. I would put the new one back here right? No. No reason to do so. It's all unsorted. So when you insert, you would insert at the front. You want to do that in constant time. Or if you have a tail pointer you can do it at the rear. Ok, fine. How about removeMin? Still o(n). We would have to go searching for it. Ok fine. Let's suppose we decide we can fix this. We will fix it by using a sorted array. In that case, how long does it take to do a insertion into a sorted array? Two, three, five, eight, thirteen, twenty one. And I want to insert eleven. How much time does that take? Logn right? How come its logn? Why are we thinking logn? Binary search. Very good. So you observe the opportunity for binary search. So we use binary search to determine that eleven goes here, but we have to sit the data. So this isn't true. Oh gosh. I swore when I came to school today. Today would be a better lecture. Of course then Mondays. That's a low bar. Alright. How about for a linked list, a sorted linked list? Can you do binary search? No. Can't do binary search in this case. It's o(n) to find. Ok so this is the moment where. This is for find. This is for shift. How about removeMin? Are those correct? They are constant in both cases. Is this correct? Could it be correct if I have put those differently? Ok. So I should have done twenty one, thirteen and eight, five, three. And then it would be constant time. Cause we always remove from the end of the trunk of data. Ok. How about for a singly linked list? Is it constant time to remove the minimum? Yes. If you keep the minimum where? At the head of the list. Right? What if you keep the minimum at the tail and you had a tail pointer. So I'm gonna keep the minimum here and have a tail pointer. What do you think? Removing that guy. No. Because I can get to it in constant time but resetting this tail pointer requires traversal of this structure. Ok. Everybody good? Ok. So take a look at this nasty table. And it looks like there's some trade off going on. Right? We got constant time for one of those function and liner time for the other function. What would be better than this? What would be better? Logn would be better especially if we are able to replace the linear time function with logn. Well. I'm not gonna tell you how good it gets. Instead I'm gonna switch gears so that's a reasonable goal. And the question is whether not we can do logn here in constant time. Just how good can we do. Using a different structure. Ok. Now. I want to leave this one hanging. Because I want to show you something completely new. This would be more fun to you. If you focus here instead of on your paper. Ok. Don't look. I know you wanna look. Right. But don't. Alright. So here's the new structure. What I want you to do is tell me everything you can about it. Tell me everything you can about it. Everything you think might be interesting. Everything you think characterizes it.
You guys are like on it today, yes? Aye! It's a complete tree, a complete binary trees. So good observations. So, I'm gonna write that down. It is a complete binary tree. Ok, anything else?Yes? It's what? Ordered in its levelS but it isn't OHH! It isn't ordered in its levels, that kind of a interesting in itself, right? yeah? OHHH---, Very good, ok? So this is a complete tree, where each parent is less than its two children. Each parent 's key, each parent's key is less than the keys of its 2 children. Ohh, that's new, we haven't seen such a thing before. This two things together actually characterize the structure compeletely, though typically we will take an input implication of the second, and that implication is the following: that every path from the root to a leaf is monitonically increasing. Very good. So the implication of the second one that we're gonna use is- every path from root to leaf is increasing. Ok, this structure that you've now characterize has~ a special name, it's called a heap. It's acutally a binary min heap, but we just very quickly refer to it as a heap. Ok. So I want to do a quick recursive definition, ok? So the quick recursvie definition is a binary min heap is a complete tree, with a following characteristics: T equal an empty tree is a binary min heap. And if T equals a root together with a left subtree and a right subtree, ok? then the key of the root(the key of r) is less than the key of TreeL's root and TreeR's root, if they exist, and furthermore, TL and TR are heaps.
So this characteristic is true, recursively. OK but, but.. were actually not going to end up relying very much on this particular depth definition. The focus of the algorithms that we write on this structure are going to rely on this and on this. OK. Any questions about that so far? Here's a quick question are complete trees full? Is every complete tree a full tree? No, good. Is every complete tree a perfect tree? No. Is every perfect tree a complete tree? Yes. OK good you see where that conversation is going right? OK so let's talk about implementation of this thing and what I want to know. What i'm going to ask you to do is imagine how you would implement this thing and then, huh, tell me what the primary private member would look like in your implementation. OK so think about what your, how you would implement it and then tell me what the primary member or the the primary private member of that implementation is. Anybody want to offer something? Tell me what you think. What do you think? It's a treee! So what is, how are you going to characterize this tree in code. You're not going to, you don't want right? I don't wanna. Have you done things like this in the past? You're not talking to me? It's OK to be wrong. In fact lets day something that is wrong. I'm going to implement this tree using an integer. OK that's wrong. OK now that's out of there. So now somebody venture were we're past that, so somebody venture something. You're implementing a structure like this that has two functions what is your primary private member going to be? How are you going to hold the data? A tree node? Is that what you said? Thank you so much. Now I owe you a cookie. Did you say that? He said it? OK now he owes you a cookie. OK. Alright very good. Well.. so a tree node pointer called say root, perfectly reasonable implementation, perfectly reasonable implementation, except that we don't have to do it that way instead. ooohhhh. What's the implication? We can use an array. We can use an array. Now the thing that gets us this, is that the tree is complete. OK. We know everything there is to know about the structure of the tree. That is not so true in AVL trees and BSTs in general OK. But in this case we know everything there is to know about the structure of the thing. So we're going to exploit that and say Hey I know where the children and parents are". We're just going to lay it flat out in memory. Now in MP6 that is true as well. We are going to use a vector an array to implement the tree but it is slightly different. Where is the root in this implementation. Where is the root? Right. Early on in the array, the front of the array. Right. In MP6 the root is kind of in the middle and all the nodes in the left are less and all the nodes to the right are greater in some sense. OK. So it's a little bit different of an interpretation of using a flat, a flattening the tree. But it sort of takes advantage of the structure speed of an array in a, for similar reasons. OK now. Huh in a pointer based implementation of a tree. It's important to have the following pieces of information. You need instant access to a left child
But we're not going to end up relying very much on this definition. Here's a question: are complete trees full? Is every complete tree full? No. Is every complete tree a perfect tree? No. Is every perfect tree a complete tree? Yes. Ok, so lets talk about implementation of this thing. What I'm going to ask you to do is imagine how you would implement this thing and then tell me what the primary private member would look like. So think about how you would implement it and tell me what the primary private member of that implementation is. Tell me what you think. What do you think? It's a tree! How are you going to characterize this tree in code? Have you done things like this in the past? We can implement this using a TreeNode. A TreeNode pointer calls say the root. Perfectly reasonable implementation except that we don't have to do it that way. Instead, we can use an array. We know the complete structure about the tree. Now, in MP6 that is true as well. We're going to use a vector to implement the tree but it's slightly different. Where is the root in this implementation? Early on in the array, at the front of the array. In MP6 the root's in the middle. Ok, now in a pointer based implementation of a tree, it's important to have the following pieces of information: 1. You need instant access to a left child
I'm gonna leave it like this. I don't like leave off by one error there. How would we prove that was true? this is my best out here. This height is log N? Not induction yet. First of all what we are gonna do is twist the question around to the minimum number of nodes in the tree of height h. Answer is that and then do induction and invert it. The maximum height of a complete tree containing n nodes, we are going to say the minimum number of nodes in a tree of height h. Ask the inverse question. Algorithms that traverse the root to leaf are going to be log n. How do we insert into this structure. I'll draw like this. Here's what I wanna know from you. Tell me a number that would be a key to e super easy to insert into this structure. 13 would be super-easy to insert. Where does it go? It goes into 7. right here. The reason it's super easy to insert is it's greater than 7 so it's correct and easy to insert because it's something that goes right here in the array. Anything that is greater than 7 can go that spot and that spot corresponds to this cell. The smallest one would be 8 but it's already in the tree. So 10 would be fine. I'm gonna insert 5. I want to insert 5. you don't like it because it breaks the key property, where that property is an order, a monotonically increasing path from the root to a leaf. So how can I fix it? Swap! very good observation. I can just, it is safe, for me to swap 5 and 7 here. Because if 5 is less than 7, then it is certainly less than 11 because 11 is greater than 7. It is okey parent for its sibling. It is an okey parent for the other side of the tree. So that was a safe thing to do. Do it again! Is it safe to swap 5 up to here? 2 things are going on. I believe you understand it's ok to bring 5 up. But is it ok to bring 6 down? Anything less than the previous key is ok. And we know 6 is less than 7. But we know 6 is less than 7 because it was above it and it was a heap to start with. So it's okey to bring 6 down. Now the heap property this property about increasing path from root to leaf is restored. That process, that swapping process, we refer to as heapifyup.
Questions? you good? Okay. Let's see. I don't know if this is right. I'm gonna leave it like this. I don't want to like leave off by one errors there. Alright, how will we prove if that was true? This is my best out here. How do we prove that that's true? That this height is log n? No. Not induction yet. Not induction yet. First of all, what we're going to do is twist the question around to the minimum number of nodes in a tree of height h. Right? So twist the question around, answer that, prove that by induction and then invert it. So the maximum height of a complete tree containing n nodes. We're gonna say the minimum number of nodes in a tree of height h. We're gonna ask the inverse question. Alright. Fine. Log n. Algorithms that traverse height to to top root to leaf are going to be log n. Fine. How do we insert into this structure? Now here i'll draw this like this. This zero. This doesn't work anymore. Don't look at it. alright here's what i want to know from you. Tell me a number that would a key would be super easy to insert into this structure. Super easy to insert. Tell me a key that would be super easy to insert. Yeah? 13 would be super easy to insert. Where does it go? It goes into seven's right. Right here. Right? The reason it's super easy to insert is. it's greater than seven so its correct and its easy to insert because it's something that goes right here into the array. Okay fine. Anyhting that is greater than seven and is gonna be can go in that spot and that spot corresponds to this cell. Okay. Good observation so three thousand would be enough. The smallest one would be eight but it's already in the tree. Alright so 10 might be the smallest one. Okay fine. I'm going to insert ohhh i don't know. You want five? That's what I was going to say. Really? okay. Yeah I'm telling you, the E.S.P runs strong in this room. I want to insert five. Do you like it? (Crowd says no). Okay you don't like it because it breaks the heap property. Where that property is an order a monotonically increasing path from root to the leaves. So how can I fix it? Swap. Very good observation. Look. I can just. it is safe. it is safe for me to swap five and seven here. right? Because if. if five is less than seven then it's certainly less than eleven because eleven is greater than seven. right. So if five is less than seven then it's an okay parent for it's sibling. Wait. It's an okay parent for the other side of the tree. Okay. Alright fine. So that was a safe thing to do. Are we done? Oh what should we do? Do it again. That's right. Is it safe for me to swap five up to here? Wait a minute. Two things are going one. I believe. I believe you understand it's okay to bring five up but is it okay to bring six down to this spot. Is it okay? Anything less than the previous key is okay. And we know six is less than seven because we learned it when we were two. But we know six is less than seven because it was above it in the tree. And this was a heap to start with. Okay. So it's okay to bring six down. And now the heap property. This property of a path increasing path from root to leaf is restored. Any question about it? That process. That swapping process we refer to as heapify up.
OK. My question is what is running time. log(n). It was constant time to put the original value in place and then you gonna to swap all the way up. Let's write some code. So here is insert. It is if the size is equal to. Wait a minute. This is we got an array has big size. How big is that array ever going to be. If that array is full. We better grow it somehow. Then we are going to increment the size. The current biggest location place our value into that position. So that was putting five at the end of the existing chunk of data in previous example. We are gonna call a helper function heapify up from that location. That is exactly what we wanna did in the previous page. Double the size and copy the data. Here is the beautiful thing. Doubling the size means opening up the next row of the heap. Is that awesome? So let's talk about heapifyup for a minute. So the cIndex is the current index, and basically I want to know if I should keep going. I wanna know if I should keep going and so it is basically the cIndex is more than zero. Cindex is relative to its parent. If it is less than its parent then I am gonna call some swap function, swap those keys. May be I am gonna swap intems[c] index with items[cparrent]. And then I am gonna call heapifyup on the parent.
And my question is what's its running time? log(n)! That's right, right? It was constant time to put the original value in place and then at worst, you're going to do swaps all the way up. All right, any question about it? Yes? I didn't fix the array, I know, I was being lazy and you called me on it. Fine. This is five. This is seven. This is five. This is six. Now? Now we're good? Is it good? Okay. All right, any question about it? Okay, fine, let's write some code. Okay. So here's insert, okay? It is, if the size is equal to oh, oh wait a minute. Wait a minute. This is, you know, we've got an array. It has fixed size. How big is that array ever going to be? Well, we don't know necessarily, but if that array is full, we better grow it somehow. Talk about that in a minute. Then we're going to increment the size. Increment the current biggest location. Place our value into that position. So that was putting the five at the end of the existing chunk of data in the previous example. And then we're going to call a helper function called heapifyUp from that last location. Okay? Any question about that? That's exactly what we did on the previous page. Now, I want to show you something truly beautiful. Okay? If the size is the same as capacity, it means the array is filled. So, our remedy is.. What is it? Double the size and copy the data. Right? So like this. Double the size and copy the data. Here's the beautiful thing. This is the thing that gives me goosebumps. Okay? Doubling the size means opening up the next row of the heap. Isn't that awesome? It's beautiful, right? We're so lucky. All right, any questions about it? Okay. So that's what we'll do. We'll open up the next row. We filled up this row, we'll double the size, copy the data it corresponds to, adding another row. Any questions about it? You're good? Okay, so let's talk about heapifyUp for a minute. Um. So, the cIndex is the current index and basically I want to know if I should keep going. I want to know if I should keep going, and so it's basically if the cIndex is greater than zero. And maybe it's one here, actually, because of our particular implementation. Okay? If the uh item at cIndex is what relative to its parent? If it is, it's less than its parent. Right? Because we're trying to move it up. So if it is less than its parent, then I'm going to call some swap function that swaps their keys. Swaps those keys. Uh, so maybe I'm going to swap items[cIndex] with items[parent(cIndex)], and then I'm going to call heapifyUp on the parent.
Ok,any question about it? Simple code, complex, complex ideas, simple code. Alright, any questions? You good? Ok I wanna start with remove, we've got, according to my watch, we have 3 minutes, and so I wann leave you,I wanna leave you hanging in the middle of remove min, ok? So where's the minimum, always? At the root, I will return it everytime. The heap is broken!! We have broken the heap by removing the minimum. What are we gonna do? It's like cutting off you're right an left arm. What on earth are we gonna do? We need some glue, we need some glue to glue it back together. Where might the glue come from? In this case, ok, so I am gonna do this in red, and that's a little bit of a hint, that is gonna get abrase later, ok? So, uhm, we might say: Oh look! we can just move 5 up, right? and then we can just move 9 up, right? and then we could just move 12 up. But then, its not a complete tree. Ohhh---, Ok, so I am gonna earse all that beacuse that breaks the completeness, which kind of breaks our whole reason for using the array to begin with, ok? The only element of the tree, the only node in the tree that I have easy acess to, that I can grab without breaking anything else is-11, ok? So, here's the justification, I know I need to remove something from the structure, I know I need to remove something from the structure. The easiest thing to remove from the whole thing is 11. So I am gonna remove 11 and use it as the glue, ok? where the thing I really wanna remove lives. Ok, so I am gonna remove 11, oops! I shouldnt do this part in red beacuse it's actually gonna work, usually. Ok? So we gonna remove 11, perfectly fine, use it as the glue up here, and we're good right? No! what are you gonna do? how are you gonna fix this? Swap 11 with- 5 in this example. In general, it's minimum child, ok? So we are gonna swap with the minimum child. So we swap 11 with 5, and then we swap 11 with 9. Oops! And then we swap 11 with 12. Uhm, No! no! no!, then we observe that 11 is greater than both of its parents, so we can quit, ok? Any question about that? yeah? Hey you guys! He can't talk if you are loud, go ahead. Not necessarily, not necessarily, and first of all, anytime you say the word shift", I am gonna go "hargh! hargh! hargh!, right? Uhm, but, but also you can also messed up the order by doing that: you dont know anything about the relative values of these keys with these keys. Alright see you next time, we will implement it next time.
Okay.. any question about it? Simple code, complex... complex ideas, simple code. Alright, any questions? You good? Okay. I wanna start with remove. We've got, according to my watch, we have three minutes and so I wanna leave you.. I wanna leave you hanging in the middle of removeMin, okay? So where's the minimum, always? At the root. Dunk! I'll.. I'll.. I'll return it every time. [GASP] The heap is broken! We have broken the heap by removing the minimum. What are we gonna do? It's like cutting off your right and left arms, what on earth are we gonna do? We need some glue. We need some glue to glue it back together. Where might the glue come from? In this case, okay so I'm gonna do this in red and that's a little bit of a hint that it's gonna get erased later. Okay? Okay? So.. uh.. we might say oh look! We can just move five up, right? And then we could just move nine up, right? And then we could just move twelve up, but then, it's not a complete tree! Ugh..... Okay. So I'm gonna erase all that cause that breaks the completeness which kind of breaks our whole reason for using the array to begin with. Okay. The only element of the tree, the only node in the tree that I have easy access to, that I can grab without breaking anything else is... eleven, okay? So here's.. here's the justification, I know I need to remove something from the structure, I know I need to remove something from the structure. The easiest thing to remove from the whole thing is eleven. So I'm gonna remove eleven and use it as the glue, okay. Where.. I.. where the thing I really want to ..[gibberish].. remove lives. Okay so I'm gonna remove eleven. Whoops. I shouldn't do this part in red cause it's actually gonna work. [Gibberish].. usually. Okay so we're gonna remove eleven. Perfectly fine. Use it as the glue up here. And we're good right? No..., what are you gonna do? How're you gonna fix this? Swap eleven with... five in this example, in general it's minimum child, okay. So we're gonna swap with the minimum child. So swap eleven with five. And then we swap eleven with nine. Oops. And then we swap eleven with twelve. Uh.. no. No. No. Then we observe that eleven is greater than both of its parents so we can quit, okay? Any question about that? Yeah? Okay you guys, he can't talk if you're loud. Go ahead. Not necessarily, not necessarily and first of all anytime you say the word shift, I'm gonna go [gibberish]... right? Um.. but, but also you can mess up the order by doing that. You don't know anything about the relative values of these keys with these keys, okay? Alright see you next time, we'll implement it next time.
Alright, let's start. I never get it, it must not me. Okay, um, I have no news on the exams. I just don't know yet. I was there yesterday afternoon, and there were still two blank columns or largely blank columns for problem 22 and 24 something like that. So I have absolutely no clue about averages. All I heard is we should draw a picture for perfectify. I don't know, I am not even make a promise when those exams are going to be available. Not gonna to promise anything because you know what course staff tole me. I said I want to get this done by Friday, we can get this done by Friday. And they said you shouldn't promise Friday. And I said no, if I promised Friday we will make it Friday. And they said you shouldn't promise Friday. And I completely ignore them, and they were right. So, I'm sorry. Always listen to the course staff. Hmmm.... Alright, um so, mp6, oh let's see there is a social announcement is the semi-formal tonight. Raise your hand if you're going to the semi-formal tester street art? Nobody in this room? It's like WCS, IEEE, ACM. Every student organizations between ECE department and CS department combing to do this fancy party tonight. Suppose to be really fun and I think they still have tickets. Look like there is about a hundred people going. So, including some cs225 course staff. So, you don't have anything do tonight um it's a facebook event you can get there. Is anybody going? really? nobody? Didn't know about it. Alright, nevermind, don't go. It's your thought there, what kind of party possibly be. Um, alright, let's see. So, give me one more description of that thing. It's heap, that's right that's a heap. A two words description, I want a two words description of the abstract data type where considering using a heap for? A priority queue, very good. So, this structure right here is our latest, greatest, attempt, and clever cause we are also clever implementation for a priority queue. okay? what uh abstract data type, I'm sorry, what implementation do we try before? What are we trying to improve over? Do you remember from last time? We first implement a priority queue with just give me one. A bag? right, yeah the bag didn't work out so well. What was the implementation? A linked list, sorted or unsorted? Either we try both. The other linear structure we try is an array. Sorted and unsorted. And those all you know they have things that we liked about and they also have things we didn't like about them. Alright, that's all about last lecture in the show right there. Alright, this thing is a heap, how do we implement it? how is the, what is the implementation of a heap? What structure did we use to implement a heap? An array, that's right. So that's a piece that the first length is a little counterintuitive because this thing is a binary tree right? And all the binary tree we talked about so far have tree node pointer, and been recursively traverse etc. This one is a little different. Characteristic of a heap allows that. Allows this implementation what characteristic of a heap allows an array based implementation.
[exam discussion] [social announcement] So, give me a one word description of that thing. It's a heap, that's right. A two-word description of the abstract data type we're considering using a heap for. A priority queue, very good. So, this structure right here is our latest, greatest attempt at a clever implementation for a priority queue. OKay? What implementations did we try before? What are we trying to improve over? Do you remember from last time? We first implemented a priority queue with...? A bag. Yeah, the bag didn't work out so well. What was the implementation? A linked list, sorted or unsorted? Either, we tried both, the other linear structure we tried as an array, sorted and unsorted and those all, you know they had things we liked about them, they also had things we didn't like about them. Alright, so that's all of last lecture in a nutshell, right there. Alright, so this thing is a heap, how do we implement it? What's the implementation of a heap? What structures did we use to implement a heap? An array. So that's a piece that at first glance is a little counter-intuitive. Because this thing is a binary tree, right? And all the binary trees we've talked about so far have had tree node pointers and have been recursively traversed, etc., and this one is a little bit different. What characteristic of a heap allows an array-based implementation?
What characteristic of a heap allows an array-based implementation? You've got it, yeah? That's right it is a complete tree. Now, what that means in fuzzy land is -you know- this tree has no gaps in it. It is like we took all our data and laid it out in level order until we ran out of data. Right? Okay, so it is the complete nature of this tree. Alright then finally, what is the characteristic ordering of a heap? How do you know when you look at this, that this thing is a heap? Yeah? Increasing, what's increasing? That's a key word, what's increasing? Uh, kind of. Yeah? Every path from... root to leaf. That's right. Every path from root to any leaf is an increasing path. Alright, so I am going to wave my magic wand here. For every observation we have made about these min heaps, we can make a parallel observations about max heaps. Alright, so there are parallel explanations for max heaps. And you may see them if you are doing online studying for things. Some people -almost no instructors will use both min and max heaps, but some instructors will use max heaps instead of min heaps. Okay, lets see. So, last time we talked about an algorithm for removing from such a structure, but we never wrote the code to do that. Alright, where's the minimum in the heap? Where's the minimum in the heap? At the root, that's right. It is always at the top. So, if one our functions in our abstract data type is remove min. All we have to do is grab that node from the top. Easy-peezy right? But the problem is, if we actually move it, we break the heap. So, our algorithm was tot take this last value, because it doesn't ruin the completeness of our tree to do so. Take that last value and swap its key up into the spot previously occupied with the minimum. Now, do you like that? Okay, you like it, but only partially like it, right? Cause in a way, it breaks the heap property of the tree. Yes, you see that? So do you remember how to fix it? Yeah, heapifyDown, that's right. So this notion of heapifying the tree is one of restoring this path ordering characteristic. So we are going to the heapify that 11 down. Should I swap a 5 or 6? I should swap with 5 because it is safe to put 5 above 6, but not safe to put six above five. So I am going to always swap with the minimum child. Alright, so 5 comes up 11 comes down. Swap with the minimum child. It is always safe to do so. 9 comes up 11 goes down, and then, 11 is smaller than either of its children, so we're done. Okay, any questions about that? Is it good? Okay, let's right some code, or at least look at some code. I can't remember how much is here.
what characteristic of a heap allows an array based implementation, got it? yeah. [student answer]. That's right it's a complete tree. now what that means in fuzzy land is you know this tree has no gaps in it, it's like we took all our data and laid it out in level order until we ran out of data", right? ok, so it's the complete nature of this tree. alright. and then finally, what is the characteristic ordering of a heap. how do you know, when you look at this, that this thing is a heap? do you know? increasing, what's increasing? that's a key word, what's increasing? kind of, yeah. every path from... root to leaf. that's right. every path from root to any leaf is an increasing path. alright, so i'm going to wave my magic wand here and uh... For every observation we've made about these mean heaps we can make a parallel observation about a max heap but i;m never gonna talk about max heaps, oh wait. alright, so, there are parallel explanations for max heaps and you may see them. you may see them in. um... if your doing online studying for things. some people, some instr... almost no instructors will use both min and max heaps, uh.. but some instructors will use max heaps instead of min heaps. okay! let's see. so. last time we talked about an algorithm for removing the minimum from such a structure but we never wrote the code to do that. alright, so, where's the minimum in the head? where's the minimum in the head? at the root, that's right. it's always at the top. so if one of our function in our abstract data type is remove min, that means all we have to do is grab that node from the top? easy peasy, right? but the problem is, if we actually remove it, we break the heap. ok. so our algorithm was to take this last value because it doesn't ruin the completeness of our tree to do so. take that last value and swap it's key up into the spot previously occupied by the minimum. okay. now do you like that? okay, you like it, but only partially like it, right? cause in a way it breaks the heap property of the tree, yes, you see that? so do you remember how to fix it? yeah. heapify down, that's right. so this notion of heapifying the try is one of restoring this path ordering characteristic. so we're going to heapify that' eleven down. should i swap a five or six? i should swap with five because it is save to put five above six but not safe to put six above five. so i'm going to always swap with the minimum child. alright, so five comes up, eleven comes down. swap with the minimum child, it's always safe to do, so nine comes up, eleven goes down and then eleven is smaller then either of it's children so we're done. ok. any questions about that? was it good? okay, let's write some code, or at least look at some code. I can't remember how much is here. ok.
So, our keys are type T here, and we are basically going to grab the root of the tree for returning. So, this is the value that we are going to return. Then, we are going to replace that value at the root with the last value. In this case, that was 4 replaced by 11. Then, we are going to decrement the size effectively removing the last element from the tree, but we have kept it, so we didn't remove it, we just removed something. And then, heapifyDown from the root, and then return that minimum value. Any question about that? Is it okay? Alright, so now lets do heapifyDown from an index. Now, keep in mind that that index is the location of the key. So we are always going to be comparing our array at location index to get the key values. So if cIndex has a child, what is has- oh- I'll ask that in a minute. For a minute, just assume that hasaChild just works. It will tell you true or false based on whether or not cIndex is a leaf. I could of put isALeaf there. If not isALeaf(cIndex), that would of been fine. It is just the opposite. Alright then, I am going to grab the index of the minimum child. Okay, so I am going to make this function deal with finding the minimum child. And we'll talk about why I did that in just a minute. And then if the location is okay- which way does this go? Which way does this go? If the thing we are heapifyingDown is... what inequality goes here? Greater than the minimum child than we should shove it down. Right? Good. Yes, if items[cIndex] is greater than the minimum child, then we should swap the values. So we should swap items[cIndex] with items[minChild]. Yeah, what? Alright, indexMin items[minChildIndex]. Ahh! Swap those two, and then heapifyDown on minChildIndex. Okay, does this seem okay? Okay, we used two helper functions to make this code look beautiful. Beautiful code at all costs and I am not actually going to expand this, but I am going to know what that code looks like. How am I going to check if cIndex has a child? Yes, Ian? Excellent, that's excellent. What is 2 times the current index? It is where the left child would be if it existed. So if that value is greater than the total number that we have, greater than size, there is no left child. And that is all that code is, so this is 2 times cIndex I should be able to spell that- greater than size. Or you could say- no you shouldn't say left child. You should say 2 times cIndex greater than size. Yeah?
yes. exactly, exactly. yeah, remember that this is a one based array, right, like that, starting the root at one gained us the efficiency of being able to use two cIndex, two times the index as our last child. that's in last lecture. ok. alright any other questions about... OH! I know. So. this min child. actually when i wrote this code. i think i remember spending the very most time debugging this part of the code. and the reason for that is because... notice that i don't deal with the case, at all, that it has only one child. right, i don't deal with that. that one strange incident. one strange case in a complete tree where there actually aren't even two children. i don't deal with that here, at all. i only deal with it in this function. so this function, minChild, actually hides this test to see if there are even are two children, and in either case, if there are only one child it returns it, if there are two it returns the minimum of the two. ok. alright and because of that little ugliness, i shoved it into the helper function. alright, any other questions about this code? what questions do you think i'm going to ask you? i've just shown you some code, what do you think, i'm going to ask you? exactly every good. what the running time of this, we've got the running time, we completely understand how it works. whats the running time of this thing? of removing something from a heap? logn, log n, and please justify that. the running time is big o of logn, O(Logn), because, that is the height of a complete tree. it happens to also be a lower bond. ok, any questions about that? ok. so, i love this discussion because, um, oops, wow. I love this discussion because our original goal here was to implement priority queue. our goal was to implement priority queues with the assumption that that abstract data type would some how be useful to us. ok. and we proposed a whole bunch of implementation. and this last one, that we'll actually compare more carefully to the other ones, a little bit later. this last one is a structure that is beautiful in it's own right called a heap. but a heap really has, you know we a discussion about implementing this implementation, right. and in the end the, uh, the heap was... the discussion about the heap was well should we implement is using pointer or as an array." and we decided it should be clever use of an array. and this notion that an abstract data type can actually lead to this sort of unfolding discussion of implementation in incre... decreasing abstraction more specificity is fascination to me. more over, there are tons of structures and algorithms for which priority queues are an extremely important, um, element. so for example the event queue in every single video game that ever exists. so this an event queue. uses a priority queue. it which one need to come next. it's the. it is prioritized by time. even if all the events were created at the same time it can be thrown into a priority queue so that the next one with respect to time could be handled. um. another application. i'll bet you won't be surprise that original systems that allocated memory, dynamic memory, used a priority queue, right. implemented as a heap, yes. i don't know if they put the priority queue level. but that, i bet they did. so memory allocation... where in this instance. the size of the block of memory to be used typically was, in very early implementation, when they were just doing things, um, sort of in an add... without a lot of resources. when they were just developing these algorithms. that memory allocation was based on how much memory a block of memory had. that size of the block. oh my gosh, english, speak english. ok, so the priority was the size the block there of memory. ok, another one is, oh your to do list. right. what key do you use for your todo list?
Due date, so you do next due next, the thing that is due next gets your attention. It's some strange weighted average, right? Of due next, worth most, you know. Oh, this, it's, like most, the one that makes you happiest. Oh that'll be us, you know. Um. Uh, alright. So, you know, this is this function that determines the keys, the ordering in the priority queue can be lots of different things. Also, when we talk about graph algorithms, we'll be using a priority queue to order the uh to order the uh to order the order. To plan the order in which we visit edges of a graph. So this is uh graph search. Graph algorithms in general tend to have a lot of priority queues. And that's foreshadowing. That's, where are we going with this? Why did we talk about it at all? Alright, any questions about that? So I love this. I love that it's a rich conversation that has many different levels. And yet, somehow inherently safe because it's just computer science, not it's not like philosophy. Alright, okay, so is that thing a heap? Is it? If I'm keying on the characters, the alphabetic order of the characters. No. What's your evidence? B U oh the U is greater than L and D, right? Okay. Alright, so I believe it. That that one is not a heap. Now what I want to know is what would be an algorithm for making that into a heap? What could you do? I'm giving you the data. You can assume basically that your data is laid out in array. Here's an array with all your data. Make it into a heap. What are you going to do? Yeah? Oh, why not sort it, right? You can use mergesort. Perfectly fine, perfectly reasonable idea. But we can do better. What is it mean to do better? What's the running time for mergesort? Big o of woah. Okay, you guys gotta write this down and put it on your mirror, okay? This can even if you don't know the proof of this, it should just roll right off. You can, you can be talking about stuff you don't know, but this one should just roll off. The running time of merge watch me get it wrong here the running time of mergesort worst case is nlog(n). So you're guaranteed nlog(n) for mergesort. It's not a great sort because it's very hard to do in place, especially if you're doing it in an array. But you actually did it in place in for mp3, I think, but your memory was all over the place. Alright, uh let's see. So, okay, so we could sort it, that would work. What else could we do? Yeah? Oh use heapify. How would you use heapify? What would you do? What is, what what how would you use heapify here? How would you use heapify? Oh, heapify down through the it turns out that doesn't work. Okay? Yeah? Very good, very good. So the other thing you can do is pretend like, pretend like this is just data that happens to be sitting in memory and do repeated insertion into the structure. So first we've got, an empty heap. And we're going to add B to it. Okay? Well, there. We did heapify up from here. Fine. Done. Then we're going to add U to it. And now we can look at this part and say okay that's a good heap. Then we can add I to it. And that's a heap. And then we add L to it, and what happens? No it's fine, this is fine. You have to swap, right, but you're inserting. So you get heapify up for free. So L and U should swap. Okay. And now that's a heap. And now everything up to here is a heap. Okay, so do you see how this would play out in the end? One at a time, you're just going to add each one of these. It's like uh you know however many vertices there are here, inserts into the structure. Okay, do you like that?
Due date so do you next, do next, the thing that is do next gets your attention. It's some strange weighted average, right? Of do next, worth most, you know. It's like most the one that makes you happiest, right? Well that'll be us, you know? Alright, so, this function that determines the keys in the ordering in the priority queue can be lots of different things. Also, when we talk about graph algorithms, we'll be using a priority queue to order the order to plan the order in which we visit edges of a graph. So this is graph search. Graph algorithms in general tend to have a lot of priority queues and that's foreshadowing. That's where are we going with this? Why did we talk about it at all? Alright, so any questions about that? I love this. I love that it's a rich conversation that has many different levels and yet somehow inherently safe because it's just computer science and not, like, philosophy. Alright, okay, so is that thing a heap? Is it? If I'm keying on the characters, the alphabetic order of the characters. No, and what's your evidence? The U is greater than L and D, right? Okay, alright, so I believe it. That that one is not a heap. Now what I wanna know is what would be an algorithm for making that into a heap? What could you do? I'm giving you the data, you can assume basically that your data is laid out in an array. Here is an array with all your data, make it into a heap. What are you gonna do? Yeah? Oh, why not sort it, right? You can use mergeSort perfectly fine, perfectly reasonable idea. But we can do better. What does it mean to do better? What's the running time for merge sort? Big O of? Whoa, okay, you guys gotta write this down and put it on your mirror, okay? Even if you don't know the proof of this, it should just roll right off. You can be talking about stuff you don't know but this one should roll off, okay? The running time of merge, watch me get it wrong here, the running of mergeSort, worst case, is nLogn. Okay? So you're guaranteed nLogn for mergeSort. It's a great sort because it's very hard to do in lace, especially if you're doing it in an array. You actually did it in place for MP3 I think, but your memory was all over the place. Alright, let's see. So, we can sort it, that would work. What else could we do? Yeah? Oh, use heapify! How would you use heapify? What would you do? What is, how would you use heapify here? How would you use heapify? Oh heapifyDown at the root? It turns out that doesn't work. Yeah? Very good, very good. So the other thing you can do is pretend like this is just data that happens to be sitting in memory and do repeated insertion into the structure. So first we've got an empty heap, and we're gonna add B to it. Okay? Well, there we did heapifyUp from here, fine, done. Then we're gonna add U to it and now we can look at this part and say okay that's a good heap. Then we can add I to it and that's a heap. And then we add L to it and what happens? No, it's fine, this is fine. You have to swap, right? But you're inserting so you get heapifyUp for free so L and U should swap, okay. And now that's a heap. Now everything up to here is heap. Okay, so do you see how this would play out in the end? One at a time, you're just gonna add each one of these. It's like however many vertices there are here inserts into the structure. Okay, do you like that?
Yeah, Nathan what are you thinking? It is also n log n, good observation. Yeah this is n log n. Now let's talk about why, okay? Let's talk about why. This you're affectedly calling heapify up, yes? And you're going to call it on every single piece of data, okay? Look at all of these leaves down here for they're going have to make a trip. Potentially, all the way up the tree right? Each one of these, so that's a lot. This is like effetely have data, could be have a data. And they're going to go all the way up the tree. So that is, big O of n log n because it's n/2 things or big O of n things each of which go log n of the tree okay? Alright that's not satisfy, so why are we having this conversation if the best you can do is n log n? okay, so......it isn't the best you can do. what is better? what's better than n log n? Big O of n that's right. What are we going for is the ability to take a an array of data like this and create a heap out of it in linear time. Alright, so, I have a way of uh.. kind of giving you a hint about this. Uh, I need a volunteer. Any volunteer to come to the front of the room? This make this thing up on a Friday. Hurry up, now, yes you know you want to do it. Raise your hand if you want to do it you are kind of afraid to. Raise your hand if you're afraid to raise your hand that you're afraid. Okay, you're up. Okay, and what I want you to do is point not to, well, you can choose whether point to the n-tree in the array or a vertex in the heap that is already a heap. It's already a heap. A root of some subtree which is already a heap. D, okay, that's lucky. Alright, D is already a heap right? Okay, fine uh point to another one. That's already a heap. okay good H is already a heap. Point to another one. This is a lot of pressure isn't it? I will giving you hint, there aren't any more higher up the tree. Okay, very good, no no no, higher up of the tree. You're not done! There are no more higher up of the tree. Oh! look those, all of those are already heaps. Okay good, thank you. Oh yes, they're already heaps. Do you see that? Yes, thank you very much for doing that. Do you see they're already heaps? And they're guarantee to be heaps right? Where as D is just lucky and H is just lucky. So the leaves are already heaps. Okay? Alright, so stop me when I running to a node that is no longer heap. You're heap, you're heap, you're heap,you're heap you're heap, this one is already a heap right? These are already heaps, yeah? How about L? Is L already....thank you. How can I fix it? How can I make it so that this node this vertex right here might hold different key, but it is the root of something that is already a heap. Do heapify......down. Let's right, heapify down on L. Okay? Heapify down on L. What happens? A comes up. Okay fine, then we have to do it here heapify down on I. Then we have to do it here heapify down on U. And then eventually heapify down on B. Okay? Any question about that? Is this n log n? Feels like it could be right? Feels like it could be because B is trip to the bottom could go all the way down, B could go all the way, this could've been a Z sitting here right? B could go all the way down to the bottom. The difference in this case is, only one vertex that has to go all the way to the bottom, instead of all the leaves have to come up in the other instance. So, let's see if this actually does our linear running time. Before we do that, here are the three things, here are the three alternative. That was going to planing on my part, there is answers on the other side. Okay, sort the array big O of n log n okay. Sort the array, and then you can argue. uh oh, No, don't say the class is over. No.....no no no. It's not that much Friday.
And nathan what are you thinking? It is also n log n, yea this is nlog n, Lets talk about why. You're effectively calling heapify up and you are going to call it on every single piece of data. Look at all of these leaves down here that are going to have to make a trip all the way up the tree, right? But this is what you successfully have the data and they are going to go all the way up the tree. So that is, you go up log(n) cause this is n over two things or big oh of n things each of which goes log(n) up the tree. Alright so that is not satisfying so why are we having this if the best we can do is nlog(n)? Okay, So It is the best we can do, what is better? What's better than nlogn what we are going for is the ability to take an array of data like this and create a heap out of this in linear time. So i have a way of giving you a hint about this. I need a volunteer. I need a volunteer to come to the front of the room. Oh this is good on a Friday, hurry up, now you know you want to do it. You are just kind of afraid to. Raise your hand if you are afraid to raise your hand because you are afraid. Okay you are up. Okay. Now what I want you to do is point not to well you can choose what you point to between entry in the array or a vertex in the heap that is already a heap. It is already a heap, so the root of a sub tree that is already a heap. Okay that is what good alright, so d is already a heap right, okay fine. Put another one. That's already a heap. Okay good h is already a heap, so point to another one. This is a lot of pressure isn't, Ill give you a hit there are more higher up in the tree. Okay, Very good no no. Higher up in the tree. There are no more higher up in the tree. All of those are already heaps okay good, thank you. Yeah they are already heaps. Can you see that? yeah thank you very much. Can you see that they are already heaps? And they are very cheap heaps. Right? You know with H are just blocks. The leaves are already heaps. So that means when I run into a node that is no longer a heap. This one is already a heap, Already a heap. How about L, is L already a heap? Thank you. How can I fix this? How can make it so that this node this vertex right here, might hold a different key, but it is the root of something that is already a heap. Heapify Down that's right. Heapify Down on L. Okay? Heapify Down on L. A comes up, right? Okay fine, then we have to do it here, heapify down on I. Then we have to do it here, heapify down on U then on V. Okay? Any question about that? Is this nlog(n)? Feels like it could be right? It feels it could be because V's trip to the bottom is going to to go all the way down. This could go all the way down to the bottom. The difference in this case is only vertex that has to go all the way to the bottom. Instead of all of the leaves coming up in the other instance. Okay? So let's see if this actually gets us linear running time. Okay? Before we do that here are the three things. Here are the three alternatives. That is good planning on my part. Have the answers on the other side. Okay, sort the array big oh of nlog(n). Sort the array, then you can argue. Uh oh. No don't you cross over. Huuuh. Nooooooooo. Noooooo nooo nooo. It's not that kind of Friday.
haha just a minute alright
2 to the h plus one. I can do this really fast. 2-h uh. Alright, any questions about it? It's like the easiest time to [gibberish]. Somebody magically gave you the answers. Okay? Alright, but we don't want this thing in terms of h we want it in terms of n. So what we know is that umm that height is big oh of log(n). Or n is greater than or equal to two to the n. I can do this. So h equals. What's the exact expression for h. h is at least [gibberish]. I'm going to do it like this. Ill figure out the inequalities in a minute. So I know s(h) so it is the sum of the pathways is equal to 2 to the h plus one. minus 2 minus h. But I also know that h is at most some constant time log(n) and so this thing is at most 2 to the constant time log(n) plus 1 minus 2 minus constant time for log(n) yeah. Okay which is we do all of this math big oh of n. The only salient piece is this first term. Only salient piece is this first term. Oh the big C matters in this case. I'm going to figure this out. I am. I think I have to do that. Alright. Only one more little thing. So. Here is what I want to do. I made a heap and now I want to use that heap so that the data can be skimmed in a particular order. I started off data in no particular order. And [gibberish] and then I built a heap out of it. Now I want to view this heap to sort of finish the sorting of the the sorting of original data that was in no particular order. How would I do that? How might I do that. How would I sort this thing. What could I do? How do I get this data from that. I mean yes. I think the biggest hint I have is selection sort if you remember correctly remember selection sort? Without a heap how can I create. I can make another array if I want to. How can I make a sorted array if I got a heap?
It's two to the h plus one. I can do this really fast. Minus one. Minus eight. Alright. Any question about it? It is the easiest the indeption you need to do. It is easy recurrsion. Somebody magically gave you the answer. Just to prove it is true. But, we don't want this thing in turns of h, we want this thing in turns of n. So what we know is that the height is O(log(n)). So I know the s of h which is the sum of the path length is equal to two to the h+1-2-h, but I also know that h is at most some constant times log(n) there. So this thing is at most two to the c*log(n)+1 minus one minus c*log(n). If you do all the math O(n), the only failure piece is this first term. Here is what I wanted to do. I made a heap and now I want to use that heap. So I started of with data that was in no particular order. I started of with data that was in no particular order. And then I build up a heap out of it. I want to use that heap to finishing sorting of that data that was in no particular order from which I built a heap. How may I do that? I wanna sort using this thing. How do I get sorted data from the heap. I think the biggest hint I have is selection sort if you remember selection sort. How can I make a sorted array if I got a heap?
you guys are thinking way too hard. the heap past to function has insert and removed min. Remove min... etc.. until you are down. Remove the minimum, remove the next minimum, remove the next minimum. So, this is the sorting algorithm. I'm gonna talk about the benefit in just a minute. So the first thing you wanna do is with your data that came in unsorted. So this is given and unsorted array. First thing you wanna do is build the heap. Okay. Now. If I remove the minimum, if I remove A what am I gonna do with it where am I gonna put it? In front of some other array. Build it up. Now it will be fine. I don't wanna use the space so where is the room for A? If I remove A, if I pull A off, first thing I'm gonna do is get rid of w so I can use it to plug in for whole, So guess what. I have room for A so I'm gonna put it here. So do that again, remove it. Then B's gonna be here eventually then remove the minimum. We have room and B's gonna be here. This is a do a repeated remove min, keeping values in the structure. And then the last thing is you wanna reverse the order of your array if you want it to be an increasing order. What's the running time of each of the step? Running time of step 1 is big o of n. We just showed it. We almost showed it. Repeated remove min. Darn it. This is not better than n log n. And then to reverse the array is big o of n. The whole running time is big o nlogn. We don't need another one because this one is in place sort with worst case nlogn, whereas quicksort dosen't give you worst case nlogn. I have one last thing before you go because it's fun. Why did I choose this picture for our closing thought? it's a fun a picture but why is it for today? When you are together with your friend and you decided to make a human pyramid. Who goes on top? The lightest person. So this is like a physical representation of heap. We will talk about it next time.
are thinking way too hard. The heap has two functions: it has insert and it has removemin. yeah? yeah, removemin. removemin. removemin, etc. until you're done. remove the minimum, remove the next minimum, remove the next minimum. alright! this is a sorting algorithm. so, the and I'm gonna talk about the benefits the running time the benefits in just a minute. um, so the first thing is to... the first thing you wanna do with your data that came in unsorted so this is given an unsorted array first thing you wanna do is build a heap. mkay. now, if I remove the minimum, if I remove A, what am I gonna do with it? Where should I put it? in the front of some other array, right? build it up, that'll be fine. but you know what? I don't wanna use this space? so where is there room for A? yeah, look! if I remove A, if I pull A off, first thing I'm gonna do is swap up W, right? I'm gonna get rid of W so I can use it for plugging the hole. so guess what? I have room for A. so I'm gonna go ahead and put it here. okay? and then do that again, remove then B is gonna be here eventually, then remove the minimum. we have room and so B is gonna be here. okay? so this is do a repeated removemin... uh, keeping values in the structure.and then the last thing is you might want to reverse the order of the array if, if you wanted it to be an increasing order. so you might want to reverse if you depending on what sorted order you want. okay, and what's the running time of each of those steps? running time step one is O(n), we just showed it. we just well, haha, almost showed it. repeated removemin, darn it. this one isn't better than nlogn. this one is, you know, you may have to lots of data may have to go pretty far. and then to reverse the array is again O(n). so the whole running time is O(nlogn). and the answer to why did we need another is that this one is an in-place sort. with worst case nlogn, whereas quicksort doesn't get you uh worst-case nlogn. okay, it does it in place, but not worst-case nlogn. okay, alright, I have one last thing before you go 'cause it's fun. we'll uh why did I choose this picture for our closing thought? it's a fun picture, right. but why is it the picture for today? when you're together with your friends, not at the semi-formal, and you decide to make and you decide to make a human pyramid, who goes on top? the lightest person, right? who's on the next layer? the next-lightest. so this is like a physical manifestation of a heap. there you go, it's not quite right though, we'll talk about it next time. alright, bye. what's up? I decrement size, but I'm not freeing the memory, so um what I'm doing by decrementing size is kind of moving that wall over. so that I don't in fact that, that, that means that space is available to me. yeah. yup. has a child, it has this code. oh, it has that, oh yeah, you're right, you're totally right. it's less than or equal to, right? yeah. yeah, oh, is it, okay. yes, there. okay. uh huh. about what? oh yeah. yeah. it's like. okay. so I can say less than or equal to. logn. okay, excellent, okay. thank you. that was exactly what I was gonna untangle.
Ok. So lets start. I'm waiting for a. Well, I'll tell you configuring update for win 10. 96% complete do not turn off your computer. I have high hopes. There is a second to go with 70% complete. Alright. I have new update on the exam. Thank you. But I do have quadruplet battery. Do you know quadruplet battery exist? I don't know. And there are like tiny. Thank you. Let's see. Updating windows. 0% percent. Your pc will restart several times. Ok you have handouts. We are gonna do this. We can do this. This is ok. MP6 is due tomorrow night. Let's see. Grading has been happening. So you should get some feedback on how it's going generally or have available to you some feedback on how it's going generally. Alright, so. Oh Mattox Thank you very much. And the question is can I do anything about my machine? Oh good. Eight. Alright. So there's a picture on slide one. And there are some blanks following it. I want you to get into the zone and figure out what that at the bottom is intend to say, so this is the fill in the blanks exercise at the bottom of the first slide. Raise your hand if you make a human pyramid this weekend. Just to see. Oh no. Nobody. Gosh. Just to see what is was like. If you don't know what the heck I'm getting at here. Please to feel free to wander around looking for somebody who has a clue what I'm getting at with that particular picture using that particular context. Sixteen. Raise your hand if you have written a word in some blank. Ok. Ten percent. Way to go. Come on guys. You can do this. What word goes there? Very good. Will you say that first word into the mic? Heap. There you go. Thank you. Excuse me while I change the battery in my pen. Did you replace battery in your pen? I was gonna give you my another one do you want it? Alright. How's it going? You should be approximately one forth of the way through your dots cause that's how far it's to your blank. Cause that's how far I'm through my updates. I'm making you nervous. It's my job to make you nervous. What abstract data type have we been working on? Priority queue. That's correct. Very good. That's the thought too. Ye Barbecue that right. Anybody has questions about it? What are the two main functions of a priority queue? First one is. Insert is correct cause we have to be able to get some data into it. And of course if you have insert, you'll have remove right? RemoveMin is correct or removeMax.
okay um
Alright fine, what are the running times of those functions? Oh, they are Big O of n, but you can say something tighter. You can say something faster. So remember, Big O of something is like less then or equal to, and so yes, you could say that they're Big O of 2^n too. The question is what's the very least thing you can say, what's the very tightest thing you can say, log(n) is correct, that's right, we showed, we argued that these things run in time log(n) because the height of the tree is log(n) and the navigation for the code is the height of the tree. OK, fine, this structure can be built in time, how long does it take to build a heap out of previously unordered data, do you remember? This was all of last time's class, pretty much, or a huge portion of last times class meeting. Yes, linear time, so we can build a heap really really quickly. Big O of n is the next blank and that helps us do it's the first step in doing a sort, an in-place sort called heap sort, and the running time of that in-place heap sort is nlog(n). That's right. Good. So that's the summary of last time, anybody want to close the loop for me on why the picture reminds us of a heap? Yeah, if you build a human pyramid, you put the lightest person on top. That's right. And if they get removed, then you have somebody climb up to be, wait no, not that. Ok, let me see how were doing here, oh my gosh, oh it's going to be a long day, OK, so I'm actually flipping my page, if I were on, if I actually had my laptop, I would advance the slide, and so you're going to move to the slide that says remembering CS 173. DUN! DUN! DUN! and the verbage says let r be an equivalence relation, raise your hand if your stomach turned just a little bit there. On the set of students in this room, OK, I say a couple hands go up over there. Hey, so we have an equivalence relation on us, except that I'm not a student, so on you, there's an equivalence relation where any pair of you are related to one another if you have the same favorite among this set. Now, before we actually talk about the equivalence relation itself, I want you to help me figure out what goes in the blank in that set. What goes in the blank in that set? So I, the set contains a,fb,tr,cc,pmc what's the last one? It depends what those other's are right? There might be an obvious one if you can figure what those others are. fb is not Facebook, though it might be I guess, no its not Facebook. Its not football either. First blood, did you say first blood? That's what we say when you guys are taking exams if somebody finishes their exam and leaves the room, we call it first blood. yeah. Is it cruel, I don't know, it's funny it's like a little incite, what are these things? what's cc, not carbon copy, what is cc? name something that's cc. Closed caption, not carbon copy, not closed caption, not nearly so boring, these are fun, come on! that's a big hint. What did you say? Captain crunch, so you think they're cereals, no. That would have been good though, next year I'll do that. What are they?
I'll give you a hint. the A used to be a B. oh. but I changed it to A for this year. and we're at 83 percent. yeah? what? oh, jeez. yeah. it's rather embarrassing actually. we'll talk about it later. okay. alright, what are these things? c'mon, we gotta get going. what's CC? you can get this. creep what? creepy commune, no. no. alright, fine. how about PMC? how about just MC? you know what? this tells me you work too hard. is that a clue? it's a clue. anybody have something for me, any guesses? master summaries, no. these are fun. oh it is? what? they're not beers, darn. next year. no, cause that's just a that's just like an old fart trying to be cool. like if I use a lot of beers in here, it's just I'm just trying to be cool, right? so no, this is way more fun than that. we got nothing? I'm not gonna tell you. I'm just not. alright, so just choose one, just choose choose one that you think might be your favorite. choose one you think might be your favorite. now, uh I wanna talk to you if you decide arbitrarily and I'm not telling you what you have chosen here. uh if you think your favorite might be uh denoted by A. okay? alright. so I have the two of you. guess what? since you both chose A, you are related to one another under this equivalence relation. okay? now uh that means that you are part of the same equivalence class, okay? so everybody who chose A relate raise your hands please. everybody who chooses A. just the two of you? I don't even believe it. okay, it's your grade for this class, how about that? alright, there you go. we're at 97 percent, thank god. yeah, about. alright. uh, okay, so they're related to one another. now, are you related to anybody else under this equivalence relation? oh, anyone else who has a different favorite. no, the answer is no. so nobody is related to anybody else who has a different favorite among the elements of this set. it's killing you, isn't it? I'm not telling you, I'm not. I'm not gonna tell you. oh. I need to be able to write. I don't know. companies? no. The machine is dead. it's dead. fine, oh. yeah but. we've updated your PC. all your files are exactly where you left them. I am so sorry, you guys. but I can't have them apparently. not Apple, full banana, there is ref uh. oh I removed a reference to fruit, though. yeah. I took one out that was that had the word fruit in it. it was FN. yeah. who said they're games? yeah. yeah, they're games. they're games. A is agario, duh. oh. I took out fruit ninja. 'cause it's old, right? so what's FB? what's TR? or temple run, right? okay, what's CC then? or candy crush or? cookie crunch. cookie crush. cook or candy crush wait. CC is like all of them or something. PMC? no. candy crush I think is what I intended. alright this is just we've got some feet newf let's start. oh yes, let's. I'm so sorry you guys. okay. alright. oh, I'm cortana, ask me anything. this is gonna be awesome.
I'll give you a hint, the A used to be a B. But I changed it to A for this year. And we're at 83%. Yeah? What? Oh. Geez. huh. Yeah. It's rather embarrasing actually. Okay. What are these things? We've got to get going. What's CC? You can get this! Creep what? Creepy Commune? No! No. Alright. fine. How about PMT? How about just MC? You know what? This tells me you work too hard! Is that a clue? It's a clue! Anyone have something for me? Any Guesses? Master of Ceremonies? No, these are fun! They're not beers! Darn! Next year! No, cuz that's just like an old fart just trying to be cool. Like if I use a lot of beers in here, I'm just trying to be cool. So no, this is way more fun than that! Ain't got nothing? I'm not going to tell you. I'm just not. Just choose one that might be your. Just choose one that you think might be your favorite. Okay now, I want to talk to you if you decide arbitrarily and I'm not telling you what you have chosen here. If you think your favorite might be denoted by A, okay? Okay, so I have the two of you. Since you both chose A, you are related to one another under this equivalence relation. Okay, now that means you are part of the same equivalence class. So everyone who chose A, raise your hands please. Everybody who chooses A. Just the two of you? I don't even believe it. Okay its your grade for this class. How about that? There you go! We're at 97%! Thank god! Yeah, about. Alright. Okay, so they're related to one another. Now, are you related to anybody else under this equivalence relation? Oh, anyone else who has a different favorite. No! The answer is no! So, nobody is related to anybody else who has a different favorite among the elements of this set. It's killing me isn't. I'm not telling you! I'm not!I need to be able to write. I don't know. My whole machine is dead! It's dead! Oh. Yeah but. We've updated your PC! All your files are exactly where you left them! I am so sorry you guys. But I can't have them apparently. Not apple, full banana. Uhhh. Oh I removed a reference to fruits though. Yeah. I took one out that had the word fruit in it. It was FN. Yeah. Who said they're games? yeah! They're games! A is Agar.io duh. ohhh! I took out fruit ninja cuz it's old right? So what's FB? What's TR? or? Temple Run! Okay, what's CC then? or? Candy Crush or? Cookie Crunch? Cookie Crush? or Candy Crush? Wait? CC is like all of them or something. PMC? Alright, this is just, we've got some. Lets! I'm so sorry you guys. Alright. Ohh! I'm Cortana! Ask me anything. This is going to be awesome.
I owe you twenty minutes of your life I'm so sorry. Alright, Aight sooo, (s,t) is O and my pen works. (s,t) is an set of element R so equivalent relations are just sets of pairs of things that are related to one another. If these two students have the same favorite among all of those so I used to do this. I used to do that and I'm thinking that that's still like, you know, is there anything that is better than plants verses zombies? I dont know, I don't know. So a couple of you one of your initials. a, m, and and who, what're your initials, AB? These two students told me that they shared an affinity for a agario. They didn't know that that's what they were doing, so what i want to point out to you at this point is that there are lots of different ways of representing an equivalent relation. One of them is the a set of pairs, where the set of pairs have a particular characteristics. And those characteristics are the pairs are reflexive, symmetric, and transitive. RIght? Remember all that? Okay, so now what I want you to do is raise your hand if A is your favorite among those video games, those handheld games. Okay, what are you initials? Also AB? Okay I'm going to make you the OAB, and know that he's related to everybody else in the set, right? no matter what, take somebody else? One more person for whom agario is the best ever? Ok, I'm going to make somebody up, this is our local ghost, and note that that person or that ghost, that entity will be related to everybody else in that set. Okay? Now, among these choices what, oh raise your hand if your favorite is flappy birds. Okay, there's a bunch of you right? How would you characterize if I drew that graph, that graph represented your collective relationships, how would you describe that graph? It is a complete graph, right? Can you see? A graph containing every possible edge, and tons of students, we could figure out how many as to there are, we don't have time for this. Okay? But that's the complete graph, and the key thing to observe is there is no edge that crosses over from one complete subgraph to the other. Such an edge doesn't exist. Alright, and moreover we could make a set of things corresponding to the temple run people, and the cookie clicker people, who don't want to admit people, and the pocket minecraft people, but oh, did I not say that yet? The p is confusing, if I just put mc it woulda been oky? Okay any question about that? Now, the fact that I, moreover, moreover if I say choose a favorite, choose a favorite from among that set, then I can rest assured that everybody in this room will be in one of the subsets. Yes? Right? because I'm going to insist. Do you like any of those game? laughs". Do you like any of those games? Who doesn't like any of those games? I insist that you choose one though. so I'm asking a question that I can be assured that everybody in this room, as begrudgingly as they may be, they would have an entry somewhere, a vertex, somewhere on this table. What I'd like to point out is that on this diagram here, on this roughly sketched out diagram is a collection of disjoint sets. Okay, representing
BLANK I owe you twenty minutes of your life, I am so sorry, alright so on my pen works, life is good s and t are elements of set R so equivalent relations are just a set of pairs of things are related to on another if these two students have the same favorite among all of those so I used to do this I used to do that and I am thinking that that's still like you know is there anything better than plants vs zombies I don't know so a couple of you, what are you initials AM, what are your initials? AB? OK These two students told me that they shared an affinity for a Garrio they didn't know that's what they were doing so I want to point out to you at this point is that there are lots of ways of representing equivalent relations one of them is via a set of pairs where the set of pairs have particular relations particular characteristics and those characteristics are the pairs are reflexive, symmetric and transitive remember all of that? so now. what I want you to do is to raise your hands if A is among your favorite video games what are your initials? also AB? So I will make you the other AB And note he is related to everybody else in the set no matter what somebody else, one more person for Garrio is the best ever? OK, I am gonna make somebody up This is out local ghost Note that person or that ghost that entity would be related to everybody else in that set among these choices raise your hands if your favorite is flappy birds ok, there are a bunch of you right? How would you characterize if I drew the graph that represented your collection of relationships how would you describe that graph it is a complete graph so it is a graph containing every possible edge and there are tons of students and we can figure out how many edges there are oh my, we don't have time for this but it's a complete graph and the key thing to observe is there is no edge that crosses over from one complete subgraph to the other so such an edge does not exist and more over we could make a set of things corresponding to Temple Run people and the Cookie Clicker people who don't want to admit it, pocket minecraft people didn't I not say that yet? It is the P confusing, if I just left MC it would have been ok? Any question about that? now and moreover if I say choose a favorite from among that set that I can rest assured that everybody in this room will be in one of these subsets, yes? because I am gonna insist? Do you like any of those games? Who doesn't like any of those games? I insist that you choose one though I am asking a question where I can be sure that everybody in this room as grudgingly as they may be would have an entry somewhere have a vertex somewhere on this table on this slide ok? Alright, any question about that? What I would like to point out is that the diagram here the roughly sketched nervous diagram is a collection of disjoint set, representing
the equivalence relation now every equivalence relation has a set of equivalence classes now the notation for math says that you take the square brackets you denote what relation what you are talking about and you throw between the square brackets some representative of the set. so for example if i am expressing if i want this equivalence relation to represent that set then i would throw the student into other ab the student into the square brackets and what we would understand that means the set of everybody that is related to oab under the equivalence relate. now what is the difference between that set and this one what's the difference between that set and this one what's the difference say nothing there is no difference those are the same set right and so it feels like it feels like by choosing this person i playing favorites a little bit right oh i prefer you over the ghost right but in fact the identifier that you happen to choose to represent the group is somewhat arbitrary. it could be any it could have been any of those students all we mean by a choice here is the collection of people who are related to this student any question about that it could be anybody it doesn't have to be any of these two it could be am or ab or anybody else who like agario any question about that and that's notation for math that is not i am not making that up that probably came from 173 okay. one more thing to point out is that really there is nothing in the mathematics that indicates the names of the games usually when we talk about equivalence relations we just use the identifiers that correspond to the domain of the relation that is we use the identifier of the students in this example. the games itself they don't appear in the math i put them here the equivalence relation would not change a bit if i erased all of these little helps at understanding and understanding diagram okay any question about that so really there isn't a lot of meaning necessary to equivalence relation except to say that these pretty much the same these are all pretty much the same etc.. that additional meaning is not part of the math is part of the application ohhh okay alright. one more thing okay, so we are going to create and abstract data type that will help us ahh maintaining an equivalence relation okay. we are going to define and maintain an equivalence relation across the members of some set so what that means for example is that i would be able to tell immediately given a student what their membership was across the collection of sets okay and in fact one key thing what we wanna be able to do is given two students tell immediately whether they are in the same set the same disjoint sub okay set any questions about that this is supposed to be just kind of reminding you about how these things work okay. and sort of setting us up for umm for actually working with that abstract data type okay so that is the intro let's do some examples oh i didn't change all of the sets i only got the first page alright, so R is the same equivalence relation but i have chosen about oh looks like about 10 students and i am drawing the picture a little more carefully i think so here is what i want to be able to do i want to be able to use to functions one is find and ah and one is union now if i say find 4 what are you going to do
The equivalence relation. Now, every equivalence relation has a set of equivalence classes; the notation for math says that you take these square brackets, denote which relation you're talking about, and you throw between the square brackets the representative of the set. So, for example, if I'm expressing this equivalence relation to represent that set, then I would throw the student into the square brackets and what we would understand is that that means that set of everybody that is related to OAB under the equivalence relation, okay? Now, what's the difference between that set and this one? There is no difference; as they are in the same set. It feels like choosing the person I'm playing favorites; but, in fact, the identifier that you happen to choose the group is somewhat arbitrary it could have been any one of those students. All we mean by a choice here is a collection of people who are related to this student, and it could be anybody. That's the notation for math; I'm not makin' that up. It probably came from CS173! Okay, one more thing to point out is that there is nothing in the mathematics that indicates the names of the games. Usually when we talk about equivalence relations, we just use the identifiers that correspond to the domain of the relation; that is, we use the identifiers of the students in this example. The games themselves don't appear in the math. I put this here the equivalence relation would not change if I erased all of these little helpers at understanding the diagram. There isn't a lot of meaning to an equivalence relation except to say that these are all pretty much the same, these are all pretty much the same, etc. That additional meaning is not part of the math it's part of the application. Okay, alright, one more thing. We will create an abstract data type(ADT) that will help us maintain an equivalence relation. Let's define and maintain an equivalence relation across the members of some set. So, what that means, for example, is that I would be able to tell immediately, given a student, what their membership was across the collection of sets. And in fact, one key thing that we're gonna wanna be able to do; given two students, is to tell immediately whether they are in the same disjoint subset. This is supposed to be just kind of reminding you about how these things work, and it sets us up for actually working with this abstract data type. Okay, that's the intro. Let's do some examples. R is the same equivalence relation, but I have chosen only about ten students. I'm drawing the picture a little more carefully here(I think). Here's what I want to be able to do: I want to be able to use two functions one is find(), and one is union(). If I say find(4), what will you do?
You want to go, there it is! Right? It's right there. I see it. What I really mean by find(4) in this context is, tell me what its equivalence class is. Tell me some representative of the set in which it resides. So this is very different than find from the past, right? In the past when we did find, we pointed right to it, or return its key. We're gonna do something different here. In this case, you are going to return, you're gonna return a representative from the set containing 0, 1, 4 and 8, and anyone of them is fine. Wow, what? Okay. Okay? Anyone of them is fine. Feels very ill defined at this moment. What must be true, I'll answer your question in just a minute. What must be true, is if two things are in the same set, they must return the same representative. So I don't care which one of these you use to represent this set. But I want to be sure of, is if two things are in the same set, it will tell you. You will get a true because the representative is the same. Okay, was there a question? Did you have a question? Yeah. I can return 4, yeah. Yeah, it does, doesn't it. But when when I do a find(8), then I can't return 8, okay? So sure I can return 4 but that means I am gonna know when I know where 8 is, then its representative is 4. Mike? Yes. Okay, so the question is what if you have a 12 and it belongs to the blue and green. It can not. 12 can not be an element in two different equivalence classes. Equivalence classes partition set. There is no intersection, the intersection between every pair of set are disjoint, are empty. Okay, is that clear? Alright, so good question, I am glad you ask it. But that can not be, okay? Alright, fine. Here is an example of typical use of this structure. If it's not the case that 7 and 2 are in the same set. If it's not, if 7 and 2 are in different sets, then take the union of the sets represented by the find(7), and the find(2). So take the union of these two sets. Alright, so find(7) is going to essentially give us some representative of that set. Find(2) is going to give us some representative of that set. They can not be the same because these are disjoint sets. And so we are going to, as a result, the then" is going to be to take the union of these things. Now we are going to assume that find, I am sorry, the union operates on representatives. So assume the union operates on reps. Representative. Any question about that. Alright, fine. Here is little bit of a more formal description of the abstract data type. Each set has a rep, so we are going to maintain a collection of disjoint sets. In this example here, we have three of them. We have three of them, obviously. Each set has some representative member, we are not gonna to try to prescribe who that is. We are gonna let that, just kind of flow out of the application somehow, the implementation somehow. And we need to be able to support the following functions. We are gonna need to make a set, from a particular key. So this is a key. We are going to need to be able to take the union of two things, where these things are representatives. Okay? Sometimes you don't have to, sometimes you can just. Well, we'll talk about that later. And then find will return a representative.
Just like we said before. Okay, so I thought about this for a minute and I came up with this idea for a data structure to support this abstract data type. I set up this example into an array where every array entry is an identifier for one of the elements in the set. Now that's perfectly reasonable to do because we could either make this an associative array or we could keep a map of each of these identifiers to a richer key type. So it's pretty reasonable, actually, to be able to say, Well, I'm gonna use the indices as indicators, as element identifiers." Okay? So the indices are element identifiers and now, take a look. 0, 1, and 4 have 0 as their data indicating that they all belong to 0's set. So in this case, 0 is the representative. Any question about that? Is it good? Okay, and you can see 2 and 7, oh look, and then 3, 5, and 6 perfectly fine. Alright, so what I want to know is from you what is the find algorithm? So I want to know a representative of the set containing 5. I wanna know a representative of the set containing 5. How fast can you give it to me? Some representative of the set containing 5. Okay, well, I've got it stored here, that's true, but 5 itself is, too, but then I can't be sure if I use those, then I can't be sure 3 and 5 have the same representative, right? So, if I ask for the find of 5, I'm going return 3. How long does that take? Constant time, that's right. So, I can, if I get things set up like this, then I can implement find in constant time, because the find of 5 will return 3. Any question about that? Yeah? Yep, these are the indices, I'm going to call them IDs, but they're just indices, and then these are the representative here. Reps. Okay? Any question about that? Now that seems to work pretty great, right? Now, how about if I take a union? Uh, I don't know, it doesn't really matter. We're going to take a union of those two. So this is going to be the union of the find of 1, and the find of 2. Because I want to take unions of representatives. Just clean to do it that way. Alright, how do I go that in this case? What's my algorithm going to be? Yeah? Yeah, so I'm going to change the representative of the sets to be the same. That's right, they all have to have the same representative. I don't care which one it is but they all have to have the same one. Okay, fine. What am I going to change it to? What do you think? Raise your hand if you think I should change the representative of all of them to 0. Okay, raise your hand if you think I should change the representative of all of them to 0. Of all the ones in the new set. Okay, doesn't matter, but, how am I going to find them to change them? What's the algorithm for doing this union? Yeah, look. I've got to go, Hey, should I change you?" "Should I change you?" "Should I change you? Yeah, I probably should. I don't have to change 3, right? Don't have to change this one. And I do have to change this one. I can't think of another way. I can't think of another way of knowing what elements are in a particular set without just actually going through and looking. Right? So the union in this case is big o of n. Groooaaannnn. That's a groan. Okay, so let's see if we can do better.
alright I love this alright so these structures are called up-trees and they are awesome! okay? The first diagram that is drawn here is a forest of up-trees one of each up-trees has a single node and by conventional we draw it pointing we draw this little arrow point up to indicate that is the root okay? now how do we implement this thing? we implement it by denoting it as a root as negative one in a little table or array okay? any question about that? so I know if you give me a table that looks like that then I know to draw this collections of up-trees now here's the thing we are going to use one up-tree per set so right now I've got four different sets each with one element each of which is the root of up-tree okay? alright so now this is not interesting it's more interesting if I take an union so the question is what happens if I take a union of zero and one, for example? here's what I'm going to do here's zero ok here's my up-tree that's zero here's my up-tree that's one I'm going to do this okay? I am going to take it and point it to this other element so in the picture I'm going to take it like this so zero points to one and in the table one is going to become zero's parent so this is the new representation of that okay? are you doing ok? now if I do a find on zero here's what's gonna happen I'm going to zero ok? who's your mama? it says oh! one it goes to one and then who's your mama? I have no mama I'm a root so one is returned ok? so Find(0) returns one after a walk up the tree ok? any questions about it? assure yourself if you do a find of zero and find of one you get the same thing by do find a zero I got one if I find a one yeah! alright so let's do another union because this is interesting this is new lets' do another union let's do union wanna say something? ok zero and two this is actually really one to do ok? so this is the point which I'm going to make it important to do a find of zero and the find of two because the only arrows that we are going to change is going to be the roots arrows ok? so we are going to start here we are going to start with this representation and effectively we have got a picture there we gonna to a find of zero to get one and a find of two to get two and we gonna to do this so zero is still going to point to one one is going to point two two is a root and three is a root ok? any questions about it? yea (student asking questions) yep they are roots right? they are roots of the top yes yep that's right but we have more than one now that picture is accurate as our last example ok? is it ok? alright yep? (students asking) zero points to one still see zero points to one? one now points to two and two is a root ok yea? (students asking) yes unions only happens at root unions only happens between things whose value is negative one ok? any question about that? yea? (students asking)
Alright, I love these. Alright, so these structures are called uptrees, and they're awesome, k? The first diagram that is drawn here is a forest of uptrees, OK? Each one, each tree there has a single node, and by convention we draw it pointing, we draw this little arrow pointed up to indicate that it's the root. Now how do we implement this thing? We implement by denoting it as a root as negative one in a little table or array. OK? Any question about that? So I know that if you give me a table that looks like that, then I know to draw this collection of up trees. Here's the thing, we are going to use one up tree per set. So right now, I've got 4 different sets, each with one element, each of which is the root of an uptree. So now, this is not interesting, it is more interesting if i take a union. So the question is if I take a union of zero and one, for example. Here's what I'm gonna do. Here's zero, k here's my uptree at 0, here's my uptree that's one, I'm going to do this. I'm going to take it and point it to this other element. So in the picture, i'm going to take it like this so zero points to one, and in the table one is going to become zero's parent. so this is the new representation of that. Ok ,you doing Ok? Now if I do a find on zero here's what gonna happen. I'm going to go to 0, k, whose your mama, it says, oh, one, it goes to one, says whose your mama? I have no mama, I am a root. And so one is returned. So a find of zero returns one after a walk up the tree. Any question about it? Assure yourself that if you do a find of zero and a find of one you get the same thing. If I do I find of zero I get a one, if i do a find of one, Yay! alright, so lets do another union, because this is interesting, this is new, lets do another union. Let's do union of.. wanna say something? OK, zero and two.This is actually a really good one to do. This is the point of which I'm going to make it important to do the find of zero and a find of two because the only arrows that were going to change are gong to be the root arrows. So I'm going to here, we're going to start with this representation and effectively we've got that picture up there, were gonna do a find of zero to get one and a find of two to get two and were gonna do this. So one is, zero is still going to point to to one, one is now going to two, two is a root and three is a root. Any question about it? Yeah? Yep! but they always are right? The roots are at the top. Yea. Yep. yep. but we have more then one, so that picture is now accurate as of that last example. Ok, is it OK? yeah? zero points to one still see zero point to one, one now points to two and two is a root. Yeah, yes. unions only happen at the roots. Unions only happen between things whose values are negative one. Any questions about that? yeah?
Yep....Yep... Alright. Any other questions about this? Do you wanna do another example? [Student asking a question] No, not necessarily, a great question. So the question is: do the values inside here, do these values represents the height? They happen to represent the height in this particular example. You can't count on that usually. Actually they don't quite represent the height. They are identifiers. So if these were students' names, these would be students' name except for this one, these would all be roots. So this says my parent is identifier one, 1's parent is a root. It has no parent. Does that help? So the N-trees are identifiers. [asking] No, there will be nothing to do. cause they are already in the same set. ...yes, that's right. Because you only can take a union of two different sets. You might end up creating a loop... I don't know. A union of a pair of things will still just be that. A union of two same things will still be that thing. Just like sets. OK. Any other examples you wanna to look at here before we go to a bigger one? OK, so let's clarify this and do it in a little bit larger context. We are going back to the games. But notice again there're no games. There's no indication of who likes which game. There's no angry birds appearing anywhere in the description. You have to keep that separate. If you're describing meaning to your sets, you have to keep that separate. In fact, when we use this structure which will happen in MP7 when we use this structure, there's actually no meaning to the sets. They're all sort of status. Alright, let's draw a diagram. I've created the structure in memory that denotes these sets. So this is what memory looks like. But I want to draw the up trees, the pictures of up trees that correspond to this memory. What does it look like in the array. So 0's parent is 4. 4's parent is nobody. So I've got 0, 4 done. 8's parent is 4. And 1's parent is 8. And I just started with that one because 0 came first. 2's parent is 5 and 5 is a root. So I'll go ahead and do that part next. And 9's parent is 5. 7 is a root. 3's parent is 6, which is a root. So now, what do I get back when I do a find of 4. If I do a find 4. You go to 4 and you walk up. But there's no place to walk, so what do you return? 4. Find of 8 returns... OK we go to 4, 4 is a root. So this returns 4. So this is true. Now this one gets interesting, how do we take the union. Well, first of all, how do we evaluate this, what's the find of 7? 7. What's the find of 2? 5. Are they the same? No. So we should take the union of those, which in this case is to take this 7 and point it to 5. Or this 7 is going to become 5. Yea? [asking] No, it doesn't point to 2.You always do the adjustment at the roots. So raise your hand if this surprises you a little bit. Cause this is an itinerary tree not a binary tree. Alright. Ahhhhhh
Yep, yep, Yes. Alright. Any other questions about this? Do you want to review another example? No, not necessarily. So the question is, do the values inside here. Do the values represent the height? They happen to represent the height in this particular example. Actually they don't quite represent the height. So if these were student names. Except for this one. These would be roots. This says my parent is identifer one. Identifier's one's parent is a root. It has no parent. So the entries are identifiers. Anything else about this? Yeah, let's do one. No, there would be nothing to do. Because they are already in the same set. Yep, Uhh, one two, yes. That's right. Because you only ever take the union of two different things. You might end up creating two different things. You might end up creating a loop, I don't know, ok? A union of a pair of things will still just be that thing. Just like sets. Just like the sets you've known since you were a third grader. Ok how are you doing? Any other examples here before we go to a bigger one? Ok, so let's clarify this and do it in a little bit larger of a context. We're going to the games. But notice, again. That there are no games. There is no indication of who likes which game. There is no angry birds appearing anywhere in the descriptions. If you re ascribing meaning to your sets, you have to keep that set separate. In fact when we use this structure which will happen in mp7. When we use this structure there is actually no meaning to the sets, there all just sort of a status. They keep track of a status. Ok, so let's draw a diagram. I have created the structure, in memory that denotes those sets. Ok, so this is what memory looks like. I want to draw the uptrees, the pictures of the uptrees that correspond to this memory, in what it looks like in the array. So zero's parent is? So zero's parent is? Four, ok. Four's parent is? Nobody, ok. So I've got zero done, I've got four done. Eight's parent is four. And one's parent is eight. And I just started with that one, because zero came first. That is the only reason. Two's parent is five and five is a root. Two's parent is five and five is a root. And nine's parent is five. Seven is a root by itself. Three's parent is six, which is a root. Ok? So now, what do I get back when I do a find of 4. If I do a find of 4, you go to 4 and you walk up, but there is no place to walk. So what do you return? 4, is correct. Find of 8, returns. Ok we go to 8, it goes to 4, 4 is a root, so this returns 4. So this is true. Now this one get's interesting. This one gets interesting. How do we take the union. First of all, how do we evaluate this? What's the find of 7? What's the find of 2? Five. Are they the same? So, we should take the union of those which in this case, which will take this seven and point it to five. So, this seven is going to become five. No, it doesn't point to two. You always do the adjustment at the root. Raise your hand if this surprised you a bit. Because this is a ternary three rather than a binary tree. Oh my gosh. Oh my gosh. Ugh. Ok.
my clock says it's time to start It's 12/9 Tuesday?
My clock says it's time to start. Is twelve nine, Tuesday? I think, I think this is what I meant there. I think I forgot to change them. Those are Tuesdays, right? OK. There we go. Alright. Yes? [student question] There is new on the exam, thank you for asking, [uhm]. Alright so [uhm]. You should be receiving your scores back in your svn our intet.. our plan was to create a folder in your repository mt2 and in it you will have the scanned copy of your exam, so you can see your work. [uhh] And a report that tells you how you did on each of the scantron and the hand graded [huh] portion of the test. Now [uhh..] Also simultaneously the rubric will be posted so you can go and look and see how the graders decided how many points you should achieve for each part. Now this is, none of this is what you want to hear, right? What is it that you want to hear? [student ask when?] Oh, when? It should be, it might be happening as we speak. He said, He said do you want me to push the button before lecture, I'm like [uhhh] I dont know how to make that decision. So he, I think he was going to send it out momentarily. [Uhm.] [student voice] Yeah. Ah regrades are going to be, very good question, so the regrades are going to be, we're leaving it up to the individual TAs to handle it but if it appears that they are going to tell you large windows of time that they're available and you can come talk to them with your exam in front of you, because they where all scanned so [uhm..] You can ask for regrades inside those windows. They're expecting to be able to take care of them that way rather than putting piles in my office. There's another key question you're not asking, Yeah? I know... I know.. [uhm] so the average on the exam for this exam typically goes up from the first exam. The average was 68.. The last average was 75 So uhm. So heres the heres the heres the parting line we do not curve, we do not curve individual assessments in this course OK. [huh.] But we are open to adjusting the grade cutoff at the end of the semester so in your, so in your [sidekey?] you should still imagine the ohhhh.. this exam, you know. If you aren't happy with your score, you should go ohhh I gotta keep working really hard [uhm] because there are sort of no automatic you know ohh don't worry about it's really 7 points higher im not doing that OK. But, but in the end you know I like to see lots of A's and so at that point we will change the, where we draw the line in the grading moment. OK. Any questions about that? I also toyed with the possibility of figuring out additional ways to do extra credit. But in my experience extra credit helps the students who most, who have extra time and the, the students who have extra time tend to be those who don't need the extra credit. So I'm torn on you know building in additional work to do. [uhm] I don't know I'm still thinking about that. So [uhh] I haven't looked at histograms on individual problems yet, so I don't know, you know, i don't know yet how they each look. I will do so just to make sure that's typically how I make sure that the scantrons are graded accurately. To look at histograms and see if they make sense. Alright any other questions about tests? [uhm] I think its not premature for me to talk about the final just a little bit. Here's how you should think about the final in this class [uhm]. It is a third midterm with a tree question, an interesting tree question and [uhmmm] probably a little bit of memory management on the multiple choice so its really like a third midterm the bulk of your studying should be on the material you that have not yet been tested over and [uhm] and then, you know, make sure, just kind of revisit some of the earlier material. Are there any questions? administrative questions? [uhm] yeah Arma? [student asks question and cinda listens]
Oh you want more final, you want more questions... more sample tests for the final. I'll see if I have any good ones laying around. You can keep pestering me about that.. if you want.. to like do it. Alright, here, questions, administrative issues. How do i determine the class curve at the end? I want lot's of A's. So yay we're all on the same page! So the class curve at the end, for the last few semesters I haven't had to do a curve, but um, it's okay it's a recalibrating semester. What i tend to do is look for gaps. What i do is look for the overall spread of scores and adjust but only in a direction benefits you, i would never make a line harder to, ill never make it harder to achieve a particular grade, so we only curve up instead of curving down, okay. Um, any other, does that answer your question. it's an art thats why i get paid the big bucks. alright, any other administrative questions? Labs do meet this week and the interesting thing is that the instructional labs close at 5 oclock on saturday for the holidays why yes they do! and every semester we remind ews the lab managers we remind them you know we have labs at 7 oclock on friday nights or certainly at 5 oclock and they go oh yea yeah we will take care of it and every semester the doors are locked. so you may have to bring a battering ram to get into your lab sections on friday night. alright, any other administrative questions before we move on. you are not getting exams back in your lab sections. did you say the words so we dont have to go to our own lab sections did you say those words? you never have to go to your own lab section. and there's no incentive to do so because we aren't handing them back in those sections. any other questions? alright lets roll here, lets play school. we were talking about oh look we are starting class at 11:08, we're on it today. so we were talking about a structure for maintaining a collection of disjoint sets. so in the illustration here, we have four disjoint sets, the cardinality of this set is 3, good, right i just wanted you to like to connect to the set, this one has one thing in it, this one has four, this one has two, now last time, we talked about implementing the functionality of the disjoint sets abstract data type that abstract data type has two functions anyone remember what they are. two key functions. there were three listed but one of them was just make a set so okay i'll give you that one, what were the other two key functions for disjoint sets abstract data type, union and find. wait i dont know where you were, okay, ADT disjoint sets has find and union. now, find you can think of as returning the set in which a particular key resides, but it does so by returning representative of that set and union is just like the union you learned about in third grade, it takes two sets and puts it altogether in one set. the representation that we ended up with, the implementation that we ended up with is something like this it's called uptrees, a picture of the uptrees that might represent these looks like this and the data the way it looks in memory corresponding to the uptrees looks like this. now, um, i didnt want to go over this because i didnt want you to fall asleep at 11:10 but i will tell you that i put an error in that construct so i want you take about 2 minutes and refresh your memory on how these things work and tell me where the error is there might be more than one error, find the error in the model versus the data.
Yes? Very good. So in the table, it's.. So remember that roots are indicated by negative numbers, okay? And in the table, 6 is supposed to be a root. Okay? And not 3. In the table it says 6 is 3's parent, okay, so that's the bug. That, that was my intentional bug. Anybody else find something, something different? Some other error? Okay, so notice that these are not ordered trees in any sense. So, it didn't matter where I drew the 2 and the 9 here relative to one another. There is no notion of a left child and a right child, or a middle child, or an early middle ch- there, you know. So this tree is not ordered, it's not necessarily binary, though this, uh, this examples happens to not have any non binary nodes. Uh, let's see. It is directed, though. That's the key part. Alright, any questions about it? Alright, let's take union just to remind ourselves how you take union, both in the context of the model and in the context of its representation in memory. So I want to take the union between these two sets and do something, and do something that makes all of these in the same tree. So how should I do that? I've got these two trees, what should I do? What should I do? Yeah? Yeah, make one of the roots point to the other. Now, should I do this or should I do this? Should I do this, this one? Okay, and now I have to like turn around. Oh, wait. Okay. So your opinion, I should do this? Okay. Um. Alright. You think 5 should point to 7. Okay, now, what I want you to get from that little exchange is that there was a choice to be made, and for now, we're going to make an arbitrary choice. Um, a principle, but arbitrary choice. And I'm just going to have the one on the left point to the one on the right. Okay. But you should recognize that it, sort of, you know, that was arbitrary. Okay. Finally, if I say something like the union of 2 with 7", what I really mean is the union of the set containing 2 with the set containing 7. So I need to call find() in order to get the appropriate representative of that set. Okay, any question about that? Alright. So, uh, and the reason I bring that up here is because when I talk about these functions and when we discuss running times of these functions, we want to find() to be decoupled from union(). When you implement these things in mp7, you're going to throw a find() inside, because you don't want to have to demand that the client do this every time. So, there'll be a slightly different specification for the union function in the mp than there is here. Okay, but I want to decouple them because I want to be able to talk about running times separately. Alright, any question about that? Okay. So let's write some code, yay. Alright, so.. The function find() is going to take a key or a element identifier, some kind of identifier, and it's going to return the root of the uptree. Returns the root of i's uptree as a representative. Okay. Now. Woah, look at this code. This is really cool. If, if the value in the array at i is less than zero, it means that i is a root, right? That's what we agreed on. In which case, we're going to return i. Otherwise, we're going to walk one step up the tree. Okay, so, we're going to find() on i's parent.
Very good! So, in the table, so remember that roots are indicated by negative numbers. And in the table 6 is supposed be a root, not 3. In the table it says 6 is 3's parent. So, that is my intentional bug. Anybody else find something different some other error? So notice that these are not ordered trees in any sense. So it didn't matter where I draw the 2 and 9 here relative to one and another. There is no notion of a left child and a right child or a middle child. So this tree is ordered, it is not necessarily binary though. This example happens to not to have any non binary nodes. It is direct, that is the key part. Let's take the union just to remind ourselves how to take union both in the context in the model and in the context of its representation in memory. So I want to take union between these two sets and do something that makes all of this in the same tree. So I got these 2 trees what should I do? Yeah, make one of the root point to the other. Now, should I do this or should I do this? OK you think 5 should point to 7. Now what I want you get from that little exchange is that there was a choice to be made. And for now I am gonna make a arbitrary choice. I am just gonna have the one on the left point to the one the right okay? but you should recognize that was arbitrary. OK finely, if I say something like the union of two with 7, what i really mean is the union of the set containing 2 with the set containing 7. So I need to call find in order to get the appropriate representative of that set. Ok any questions? All right so, and the reason that I bring it up here is because when I talk about these function and when we discuss running time of these fictions, we want to find to be decoupled from union. When you implement these things in mp7, you are gonna throw a find inside because you do not want to have to demand the client do this every time. So, there will be a slightly different specification for the union function in the mp than there is here. But I want to decouple them, because I want to be able to talk about running times separately. All right any question. So let's write some codes. Function find is going to take a key or a element identifier and it is going to return the root of the up tree, as a representative. Now, look at this code, it is really cool! If the value in the array at i is less than 0, it means i is a root, that is what we agreed on. In which case, we are gonna return i, otherwise, we are going to walk one step of the tree. Ok, so we are gonna find on i's parent.
any questions about that? okay, none? it's really quite in here. We should play music or something. Do you know who Laurence Angrave is? He's the instructor for 241. This morning he sat in my office and he wrote a parody of blank space for his students. I'm like you genius, that's the teacher of the year right there. Alright, uhhh, so whats the running time... how did that even come up? Blank space! Its a blank space! Thats where it came from. Yea, its blank space right there. What does the running time of this function depend on? Not the size of it. Kind of. Depends what you mean by size. It's the height, thats right. You're going to walk up the subtree, and so the number of steps, the number of effectively iterative calls to find depends on the height of the tree. In the worst case, I agree with you, you could just have the chain, kind of like the one on the right, there. I think you could come up with a way, a set of unions that come up with the worst case thing. This would be O(n). But thats not particularly interesting. What I want to know, is what is the very best tree look like. Whats an ideal tree? What do we wish these trees look like? A binary tree? No, we can do better. We can also do better than avl trees. These are not necessarily binary trees. We can have a root, lets say 4. It should be 13 if we're talking about Tayler Swift since thats her favorite number you know. I could do some real damage to my U of I freshman, right guys. Alright, so this is an ideal tree. I have her on my brain today, I should shake it off. Alright, lets take a union, okay. Lets take a union here. all we have to do, look it. We got the root of two trees. All we have to say is s[root], one of the roots has to have a parent who is equal to the other. Now, as I said, this is an arbitrary choice at this point. There is nothing wrong for me to write down there. I think what i did was always this. The first one points to the second. I think it is that I said, the parent of root 1 becomes root 2. Alright, whats the running time of this function? It's constant time. It's just an assignment. Its just a change of a value. So, what we want to do is aim towards this, because then our finds are fast. What we have now is a case where we can create, you know, given our current code, unfortunately, things can look like this. So lets get a little smarter. In that example, should i do? what would be smarter? should i do this or should i do this? Which one?
Any question about that? ok.. None? It's really quite here. We should play music or something. Do you know who Lawrence Angrave is? Do you know who he is? He is the instructor for 241. This morning, he sat in my office he wrote a herd of blank space for his students. I am like you're a genius." That's the teacher of the year right there. Alright! So what's the running time? Where did that come up? Blank space! It's a blank space. That was where it was That's where it came from. Yeah, that was a blank space right there. What's the running time of this function depend on? What's the running time depend on? Yeah? No! Not the size of it. Kind of. Depends what you mean by size. Depends what you mean by size. Yeah? The height! That's right. You are gonna walk up this tree right? So the number of steps. The number of effectively iterative calls to find depends on the heights of the tree. In the worst case, I agree with you that the worst case you could just have a chain right? Chain kinda like the one on the right there. And you can come up with the way set up union that creates that the worst case thing. So uh... This would be big-o of n. But that's not particularly interesting. What I wanna know is what is the very best tree look like? What the ideal tree? What do we wish these trees look like? Binary tree? No we can do better. We can do better than AVL trees. Yeah? Very good. These are not necessarily binary trees. We can have a root. Let's say, four. Okay? Should be thirteen for talking about Taylor Swift. Cause that's her favorite number you know. Why? You didn't know that? I can do some real demage to my U of I freshmen right guys? Issac knows that thirteen is Taylor Swift's favorite number. Yeah? Yeah I did. That's right. Alright this is an ideal tree. I have her on my brain today. I should shake her off. Alright let's take a union. Let's take a union here. All we have to do. Look it. We got the roots of two trees. All we have to say is s root of one one of the roots has to have a parent who is equal to the other. Now, as I said, this is arbitrary choice of this point. There's nothing wrong for me to write sown there. I think what I did was always this. The first one points to the second. So I think it is that I said the parent of root one becomes root two. Is that right? Alright, What's the running time of this function. It's constant time! That's right. It's just an assignment. It's a just changeable value here. So this is that. Alright, that's pretty good. So what we wanna do is aim toward this because then our finds are fast. What we have now is a case where we can create you know given our current code, unfortunately things can't look like this. So get a little smarter. Now, I have a question in that example. In this example, should I do what would be smarter? Should I do this? or should do this? Which one?
Should I point zero to one, or one to zero? Yeah, zero to one, that's right, because look at what happens, you kind of just tuck in the zero, right? You tuck the zero under the one and increase zero's distance from the root but there aren't many nodes there, so yes I've increased the find for zero, but I've got to increase the find for something, right? That's what union does, it builds up this tree. So I'm going to choose the one of these that reduces the height for the smallest tree I'm sorry, INCREASES the height of the smallest tree. So recognizing that we have that choice, I have a vote I need you to take. So here's a couple examples, don't look at this stuff on the bottom yet, we'll talk about it in a second. Here are a couple trees, and this time the choice is not quite so clear whether or not the left should be pointed to the right or the right to be pointed to the left, okay? So think about it for about fifteen seconds. So I'm going to ask you to vote and the vote is whether or not you prefer this (pointing the right subtree to the left) or this (pointing the left subtree to the right) so blue or green. Okay so raise your hand if you prefer the green arrow. Okay if you prefer to point to four to seven. And raise your hand if you prefer the blue arrow? Okay blue wins, kind of, okay. You want to try green do you want to try again voting again? Yeah you can vote for green again. It's about the same. So look these are both great choices. They just happen to reflect different algorithms. Let's talk about the blue one first, it's called union by height, and the idea here is that we take the shorter tree and point it to the taller tree. So this is shorter tree points to taller. Okay, and what that does is it leaves doing a union is not changing the height of the tree unless they were both originally the same height, does that make sense? So doing a union doesn't change the overall height of the tree unless they were the same height to begin with, and then it increases it by one. So, this keeps the overall height of the tree as small as possible, is the sort of tuck it in under the height of the other choice. Any questions about that? So we're going to implement that, and the idea here is that we need a mechanism for keeping track of the height of the tree. Okay, so let's see seven is going to point to four, four is going to be a negative something, in the past we said it's negative one, but here i'm going to use my memory pretty closely, or pretty carefully, since I know that four is associated with this new tree, build a root of this new tree I'm going to kind of pretend like I've got space in four to store the height, okay? And so, here I am going to let this still be negative, so instead of negative one it's going to store the negative one, what is that in this case? So the value there will be negative four. Okay, so the height of the tree is three. I just get three there. Okay. So the root, there's a bug with that by the way, you should figure out what it is while I write this down, okay, there's a bug with that idea, you should figure out what it is. The root stores negative of tree height. What's the bug? Ian?
Should I point zero to one? Or one to zero? Yeah! Zero to one, that's right, because look what happens. It's like you kind of just tuck in the zero, right? You tuck the zero in under the one. And yes, you increase... you increase zero's distance from the root, but you know, there aren't very many nodes there so, I... yes I've increased the find for zero, but I've gotta increase the find for something, right? That's what union does. It builds up this tree, so I'm gonna choose the one of these that reduces the height for the smallest tree... or, sorry, increases the height for the smallest tree. Ok, so recognizing that we have that choice, I have a, I have a vote I need you to take. So here's a couple of examples, k? Don't look at the stuff at the bottom yet. We'll talk about it in a second. Here are a couple of trees, and this time, the choice is not quite so clear, whether or not the left should be pointed to the right, or the right should be pointed to the left. K? So think about it for about 15 seconds........So I'm gonna ask you to vote, and the vote is whether or not you prefer, uh, this....or.....this. So blue or green? Uh oh... blue or green? So raise your hand if you prefer the green arrow. If you prefer to point 4 to 7, and raise your hand if you prefer the blue arrow. Ok, so blue wins, kind of, ok. You want to try-...greens, you want to try again? Voting again? Yeah, you can vote for green again, yeah that's about the same. Ok. So look, these are both great choices, k? They just happen to reflect different algorithms. Let's talk about the blue one first. It's called, Union by height. And, the idea here is that we take the shorter tree, and point it to the taller tree. So this is, shorter tree....points to taller... K? And what that does, is it means doing a, doing a, doing....doing a union, does not change the height of the tree unless they were originally both the same height. K, does that make sense? So... doing a union doesn't change the overall height of the tree unless they were the same height to being with, and then it increases it by one. So, this keeps the overall height of the tree as small as possible. It's the sort of, tuck it in" under the height of the other, uh, choice. Alright, any question about that? So we're going to implement that, and the idea here is that we need a mechanism for keeping track of the height of the tree... K? So let's see, so seven is going to point to four. Four is going to be a negative something....In the past we said it's negative one, but here, I'm going to use my memory... I'm going to use my memory pretty closely, or, pretty carefully. Since I know that four is associated with this new tree, it's still the root of this new tree, I'm gonna kind of pretend like I've got space in four to store the height. K? And so, here, I'm going to let this still be negative, but instead of negative-one, it's going to store the height of the tree. What is that in this case? So... the value there will be negative-four, k? Because the height of the tree is one, two, thr-...wait..one, two, I only get three. I'd skip three there. K. So the root... there's a bug with that by the way, you should figure out what it is while I write this down... there's a bug with that idea, and you should figure out what it is. So the root stores....negative....of tree height. What's the bug in...
Yea, good. Okay. Suppose that my tree, what is its height? it's height is 0, and so, in order to indicate that its a root, im gonna say negative 0. How does that work? Ehhhh. Do you have an idea for solving the problem Nathan? Just a minute. What? Very good. So, I'm just going to bump it up. I'm gonna not say 0, I'm going to say 1. So it's going to be I'm gonna store the negative of the tree height plus 1. So I am going to store negative 4. Whoever said that was correct. OKay. Any question about it. Just a little hack. It happens to be quite convenient. Alright. Uhhhhh, lets talk about the other alternative. the green preference. Now here's the thing. this time, we're going to take this giant tree and say whoa. Thats a big tree. I don't want to increase the height of that many nodes. So I shouldnt make it point to something new. Its a big tree. I don't want to change the height of lots of things I might be look for later. And so what we're going to do instead is take the smaller tree in terms of number of nodes. And go ahead and increase the distances to the roots for each of those. So, this increases the distance to the root for the fewest nodes and idea is that you point the smaller tree to the larger. Where smaller and larger are in terms of the number of nodes. Okay. so I can do part of this myself. Four could point to seven. What should seven's value be? I can even do this part. Seven is going to be a root, so it's value is going to be negative. But what else should we store there. Yea, the new size of the structure, the new number of nodes in the structure. Okay fine, so I think thats 12, unless it's somehow changed since the last time i taught this class. Okay, any question about it? Is it good? Alright, so what happened? Where did that 12 come from? we used to have two trees. This one would've been negative four. This one wouldve been negative 8. And so, to get this new value, all we did was add them. Any question about it? Alright, both of these schemes for union guarantee that the height of the tree, and thus the running time for find, is... What would be super good news? Constant time would be great news, but we can't get there. Both of these schemes for union guarantee that the height of the tree is O(logn). There is a third metric that you can use for deciding who should point to whom. A third mechanism for smart union called union by rank, and we don't talk about it here. The height of the largest embedded perfect tree, or something like that. So union by rank is also sometimes used.
Yeah, good. Ok. Suppose that's my tree. What is its height. Its height is zero and so in order to indicate that it's a root, I'm gonna say negative zero. How does that work. Do you have an idea for solving the problem, Nathan. Just a minute. What. Very good. Right, so, you know, I'm just gonna bump it up, right. I'm gonna, I'm gonna not say that zero. I'm gonna say it's one instead. So, it's gonna be, you are gonna store the negative of the tree height plus one. So I'm gonna store negative four here whoever said that was correct. Ok, any question about it. Just a little hack. That happens to be quite convenient. Alright, umm, let's talk about the other alternative, the green preference. Here's the thing. This time, this time we are gonna take this ginormous tree and say wow, that's a big tree. I don't want to increase height of that many nodes. So I shouldn't make it to point something new. Ok. It's a big tree. I don't wanna change the heights of lots of things I might be looking for later. And so, what are we going to do instead is take the smaller tree in terms of number of nodes it contains, and go ahead and increase the distances to the root for each of those. OK. So, this increases the distances to the root for the fewest nodes and the idea is that you point the smaller tree to the larger, where smaller and larger are in terms of number of nodes. OK, so I can do part of this myself. Four should point to seven. What should seven's value be. I can even do this part. Seven's gonna be our root and it's, so, its value's gonna be negative, but what else should we store there. Yeah, the new size of this structure, right, the new number of nodes in the structure. OK, fine. I think that twelve has been somehow changed from last time I talk in the class. OK. Any question about it. Is it good. Alright, so what happened. Where did that twelve come from. We used to have two trees. We used to have two trees. Umm, this one would have been negative four. This one would have been negative eight. And so to get this new value here, all we did was add them. That's right. Any questions about it. Alright, both of these schemes for union guarantee that the height of the tree and thus the running time for find is, what do you think. What do you think this does. What do you hope this does. What would be super good news. Constant time would be great news we can get there. Log n, right. These, both of these schemes for union guarantee that the height of the tree is big-oh of log n. There is a third matrix that you can use for, for deciding who should point to whom, a third mechanism for smart union called union by rank and we don't talk about it here. But it's, you know, it's similar sort of like the, the height of the largest embedded perfect tree, something like that. So union by rank is also sometimes used
Umm, but it also guarantees that same running time, okay? So now, let's write code that does this. Let's write code that does. Um, oh and we're not going to prove the log n here. We're going to move right past it, we're going to be satisfied with this moment of having log n, but we're not going to take the time to prove that because we're going to do better. Alright, find has not changed so the code for find didn't change at all but the running time of find is going to change, we didn't even touch it and its running time is going to change. Alright, so here is union by size, union by height could be done similarly, I don't even think we ever ask you to do it I think we always ask you to do union by size. Notice that the new size, the sum of the values at the root just like we suspected might be the case, if so we've got this helper function is bigger" that merely takes the negative of the value in the root right, and compares them. But I got a little bit lost in the inequalities there so I wanted to test that separately and make sure it did what I thought. So let's see this is this means... root 1's tree has more nodes... than root 2's. Okay. Alright, root 1 is bigger then, we're going to point root 2 to root 1, and then root 1 gets the new size. Okay, any questions about that? Otherwise we'll do the opposite. Any question about it? Okay what's the running time of that code? Yeah, it's constant time, good. Because there's no traversing going on, there's nothing about the size of any of these structures that affects running time here, right? We can look up the sizes are just array look-ups. The comparisons is a constant time thing, a conditional evaluation then we got a couple of assignments. So this is still a constant time operation but it has the effect of maintaining the trees as short trees so now we can say find is big O of log n. Do you remember what was the best we had before we started using these up trees? The naive implementations of I guess it was probably using an array. Do you remember what it was for using an array? It was constant time for size, but big O of n for taking the union. Okay. So this is using an array. And you can go back using an array naivelyish. You can go back and review that. Okay. Do you like this better? Kind of depends on which one you do most often, right? And in fact in this sequence of using these structures you can only take unions so many times, so this doesn't feel quite satisfying to me yet. Okay. We shouldn't stop here. We should do one more thing. Let's suppose we do a find of 4.
Um, but it also guarantees that same running time. Okay, so now, let's write the code that does this. Let's write the code that does this. Oh, we're not gonna prove the log n here. We just, we're gonna move right past it. We're gonna be satisfied at this moment of having log n. But we're not gonna take the time to prove it because we're gonna do better. Alright, find has not changed. So the code for find didn't change at all. But the running time of find is gonna change. We didn't even touch it. And its running time is going to change. Alright, so here is UnionBySize. UnionByHeight could be done similarly. I don't even think we ever ask you to do it. I think we always ask you to do UnionBySize. Notice that the new size is the sum of the values at the roots, just like we suspected might be the case. Umm, if, so we got this helper function isBigger that merely, you know, takes the negative of the value in the root, right? And compares them. But I gotta a little bit lost in the equalities there, so I want to test that separately and make sure it did what I thought. So let's see. This is, this means root1's tree has more nodes than root2's. Okay? Alright, so if root1 is bigger, then we're gonna point root2 to root1. And then root1 gets the new size. Okay? Any question about that? Otherwise, we'll do the opposite. Any question about it? Okay, what's the running time of that code? Yeah, it's constant time. Good. Because there's no traversing going on. There is no, there is nothing about the size that any of these structures that affect the running time here, right? We can look up the sizes, are just array look-ups. The comparison is a constant time thing, the condition evaluation. Then we just got a couple of assignments. So this is still a constant time operation. But it has the effect of maintaining the trees as short trees. So now we can say that find is O(log n). Do you remember what was the best we had before we started using these up trees? The naive implementations of, I guess it was probably, umm, using an array? Do you remember what it was for using an array? It was constant time for find, but it was O(n) for taking the union, okay? So this is using an array. And you can go back. Using an array naively I should say. You can go back and review that, okay? So do you like this better? Kinda depends which one you do most often, right? And in fact in a sequence of using this structure, you can only take unions so many times. So this doesn't feel quite satisfying to me yet. Okay? We shouldn't stop here. We should do one more thing. Let's suppose we do a find(4).
If we do find a 4, we recursively walk all the way up the tree. Right? But this is recursive process, which means after it's complete, we have to fall out of the recursion and after it's complete, we know about ten. So in a post-order way, we are gonna do the following: when we first look at 4, we are going to do a find on 4's parent, and after that is successful, we are going to connect 4 to that parent. Then going up the tree, there will be a find on 2 after which we are gonna connect 2 to that root. Then, there will be a find on 7 after which we are gonna connect 7 to the result, and then there will be a find on 9, after which we are gonna connect 9 to the root. Now, this is what that looks like after that process, you could probably draw it too, I'm gonna just redraw the whole thing with the blue arrow taking into account the correct arrows. So ten still has 9 as a child, and 11 as a child. But now it also has 7 and 2 and 4, and 1 points to 9, and 8 points to 7, and 3 points to 2, and 5 and 6 point to 4, and nothing points 11. So we took this tree whose height was one, two, three, four, five... whose height was five and by doing a find on it, change it to have height two. Any question about that? Alright what do you think the code looks like? So this is the old code- this is the old unionBySize. We are kind of ignoring it right now. This is the new find except that is the old find with just a few spaces thrown in. What goes in those spaces? Remember that what we are doing is changing the parent of the current node to be the result of the find. Let's take that sentence and put it in code. we are going to ...oh here is the result to the find. We are going to change the current parent, current node's parent to be that. That's it. So this implements path compression. You guys are quiet today. Any question about it?
Okay, if we do a find of 4 we recursively walk all the way up the tree, right? But this is recursive process, which means after its complete we have to fall out of the recursion and after its complete we know about 10. So in a post order way, in a post order way we are going to do the following: when we first look at 4, were going to do a find on 4's parent, and after that is successful we are going to connect 4 to that parent, okay? Then, going up the tree, there will be a find on 2, after which were going to connect 2 to that root. Then, there will be a find on 7 after which we are going to connect 7 to the result and then there will be a find on 9, after which we are going to connect 9 to the root. Now, this is what that looks like after that process; you could probably draw it too, but i'm just going to redraw the whole thing um with the blue err[?] taking into account the correct arrows. So, 10 still has 9 as a child, and 11 as a child, but now it also has 7 and 2 and 4, and 1 points to 9 and 8 points to 7 and 3 points to 2 and 5 and 6 point to 4, and nothing points to 11. So we took this tree whose height was 1 2 3 4 5 whose height was 5 and by doing a find on it changed it to have height 2, okay? Any question about that? Alright, what do you think the code looks like? So this is the old code, the old union by size; we're kind of ignoring it right now. This is the new find, except that its the old find with a few spaces thrown in; what goes in those spaces? What goes in those spaces? Remember that what were doing is changing the parent of the current node to be the result of the find. Okay, so lets take that sentence and put it in code; we're going to... oh here's the result of the find. We're going to change the current parent, current node's parent to be that. And that's it. So this implements path compression. Boy, you guys are quiet today. Any questions about it? Yeah?
Sixty-thousand five hundred thirty two to the 65536 how big is it? It's big beyond all comprehension. Ok. The number of atoms in the universe I think is around they expected 2 to the 300. Ok. Number of atoms in the universe. Teen-tiny things big big space.
This probably doesn't work. Okay, yup. It's if you set up the system and you just use it to build up the relationship between the elements in your set and query it through that result. You guys, I have another minute. Okay, so this is it for disjoint sets. The next data structure of interest is graphs. And the next thing we're going to do to talk about graphs is to look at some amazing examples. Yeah this is my facebook community in the bottom right. What do you think that is? This is my least favorite graph in the world. This is a collaboration graph. We'll talk about it next time, bye.
Uhh... this probably doesn't work cause it's probably a Java applet. But it was... yeah. I don't even remember what it was. Okay! [Someone's name] Yup... Yup. It's if you set up the system and you just use it to..uh..build up this, build up the relationships between the elements in your set and query it, that's the result. You guys! I have another minute! (Yeah.) Okay, so this is it for Disjoint Sets. The next data structure of interest is graphs. And the next thing we're gonna do to talk about graphs is to look at some amazing examples. Yeah this is my Facebook community in the bottom right. What do you think that is? This is my least favorite graph in the world.This is a collaboration graph. (Oooh. Oh.) Yeah. We'll talk about it next time! Bye! [post-lecture convo]
Ok let's roll. Um. So I gonna call an odd ball here and change the.... Um so for few minutes, your um.. our discussion will not match the handout. Cause I'm actually gonna go back to um last time's slides. Um... just because I have a mast all of these different applications of um graphs. And they are all cool. So my plan for today is to spend first few minutes going over these applications of graphs. Just sort of for fun. And then we will start lecture officially. At that point we'll talk little bit about the exam and about sort of finishing out the semester. But I wanna start with this kinda light stuff. So from your discrete math experience, you know that a graph is a pair. A graph is a pair. What? Do you mean the fruit pair? What's a graph? It's a pair of sets. Does that help you? See it? Do you remember graph is a pair of sets one of which consists of vertices one of which consists of edges. And we'll talk a little bit more about the notation that goes along with that later on. For now, every graph is just a vertices and edges. We constraint on the endpoints of the edges right? Every endpoint has to be in the set of vertices. Now, when you talk about application of graphs, you responsibility from the out set is to be able to discuss the parallel to edges and the parallel to vertices. Thank you. It's magic this whole class thing. Thanks Tim. So you have to be able to draw parallel between what constitutes an an edge in the application and what constitutes the vertex. And from there, you can use what you know about graphs to start asking interesting questions of your application. Um we in this class, we gonna talk about some very introductory algorithms on graphs and it is the substance of 374 in CS 374 or in some graph algorithm classes in math departments and combinatorial optimization classes especially where you end up talking a lot more in depth and a lot about a lot more sophisticated graph algorithms. Alright, so let's start with applications. These are all graphs. They all have vertices and edges but their context is completely different. Ok? This one in the upper left and any guesses about what it is? One upper left is the internet. It's an artistic interpretation of the internet in 2003. So I am not sure. So long time ago right? I am not sure that the internet would fit on this wide now. And I am not sure it really did then. Cause like I said, this is an artistic interpretation of data. And honestly I cannot remember whether this is the internet or world wide webs. So I don't remember actually the technical details of what the vertices are. Routers or main portal sites for example. I don't actually remember. But the cool thing about it is if you take connectivity data and you interpret it sort of with color and you get this beautiful thing. And in either application, you can ask interesting questions. Like for example, you know, what's the diameter of that graph or what is the longest path within the graph. And I am pretty sure the answer for this such question would be interesting even in the context of world wide web or in the context of the internet. Alright any comments about this piece of art up here? Any comments or questions about it?
Ok let's roll. Um. So I gonna call an odd ball here and change the.... Um so for few minutes, your um.. our discussion will not match the handout. Cause I'm actually gonna go back to um last time's slides. Um... just because I have a mast all of these different applications of um graphs. And they are all cool. So my plan for today is to spend first few minutes going over these applications of graphs. Just sort of for fun. And then we will start lecture officially. At that point we'll talk little bit about the exam and about sort of finishing out the semester. But I wanna start with this kinda light stuff. So from your discrete math experience, you know that a graph is a pair. A graph is a pair. What? Do you mean the fruit pair? What's a graph? It's a pair of sets. Does that help you? See it? Do you remember graph is a pair of sets one of which consists of vertices one of which consists of edges. And we'll talk a little bit more about the notation that goes along with that later on. For now, every graph is just a vertices and edges. We constraint on the endpoints of the edges right? Every endpoint has to be in the set of vertices. Now, when you talk about application of graphs, you responsibility from the out set is to be able to discuss the parallel to edges and the parallel to vertices. Thank you. It's magic this whole class thing. Thanks Tim. So you have to be able to draw parallel between what constitutes an an edge in the application and what constitutes the vertex. And from there, you can use what you know about graphs to start asking interesting questions of your application. Um we in this class, we gonna talk about some very introductory algorithms on graphs and it is the substance of 374 in CS 374 or in some graph algorithm classes in math departments and combinatorial optimization classes especially where you end up talking a lot more in depth and a lot about a lot more sophisticated graph algorithms. Alright, so let's start with applications. These are all graphs. They all have vertices and edges but their context is completely different. Ok? This one in the upper left and any guesses about what it is? One upper left is the internet. It's an artistic interpretation of the internet in 2003. So I am not sure. So long time ago right? I am not sure that the internet would fit on this wide now. And I am not sure it really did then. Cause like I said, this is an artistic interpretation of data. And honestly I cannot remember whether this is the internet or world wide webs. So I don't remember actually the technical details of what the vertices are. Routers or main portal sites for example. I don't actually remember. But the cool thing about it is if you take connectivity data and you interpret it sort of with color and you get this beautiful thing. And in either application, you can ask interesting questions. Like for example, you know, what's the diameter of that graph or what is the longest path within the graph. And I am pretty sure the answer for this such question would be interesting even in the context of world wide web or in the context of the internet. Alright any comments about this piece of art up here? Any comments or questions about it?
Okay let's move on to the next one
No, I don't think so, it's think it's laid out by some... ya know, physical, physical relationship of the edges not by geography. That would be interesting too... But kind of unnecessary, haha, it's like they put all the derby girls out in a barn, hahah. I don't know! Alright, so I, this was really fun to do and like I said it's from a years ago so... Sylvia, are we Facebook friends? Am I Facebook friends from anyone in here? Yes! Right, of course. So you guys aren't on here... yet. Next year. Ok. This graph... or any questions or comments about this one?...yes? So the weird thing is I don't have a lot of... I haven't stayed in touch with a lot of my college friends... isn't that sad? You guys have to do better than I did about that. I suspect that that's what some of this is. I... I don't know. There are only a very few people from college that I'm still in touch with, it's weird. Because I loved college! I should look them up. Alright. Um... This graph is fascinating, ok? It's complex. It is a... let me see how to describe it. Oh! Every vertex... every vertex is, a class, a course, offered at some university. It's a small university, ok? We could do the same thing for our, our, university but, this was done for some place else. Some place with not very many courses, k? This might just be a subgraph. So every vertex is a course. And, there is an edge between a pair of courses if some student is enrolled in both. Ok? Does that make sense? Sooo... if you are in these two courses then you represent the edge between. Now it may be, if there are five students or ten students, but, if these two courses have student overlap, there's an edge between them. Now. All these edg-, all these vertices have shapes associated with them. What do you notice about the configuration of the shapes? You can even just look at a little subgraph, and little subgraph and you can notice this... characteristic that I'm talking about. What is true... and, yeah? Very good! No two of the same shape are connected. We say that, the vertices on this graph are colored. In this case they are colored and shaped. And what that means is, every edge's endpoints are different. Now, what on Earth is this graph used for? It's very timely, because it's used for finals scheduling. So, all of the, for example, I'm going to take the green circles because they're easy to talk about and easy to see. All of the green circles, can be scheduled simultaneously. Right? Let's put those at 8AM, Friday morning. K? And all of the blue triangles can be scheduled simultaneously. There will be no conflicts. K? So, this is it. Now, here's the- so that is the formulation of the problem. That's the formulation of the problem, kind of cool right? You're sitting there wondering, oh, I wonder if our registrar has software that does this?"...It doesn't... Because there is no algorithm, there is no efficient algorithm for solving this problem. K? Woah? I didn't know, I didn't know there were-yes! In fact, this could be your path to fame and fortune! I didn't know there were easily stated problems for which there's no reasonable algorithm. Now, you know, can you get close? Can you do well on sub-problems? Does a greedy approach work? You know... there are all kinds of things that, that, can make at least pieces of this problem a little more tractable, but, isn't it interesting to think about the idea that there are questions that are easily posed, but for which there exists no known efficient, efficient is key here, solutions. K? Alright, so, there you go. A graph coloring. Any questions or comments about any of these? K let's look at a few more. Um, oh... oh c'mon, you can do it. I love this one. Raise your hand if this game is familiar to you. The game in the upper-left, er, upper-right corner is familiar to you. Ok, it's a little puzzle game, um... you get a board, or a card that tells you how to configure the game, and the object is, uh-oh, somebody help me out here, to get the red car out, right? Is that right? And, you're movements are constrained in that... oh, somebody help me... how do you do, what is the constraint on the movements? Yeah?
I think it is probably laid out by some physical relationship.
Okay so or forwards or backwards right? There is no turning it's plastic, if you tried to turn these cars they'll break. Right. So each car can only go, you're trying to get the red car out, and each car can only move forward and backward it's a little puzzle. Alright, so the question is what's the graph? Now remember, remember, that to describe a graph, means to tell what the vertices represent and what the edges represent. So what the heck is that graph? You're welcome to come up here closer if you can't see very well from back there. You're just welcome to stand right up and come and look if you like. Let me see how well you can see. Can you see very well? Kind of, okay. Where it looks like there might be an edge between them, pretend there is. What is the graph what are the vertices, and what are the edges? And then I'm gonna ask what are the green dots? Mmmmmm. Finishing positions is a good guess. It's a good guess. Yeah? Start with vertices. Yes, very good. So we say that the ver- each vertex is a state of the game, and that corresponds to a position, a set of positions, of all the cars. So presumably, that picture in the upper right hand corner, corresponds to one of the vertices in the graph. Okay? Any question about that? Yeah? Yes! Very good. So the edges between them are uh correspond to the ability to move from one position to another via a valid move. Okay? Alright, fine, What are the green dots? Yeah? Yeah! The path to completion, very good. So presumably this is the start configuration, and I'm guessing, I'm hoping, I guess, that in fact those green dots correspond to the shortest path to completion, okay? And that blue up there is done. Alright, so what's with all of fan out up there, with all the different the fan out in the path? Somebody who plays the game, tell me what happens at the very end. Somebody who's played the game, tell me what happens at the very end. Yeah? [student response] Uh huh? Ah! Okay, so I think, that that corresponds to ending of over here, but I don't think it describes this stuff. Yeah? Yeah okay, so sort of. That's a little closer. So those are all the shortest paths so presumably you wouldn't have any kind of extra" moves. Gratuitous extra moves. The answer is when you're close to the end, there are lots of different ways to finish it off. Right, like you can move backward and, you know, I don't know. You can- you get to decide which one to move first and you know, you can finish the game up either way. So at the very end, there are lot more degrees of freedom to finishing the game efficiently, k? So this is a great game to play, while you're riding a bus, say over thanksgiving. I'm pretty sure there are mobile versions of it. In fact, all these think-fun puzzle games, are super fun and probably have mobile apps that correspond to them. Okay, uh I have a question for you, don't look at the graph yet, I have a question for you. When you were in about 4th grade, probably, your math teacher gave rules for checking for divisibility, right? What was the rule for checking to see if something was divisible by 2? Even, right, The, the one's digit was even. How about the rule for checking if something was divisible by 3? Some of the digits uh is a what? Divisible by 3- Oh my gosh, it's recursive! [students expressing stress at hearing recursive] You didn't know it! You were doing a recursive algorithm when you were in 3rd grade, right? Because what if the sum of the digits is 18? You added again, right? Ohoho, goosebumps, right here. Okay. Uhh alright, how about 4?
Last two digits you has to know you fourth time table pretty well, right? Five, easiest one, and the one place good, six, two and three, seven. No body ever knew a rule for seven, right? about about eight? Was there a rule for eight? Last three Digits? Long division skill. Or it is your eighth time table pretty well. How about nine? Yes, some of the digits is again. Ok. It is that whole seven thing always buged me a lot. If it is like 8, you could do like divided by half and then do it with 4. There is no rule for seven, really a problem for me. It turns out that there is a little graph that could help you out with the divisibility by 7. It is a algorithms for checking. I am going to go through it very quickly. You will not be tested on this, it is nifty. You start at the circle node on the top, this is an example of a finite state machine. A particularly finite state machine, of which a graph is a key component, for each digit D in the given number, starting from the left as if the number is a string, I am not sure if it matters. For each digit follow D blue edges, after you do that, follow the red edge. So it is blue for the magnitude and then follow a red. For example, when I read the three, I am gonna go one, two, three, got it? And then, followed the red. So after the red, I am in that state. Any questions? Now let us do seven, cause it is fun. Do it in a different color even. Now seven. One, two, three, four, five, six, seven. and then one, the red one, to go here. Ok. Now zero, so I don't go anywhere but I do have to follow the red, and then, three, one, two, three, follow the red, oh, look. If you end up in the circle node, your number is divisible by seven. Alright, any questions? I will tell you how you come up with it. It is cool .In CS376 you used to study things and it would be a homework problem in that class long time ago. I am not sure if they have time for fun little puzzle like this now, but this is.. What do you think each vertex represent? Mode seven, very good. So my guess is that 3000 is what ever the first one is mode 7, and then, the seven get you back to that thing. It takes that all the way around. It has to do with with the values mode 7 to get the divisibility of powers of ten mode 7. A number theory class, not know it very clear. This is a graph applications, who know. You could wright code to do that very fast. When I firstly got there, one of a faculty person who ended up being my advisor who is now a friend, told me that finite date machine, were just programs. And then I asked what are you talking about, one of them is like this combinatory structure that you can build picture out of. One of them is a way of speaking, a way of control data. They cannot possibly the same thing. But he is right about it of course, a advisor always are. Not true, but in this case, he was. Basically, you are changing the state of your system conditionally. If you see something like three, you increase it by three. What ever you see there is the value you use implement the state of the diagram. There is code all over the place, I am pretty sure, that you could actually wright the code to do this by looking at the diagrams.
Last 2 digits. so you had to know your four's time tables pretty well right? Five? easiest one. yeah in the one's place. good. six? two and three. seven. nobody ever knew a rule for seven right? how about eight? was there a rule for eight or did teachers... Last three digits. oh boy. So you have to pull out your long division skills for that one almost no matter what okay. Or get to know your eight time tables pretty well. okay fine. How about nine? yeah sum of the digits again right. okay alright it's that whole seven thing that always bugged me a lot. because with eight you can like divide in half and then do the four trick right. Alright so the whole there is no rule for seven really was a problem for me in fourth grade. alright. Well it turns out that there is this nifty little graph that can help you with divisibility by seven. It is an algorithm for checking. I'm going to go through it really quickly. You will not be tested on this but it's kind of nifty. alright so you started the circle node at the top. So this is an example of a finite state machine. a particular kind of finite state machine of which a graph is a key component. For each digit d in the given number. Starting from the left as if the number is a string. Though i'm not sure it matters. It probably does matter actually. For each digit follow d blue edge and then after you do that follow a red edge. so its blue for the magnitude and then follow a red. so for example when i read the three I'm going to go one two three. got it? and then follow the red. So after the the three i'm in that state. Any question about it? Okay now let's do seven because this is fun. I'll do it in a different color even. Now we're going to do seven. Alright one two three four five six seven. oh look it brought me back to where i was. And then one. the red one to go here. Now zero. So i don't go anywhere but i do have to follow the red. and then three. one two three. Follow the red. oh look. if you end up back at the circle node, your number is divisible seven. yippeeeeee. yessss. not even kidding. alright any question about it? yeah? Did somebody get a PhD for this? probably not. [laugh] alright so you know. i'll tell you how you come up with it. It's cool. In CS what used to be three seventy three you studied these things. And this would have been a homework problem in that class. when it was offered a long time ago. i'm not sure they have time for fun little puzzles like this now. but yeah this is what do you think each vertex represents. mod seven very good. my guess is that three thousand is whatever the first one is mod seven. and then the seven gets you back to that same spot. is that right? it takes you once all the way around. oh and then one more. so i don't know exactly. but it has to do with the values mod seven together with the divisibility of powers of ten mod seven. a number theory class would also make this pretty clear probably. Alright any other questions about this? To graphs! Look it's a graph. these are graph applications. who knew? you could write code to do this super fast. oh when i first got here. The faculty person who ended up being my adviser and who is now a friend told me that finite state machines were just programs. And I went what on earth are you talking about? One of them is this commonatorial structure that you could build pictures out of. and one of them is a way of speaking. a way of controlling data. They can't possibly be the same thing. but he's right of course. Advisors always are. No not true but in this case he was. That basically you're changing the state of your system conditionally. If you see a three, you increase something by three. Or whatever you see here is the value you use to increment the state of the diagrams. So there's code all over the place there and i'm pretty sure you could actually write the code to do this by looking at the diagram. okay any questions about it?
All right. All of these have stories. I think this is why we are gonna do this. All right. So here is another graph. You've probably seen graphs like this before. Um..this is a surface mesh, uh... of a little thing. OK, a surface mesh. But dataset itself, which is really just the vertices here. The data set itself is a classic dataset used in, um, graphics algorithms, used as a benchmark for any kind of new graphics algorithm that anybody ever wants to do. So they refer to the dataset itself as the Stanford bunny, for obvious reasons. It came..I mean it happen to have originated at Stanford in their graphic research group. And examples of its use as a benchmark are, are there somebody with testing out too see how there, you know, how their, the lighting source worked with this shiny texture that map onto something in here. You know, hair is the hardest thing to model. And so it's very common to have a ten-set modeling hair graphically. And the graph part of this is really fascinating. So this data set is way way way way way too dense. It has way too many vertices. And so the goal is to come up with a reasonable way of shrinking that dataset into something tractable, something that can pop way quickly or something you can animate most specifically something that can be man animated for example. And then to use the triangulation the triangle mass mesh must be between the vertices and surfaces on which to build your graphic applications. So sitting underneath that shiny bunny is actually a whole bunch of triangles, each of which has coloring map onto it, in a particular way. OK, based on physics, the physics of light and color, OK, and movement and angle, and lots of different things. So, the goal, then, is, in computational geometry is to take a dataset and to shrink it down in a meaningful way. Now this bunny was created with pretty good, with a pretty good algorithm. It looks like because in areas of high curvature there are still lots of points. But in area of low curvature, like, you know, where the cross the back of bunny, there aren't many points that is the triangle themselves are fairly close to the actual surface the bunny. OK, Any questions about that? So this is cool. This was when I first came to grad school this was what I thought. I wanted to do 'cause it's just fond to think about. OK, so the graph itself is the vertices that actually do lie on the surface of some bunny, somewhere, historically. And the edges are created algorithmically to represent the surface of bunny, to be representatives of the surface of the bunny. Now all right so what's the rest of the story? The rest of the story was I was in my aunt's house in Saratoga, CA, which is kind of close to Stanford and we were in her family room. It's a family gathering I haven't seen her for a long time, it was great. Sitting in the family room, looking up at her book shelf and there is the Stanford bunny, like. So little tarakada bunny, right? I had only ever seen it in that form. And I guess... I'm like Ah..!!! GOD! Ah!!!! Ah!!!!!! So the most mysterious thing to fame I ever experienced. After I woke up... no I didn't really pass out get but you were to get that bunny! but it turns out the bunny is just some mass-produce little long ornament. There is probably thousands of them especially in Bay Area long ornament stores, or something like that. But!! But you know just a for moment before that I thought I was in the present of greatness. So this is rightly boy, who is now 8. OK any questions or comments about that? So if you are interested in computational geometry or graphics, of course there are experts in our department who will be very happy to talk to you. All right.
alright all of these have stories I think this is why I meant to do this Alright so here's another graph You've probably seen Uhm graph like this before This is a surface mesh Uhhh Of a little thing okay a surface mesh The data set itself Which is really just The vertices here The data set itself is a classic data set Used in uhm Graphics algorithms Used as a bench mark for any kind of new graphics algorithms That anybody ever wants to do So they refer to the data set itself as the Stanford bunny For obvious reason, it came I mean it happen to have originated at Stanford In their graphics research group And examples of it is used a bench are of there was somebody testing out to see how Lighting source works with this shiny texture that they are mapping on something You know hair is the hardest thing to model and so it's very common attempts at modeling hair Graphically, and the graph part of this Is really fascinating, so this data set is way way way way too dense IT has way too many vertices so the goal is to come up with a reasonable way of shrinking that data set into something practical so you can pop away quickly or something you can animate, most specifically something that can be animated, for example And then to use the triangulation, the triangle mesh between the vertices As surfaces on which to build your graphic application so sitting that shiny bunny is actually a whole bunch triangles, each of which has coloring mapped onto it in a particular way based on physics, the physics of light and color Okay and movement and angle and lots of different things Okay, so uhhh the goal then is in computational Geometry is to a data set and to shrink it down in a meaningful way Now this bunny is created with a pretty good algorithm because in areas of high curvature there are still lots of points but in areas of low curvature, you know, across the back of bunny There aren't many points, that is the triangles themselves are fairly close to the actual surface of the bunny Any question about that? so this is cool When I first came to grad school, this is what I thought I wanted to do because it's just fun to think about Okay, so the graph itself is the vertices that actually do lie on the surfaces of some bunny, somewhere history and the edges are created arithmetically to represent the surface of the bunny to be representatives of the surface bunny now so what's the rest of the story? The rest of the story is that I was at my aunt's house I was in Seratoga, California which is kinda close to Stanford. And we're in her family room ,it's a family gathering, I haven't seen her in a long time it was great, sitting in the family room looking at her bookshelf, and there is THE Stanford bunny. Like the little terracotta bunny. I had only ever seen it in that form. And I gasped. I'm like *gasped* It's the nearest thing to fame I've ever experienced And after I woke up, no I didn't really pass out Well it turns out the bunny is just some mass produced lawn ornament. There are probably thousands of them. Especially in bay area lawn ornaments stores or something like that, BUT just for a moment there, I thought I was in the presence of greatness. Alright any questions? So if you are interested in computational geometry or graphics, of course there are experts in our department who would be VERY happy to talk to you Alright.
Everybody has their favorite graphs. This is my least favorite graph. I hate this graph. I like part of it actually. I like this one. I like this one....(repeat) I do not like this one. I really don't like that one. I don't like this one, this one..... I don't like that one neither....I don't like this one. All right, should we talk about what this graph is? Pains from stomach hurt. All right, so the vertices are CS225 students, and the color of the vertex, color and size actually is the semester the student was enrolled. Ohhhh... Ok, the orange ones are the current semester and this is MP3 from few years ago. What? So green is I don't know, the year before. the semester before. So, do you see why I don't like this one. So this person says to this person Hey, let's go get ice-cream". And this person says:I can't go, I have to work on my MPs" And this person says "Oh I can get that over with you." Thereby denying this person the joy of conquering. Ok,ughhh... Why don't I like this one? Because our MPs allows a pair but not a triple. So I don't know... You know there are a lot of stuffs to talk about here. This person needs a lot of help. I am pretty sure this person was because they probably get caught in. This almost certain get caught in. Oh yeah okay there is an elephant in the room right? I could actually write down the netid right here, and you guys go like. Oh yeah, I know that one. Pretty sure, it's been there for years. We have tried to figure out, then when we've tried to get the person to get down. They won't, they don't. Like the one person, normally when we see person's github, we ask them to take it down, and they go Oh, yeah,sure sorry" just take it down, I don't care. Umm cuz they don't want me to think you know whatever. That person, that is just still there. But I am pretty sure if I did say like go oh yeah, rings the bell. Any question or comment about this? The key thing I am pointing out here is if you use somebody else's code, especially something you find online. This is the first one that appear on github I believe a long time ago. So here's what happens. I am pretty sure that this person and this person really had no reason to have written/ worked together. And certainly these people they didn't know that they're working with other people. They didn't know this is the rule of transitivity here. If they're both like this one, they're very likely to be like each other. Moreover, that codes always gonna be there. I can't get it taken down. If you use it you join the club. Like everytime I see this graph, I go I know who that one is. You can't get your code's DNA out of the graph at that point. Ok?
Everybody has their favorite graphs... this is my least favorite graph. I hate this graph. I like parts of it actually. I'll show you the parts I like. I like this one. I like this one. I like this one. I like this one. I do not like this one. I really don't like that one. And I don't like this one, this one, this one... I don't like that one either. Mm mm I don't like this one. Alright, should we talk about what this graph is. It makes my stomach hurt. Alright, so, the vertices are CS 225 students and the color of the vertex, color and size actually, is the semester in which the student was enrolled. Oooooohhhhhhhhllll. The orange ones are the current semester and this is MP3 from a few years ago. What? So green is well I don't know.....the year before, the semester before. Soooo do you see why I don't like this one? So this person says to this person, Hey, let's go get ice cream." And this person says, "I can't. I have to work on my MP. And this person, Awwww. I can get that over with for you. Thereby denying this person the joy of conquering, right? Okay, why don't I like this one? Well because our MPs allow for an sided pair but not a triple so I don't know. And so you know there's lots of stuff to talk about here like this person needed a lot of help. I'm pretty sure this person was Pete. Because they probably got called in. I don't know whether this person did or not. This one almost certainly got called in. Oh yeah okay there's an elephant in the room, right? I can actually write down a netid right here and you guys would go, Oh yeah I know that one." Pretty sure... it's been there for years and we've tried to figure out and we've tried to get the person to take it down and they won't and they don't and it's like the one person normally when we see the Github stuff we ask the people to take it down they go, Oh yeah sure sorry!" I'm like whatever just take it down I don't care. Cause they don't want me to think you know whatever. But that person that its just still there. I'm not gonna say the netid because that would I bet would have to violate all kinds of rules but I'm pretty sure if I did say it you would go, Oh yeah, that rings a bell." Any questions or comments about... Oh, so the key thing I wanna point out here is that if you use somebody else's code, specially something you find online, this was like the first one that ever appeared on Github I believe a long time ago. So here's what happens I'm pretty sure that this person and this person really had no reason to have written similar or have worked together and certainly it's the case you know these people they didn't know that they were working with other people. They didn't know that this is the rule of transitivity here. If they are both like this one they're very likely to be like each other. Moreover that code's always gonna be there I can't get it taken down. If you use it, you join the club, right? Everytime I see this graph in the future, I'm gonna go oh yeah I know who that one is. I know who that one is. Right like you can't get your codes DNA out of the graph at that point. Okay?
Any questions about it? Yes? Look at all the questions. The orang? Well it's this semester ten semesters ago. I have not run thisgraph for this semester yet. I haven't seen the graph yet. I'm going to. Yes? Yes I have to call in.. Oh yeah. oh yeah. And the class was a lot smaller then. There weren't any orange dots there. I think it didn't draw all the ones that were just singular orange dots. okay. yeah it's a huge problem. we should all be embarrasssed by it. okay. ah. so the thickness of the edge measures the amount of similarity. okay so this person thought it was really safe just to hold wholesale copy this code. And it's exactly the same; pretty much exactly the same. where yeah the width of this line tells you how similar they were. okay. and it's just a similarity scale between 0 and 1. presumably it's close to the fractions of similar lines of code. okay. yeah? oh this is actually, i think, the most fascinating question. umm... so he said, well what if it happens accidentally?" and the amazing thing is it doesn't happen accidentally. it just doesn't. it's the weirdest thing. umm.. people write, just like when people write english. it.. it's very, you know, people have their own style; people do things, measurably differently. so now, especially our mp's are just big enough, i think, that it's not a problem except for mp1, right? like, we're.. oh gosh! how else can you do this besides a nesteed for loop right? umm.. so mp1 tends to sort of give false positives. umm i have seen for mp4, it's clamped down enough that we saw what we call the Charlie Mooney effect. Charlie Mooney was one of the very best course staff people in history. and he, like, would teach the material and he taught it in such a particular way that it informed people's code and very substantially and so we saw a bunch of them look very much alike because of Charlie Mooney's instructions. So, you know, of course we're fair, right? like we're, i'm not, i certainly don't want to be at war with students. so, right, you know, we don't push on that very much. do comment's come into play? the question is do comments come into play?" so, umm.. i feel a little.. uh.. strange discussing like how we do this.. but still, because.. because, you know.. information is good, we should be on the same page, right? umm.. so the question is, do comments come into play?" comments do not come into play in this analysis. but i never ever ever ever call anybody in without looking carefully at the code. and so when i have, you know, comments are a tell. like if people have comments that match too, then i'm.. i'm like a hundred percent sure this is a probable. so they come into play that way. they don't come into play in the initial analysis. they are looked at. okay. third question! yeah? who's.. i can't tell you. it's on github it 's there now. you shouldn't go look because then i'll you know... it's there. yeah?
So there are actually a few different algorithms that do this This particular one was created using MOSS which is a measure of software similarity Probably the most widely used in courses like this I tell you this now, I used to not tell this because I wanted to keep it on the down low So it's unfair because students will exploit, by googling how does MOSS work? Those people will have the nefarious advantage over people who are kinda oblivious. So I'll tell you we used to use MOSS, it's done, you can look it up, you can read the white paper It's done by looking at Strings of code what are called N-grams, I believe it does not look at the compiler code. There are new tools out there that some of our students are developing. And we're migrating to those, because they actually do look at the syntax tree. Alright so my least favorite graph. The upshot is so here's what I really want to say about this Oh my gosh [mumble] Here's what I really want to say about this. You are all, there are two things, you are all extremely fortunate to be here. This is an amazing place but to also deserve to be here. They don't let anybody in here out of pity. So this is an opportunity to grow and to challenge yourselves and you know, to walk in this community of achievement and discovery is a better way of saying it. If you do this, if you do this, you hurt everybody right? You cheapen the value of your degree You create this kinda of I'm going to sneer at your when I walk by in the hall" not that you care about, but you know you risk your degree, right? You risk getting in trouble for this. But most importantly you don't grow in the way we think you can and we want you to grow right? So the incentives to NOT do this are actually really huge. Now if you ever have that feeling, oh it's 11:59 and 59 secs right? And this is your out, OMG come talk to us. We'll figure it out, we'll help you figure it out. We don't, you don't have to do that. There's other ways. Yeah? [mumble] Helping" So we hire the TA's because they are good teachers generally. Generally really good teachers and we've never seen a connection like this with a TA or CA NEVER, EVER EVER So what happens is that your random friend got an A in the class looks at your code. And they go I don't know what you're doing, here's what I did" and then you're lost. The CA's will never do that, that's not what they do. That's what the difference, right there. The minute you look at somebody else's code, your ideas are shaken. Yeah? [silence] I mean ideally it shouldn't matter. I'm actually doing it for Lawrence in 241. yeah so he doesn't have the issues, alright yeah so the comment was shouldn't we start the semester with this? Probably true, point taken. Alright Happy thanksgiving. I'm thankful for all of you! Now, it's right now
welcome back. how was your break? So we have this many more hours together. one hand. and we have a ton of content to do. So ideally this would be sort of the time between midterms. it isn't. It actually is the book of final exam. So we cannot turn off the deal yet. Because you know, you are not a computer scientist dough(?) of graphs. Our discussion of the details of graphs algorithms. In the discrete math class all of these definitions had been handed to you. If you're probably, 3 or 4 lectures scattered about the argumentation. If you glance over this list. It's kind of ugly. Each of these capitalized things is a phrase. If you glance of this list, and you don't yeah yeah yeah", then you might want to revisit these terms in a fairly focused study kind of way. I'm going to be using these terms without definition in these 2 lectures. I'm almost certainly completely not able to reinforce their definitions. I won't just cruise right past, but it's very likely there will be very little concrete and rigorous definition of these kind of stuff going forward. I'm gonna advance that slide and we'll be done. Ready for this? Okay, they're gone. But we know them. So we're going to spend just a few minutes talking about some theory that's going to help us analyzing running time of algorithms. These are so fundamental that I want to make sure you have them. We're starting off with a graph denoted by a pair of sets, one of which is vertices the other of which is edges. It's a combinatorial construct. By way of notation, we're typically going to refer to the size of the vertex set as n and size of the edge set as m. Most of the algorithms that we're going to talk about have running times that depend on the number of edges in the graph. But usually when we wanna report the running times, we wanna report them in terms the number of vertices, n. So what we need to do before we go on, is make sure we completely understand the relationship between the number of vertices, n, and the number of edges, m. That's what this slide is all about. The question is, if I tell you I have a graph that has n vertices, how many edges does it have? Alright first thing we're gonna talk about is the least possible number that such a graph would have. So it would have no fewer than what? The answer is, depending on whether the graph is connected or not connected. What does it mean for graph to be connected? See I couldn't going through the definitions without saying them.
From say the last part again from what? Very good. So the shorter version of that was exactly right. The shorter version of it is between any pair of vertices there is a path. There exists a path between any pair of vertices. Alright if that is the case, then your graph is connected. Now what does it mean for it not to be connected? Well, it's the not of that. That is there is a pair of vertices where there isn't a path between them which means you cannot get from one vertex to another walking on edges. Okay? Connected. Not connected. Alright so let's start with not connected first. What's the fewest number of edges a graph that is not connected can have? The fewest number not connected graph. Everybody raise their hand with the number. Zero is correct. This right? Alright about connected. Ooohhh gets a little harder. Uh oh. Yeah? N-1 very good. Did you sketch that down and figure it out or did you remember it? You just okay. That's called remembering it I think. Yeah good. Very good. I believe at last count the last time I did research there are 37 different proofs of that result that the least number of edges in a connected is n-1. Okay? We're gonna do one of those proofs on the next page. The one that I kinda like the best. Alright fine. Let's talk about then the upper bound on the number of edges and this time we're gonna characterize the graph as either simple or not simple. Uh oh. What's a simple graph? Mike. Alright no multi-edges we usually say so simple means a simple graph means that there are no self loops like this is disallowed. And I shouldn't have made that directed. And no muilt-edges. Good. So that means none of those. Okay? Alright here's a nice time for me to say that if I forget to say a graph is simple in this class you should assume that it simple. So the default graph here is a simple graph. Any question about that? Let's see if the graph is not simple, how many edges might it have? Is infinity a number? It's like a place. Infintely many right? Because we could just keep drawing them and no matter how big or how many we drew we could just add another so there is no limit the number of edges. Okay. How about for a simple graph? Yeah? Ohhhh. This is an upper bound so we wanna put in as many edges as we can. As many edges as we can. Yeah? Ohhhh nooo. You should sketch it down just a little bit. Just draw a few pictures and see if you can come up with a scheme for figuring this out.
From say the last part again. From what? Very good. So the shorter version of that was exactly right. The shorter version of it is between any pair of vertices there is a path. There exists a path between any pair of vertices. Alright. If that is the case then you're graph is connected. Not to be connected well it is the not of that. That is there is a pair of vertices where there isn't a path between them which means you cannot get from one vertex to another walking on edges. Ok connected not connected. Any question? Alright so lets start with not connected first. What's the fewest number of edges a graph that is not connected can have? The fewest number of not connected graph? Everybody raise hand with the number. Zero is correct. Alright. How about connected? Gets a little harder. Uh oh. Yeah? N-1. Very good. Did you sketch that down and figure it out or did you remember it. You just ok. That's called remembering it I think. Yeah good. Very good. I believe at last count the last time I did research there are thiry seven different proofs of that result. That the least number of edges in a connected graph is n-1. Ok. Uhh were gonna do one of those proofs on the net page. The proof that I kind of like the best. Alright fine.. uhh.. lets talk about then the upper bound on the number of edges and this time we are gonna characterize the graph as either simple uh oh. or not simple. h oh. Whats the simple graph? Mike? Alright no multi-edges we usually say. So simple means, a simple graph means that there are no self loops. Like this is disallowed. Ok I shouldn't have made that directed and no multi-edges. Good. That means none of those. OK? Alright uhh here is a nice time for me to say that if I forget to say a graph is simple in this class you should assume that is simple. The assumption, the default graph here is a simple graph any question about that? Ok. Alright Fine. Uhhh lets see. If the graph is not simple. How many edges might it have? Is infinity a number? Infinitely many. We could just keep drawing them no matter how many we drew we could always just add another so there is no limit to the number of edges. Ok. How about for a simple graph. Ohhh. Yeah? Ohhhh this is an upper bound so we want to put in as many edges as we can. as many edges as we can. Yeah? Ohhhhhhh noo you should sketch it down just a little bit. Just draw a few pictures and see if you can come up with a scheme for figuring this out.
Those of you with your hands raised, uhmmmmmm. I wan't you to very carefully instead of just saying the answer, the next thing I'm going to ask you is: How do you know that's the answer? So think a little bit about how you would argue that your answer is correct. For those of you who are waiting for me to respond. Okay ready? It is N*(N-1)/2. Where did that come from? N time N minus 1 over 2. Okay. Alright. So raise your hand if instead of saying that, you were actually going to say N choose 2. Were you going to say N choose 2? Okay good, we're going to talk about all of yours together so remember that its you and who said N time N minus 1 over 2? Okay good, help me remember that its the two of you guys. Okay? And lets see there's one more way of thinking about this. Yea? ESP here you don't even have to finish. Okay? Yes. The summation of- oh you wanna finish? Yea. Summation K equals 0 to N minus 1 of K. Very good. Alright. So you learned early on. So you learned early on that all three of these things were equivalent. But. In the context of this particular application of these results, there are different ways of looking at the problem that leads to each one of them. Okay? How- what justifies this? We're counting edges. We're counting edges and I want to know why this is a good answer? Who said this one to me? Why is this one a good answer? Very good! Excellent! So what he said was Look, every edge has 2 endpoints. Each of those endpoints has to be a vertex, so the total number of ways of choosing edges is the number of vertices choose 2. Any question about that? That's how many edges there are. Any question about it? No? Good? Okay, uhmmmmmm. Let's talk about this one next? How do you justify this one? Who said this one? Who said- Oh yea, how do you justify this one? Oh its the shorthand for this one? So should we talk about this one first? How do we justify this one? Mike? Very good. Very good. Okay. So. Here's how we're gonna argue this. Okay? I'm gonna start at a particular vertex and say alright how many new edges can I draw from that vertex. And if there are N vertices then I can draw and edge to all of the other ones, or N minus 1. Then, I can go to the next vertex and do the same thing. How many can I draw? N minus 2. Go to the next vertex, do the same thing. N minus 3. Okay? is that clear? In the end you end up with a summation that looks like this. Alright. One last cool thing to discuss. Okay? Pretend that I drew this whole graph. Pretend I drew all the edges here. I think I probably missed, well, some. Pretend I drew them all. And pretend this is a complete graph with N vertices. Now what I want to do is count edges by counting endpoints. Okay? How many endpoints are there here? N minus 1. How many endpoints are there here? N minus 1. How many endpoints are here? N minus 1 all the way around right? How many N minus 1's do I have? N of them! That's right. N times N minus 1. So whats with the division by two?
good very good, i just counted end points, right and so this is the degree of each vertex, thats one of those vocabulary words, times the number of vertices that gets you all of the end points, divide by 2 since we are counting edges and not endpoints. Okay, it is clear. Now I love this but there are these three completely different ways of looking at looking at the same problem, thats cool right? Any questions about it? Okay well one more little thing that we are going to need for many of the algorithms that we do. Many of the algorithms that we do will go across a vertex and do something for every edge on the vertex, so our algorithms will iterate over all vertices. When I looked at this I was like waaooo. I need to redo that expression. So many of our algorithms will do something over each vertex for each incident edge on the vertex. Now, I want to know an exact expression for what this must be. And i don't mean upper bound on it, i mean tell me as accurately as you can, what you get if you add up all of the degrees of all the vertices. Very similar to something you already thought about today. Yea, twice the number of edges, very good. No matter what, if you add up, if you add up all of the degrees of all of the vertices, you end up with all of the end points which has to be twice the number of edges. Now, why is this important, why don't we always just use this? And the answer is because not all graphs have all of the edges. Not all graphs have all possible edges, sometimes we can be a little more specific with our algorithms and base them on the running time, the actual number of edges. Alright, any questions on anything on this page? I think i promised you this proof. So lets go do that. Okay, I am going to do a lot of talking for the next few minutes. You will notice that, it has a little bit different of a statement, okay? What minimally connected graph means is if you took out an edge, the graph would fall apart, okay minimally connected means removing an edge, makes the graph disconnected. Another way of saying this is a connected acyclic graph, right minimal means that there are no extra edges, so this is another way of saying it is a tree.
Good,very good! I just counted n points right? and every edge has two end points. So this is the degree of each vertex that is one of those vocabularies words times the number of vertexes that get you all end points divided by 2. because we are counting edges not end points. Is it clear? Now I love this there are these 3 completely different ways of looking at the same problem. That's cool. Any question about it? OK one more little thing that we are gonna need for many algorithms that we do. They will go cross a vertex and do something on every edge on the vertex. So, our algorithms will iterate over all the vertexes. So many of our algorithms will do something over each vertex for each incident edge on the vertex. Now I wanna know an exact expression for what it must be. And I do not mean a upper bond on it, I mean tell me as accurately as you can, what you get if you add up all degrees of all the vertexes? Very similar to something you have already thought about today. Yeah, twice number of edges, very good! no matter what, if you add up all the degrees of all the vertexes, you end up with all the end points which has to be twice the number of edges. Now why it is so important? why don't we always just use this? The answer is because not all graphs have all their edges. somethings we can be a little bit more specific with our algorithms and base them on the running time, the number of edges. Any questions? I think that I promise you about this prove. So let's go do that. Here is the set up. You notice that the theorem itself has a little bit different of a statement. What minimally connected graph means is if you took out an edge, the graph would fall apart. so, minimally connected means removing an edge makes the graph disconnected. another way saying is it is connected basically graph. Minimal means there are no extra edges. So it is another way saying it is a tree.
and then how many edges does it have? well it's just another way of saying n-1, cuz the size of v is n. Alright so what we're gonna do is we're gonna consider a random, arbitrary minimally connected graph. I've drawn a picture of one here, we're going to let v and e denote the vertex and edge sets. Now there's a lemma that we're going to need, that is every connected subgraph it's like subsets of these with some constrains of them you should look up them to be concrete so if you take a connected subgraph and you remove an edge, they'll fall apart. there's an easy way to prove this: if the subgraph is not minimally connected, you can remove an edge and it wouldn't fall apart. but then it would be true of the super graph too the larger graph too. and we already know that the large graph is minimally connected, so the prove is sort of unsatisfying, it's an easy proof by contradiction. okay finally we have our inductive hypothesis, notice here all I've done is I restated the theorem for graphs with fewer vertices. So it just says for any j less than the size of vertex z, any minimally connected graph containing that lesser number of vertices has j-1 edges. That's the inductive hypothesis, I'm gonna ask you where we're gonna apply it. So base case, a minimally connected graph of 1 vertex have no edges. Is that true? Yes. we're going to take a large graph and break it apart. we're going to pull out any one of the vertices and its incident edges. remove its incident edges, partitioning the graph into how many components do we end up in the graph? d+1. where c0 is going to be the vertex we remove. choose any vertex w and the edge set is empty. all the other components are going to look like this. How many edges do we have in the whole thing? all of we gonna do is count up edges. How many edges (what's the size of the edge set) are there in component k (any one of the component)? you know how many there are.
Umm, So I think, so the question is, how well do we need to know this, yes? Is that right? Um, So absolutely you should know that a tree has (n-1) edges. okay? Connected acyclic graph has number of vertices minus one edges. Thats should be a back pocket result, okay? Now, should you be able to prove it? This is kind of an accessible proof, because, we can draw a picture that will guide you through it. So the process of doing this proof is, draw yourself a little picture, give yourself labels to argue about, and then, just put it all together. Okay? So, should you memorise it? Well no, you shouldn't. Should you know how to do it? I think so. I think you should. CS 374 demands much more robust proofs regularly, so, if this is an on-ramp to that kind of argument, then you know, so be it. I think its appropriate. YEAH? Where, right here? Right here? Right here? huh? This one right here? Look, this one? Inductive hypothesis. Oh my gosh, I'm sorry. I'm doing this at me, not at you. Who knew you could be unclear in that particular way. I'm sorry. Alright, anything else? Yeah? Right here? Its the number of components. So, choose any vertex and let D denote its degree, remove its incident edges, partitioning the graph into D+1 components. So, I'm adding up from component 0 to component D, the last one, all of the edges. Okay? Is that alright? Alright. You good? It is what it is. Okay, lets move toward implementations. Alright, I wanna say a little thing about implementing graphs. You have been implementing graphs ever since about MP4 I believe. Yeah! The MP4 where you did flood fill you know. You were just operating on a lattice shaped graph that we think of as an image. Right? Its a pixel together with its neighbours. Each pixel is like a vertex. Each neighbour represents an edge. So, you've already operated on graphs. Now, that is extremely common, where the graph implementation itself is implicit in the application, okay? So, there may be lots of instances where doing graph algorithms, but you don't necessarily have an explicit graph data structure that you;re gonna point to. Instead you'll be talking about shapes, or who knows what else. States, game search engine, or something like that. So graphs are often are often not explicit in your algorithms, All of that said, there are some classic results that arise from classic implementations of graphs and we have to talk about those because everybody in your future world will expect you to know about these particular graph implementations. So we're gonna talk about them. Alright, so we're going to have an abstract data type that is a graph. The data associated with it will be some structure that reflects the vertices. Oftentimes this will be just a map or a hash table of vertices. Maybe its just a vector, where each vertex identifier is an index. Who knows, open to application, Doesn't matter that much. Same thing with edges, you have to have some structure that stores all the edges in your graph. Now what is that, I don't know. Maybe its a hash table again. Alright. But then, you also need some structure that reflects the connectivity of the graph. This is where we're gonna spend a lot of our energy. So this is like a look up table for data about vertices. This is like a lookup table for data about edges. And this is some structure that keeps track of how all the graph is connected.
umm so I think so the question is how well do we need to know this so absolutely you should know that the tree has n-1 edges. connected acyclic graph has number vertices minus one edges that should be a back pocket result. Should you be able to prove it. This is kind of I think an accessible proof. Because you can draw a picture that will guide you through it. Draw yourself a little picture and give yourself labels to argue about and then just put it all together. Should you memorize it? No, you shouldn't. Should you know how to do it? I think so. I think you should. CS347 demands much more robust proofs regularly so if this is a on-ramp to that kind of argument then you know so be it. I think it's appropriate. Yeah? Where? Right here? Right here? huh? This one right here? Look this one? Inductive hypothesis. Oh my gosh. I'm sorry. I'm doing this at me not at you. who knew. you could be unclear in that particular way. anything else? yeah? Right here? It's the number of components. So choosing the vertex and let d denote the degree remove the edges, partitioning the graph into d+1 components so I'm adding up component zero to component d the last one all the edges. Alright, we are good? It is what it is. Ok let's move towards implementation. I want to say little thing about implementing graph. You have been implementing graph ever since about MP4 I believe. Yeah! mp4 where you did flood fill. You were just operating on a lattice-shape graph that we think of as an image, right? It's a pixel together with its neighbors. Each pixel is like a vertex. Each neighbor represents an edge. You already operated on graph. That is extremely common where the graph implementation itself is implicit in the application. so there maybe lots of instances where doing graph algorithms where you don't necessary have an explicit graph data structure that you are gonna point to instead you will talking about shape or who knows what else? state in a game search engine or something like that. graphs are often not explicit in your algorithms. All of that said, there are some classic results that arises from classic implementations of graphs and we have to talk about those because everybody in your future world will expect you to know about these particular graph implementations so we will talk about them so we are going to have an abstract data type that is a graph. The data associate with it will be some structure that reflects the vertices often time it will just be a map or hash table of vertices maybe it's just a vector where each vertex identifier is an index. Who knows. opened to application. doesn't matter that much. same thing with edges. You have to have some structure that stores all the edges in your graph. Now what is that? I don't know. Maybe it's a hash table again. alright but then you also need some structure that reflects the connectivity of the graph. this is where we are gonna spend a lot of our energy. This is like a look up table for data about the vertices. This is like a look up table for data about the edges and this is some structure that keeps track of how the graph is connected.
Okay, now... Functions on such an abstract data type are many, There are many many. Uh, at a minimum we have to be able to insert vertices and edges, remove vertices and edges. It's very common to need the set of incident edges given a vertex. So this function would return to you, would return a set of incident edges, or an iterator over them, for example. OK? But the way you should think about this function is as returning a set of incident edges. OK? Our adjacent is a boolean that tells whether not v1 v2 is an edge in the class, see just test, and then finally these two we'll talk about them more... They are only for directed graphs. For now we're going to assume our graphs are not directed, they are undirected. Alright, any questions so far? Here's how we're going to do this. We're going to look at three different implementations and we're going to compare a few functions across all of them. Now, we're not going to look at all of the functions on the previous page, because we would fall asleep. These functions are adequate for getting at all of the issues. OK? Alright, implementation one. It's called an edge list, and basically it works like this. It is a structure for this, a structure for this, a structure for this, and we're not going to specify any particular reflection of the connectivity. OK? So we're just going to have maybe it's a hash table, constant time access to the vertices. Constant time access to the edges, and that's our structure. That's it. OK? Now, what does it look like? What does it, what does the implementation look like? The data associated with each of these things. Well the vertices it's just a list of vertices. Maybe you associate a weight with them, or a time they were created, or any other data that you want. But for now they are just a set, it's just a set of vertices, or a map of vertices. The edges though are more interesting. Edge A, for example, will contain data that reflects it's endpoints. We've got u and v here. B has v and w. C has u and w. And D has w and z. We're going to engineer everything so that u v is the same as v u. So it doesn't matter which order I put those in. Alright, any question about that? Yes? [gibberish] So that's a more complex, that is, that actually does... So what you're suggesting, so the suggestion on the floor is how can this be a good idea? Wouldn't it be a better idea to list for each vertex it's set of incident edges, and yes, that would be a better implementation. But we're not going to do it yet, we're going to be stupid first, because that's what we do around here. OK? We do things naively first, and then we'll move into complexity. OK, so I want to know how long does it take to insert a new vertex into this structure? There, I did it. How long does it take to add a new vertex into this structure? Constant time, very good. OK, this is adding into either the array or map. You have to be able to assume it's constant time. Fine. How about removing a vertex? Oh, and I'll use this notation. The size of the vertex set is n, the size of the edge set is m. So there are n of these and m of those. Ok, what does it mean to remove a vertex? Here, there I removed v and I have to remove all of it's incident edges. So removing a vertex really means remove the vertex and incident edges. So how long does that take? Big O of m is correct. Because we have to search this structure, right? Oh, there's a v, there's a v, and no more v's. We have to search that structure.
Alright, how about checking to see whether two v
Checking to see if two vertices are adjacent, or whether an edge exists in the graph. Go looking, no choice but to traverse that edge list looking for two end points. Returning the set of incident edges for a given vertex. Again, this is boring. You have to go in search of them. Decidedly uninteresting. Another strategy; keep the vertex set at size n and edge set at size m, but add a table with a row for every vertex and a column for every vertex. This is a probably implemented as a 2 dimensional (2D) array. The data stored here would tell you the index of this row, for example. The implementation, you would connect this to this row in the table. Similarly for the column, you'd also have some index here that's specified by the column, it'll be the same column as row. There is going to be an entry in cell uv if uv exists in the graph. Now it turns out to be very convenient to instead of just a boolean indicator, to keep a pointer to the edge that actually exists. Then you can store data about that edge, so uw is it there? Other things are just NULL. It's called an adjacency matrix. Running times of each of these functions given all of this structure. How long does it take to insert a vertex? What if the matrix is full? This is a 2 dimensional array. We need to be able to add a row and column to this matrix, and you know we're not stoopid. We're going to do it in such a way that we actually double the size (and copy the data). And the advertised cost for this (the cost of copying) is n squared (n^2). But we get n future adds for free, so the overall cost is going to be big O of n (O(n)) for re sizing. So periodically you have to do an expensive re size. How about removing a vertex? It's the same story. Actually. Let's remove v. How do I remove v from here?
O(n). Any questions about it? We will leave it blank and resize it downwards em when it gets too sparse. So we don't need to shift the data but we do have to walk across looking for all of them. ok? alright, good question. How about checking to see if to vertices are adjacent? O(1). Yeah! This is why this one is so beautiful. This is a constant time array look up right? Is this null is this null is this null......That's it. yeah? Yeah you also have to go down to the bottom but that's n as well. thank you for saying that. So you have to go this way too. yeah so it is two n instead of 1 sorry. Alright and finally how long dose it take to return the set of incident edges given an vertex. Where do they come from? they come from the array on the table right? And so this is O(n) as well. Is that better than this? Is that better than the one on then previous slide? The answer is it depends. What dose it depends on? Yes how big the n is! That is right. Whether m is bigger or smaller than n. very good. In general it is better. ok? it is pretty rare you would not implement your graph using this structure if you don't have many edges. So in general this is a better approach. Next time we will get to [gibberish] of recommendation and we will do an implementation called an adjacency list.
Okay welcome to systems programming so let's get started let's write our first c program that makes use of a system call i'll do an example and then I'll let you play as well so uh here's a little virtual machine i've got up and running and i can write a little c file here so what we're going to do is make use of a system call called write so let's try this we'll say okay write and then i need to give it a file descriptor more about that in a moment a little message like hello and then the number of characters or bytes that i actually want to send here so h e l l o that's five bytes we're going to send so let's try compiling this and once that's going we'll see that whoops we've got a little bit of a problem here that write was not declared before okay so the c compiler here is warning us that we're trying to call a function called write which hasn't yet been declared so we could declare it now i happen to know for example that the write signature looks a little something like this it takes um, it's called write  it takes a file descriptor which is going to be an integer it takes a pointer to a character and it takes another integer which is the number of characters to write so it looks a little bit like that in fact it takes a void pointer which means point to it without any particular type so i could attempt to compile this for example see if this works and oh ho ho if we look at the left hand side we can see we managed to compile a program called program here and when we ran it we got hello alright so let's do a little better then that though rather than me having to manually write the declaration in here these are already included inside an existing file which I get for free it's actually unistd.h okay so let's tell the preprocessor to read in the contents of the file go in and find a file named unistd.h and include all the text that is in that file okay so now when we run this we'll compile it and run it and great it prints out hello if i wanted to print out hello with a new line let's increment this to six and now i've got a program called Hello okay great and of course i could make my program print out hello world and do it on two different lines alright so uh that's my program working now it's time for you to play you create which uses a system call write to write a little message on the two lines see you in the next video after you've said hello to the world bye
so let's talk more about that file descriptor I'm gonna make my program be a little bit more useful by printing out Hello World" a few times so for example, I have a variable 'count' here and a little for-loop Start with count equal to five, while count is greater than zero each time around the loop we're going to decrement 'count' In C, there is no boolean type. instead, if I've got an integer value which is nonzero, that is treated as a true value So, I could actually write this more tersely just by saying hey, count!" meaning is count a non-zero value and if you compare two things, you'll learn that with an integer value of either 0 or 1 to mean for example if they are either the same or different so, we're going to print out hello world" 5 times I want to show you just a little idea here that actually I've got two file descriptors which are valid when my program starts. And they're called 1 and 2. Why might it be useful to have two output streams? well, you can imagine we have a program that is calculating something for example it's thinking of something to say or it's going to write to a file but we may also want to display some error messages back to the user or we might want to print some progress information the first output stream identified by the number '1' is the regular output, standard output The second one is reserved for error messages. Let's, for example, use this. Instead of error messages, we'll put a little dot to see this We'll run this and we should (if we got everything correct) see Hello" and...lib lib lib lib Now, why do we see .lib", because we said "hey, I'm going to give you a pointer and I want you to use that pointer and take the next 6 bytes from it which is the next  six character So we just got whatever happened to be in memory after our dot. So, we only wanted to do the dot Change that and run it again And great, we've got Hello and dot Hello dot Hello So, right now, both the output and the standard error are going to different places we could actually change that over here in the console before we start the program Our terminal can actually control where the output goes So, for example, I might say, I want to take the standard output and put that into a file. So, output.txt" So now, if I run this before the program starts, I'm going to redirect it's output into this new file Okay, so what we see on the console output is anything written to standard error The standard output is inside output.txt To prove it, let me have a look at that file. Let me cat that file So, output.txt And here it is! It says hello, hello, hello, hello" Now, rather than writing 1 and 2 over here, perhaps we should actually have some constants which signify what those values actually mean so we could say start define things to say have a constant here, I'll call it say STDOUT_FILENO 1" And I'll say define STDERRFILENO 2 so anytime you do hash define, you're talking to the preprocessor to say hey, in the future, parts of this file, if you come across this character sequence, then replace it (in this case) with either a 1 or a 2 depending on what it is" We can compile this, except I've got a surprise for you which is that these particular macros are already defined inside unistd.h So, I don't actually need to define them here in my program. So that's my little program. You see it's got a return value of zero. Which is a convention for being correct (no errors) But it's up to us. We could choose a different value, for example we could choose the value 42. And, I don't see an output value, but I can find out what the last exit value was of the last process Let me print it out It happens to be inside special variables so I could say Hello terminal value of this dollar question mark." which means give me the exit value (or the exit status) of the last command run. So there's our forty-two. Okay so, we've covered quite a bit of ground. We've talked about how in C, any non-zero integer is considered true" and zero is considered false" And, we've talked about these two different output streams. Now it's your turn to play with this. After that, let's have a go at creating some new files directly from C by making system calls So, now it's your turn. Have fun playing! Bye.
Welcome so let's start creating some files for that we can use the system call open() and for open we need to say whether we want to append to an existing file, create a brand new file, and we need to give it a filename For example, I might have a file name called output.txt" so the open call takes 2 or 3 arguments. the second argument will be exactly what we want to do so in this case we want to say create a brand new file and truncate it back to 0 if it doesn't exist so, I want to truncate as well if we are creating a new file we better say who can read this file and who can write to this file and who can execute this file so we are going to have to say something about the mode flags  who is allowed to do what finally this call is going to give us back an integer, a file descriptor just like we've seen so far with file number 1 and file number 2 so lets store that inside a little variable ok, so now I better actually find out what the correct syntax is and the correct arguments are in order to create a file so lets go and look that up and that we'll find inside the manual And, if, for example, I type man open" on a command line on a real linux machine. it doesn't quite work yet in my small virtual one. we didn't have enough memory to include all the manual pages yet but heres a linux manual page I found on the web for the open() and you'll see here's the function signature here where we're going to pass in an integer for the flags and the mode type so, I'm going to look up now the flags I need to open and create a new file I don't want to do append() I want to use create" and I want to truncate it as well let's include O_CREAT" here. I'm going to say "O_CREAT" which is a constant and I'm going to bitwise OR it with the flag to say "truncate" so let's look that up as well alright and i want to say when i open it that i am going to open it for say reading and writing so let us grab that as well so that is the first thing now we need to do the mode Let's write this as a variable. and there is actually a typedef it is essentially an integer but it is wrapped up in this type here called mode mode_t and we'll say that with our file we want to be fairly private and only the owner of the file can access it Let's go back up and find those flags, where are you? Here we go. We'll say that the user has read and write permission We'll copy the read one and we'll have write permission as well. But no one else in my linux system will be allowed to read it and write it. So that's the permissions we want What can we do with this? Well let's write something out to this file. We will write a little message Great!" and a newline so how many characters is that? I've got one, two, three, four, five, six, and a new line so that's seven characters" then we'll close this file descriptor meaning we don't want to use this descriptor anymore that will ensure as well that all of the bytes that we send to the file stream have been saved We're not doing any error checking right now, we're just trying to write the smallest possible program to create a file and send something to it let's run this and see what we get we'll run into an error which is: we haven't defined what this mode_t is what we forgot to do, was to do the includes the good news is that the man pages tell us which includes we need to put at the top of our program so let's grab those and insert them in here i will just get the formatting correct and, run it again Right so our program ran and it's still printing Hello" to standard out and dot to standard error but hopefully, it also secretly created another file let's have a look at that file I can do ls" and see if anything exists starting with "out" yes we've got output.txt. great! let's look at the contents of that file and it says Great!" Fantastic Right so now it's your turn to play: create a file and see if you can send some bytes to that file. so you'll be using open(), write(), and close(). Bye.
Hello, suppose we want to actually print out some integer values write() doesn't give us that fuctionality write() is the low level call that we make to the operating system to say look, here's a pointer to some memory and please take so many bytes from that memory and send it out to a file" or, possibly, another device if we want to change a bit pattern into a sequence of characters because we want to read, say, one-seven for the value seventeen that's not something that the system does instead, we've got some C standard library calls that we can call that do this for us and they will wrap the call to write() so as an example, let's try printing something out we can say printf my value is" and I can say %d" this means that the next argument I give in printf() better be an integer value so the bit pattern we pass to printf() will be treated as an integer to be displayed so let's have a little variable called result and I can say result is sixty five if I attempt to run this, we're using printf(), we haven't declared it beforehand so we get a warning to say oh, you're just using it." and, what we should've done is actually declare the function signature of printf() and that I know from looking at the man pages is inside stdio.h if you're coming from a cpp background, there's no IO streams we dont have operator overloading. instead, let's use printf() so we've got my value is 65" and, you'll see that actually this was printed out after the hello hello hello hello here's why: printf() has a buffer. the C libraries have a buffer so it's only going to call write() when that buffer is full or if we explicitly tell it to or if we finish a line so let's put a newline in here and run it again this time, we've compiled it, and we should see that my value is 65" appear before my hellos so this time, because we sent a new line, printf() will be making that call to write() to send its buffer out to standard out so now we can actually print out the value of our file descriptor let's do that. after we've opened our file, I'll send fildes is" and, we will print out fildes. and, let's get rid of the first one and let's flush our little buffer by sending in a newline and we'll see that our value is three so, we've opened up a file descriptor who's value is three in fact, that is expected by specification because if we successfully open a file, we'll get back the lowest unused integer (the lowest unused file descriptor) as one and two are already being used, we get back three so just for fun, let's actually close one of the existing file descriptors before we do the open() so let's close standard error I'm sorry, we'll close standard out and, we won't close our own file descriptor until the very end of the program here so I'm going to move that line down to here great, so, let's run this so, what did we do? we opened a file descriptor and now if we look at the output of the program, you'll see we're only getting our dots printed out on standard error why is that? what happened to our standard output? well, we better check out file output.text and you'll see that everything printed to standard out has been sent to our file why? because when we called open(), it gave us back a file descriptor for stream number one. and, that is the. that is where all the standard output is going to go so, all future output is being sent to our file this is a neat way if you'd like to do logging and we've just changed our program so that all future output goes to output.text now what if we've got a problem with open() ? right now, our code doesn't check for any error and, a better program would actually check the return values of our different calls for example, it could be that open() could fail. suppose, for example, we gave it a bad file descriptor now so we can see what's going on, I'm not going to close standard out anymore. I'm just going to give it a bad file name now, our program compiles correctly of course but this time our file descriptor is negative one so, we should check that in fact, if we check the man page of open(), it's always a good idea to check the section called return value" and you'll see, it's specified here that we'll get back a negative one if an error occurred so the last thing we'll do today is let's capture that and quit if we get a bad error so, if fildes equals negative one a common error is to write equals instead of double equals for comparison and we want to quit here so we'll leave our program, so let's exit with a value to say: hey, we couldn't carry on" I could've returned zero but I wanted to show you an alternative way to quit a C program is to call exit and we'll print out an error so, something bad happened while calling open so, we'll use perror() let's run this and, I get some implicit problem here that we're calling exit(). I need to find the right #include to call for that. but, you'll see on the lefthand side that we've got open() failed, so that's the part of the error message that I supplied followed by a colon followed by no such file or directories so it's complaining that my file name is bad if I had included a dot here, this is also an invalid file name because a single dot corresponds to the current directory and, it's complaining that it can't open that because dot corresponds to a directory so now it's your turn to play. bye!
Hi, so C is designed to be a portable language in a sense that we could write a C compiler for many many different hardware architectures from small embedded machines to large mainframes so C does not specify a precise number of bits required for, say, and integer instead it specifies minimums that should be supported by the architecture let's have a look at that. let's see how we can find out how large or small of numbers we can store in different types and also how many bytes each different type is  and even further, what is a byte? so let's start with our integers I could say hello but what's the largest value I can store inside my integer type? fortunately, there's some macros, some constants, defined inside limits.h let's find out what these are the int min and max is going to be %d and %d and INT_MIN and INT_MAX so, we'll print that out. I'll get rid of my unnecessary variable here let's run that and we see that on this particular machine, that an integer can represent numbers from roughly minus 2 billion to plus 2 billion a very wide range of numbers C promises that we'll be able to store the numbers between minus 32768 and plus 32767 in other words, an integer will be at least 16 bits what else do we have? how about a character? well, here's a surprising thing, a character is one byte so what do we mean by byte? surely we mean 8 bits? no. though we often say a byte means 8 bits in modern parlance, it doesn't have to be true and in fact, C is very careful to say that a byte does not mean 8 bits it means at least 8 bits our character, then, is at least 8 bits so why this distinction? well, in being portable, C needs to be able to read and write every bit inside memory and each bit inside each memory should only live inside one addressable memory location and, it could be that architecture have very different numbers of bits it can read or write for example, an early PDP machine had a 36 bit wide addressable memory so, C does not attempt to say it's going to be exactly 8 bits so how do we find out how many bits are actually in a character? well, again, the limits.h includes a useful constants here a character is %d bytes let's go and see what that is so CHAR_BITS and we'll print that out on this architecture, a character is 8 bits that's typical on modern machines so what if I wanted to know the actual number of bytes in different types? for that, we have something called sizeof we can give it a type and it will tell us how many bytes (or if you prefer, how many characters) are required to hold that particular kind so for example, let's find out how big an integer is on this machine perhaps you can guess the answer already so, sizeof int is %d and we'll have a newline as well is it any surprise that the size of an integer on this particular machine happens to be 4 bytes and that's not surprising because we need thirty two bits to represent all numbers between minus two billion and plus two billion there are other integer types you'll see things like short (which is generally shorter than an int), long (which is generally longer), long long (which is even longer, still) and compilers even occasionally provide their own custom types as well notice as well that these types are signed so we can represent negative numbers and plus numbers C also provides the idea of being able to say that we can have an unsigned version so, for example, I can have an unsigned int now there is no signed bit that is included in the bitwise representation so that's great if you wanted to represent all the numbers between zero and 4 billion on this particular machine the character type can actually be signed or unsigned depending on the particular implementation of the C language for this particular architecture so that's enough for now in the next video, we will talk about pointers now it's time for you to play and learn a little bit about the basic C primitives. Bye!
Now let's talk about pointers and arrays how might I make an array of integers? let's say I had some data and I did this well, on this particular architecture we just found out that an integer is four bytes so I've now got thirty two bytes of storage and in fact, it's going to be thirty two bytes on the stack so what do I have here? when I say data square brackets eight, I'm going to get back four times eight, thirty two bytes all together all contiguous in memory and in fact, data is going to point to  the very first four bytes so I've got four bytes and then four bytes and then four bytes and then four bytes and so on let's have a look at that so, if I say printf data is at and this time do %p, that means treat data as and print it out as an address so we'll print this out and we see we've got a value here in memory that data points to the very first element let's do something a little bit surprising here let's add one to data and print that out so, data plus one and we'll do data plus two and so on so, if we look over here at our output, we'll see that each time we add one, our address in hexadecimal is going up by four each time so we've got 9d40, 9d44, 9d48 here's why when you add an integer to an address pointer C knows the type of that pointer so in this case, we're pointing at integers so each time we add one, we actually want to progress to the next integer stored in memory and as each integer takes four bytes, that's why our address is going up by four each time so how could I use this? well, one way is to use asterisk which means use the address so, for example, I can say data the parenthesis are not strictly necessary but we'll use them in a moment and let's say store the value a hundred in there what about if I wanted to store some value at the next entry? ok so, hundred, hundred one so now I've stored the value a hundred that integer pattern into the first four bytes and the integer pattern for a hundred and one in the next four bytes and I guess you could figure out what this would do as well the asterisks means use the pointer follow the pointer dereference the pointer in other word, we've got an expression which is a memory address, now I want to use it now I actually want to use that pattern that bitwise pattern to actually read or write some memory so that's what the asterisk does means actually okay it's time to go and talk to memory this is so useful with arrays there is an alternative syntax which is to use the square brackets so for example I could have written the following which means take my address pointer add two to it and use that address for the array so these last two lines are the same in fact, here's a little secret about C that I could actually swap these around so we could also write this in this slightly crazy way so this is crazy but actually two square bracket data would evaluate to the same thing so that's something to confuse your non-C friends with that's enough with me playing with integer pointers now, it's your turn. Bye!
so what about strings in c? what if I said hello" how is this represented? well clearly it's made up of characters and I've got five characters to display h e l l o, but actually C strings contain an extra character at the end a zero value or null character to say hey this is the end of the string" so this is going to take six bytes of storage let's see if we can prove that we'll say printf() and Size of hello is %d" and we'll have a little expression here to say what is the sizeof() hello" and we'll print it out and you see that size of hello is 6 h e l l o that's five, plus an extra byte for the 0 to say that's the end so we can use sizeof() on constant strings we could also run through the string to actually find the 0 byte ourselves so let's do that let's have a pointer to a character I will initialize it to my string hello" which means pointer is initially pointing to h the first character I'll have a little count variable here and let's say while the pointer the value is not equal to 0" I want to do something lets increment the pointer lets move it onto the next character and let's increment our count as well so we can find out how many characters we have and then at the end we will say how many characters we found which are not the 0 byte so if our program works this should find five characters lets run it and i'll put in a new line at the end our little loop went around five times and all it did was increment count we could have made it of course print out each one of those letters we could also simplify our program a little bit because as you know any non-zero value is treated as true so let's remove that and say while star pointer and when we get to the null byte we will finish so just for fun lets change our program as well before we increment the pointer to print out the next characters my format string is just %c. and what character would I want? well the one pointed to by the pointer pointers to characters that Â each character is exactly one byte so when we add one to our pointer, line ten here we are actually just going to add one to it because each character is exactly one byte so there's our program and it managed to print out exactly hello" do we need to write this every time that we want to find out the number of characters in a string? no! guess what there's a function called strlen() so instead of my little loop if I include string.h I've now got strlen() so let me check the two results instead I'll say len is strlen() and pass it a pointer to my character I'm tempted to use pointer but that would be a bad idea perhaps you can figure out why so Strlen returned" and we'll talk about how to fix my program in a moment so we'll run this strlen() returned 0 why? because by the time my loop finished I'd advanced that pointer on until it had reached that null byte so when we passed that to strlen() it immediately found the null byte now what we should do is evaluate our strlen() before we change our pointer the last thing we'll do today is make our program crash let's try and change our first character to be someting else like 'J' turn it into Jello so let's dereference that pointer and use it to push in a character I don't want to have a string, i actually want to have a character let's try that and see what happens I get a segmentation fault when I try to run that line here's why, different parts of my proccesses' memory are valid for reading or reading and writing the program code, the actual assembly, the actual instructions for the cpu, can only be read and my constants, such as this hello" can only be read and the hardware is sophisticated enough to know which parts of memory are read and which parts of memory are read/write and which parts of memory are invalid so that's why I get a segmentation fault if I try to change the constant memory alright time for you to play with character poitners, bye
So this video is about how to have an argument let's have a look inside some directories that we've got on our little system so if I type ls /bin you'll see here's a whole lot of programs that I can run from my terminal window and some of them you might recognize already including ls for list the contents of a directory (what we just did) cat to list the contents of a file and print it out and echo simply to echo back whatever we type so I can say echo Hello World and we also can used echo to print out the result of the exit value of the last program run how is it that these programs then can find out the parameters (the arguments) that we supply? when they are run? and the answer is that actually our main method can have two parameters here we have an integer (the number of arguments here) and also an array of character pointers called argv for value so let's actually print out some of these things so we'll say printf and we'll have the argv, the very first entry, the zero-th index is this and we'll say argv of zero and we will also print out what the last thing points to so that's going to be argc so that's %p we'll have a new line or two alright, and change that argc so here's two surprising things first of all, the very first entry is actually the execution name of the program how we started the program here, our program is just called program" and secondly, there is actually one extra argument at the end and that points to the null string our pointer is null, it's zero so, let's now actually print out the other values we'll find out what the other values of argv is and we'll loop through and we'll print out all of those values so I'll have a little count. I'll start from 1 this time. because we don't want to print out the program name I can say: while count is less than argc, because I don't need the null pointer at the end and each time around the loop, increment count I'll print out the value of my count that's %d and print out its value as a string ok so that's going to be count and argv at index of count finally, let's put a new line in here here's my mistake: I should have said argc here for count ok, let's print it out when we start, argc is just 1. we've got just the program run it again but this time but this time have cat hat sat" and you'll see I've got three additional arguments if I had put that inside double quotes then the hat and sat would be one argument so you see that we can now send our arguments for example, I could write a little program that helps me add up some numbers and I need a simple way to turn a string of digits into an integer in other words, I want to go from ASCII to an integer so this is the simplest way of turning a string into an integer number but this function doesn't give us much error checking if it can't read it, it simply returns zero I'll talk about how we can do a better job using scanf in a different lecture so we'll add those up and we'll print the result. right so we've got a result of zero let's try running our program again with 10 20 30 and we see we get a result of 60 if I had put some non-numbers in here, I get the result ten because the string I've got here it's converted into a zero alright, that's enough from me. now it's time for you to play. bye!
hi so this video is about the environment so in addition to being able to set arguments to our little programs each program also has access to environment variables let's have a look at those now so in my shell over here so my terminal window if i type for example set i can see a list of environment variables so these can be used by the shell and any other programs that we start to help configure their behavior for example we see down here that I am running as superuser as the root on this little system here we can also see that my home directory is in slash root so that's where kind of root's files will be stored great so how will i get access to that in my c programs well there's two ways first of all there's a variable called environ which if we are running in an older posix environment we have to specifically declare  in fact we say look there is somewhere in there is already a variable declared called environ and we just need access to it so that's what the extern keyword means we are not trying to say give me additional storage for this rather that the storage for this environment variable has already been made and we just want to be able to reference it inside our program so if i use that you'll see that it's actually a character pointer pointer in other words i'm going to dereference it twice the first time i dereference it i get a pointer and that pointer itself is going to point to character strings and i can keep moving along then to print out different environmental variables so if i had the same kind of pointer  i'll call it ptr and i initialize it to environ i could print out the very first one if i say let me print out a string and a new line and if I do star pointer we can follow that money if you like we can follow where that pointer points to so it points to the first entry in this array  so we can run this and we see i get the first environment variable which looks like a key or a name followed by an equal sign followed by its value so if i was to add one to the pointer then i move on to the next character pointer and i get the next entry so let's put that in a loop how can i do that well i can say while i might be tempted to write pointer but that's not going to be particularly useful instead i want to say whilst the thing that pointer is looking at is a non null value in other words whilst i have a valid pointer why? because i happen to know that this array has one extra entry at the end which is the null entry meaning that its got a pointer that points to nothing and let's also increment our pointer at the end great so we can run this and get a look at all of the entries in fact why don't we set a couple of entries here so export secret to be 123456 let's try that and run our program again this time when we run it the environmental variable secret is part of the environment of our running program if you already know the name of the environment variable that you wish to use you can get to it directly so we can also say hey give me the environment variable and give it a name for example secret and this will give me back a pointer to a character array oops i better call it secret let's print it out and quit so the secret is and we can call exit great i've got a little program that can print out secrets so now i can make my program check that the secret is set for example for example if I try to get an environmental variable that doesn't exist then my pointer is actually going to be nil let me show you that let me try to print out the value of secret as an integer so my secret pointer is pointing to nothing we didn't set that environmental variable yet so we for example i could say look if secret is null then i'm not going to let this program run i am just going to stop so we'll stop and let's now change it so that very secret is something like abc and when we run the program again this time you'll see that secret is a valid integer value so that's just an integer representation of the pointer and we got back at that memory location the contents of that environment variable ABC okay that's enough for me now it's time for you to play bye
let's talk about strings today first of all, these two things are very different I could have a pointer to hello world" or I could have an array of characters to hello world" though both ptr and array points to the first letters some things that are noteworthy here is first of all they have different sizes so let's look at the sizes of each of these, perhaps you can guess what the result is going to be so you'll see the size of the pointer is the number of bytes to actually hold the character pointer which as this is a 32-bit machine is four bytes the size of array is the total size required to hold the whole array so when this code runs it's actually going to copy the contents of that string literal hello world" into the new array object so in this case we need twelve bytes for that, eleven for hello world" plus a twelfth to hold the null character at the end the bit pattern zero to say okay we've reached the end of the string their sizes is very different, plus remember that because we've made additional memory on the stack we can change it so I can change it to jello world" for example let's start manipulating our string we'll do this on our array so we can actually make modifications to it how about we change all the 'l's to a different letter so we'll change and we'll pass the beggining of the array so let's pass in the array and afterwards we'll print what the array is so that's %s alright so I'll have my function called change down here and it takes a pointer to that memory so we don't need to return anything because we are actually going to be using the parameter to point to some memory that we are going to change what can we do with this? well let's have a little loop that says while(p) that says while p is non zero actually what we care about is whether p is pointing to memory that holds zero in other words, we've reached the end of the string we want to follow the pointer we want to dereference the pointer and for that we need the asterisk okay so what should we do with this. well we could change all of the letters for example we could blank it out we could say star p equals and it might be tempting to write an astericks here but that's not right because the asterisk means I've given the address of the asterisk so I'd be writing an asterisk into the address of the asterisk into that occasion if I run this I get a few warnings but it runs and it runs it for forever because my loops runs forever so let me ctrl-c that to break it this time change the loop so I add one to p each time so now I've got a very strange character because it's taken the lowest eight bits and copied that into my character instead let's change that to the actual bitwise pattern of my character now I've got something which can get rid of swear words by over writing them with asterisks or perhaps a password or something but we didn't want to do that for all the characters, we just wanted to do that for the l's so let's see if my p is, at when I look at that memory location, whether it's a lowercase l and as I said before because we are working with characters it is ok to compare them so note the use of double equals here okay so let's run that we have a couple of errors here for starters we're not using pointer so I can comment out that line I've got another problem here which is that change is implicitly declared that's because we haven't declared what the function signature of change() looks like let's do that now I'm going to say later on compiler, I expect to actually define a function and I'll give you the actual code to create this change method but for now here is what it's signature looks like it's called change, it takes a pointer to a character and it doesn't return anything so if I compile that now my warnings should go away great so I've got a function that can walk through I could have another function that finds letters as well so for example suppose we wanted to find the first o in this I could change this so that rather than changing the letters if the contents of p is an 'o', let's return p now I'm going to change my method signature and I'd better have a return value that returns something if I get to the very end so for example, it returns where p is we can now update my original code so that it finds the first 'o' and gives you back a pointer to that if I print that out hopefully you can guess what my program should do okay so it gave us back a string and it this time the pointer was half way through hello world" that's OK, our pointers don't care what they point to we know that strings will continue until we reach the null byte at the end so that's how we were able to print out hello world okay that's enough for me, time for you to play. bye!
Hello! Let's talk about automatic variables so here's my main method I've got two function calls f1 f2 and today I'm going to actually define them before my main method so I don't need to put in the additional declares in so let's have f1 here and f2...ok so now I've got a syntactically correct program but I want to talk about the variables that we might put inside these so if I create a variable like this to say hey I've got a value here, something I need to compute inside f1" or maybe I want to make an array so here's my array and I can initialize it to, say, f1f1" here we go then the lifetime of my array (this variable) is only for the lifetime of the function when I return from f1, then the variable goes out of scope which means the name array" doesn't mean anything anymore inside our program but secondly, the memory that we were using for the array is automatically free'd up it can be reused for other purposes in a moment by the rest of the program so isn't that fantastic that's why it's called an automatic variable so automatic variables are very easy to use they also come with a big warning sticker and that's this which is to be very wary of just how long they live for let's do a couple of things here first of all, let's make it so that we can actually see the pointer in memory where array is pointing to so, let's print that out inside our function here remember that the name of the array (when converted to address) gives us the very beginning of the array and, we'll do that for our second function too okay, so, f2 f2 just to prove that they're making different arrays okay, so we'll compile and run this and, when we run it, we see that both f1 and f2 both these functions the array is actually stored inside the same memory location isn't that fantastic. we didn't need any additional memory and that's because after we return from f1, any of those automatic variables are free'd so they are no longer needed so we can reuse that space internally, later we'll discover that a stack data structure is used to implement this and I can show a little bit of this by having a either a recursive function or we can make another function call these so for example, I could have a function called eg and, this calls f1 so now let's have a look in the case that I'm not using f2 anymore so that can go away instead, I've got a function called eg and that can say have its own space so, blah and maybe say a thousand and twenty four bytes here and then we call f1 again so let's run this now so, in the output, you'll see that f1 is printed twice and the second time it's because it's being called from our function eg and in this case, it's further down in the stack. it's in lower memory f948 as opposed to fd50 because it's being called from eg so, we'll see more about the stack in a moment later on. I just wanted to show you that they really are stored in different places finally, to reinforce this idea, let's make a little recursive function so, I can have something which takes an integer say I'll call it level" and if level is greater than zero, let's call ourselves again with a slightly reduced value and I can of course make that simpler by just saying if level" so if level is nonzero, then call it again and let's call it with say five okay, a semicolon would help each case as we go deeper and deeper into recursion, our array is getting lower and lower and lower in memory so we have all of these arrays created. all of these different activation records in different places inside our processes's memory so the last point we'll make, which is the most important, which is that it's very dangerous to return pointers to memory that is no longer valid for example, rather than returning nothing returning void, suppose we try to return a pointer to our array then though this code might compile, okay, I can get rid of level" now it's certainly not a valid program because the pointer we get back from f1 now points to stale memory that memory is no longer ours to control it will be used in a moment for other function calls so always be careful if you are returning a pointer to something. make sure that that memory is still valid and never return a pointer to an automatic variable that's it for me. time for you to play. bye!
welcome so let's talk about some options other than automatic variables so here's a little problem i've got so far in my main method i want to print out the current time  and i'm going to write my function called currenttime that returns a new string array i already know that i cannot make an array in here to hold the result say with two hundred and fifty because when I go to return from this function the array variable won't be pointing to memory that is valid any longer so here is two options i could make my array static so how do i do that just by the keyword static so for example if i were to just say okay i've got myself a static array out here outside of that method then my array lives forever or at least for the length of my process so that gets rid of the problem of having some space i cheated i said look just give me some space for the lifetime of my program here  so that's what static does i can also put this inside the function that doesn't change the lifetime of the variable it just changes the scoping so as always that means simply that now the variable name array can only be connected to that piece of memory inside my little method so it's just changing how the actual name of the variable is bound to the memory so that's one method but instead i want to talk about a completely different way which is to use malloc so you're going to come across malloc calloc and realloc today let's talk about malloc  which essentially means give me some bytes and i can say how many bytes i need and that storage space is found inside the program's heap so for example if I want one hundred and twenty eight bytes I would say malloc one hundred and twenty eight so this is going to give me a pointer to the very first byte so let's store that inside my little character pointer here and i'll say there is my result it is possible that malloc fails if it is unable to give me one hundred and twenty eight bytes it would give me back an invalid pointer pointed to null or pointed to nothing so i could say look if result is zero or null or if i wanted to be really terse I could say if not result in other words result is null then just return that null pointer i am not going to try and use it it's not a valid pointer otherwise let's put some things inside this and I could turn the current time and store it inside that array so let me use a function called strcpy to put in the current time which is two fifty one pm #include <string.h>Â let's run this and my program calls currenttime creates some memory and then returns it this is fantastic right i've now got a way to make long lived pieces of memory and put data inside them but with great opportunity comes great responsibility here  so what we should do is let our programs is with every malloc we should at some point free up that memory to say hey i've finished with it so the correct way to do this is to keep a pointer around so let's have a pointer down here and when i finished using that memory i can free it to say hey this memory is no longer being used this block of memory of one hundred and twenty eight bytes is no longer being used please put it back into the heap and maybe we will reuse that memory again for a future malloc so good programs will have one free for every malloc  in the next video i'll talk about some of the mistakes that we can make with heap allocation but now it's time for you to play with malloc  bye
hi welcome so we have got a little function so far called currenttime() that requests 128 bytes from the heap and then providing we get a non-null pointer back from malloc we will copy in the time 2:51 PM into that memory and then return a pointer to the first byte of that memory so that's our little currenttime we've been careful to make sure that if malloc fails, perhaps our program has used all of the heap memory then we don't try to use that null pointer but now let's actually make it so that it actually makes a call to find out what the current time is the current time is known by the system so it's time to make a system call and then we will format that using a c function called ctime() to actually give us a human readable version of the time both of these functions can be found inside the include time.h I've commented them up here so the first think we can do is call time so when you call time you can pass it a pointer to a time_t variable or you can say actuall I'm not going to give you anything and it will still give you back the time in its result so let's just use the result so here's the number of seconds since 1970 we'll store that inside our little variable called secondsSince1970 but I don't want that as a value, I just want to turn that into a string for that there's a function called ctime, this a library function. there are other functions that give greater control to the precise formatting but for this demo let's just use ctime() which has some reasonable formatting that most people can understand this will give us back a pointer to the time so the time in ASCII, in otherwords in letters, in readable time and then we can use that and copy that result into new memory, into our result so one problem with ctime() is that it uses static storage in other words it's great if you just want to call it once, and it will use it's static storage to give you back the time in a readable format but don't expect that to stay around because if you call ctime() again in the future it is going to overwrite those bytes and that's why our little function here called currenttime() is useful we are going to take that temporary result and put it into some memory that is ours to control so it can't be overwritten we need to pass in seconds since midnight except we've got a problem here it doesn't actually want the value, it wants a pointer to this variable, it wants to know where in memory this variable is for that I have to introduce some new syntax, which is the & when you see & it means that I don't want to know about the variable itself, but where it is stored in memory tell me the address of the variable we didn't need this for arrays because that's what the array name gives us automatically but for other items we can use the & to find out where it is stored in memory let's compile and run it and we find out that my little virtual machine thinks it's Jan 1 2014 not very accurate, we should probably change it, but it did print out what it thinks the current time I promised you that I'd mention a few more mistakes that we can make with heap memory one mistake we can make is to double free the same pointer this can lead to all sorts of horrendous problems because when you tell the heap that you've freed with some memory it might actually use that memory for it's own book keeping so it knows that the particular block of memory is free if you free it again it can confuse the book keeping, the pointers that the heap is using itself once we've freed some memory, dont free it by accident a second time! another common mistake in C programs is to continue using memory after we've freed it we shouldn't consider that memory to be valid anymore perhaps it's going to be reused by some other part of the program that is about to call malloc() and certainly we shouldn't expect anything that we've previously stored in there to be valid once we've freed it don't try to use the pointer again so for example, this would be an error so how can we guard against some of these errors? one common defensive programming technique is once we free a pointer set that pointer to be NULL to mean that I'm not pointing to anything anymore so this avoids the problem of what is called a dangling pointer error that now our pointer is no longer pointing to invalid memory that's it for me. time for you to play, bye!
Hi, welcome! let's talk about creating more complicated data types in C so far, we've talked about integer and character pointers what if we wanted to make something more complicated like a linked list? for that, we will use a struct so, let's say we've got a struct and we'll say my struct I'll call it say Link and what should we have inside this? well, we've have a value to store and we'll need a pointer to the next link we'll need to know where the next link is in memory so, we can say struct Link and it's a pointer to that so, don't forget the asterisk so that's our little struct here. a semicolon is required at the end but it's kind of painful to keep saying struct Link" every time I want to refer to this type so I can have a link here called one" for example so quite often, we can use, or you'll find that people use typedef" to say here's an alias" and I can use typedef with any kind of type I can even use it with integers for example, I can say typedef number now I can say number x" instead of "int x" but today we're going to use typedef for our link so we'll say instead of having to write struct Link, I'll call this my link type so now I've got my link type, I can make a link here's one and if I declare variables like this, outside of my functions, then they live forever and, let me write my main method here so, my link called one" and my value live forever and in fact, they're initialized so their bitwise pattern is just all zeros so in other words, my value will be zero and the link one" will have a value of zero and its next pointer will have a value of zero as well if we wanted to change that, then we could say one.value equals fourty two and one.next equals well, where should we put it? well where should we send it next? we could say NULL" if we wish to use NULL, actually we have to #include <stdlib.h> to have NULL defined and now our Link says I'm the last thing. there's no one after me" if we wanted to be particularly crazy, we can make the next pointer point to the very same link we do that by saying one" except we don't want "one" we want the address of "one" we need a pointer to one" so how do I do that? I use ampersand to say give me the address" of this so that gives me a pointer to a link well thats great if we only need one link but that's not much of a linked list let's actually work out then how we can actually make a whole load of links for that, we'll use some heap memory and I'm going to use malloc which is also declared inside stdlib.h so, I need some memory how many bytes do I need? for that, I can say: give me the sizeof my link structure" in other words, give me the size of link_t be careful you don't put an asterisk here otherwise, you'll only be reserving enough bytes for a pointer in other words, 4 bytes or so that's not enough for what we need we need the size of our whole struct so that gives me back a pointer and I actually want to cast it so that it's type pointer to a link_t so I can now store that inside a variable and I can have it as my first pointer so, malloc does not initialize the actual memory. it just simply reserves it for us just allocates it for us. we better make sure that our Link is properly initialized so for my first Link, I want to set its value to something and I need to set its next" pointer to something so for example, I can set it to NULL or if I, oops, let me change that to put a one or if I wanted to make it point to itself, I can say ptr1" if I had two links, let's do that then I can again set up the values. be very careful when copying and pasting code that you've actually edited it correctly I can now make my first link ptr1 its next point to next ptr and the next link, its next pointer can go nowhere so, there's my simple linked list more complicated links might have a previous pointer as well so you can navigate both in the forwards and backwards direction throughout the linked list okay, so, let's now finally compile this and check that it works our program compiles correctly, but to be a well-behaved program, really we should free up the memory as well so don't forget for every malloc you do, we should responsible for freeing up that memory once and once only so free(ptr1) and free(ptr2) also, a more robust version of this program would check that malloc actually succeeded that we actually really got the bytes that would be something important to do if your program ran for a very long time or needed very large unknown amounts of memory so that's how we make linked lists in C now it's time for you to play. bye!
Okay so let's talk about how we can make it easier to create links and destroy them so i've changed my link class a little bit so now each link can have a key and a value in addition to the next pointer the pointer to the next link okay so let's make some methods to create links and destroy them we'll do the create one first so it's going to return a pointer to a link and i might call it say link_create and I'll expect a key and I'll expect a value so that'll give me two pointers if i wish to debug this I could have a printf in here saying hey creating link and I could have what the key and values are for example right so i need to get some memory let's get some memory from the heap because we want our link to last for a long time until we decide to destroy it so i'll say malloc give me some memory and how much well i better ask for how big is my memory structure link_t and i will cast that return type as a pointer to my link object why do i do that well i want to be able to reference the sub parts the components of my struct and i will call that say result and i need to initialize my pointer so now i've got that I can set the key to be a key and the value to be the value now when i do this i am copying the pointers i'm not creating new strings so in other words i've now got a pointer called key and it's looking at exactly the same string array as the parameter is i haven't made any new string arrays so let's remember that when i return this that those pointers better be valid for the lifetime of the link well that's fine if I knew for example that this will always be used with string constants or I am taking control of those values that I send in and I happen to know that their lifetime is longer than the link's lifetime so if that's the case then my code is relatively simple like this and destroying the link is also relatively simple so let's write a link destroy method destroy which takes a pointer to the link that is going to disappear so we can call that just p and what do i need to do in here well i can simply return the memory back okay so this works we could do a little better than this we could actually do some defensive programming here where we also destroy the information inside that link so for that i can use memory set so memset where I give it a pointer that I want to use the value will be zero the number of bytes can be the size of my link so this assures that i don't have any dangling pointers i have destroyed the key and value pointers i've set them back to null and anything else inside my link has been set to null so if someone happens to have a pointer to this link and they try to use the contents straight away then it will fail it will be null and secondly we are freeing it to say okay this memory can now be reused for other purposes so that's my link destroy method now suppose we discover that our strings we don't control the lifetime of these string arrays and that actually we should make copies of them so how can i do that well there's a method called strdup so let's do that strdup and this gives me back a pointer to a new string  a new character array that has been created on the heap and it's just a copy of that existing character array that we passed it so let's create our new string arrays and use those if we do that then when I destroy the link I better free up the memory associated with my key and value so before ending here I should free up those pointers so I should call free on my key and free on my value pointer as well okay so there's my code now to start working with a link with my main method I will need to always know the beginning of my linked list so that sounds like a great thing to actually have as a global variable here so let me have my link pointer here and I can call it root and so the first link I make I can initialize root to that to that very first link okay so that's it for now, it's now time for you to play with creating more links bye
hello welcome let's talk about how we can get single characters and print them out in c so here's some functions defined in std.io i can say give me a single character for example and why don't I just keep calling this so i could just say while getchar is not equal to a special constant called end of file (EOF) keep going around in a loop but if I actually want to print them out I better actually store the value of getchar so let's have an integer value called c and inside my while condition I'm actually going to assign the result into c so you'll often see this pattern inside systems programming where we take a systems call or a library call and we store the results inside a variable but because that may also signify an error condition or a termination condition we use it immediately to check inside part of a while loop or an if statement so we've got a little character loop here that is going to keep going until it gets to the end of the file so now I want to print it out guess what i can call putchar and we'll see that running  so let's run this little program ABCD it prints back ABCD okay so we don't have to display the character just as a character we can display it as a character an integer and hexdecimal values so let's use printf for that so I've got %c %d and %x for character integer and hexadecimal value alright so let's run this and you can see that the letter A corresponds to sixty five which is in hexadecimal forty one right so why don't we use our little program to print out the contents of another file so if I cat my source code I can see the contents of that great so I'm going to pipe it into my program so i'll do ./program and it reads every byte and prints it out as a character great so let's encrypt our file now so I'm going to modify our value of c if it's not a newline character so what we'll do is say if c is at least thirty two in other words at least a space an ascii space and if it is we will change the lowest bit we'll flip the lowest bit how can we do that let's xor it with one right and then we'll print it out okay so we'll run this CDE for example and it changed the C to a B and if I do 135 I get 024 so to say that I've got to the end of the file when I'm just typing you by the way you can do control d now see this working on some actual source code so let's here some text my program.c and i'm going to pipe that into my program to use as its input and you can see great we've garbled the program so if I want to I can then take that output and pipe it into my program again so now i'm going to unencrypt it because i flipped the lowest bit back   so we get back our source code so that's getchar and putchar i can also work with whole lines i can let's get rid of the loop here i can say puts hello or any pointer to a character array provided its terminated by a zero byte at the end and that is equivalent to printf by saying %s and \n at the end so i've got some character pointer here right so it's a little bit shorter to type than writing printf there is the opposite which is to get some input but this has a problem and we'll see why in a moment why this function actually call is being removed from the c standard i'm talking about gets so let's call gets and we will have a little buffer here so let's put a little buffer on the stack here i'll make it twelve bytes today  and remember when we call gets with buffer if you use the array name you are talking about the very first byte of the array and rather than printing out hello we will print out our buffer value so let's run this and we can type something in and it echos it back to us fantastic but what happens if we enter more than twelve bytes so in other words could something bad happen to our other variables well yes it could because if we go past twelve bytes we start writing into memory which is used for other purposes for example in my little program the integer is immediately after the buffer let's prove this let's set our hex value of c to be ten twenty thirty fourty let me print that out after we've called gets i'm going to print it again so we've got to remember that what we store is going to be our letters plus a null byte so in this case if I do ABCDABCDABCD I've already overflowed because the thirteenth byte is now going to be written into my integer but i am going to do just a few more I'll do ABCD there we go and we'll see that I've managed to change my integer value to 41424344 so the last ABC that I wrote in there actually overran my buffer i've got a buffer overflow and I've corrupted the contents of another variable so that's why gets is dangerous there's no way to tell gets that we shouldn't accept input that is too long for it so in a future video i'll tell you about getline and also fgets which don't suffer from these problems okay that's it for me thanks for watching and i'll see you in another video. bye!
Hello! Let's talk about how we can use scanf and sscanf and fscanf to read some data and convert that into say integers or floats or strings so we can actually use those values inside our variables alright, so, I'll start by using sscanf which can parse data inside a string inside memory so for example, let's have a little bit of data here I'll have my data be my name and a score and I want to take that and pull it apart into a string and an integer so I'll have a little buffer here, say, up to twenty characters and a little integer here and I could set this to be equal to some arbitrary value. we'll see why in a little bit and then I'm going to say okay, sscanf please read from this string array and what I'd like you to do is convert that into a string followed by one or more spaces and then an integer value" alright so scanf is going to look at our memory starting at wherever our data is pointing at and, it's going to first of all look for a string until it comes across one space and then there can be actually multiple spaces in our data and then after that, it's going to treat the rest of the string as an integer okay, now, our format specifiers say the kind of data that we want to interpret and also the number of bytes that should be written to when it is trying to parse its data so we better tell it where to exactly put these things so for our string, we want it to write it into a buffer and for the score, we want to write it into our score variable but hold on a moment when we say buffer" yes that gives us the beginning address of our array but not for score score is just going to give us whatever value score happens to hold in this case, negative forty two that's not what we need we actually want the address of this variable so we're going to say ampersand score so, lets read that and we'll print it out so here's the result and we'll say %s %d and we'll print the contents of the buffer and print the value of score so notice that scanf and printf, the arguments don't always look the same when we want to print out the values, we don't actually want to just print out the address of score we actually wanted to know what the value is great so that read that correctly scanf actually tells us something else which is how many arguments it correctly managed to parse so let's make a note of that and we'll print that out so, we'll say %d here print out the result in our printf statement here so now when we run it, we'll see that sscanf managed to read both iterms I got result two fantastic. so that's useful. now we can write robust programs to check if we really did write into both variables now you might be worried that scanf could result in a buffer overflow and, in fact, in our current code, you'd be right so if I had a very long name with no spaces here then that's longer than our buffer so what we need to do is tell scanf just how big our buffer is so in this case, it should be nineteen because we're setting scanf how many character to read from the input and our buffer, of course, if going to need one extra one to hold the terminating byte for this string so let's run this now and you'll see that first of all the name is truncated and that secondly, the return value of our scanf call here was one and it only managed to read into the buffer it gave up trying to read the integer because our buffer wasn't long enough and, in fact, our score variable still contained its original value of negative forty two so good defensive programs must check that the return value is reasonable also, when writing scanf or sscanf or fscanf, it's always a good idea to carefully check to see whether you should be looking at the address of the variable or if the variable itself actually is a pointer and is already going to give you the memory address that you'd like scanf to change alright so we've read data from a string  we can also parse data from a file stream and how can we do that? well you can use not sscanf but fscanf and if you did that, you better give it a file stream there's one called stdin already if we didn't want to use that, then we could open up a file using fopen and then pass in the file handle here and reading from stdin is such a common occurance that in fact there's another form of this which is just say scanf and if you do that, that means hey, just read from stdin" so now, let's run our program here and, now it's waiting for input so let me typing something I'll say Angrave one hundred" great! and it managed to parse both variables okay so that's enough introduction to scanf remember this next time you're trying to read 3d data and points and you want to say convert those ASCII numbers into actual floats and doubles and also remember that its important to read exactly how scanf uses these format specifiers because its not quite the same as printf alright, that's it for me. time for you to play. bye for now
hello welcome let's talk about getline so it's very very common to read in a single line of text either from the user or from a file and we would like it to be very easy to say hey let's not worry about making sure my buffer is large enough" I just want to get the whole line and thus getline was born this is being adopted into the posix standard if you are working however with older standard and an older compiler we have to ask gcc to explicitly enable it so before doing our includes with stdio we need to define _GNU_SOURCE so if we do that we would like the gnu source additions to the standard functions right so if we do that now we have got a getline declaration included as part of the #include <stdio.h> so here is how we can use getline with getline we actually set up two variables we get getline to manipulate these directly  we are going to have a pointer to a buffer and a little int to say how big is our buffer well let's just check to see really if it is an int or if we should be doing a different type so let me pull up my favorite manpage on getline see that actually the correct type to use is size_t which is essentially an unsigned int or larger on some systems so let's just make a note of that that is the declaration that we are going to be using and so we will have not just a buffer to our character array but also size as well to say how big is our buffer and i will call this say capacity right so we could start calling this and we could say okay get me a line and oh i need to pass in a pointer to my buffer variable right and notice that the declaration here is star star asteric so it's a pointer to a pointer right so how did i get that i say okay give me the address of my variable and similarly for the capacity as well the size of the variable so give me the address of my capacity and getline is going to modify those two variables directly essentially if my buffer is not large enough it is going to free up the old buffer and then call malloc so that we get a larger buffer okay technically it might call realloc but let's not worry about exactly which library call it calls we just know that it's going to do all that buffer maintenance for us automatically and now we need to give it a filestream so why don't we use say stdin now right now our code suffers from a terrible flaw which is that we've assumed that our automatic variables buffer capacity will be set to nothing so the getline knows that it can't reuse what it happens to be pointing to so we actually need to set these to explicitly to null and the capacity to zero so the first time we call getline getline will see that the buffer is certainly not large enough and will allocate enough space we can now find out what the result is which is the number of characters getline has managed to retrieve or a negative value if it failed so let's make a note of that and we'll print this out so i'll print it out as an integer and let's have a look to see what we can find inside our buffer so we want the result and we want the buffer and lastly let's put a newline here okay so we'll run our little program here and now it's waiting for me to type something okay great so it says i have got six characters wait and i printed ABCDE actually the last character might be a newline character and quite often we don't actually need that so why don't we overwrite the very last character with null with a terminating byte so let's write the code for that first of all we only want to do that if we get at least one character back from getline so let's check that the result was positive and also we only want to do this if we are going to overwrite the last character which truly is a newline we could imagine for example reading from a file where the very last byte is not actually a newline so we should just check to see what we're going to write here so let's look inside our buffer and where do we want to look? well if we read one character that would be at the beginning of the buffer so we need to look at result minus one so if that is equal to the character of a newline then let's truncate the string the easiest way to do that remember is strings are just terminated by zero so let's just put a zero directly into that byte so we are going to say at the same spot set that equal to zero right so let's run our program again okay so this time it read it correctly and in our printf we didn't get that unwanted extra newline alright our program right now is allocating memory on the heap we don't do it we let getline do it but it's actually up to us when we finish using getline to free that buffer right so let's do that let's at the very end here we can call free on the buffer we don't need to do that every time we call getline because getline by default will try to for performance try to reuse the buffer for each line it gets so for example we could call getline twice and it would try to use the same buffer but the big take home message for getline is first of all you are going to need a pointer to a buffer and a capacity variacle which getline itself is going to change the contents of as you call it it can make the buffer as large as each time you call getline it might change that buffer to point to some new memory if the buffer needs to be larger secondly it's a great idea to check the return value of getline to see how many characters it managed to read and also to see if there was an error or not and the return type for that is ssize_t for a signed size integer type and finally it's good practice to don't forget to free the memory that is pointed at by your buffer variable okay that's it for me have fun playing bye
Hello welcome so this video is a little introduction to signals so signals are like a software interrupt we can use them to control our processes and even do things asynchronously so let's have a look at a little program i have written so far that doesn't use signals yet all it does is ask for the environment of home in other words the user's home directory and then we have a little loop that prints it out and sleeps for three seconds so every three seconds it is going to print out my home directory and on this machine i am root so it just keeps on printing out slash root so of course we can stop this program by pressing control c and when you do that you actually are sending a signal sigint or sig interrupt to the process now it maybe that our process doesn't like being interrupted why don't we catch that signal and install our own little handle for that so here is how we will do this i am going to say at the beginning of my program that if you get a certain signal say sigint  rather than having the default behavior which as we know is to stop the program or quit the program let us run my code instead so i will call it say nothankyou so what is nothankyou it has to be a pointer to a function how do we do that easy just write a function and in this case the correct type is something that doesn't return anything but does take an integer in fact it is the signal that is being sent to our program and so that we know that this is being called let's write something out directly to standard output so i can say write and i can say no so what is that that is a little message of three bytes to send so let's run this now okay so here is my program every three seconds it is going to print root but now i am going to press control c and it prints no no so it's refusing to quit you might also notice that the sleep also immediately returns more about that later it is still possible to stop our program here if we do control backslash then we force it to quit so sigint is one common signal that we send our programs there are many others just for fun let me show you one called sigalarm so this time i am going to say alarm seven seconds and so when you call alarm you are going to say give me a special signal called sigalrm in this many seconds in seven seconds and we better install then well let's just run it and see what happens to begin with so the default behavior of this sigalrm is to actually stop our program it quits the program that's a pretty aggressive alarm clock i think you'll agree and it also as you see prints out alarm clock on the shell perhaps we don't want our alarm signal to be so menacing so this time instead of sigint i can say look for a certain signal called sigalrm please call my function instead okay so there we go our alarm went off after four seconds and this time we asynchronously ran our code that printed out no to standard out so this is pretty exciting right you probably thought about interrupts on the hardware level now we can do interrupts at the software level and we can respond to things which happen in our environment very quickly so we will find signals to be very useful when we start dealing working with more than one process we can control our programs and we can also work with very large amounts of data coming in alright that is enough for me bye
so usually we think about our programs as just turning into one single process now i am going to show you some systems programming magic where actually we can turn our single process into two here is how we are going to do it let us have a very simple program that says hello world and here it is so between these two lines however i am going to call fork and here's a surprise we get hello world world yes we get two worlds why is that well at the beginning there was a single process but then we called fork and now our single process is actually being cloned it has been split into two so both the processes print out world and so we see both their output on our little terminal here okay what else can we do with this well let us first of all show that there really are two different processes i am going to look at their processor id and we will print it out so i will call getpid() and you will see that yeah i have got two different processes both trying to run at the same time in fact i have got a parent child relationship here i have got the original process the parent and you can think of fork as saying let us clone this original process right here right now so that i get a child that looks just like me or at least almost like me in many many respects it is the same memory it has got it's own variables but because its got its own address space what the child now does in terms of its memory is seperate from the parents okay so let's show you what we can then do with this first of all fork actually returns something here it actually returns back an id so let's make a note of that and we'll print it out so we'll say %d and we'll print out just here okay so here is what we see that the process id 681 has fork value of 682 and process 682 has a fork return value of 0 so the fork value is different for the parent and the child and in fact fork if it returns a positive number is talking to the parent and is telling the parent here is the id number for your child so let us make a note of that let us call this here is my child so i can call my child and then i can write an if statement to decide if i am the parent or the newly created child or not so we will say look if the child id what i return from fork is actually greater than 0 then i am the parent so let's put something like hey i'm the grouchy parent if it is zero however then hey I'm the carefree child! so we will let's remove this  i'll get rid of that line now okay so now we have a little program where the parent and child are going to do two different things and in fact it is standard for the parent to wait for the child to finish we don't have to but quite often we need the child process to do something for us perhaps in the background but we don't actually want to continue until the child has finished so let us do that what i am going to wait for my child to finish so i am going to say waitpid and i need to say okay what is the id i need to wait on well here is the childid and later on i can ask for some status information about my child and for now the last argument i am just going to put as 0 so i need to have a variable called status just a little integer and in fact we are going to pass not just the value of status but the address of our little variable and later on we can use that to find out say did our child exit normally or was it terminated in a surprising way so let us run this now and what we will expect to see is that we'll wait for the child to finish before we print I'm the grouchy parent so let's run this okay so this time the child process got to print out I'm the carefree child then it exited meanwhile the parent was waiting for the async condition and when that happened the parent is able to continue and is able to print I'm the grouchy parent so i want to finish on a common programming error that can really bring down a server and that is suppose we made many many many processes so it is one thing to create a few let's call say fork a couple of times and perhaps you can guess how many worlds we'll see here that's right we see four worlds and in fact the parent finished early so this is the hash of the terminal saying what would you like to do now but we had four processes all printing out world and if we had three forks now we have eight okay so let us make something now called a fork bomb which is where we keep creating lots and lots of processes and this often happens by accident by people who are new to systems programming but just for fun because i am just doing this inside a browser it doesn't matter if i bring my little virtual machine to a halt i can always just reload the page so let's print out my id i will put this in a little loop that says while one let's fork let's print out my process id and then i will sleep two seconds so initially i have two processes and then each of those processes calls fork so we got four and then each of those processes call fork prints it out and sleeps and so every two seconds i am doubling the number of processes that are in my system so that's a lot of processes and in fact pretty soon the kernel will run out of space it won't be able to keep track of any more processes and fork will stop working and now we see here's the kernel printing out all sorts of debug messages desperately trying to make the system stable again as it arbitrarily starts to kill processes in an attempt to recover some memory and space in its process tables so amazingly my little kernel here has managed to recover to the point to where i have a working system but that is fork bombs and you should avoid from accidentally doing this otherwise you will have a system administrator telling you that you cannot log onto that machine anymore okay have fun and i'll see you in the next video bye
okay, good morning class, how are you I'm good thank you alright, for those of you that weren't paying attention, cs241 has started. good morning class, how are you?! alright, great. so, in the next 15 minutes the game of course is for you to leave this room with more passion for system programming and maybe some more knowledge about how to do it as well and maybe some knowledge about how not to do it as well so one of the intents here is cover gotchas and common programming mistakes so, if you have a burning question, there's probably someone else in this room that has the same question I will endeavor to answer as many questions as possible without derailing the lecture so feel free to speak up if it's not appropriate, I will tell you and, just stay, come down and talk to me afterwards also, I hold office hours usually three times a week immediately after lecture because I figured thats the best way to reach most of the students so feel free to stop me I may not be able to stay for a full hour every time for example, there's a faculty meeting today where we're talking about how to take over the world uiuc style but most times I'm there to help you and I love to see people progress. its fantastic stuff when you start from the beginning of this course when you don't know anything till the end where you can actually do some pretty cool things and by the way, last semester many students came to me to say hey! you know what? I just had an interview and they asked me to explain X" where X is a cs241 thing such as, what's the difference between a process and a thread? whats the difference between stack memory and heap memory? how would you do that? what's a common gotcha with this? why would a C program crash? that kinda stuff so you might find that the knowledge you gain in this class actually has an immediate impact for you outside of this class and if it does, wonderful! alright, so, let's get started with a couple of trick questions that we have here, wanna go to overhead, right! okay! how do you look up information for C library calls and system calls? easy! okay, here's the beautiful thing. with POSIX, POSIX includes many things it includes an API (application programming interface) in other ways, instead of calls, you can call and also, a manual of man pages about those calls so guess what? we're actually going to look up different calls the art of course is knowing which calls you should use and the POSIX man pages aren't going to tell you that you already have to have a basic idea of oh yeah! I need to use open" or "or yes! I need to use write or stat or lstat or fork()" so that's the main thing you're going to get out of this course is the vocabulary with the then end expectation that you would actually then start to use this stuff and look it up so we've got two different kinds of things. we've got C library calls and system calls the C library is the part of your process okay, what's the difference between a program and a process? well, the program is the code that you've written turned into bytes which say you stored on disk and then when you actually execute it, or actually run it, it becomes a process and of course you can have multiple processes running for the same piece of program code but part of that process is the C library it comes kind of bundled with or loaded at runtime and it's a set of code and maybe some constants too that just runs as part of it so what kind of C library calls do we have? well for example, perhaps you want to do a string copy where you want to say okay, copy all the bytes into a destination from a source" and we're gonna pass two pointers and it will keep copying those bytes starting from source into destination until what? until it reaches a zero byte because that's the definition of a C string of course, bad things might happen if you accidentally put these in the wrong order alright, if you tried to copy from some arbitrary place into a different place, who knows how many bytes its gonna copy before it gets to zero? oops. who knows where its going to immediately crash your program? for example, it might be that you try to write into some read only memory and the hardware say ah ah excuse me? excuse me? you see that process over there? it's being a baaad baaaaad process" ok lady gaga I might so, look I enjoyed that joke personally so, let's um, this is an example of a C library call. it doesn't need to go into the system to run this we can do this entirely inside the process space inside the virtual memory of our proces ok, what about system calls? well, here's an example of one, you've already seen it: write()" we want to get outside of our system. we want to break out of our system and get the system to break outside of our process and do something to the rest of the world okay, so, the system itself needs to handle that particular call and in fact it does that using a hardware interrupt that's the red pill, if you follow the matrix movie that's how you escape out of the box. out of the sandbox that your poor little process is stuck inside anyway, so we want to look up say some information about these and so for that we can use man" which reads man pages which are incredibly terse and utterly useless if you dont have some basic knowledge but pretty useful if you already know something about what you intend to do so let's try one box pc okay so let's try looking up for example printf()" there it is and it's in section 3 of the man page okay yeah, we want to open it. there it is now what do we see about these man pages? well the things I want to show you is that first of all it tells you what includes you better have it also includes a whole load of function calls which do similar things so, as well as printf, we've got sprintf or snprintf and, then we've got some really terse information on what it's gonna do and usually its got a return value as well so they might return say the number of characters printed excluding the NULL byte used to end output strings notice how those display little parenthesis here as if its not that important as if the number of bytes written is not that important to you as if that could never cause a big program to fail accidentally, you might assume that that is the actual number of bytes written no no no, it excludes it and it's an off by one error it's actually going to ignore the fact that it may have written a zero at the end because it's the end of a C string oops! that's exciting. you may have not had enough memory. you may have overwritten something else so, when you read man pages, read them slowly and try to understand everything they say and of course, it's always useful to find an example oh, this one actually has one, look at that! amazing most of them don't bother with an example so you end up doing any google search to say okay, easy example of blah blah blah blah" but yeah so they're a good reference material now you'll notice we had different sections
Let's do another one Let's look for fork - create a child process. Yes, that's right, you create children by forking I knew you'd remember something from this lecture. We'll play more with this later because it's an amazing thing you can do with posix. You're first process can actually clone itself, at that very moment to become two separate processes It's like you pull a switch and suddenly you've got a doppelganger If you're a physicist and you think about the many worlds theorem, it's a bit like that. The world from a process point of view splits into two. Suddenly you've got two processes for the price of one OK, so we'll see that. But again, notice we had different sections The sections you're going to see are.... can you see this? let's see if we can make it bigger section two, alright. This is where all the system calls live section three, this is where you'll find the C library stuff and section seven, you'll occasionally find there's actually longer articles. I hesitate to call them tutorials, they're not that useful but more long winded articles that have some better practices. it's worth reading at some point during this course you might find some useful information there. for example, when we talk about signals, but most of the time you'll be using these as reference unfortunately, let's go back to here and look up stat. some words appear in multiple places and if I make a new window here and I do man stat, then I get the wrong one. I get the one that would happen from the shell. So i have to say 'no, no, no I really wanted section two' so sometimes you have to force it to find the right section that's enough about man pages. you will be using them. when it comes to quizzes, i'll talk more about that later, but i will have expected you to know something basic about the return values, some of the common gotchas of using different calls do you remember how to allocate memory on the heap? if your neighbor said 'malloc' congratulations, you made a good seating choice yes, malloc is one way to say 'hey, I need some memory and it's mine until I what?' free it, yes!  when you call malloc you are going to point to some bytes. will those bytes be zero? do you feel lucky punk? the answer is maybe, but it's not guaranteed.  if you get a brand new, fresh page of memory from the OS it's likely to have been zeroed out by the OS to make sure you don't accidently get any information from another process remember, we're trying to keep our processes separate, so you can't accidentally read someone else's password, or secret key, or something else that's secretly happening inside another process the OS makes sure to usually give you some zeroed memory however, if it's reuse of your own memory, it's quite likely there's just garbage in there it could be that because it's zero it lulls you into a false sense of security, you assume memory is zero why did C do this? sounds like a terrible thing to put the onus on programmers to make sure their programs always work. why didn't they always zero out the memory? time consuming, yes! C is all about trying to be as efficient as possible and if you can't cope with that, get a different major That is C's attitude, maybe we can find tools to spot memory errors, but it's very much a case of we're trying to write a language which is just a little bit above assembler. it's meant to be that it's almost as efficient as assembly code, just a lot easier to read and write malloc has to be very efficient because we use it a lot. think about your java programs, OK I'm sorry. I know that was a bad experience, but think about all the times you've made new objects, etc. underneath that we're saying 'OK, I need some more memory' so malloc's job is to find some bytes. you say 'oh quick, I need another thirty two bytes and I need it right now. I can't continue my process untiil you give me thirty two bytes fo rme to play with. And, yes, I promise to free it later when I'm finished with it.' some processes are allocating a lot of memory all the time. so malloc tries to be efficient and when you free some memory, we can put it back into this pool of bytes that we can use later again. That's why it's called a heap, it's just going to be a big disorganized mess of allocated space and unallocated space And, in fact, it's tricky to write malloc and free, so we are going to ask you to do it in 241 we've got malloc and free. later on you'll also see halloc and realloc, but let's not talk about those now you can just implement those on top of malloc suppose we wanted to write our own string copy function. here it is! because these are character pointers, I should mention, how big is a character in C?  the size of a single [byte] if I do sizeof character,the answer is one. everywhere, at all times, before I even compile the code. it's a definition that the size of a character type is one sizeof gives you the number of bytes so a character is always one byte. If i put a variable name in there I'd get one when I add one to these pointers, it is going to be incrementing along one byte at a time. I read one byte and I add one to the source pointer and add one to the destination pointer this code is slightly broken. perhaps you and your neighbor can figure out how it should be fixed. i'll point out the following what does this do? while star source thank you, yes! remember star means dereference, follow the money, take this expression and use it as a memory pointer and actually tell me what's in there because we're talking about a character pointer, we are asking memory to read just one byte. if we had an int pointer we might be reading four or eight bytes but, no, we're reading one byte. while this is non-zero, do something. with C, anything which is a non-zero value is true what a wonderful simple world
my love for you is 42 so this means this is going to continue until we get that null byte alright that's enough hints let's fixed that code right so see if you and your neighbor can fix this code faster than your other neighbor that you're not talking to it's not copying the string, that's one of the bugs copy the bytes so actually we didn't just want to copy src into dest  all this would do is whatever the value of src is whatever the value of src is i is just some memory location, we set that into dest but dest is just a local variable so that would actually do nothing, it would actually just change src into dest what we want to do is just use src as a pointer so we need to put a star in here there we go right so we should have read the value at src hey go back to memory and then use dest as a pointer we wanted to dereference it  we wanted to say okay now write that value into whatever dest is pointing to so we've done that, we've copied one byte and we increment both pointers and then we go back around the loop so we're going to keep writing bytes until we get to the null byte is my function finished? no, what's wrong with it? yes thank you, yes we forgot to copy the null byte so this function is broken it forgot to copy the null byte but it might work if you test it if you happen to test it with memory that was already zero and you think aha I finished my mp right, no your code is broken because is forgot to terminate the C string and then some future function would start reading this and it wouldn't come across a null byte because there would be garbage after it and it would start printing random characters until it eventually got to a null byte of course if it didn't get to a null byte maybe other bad things would happen anyways so let's fix this we needed one more line to say after the while loop  alright the src should be a null byte which I could write like this okay here's another example of a classic C error which is when you've got two pointers you're probably using the wrong one okay so make sure that we change the very last byte at the end to be a zero byte so we terminate it we could have also fixed this by using a do while loop instead of a while loop so we would have only done the check at the very end we would have copied at least one byte alright so that was my string copy how about something that actually duplicates strings right so we want something that takes a character to some memory and we are going to make a new memory object and we're going to copy the contents of the original into our new piece of memory right so how do I get some new memory? easy I remember what I said ten minutes ago and say malloc so I've got malloc I've got the right size I copy.. whoops wait a moment I've got two pointers am I using them in the wrong direction? if in doubt, yes I probably am right? how do we check? easy go back to the manpage alright man let's try strcpy and BSD kindly calls them s1 and s2 okay copies a string from s2 into s1 yes we managed to do it the wrong way round what we should have done is swap these around by the way is this text large enough to see at the back? can you give me a thumbs up if it is? alright so most of you alright I'm assuming the people who didn't are going to sit closer to forward in the future but seriously let me know if it's not okay right is our code finished? okay we run it and it doesn't work, it might crash here's one problem, what's the size of src? what will this give us? one, we've managed to allocate enough space for one byte and then we try to write into that one byte okay that's fine if our string is very short, just one byte long not so fine if our src strings were longer so we shouldn't have done this right? what we wanted to know was the number of characters at the src so how can we do that? call strlen of src so now we test it and it almost works but it still crashes here's the issue, strlen tells us about the number of characters excluding the null byte at the end look C is trying to help you give off by one errors what a polite language, if it's not my fault it's your fault alright look we only need to add one to that that's just evil huh? who came up with this alright so when you write a language don't do this make your strlen actually say how many characters, how many bytes it actually took okay so we've got now we're calling malloc and we copy from the src  so this should be p, this should be from the src into our memory and finally we return p is it okay to turn p because look p is an automatic variable it's a local variable is that a problem? no because we are not returning a pointer to p itself we are running the contents of p and p is just looking at this memory that we've malloc'd and that memory that we've malloc'd will exist until we free it  now malloc itself returns a void pointer and if we wished we could cast that changes type into a character pointer in practice you don't need to that if you have a void pointer it's okay, it's allowed to cast it implicitly to a different type
alright so, is our code any good? yes, question? okay, so, this was discussed on piazza. it makes the code a bit more cluttered. if you do too many casts, you're forcing your way, you're saying: hey compiler, trust me I know what I'm doing" which is fine until the day you don't know what you're doing and you've just casted something which is incorrect maybe you're casting a pointer to a pointer to a pointer. and you would've potentially gotten a compiler error but by explicitly casting, you won't get any error so that's probably the biggest issue yes oh, I'm so, yes, you're right. I forgot that it's a character pointer. it would not have returned 1. it would've returned say 4 or 8 or however big your pointers were on your platform so, if its a 32 bit platform then how many typical bytes do you need? well, 4 bytes to hold 32 bits if its a 64 bit machine, then you'd need 8 bytes right, so, our code looks pretty good except one little issue. if you read the manpage of malloc, you can discover that malloc() can fail. and when it fails, it returns quick! read the man page! right, when it fails to give you any memory, it returns NULL so, we should check for that because right now our code would attempt to write into that 0 location if malloc fails so what we should do is, here is, we should, if p or not p which is another way of saying hey, is p zero" I didn't give any memory so no new string duplication for you and hopefully the code that calls my code actually bothers to check to see whether it got a valid pointer or not alright, okay, any other questions? alright, what's a double free? okay, so, let's say we free pointer, and then for some reason later, we free the same pointer in other words, we called free twice on the same memory block is that a bad thing? yes, that's a bad thing okay, here's why when you call free, the memory allocator says oh, look!" he or she is finished with that memory so I can put it back into my free pile and I might allocate it again when someone asks for more memory but I'm going to update my linked list structures and whatever internal structures I have to keep a count of what memory is free so if you call free again, bad things may happen to those linked list structures bad things may happen to other code that's already actually using that memory space alright because between you freeing it and freeing it again later, it could be that another malloc has come in and been given that memory so when you double free, really exciting things can happen you have no idea what's gonna happen next. you have broken the universe at this point because, artibrary things can happen to your heap memory and who knows what the rest of your program is doing to your heap so, how can you avoid it? well, there's a couple of ways. first of all, don't write this code secondly, it's a good practice in production code to set your pointer to zero in other words, don't have, what are these pointers called now? the dangling pointer! it's a pointer to some memory address that is no longer yours to play with because say you free'd it and you don't want another piece of your code to accidentally use that pointer so, when you free memory or decided to use memory for some other purpose, it's good practice to set pointers to that memory to zero this of course looks very easy and trivial to avoid. in practice, these two frees could be somewhere arbitrary in your program. maybe someone kind of tries to free your data structure twice and then you end up calling free on some memory twice right, okay, let's have an example of a buffer overflow well a buffer in C can be anything. for example, it could be just a simple array so, let's make an array myData and this says, okay, I need space for 8 bytes or 8 characters" and let's set one of those entries to p. is that allowed in C? okay, so that's a trick question. yes, the compiler will compile that for you, it might give you a warning, it might get an error if you've racked up enough options but remember, what are we doing here is we're just simply saying okay, take whatever data's pointing to, add 8, times whatever the size of each entry is, and then use that to change some memory" we actually want a bit representation in our p but, when we did this, we only asked for enough space for 8 entries. and we're trying to write a 9th entry. oops! we could also have run into the same problem if we had string copy one two three four five six seven eight ahh, I did it the wrong way around okay, so there's two things wrong with this code. first of all, the arguments is the wrong way around second of all, how many bytes is this going to write? into memory? nine! I've got the digits 12345678, and the NULL byte at the end to say hey! my string is finished" but we only made space for 8 so that ninth byte. what's that ninth byte being used for? maybe it's being used for another variable in which case we've just overwritten the value of another variable and that is how many C programs are vulnerable to buffer overflow that is how you could hack into say, a web application which didn't put enough space on a buffer and you could then overwrite nearby variables
let's do our last little thing here. what is typedef? it's just an alias we've got some basic types in C, but you can use the keyword typedef to say 'hey I need something else' I might have an unsigned int OK, that's a lot to type. I'm just going to call that my u int or I'm going to use an unsigned int to represent process identifiers for example. So don't be scared when you see typedef, it's just being able to alias a particular type so that you can have a short name for it questions? yes! because writing struct x is painful and people don't want to have to write the keyword struct everytime let's say I have a struct called poem now I'd have to say 'right suppose i wanted some memory' I want a pointer to a poem, so struct of poem pointer malloc sizeof struct poem it's kind of annoying to keep writing struct everywhere, yes? so instead you'd say typedef and that can be my poem struct And then you might go further and say I want a poem pointer, so poem_s star poemptr then you might write this code and then you might write this code and that would be wrong whoops, look, i just tried to get the size of my pointer. that's going to be four bytes or eight bytes I didn't want that, I wanted the sizeof my original structure. be careful when you start playing with typedefs you'll see typedefs commonly used with structs and for things like unsigned ints let's not compile this code for now instead let's print some things out here. how can I print strings out and single characters? well you've seen printf, fantastic. guess what? there's also putchar sixty five and that's going to print a single 'a' so if you wanted to print out a single character, there are these C calls like putchar if you want to print out a line, there's put s Hello World 'It prints a new line too' so that's useful if you know that all you need to do is print out a C string. it will print out a c string followed by a new line all of these calls underneath end up calling, what?  yes, they call write <gibberish> some point your C library says I've had enough holding these bytes, I want to get rid of them, I want to flush them, I want to send them out and when it wants to do that it calls write to the OS it turns out actually you don't need to print everything to stdout. your processes by default have two output streams. one called standard out, one called standard error. let's prove that let's use fprintf. I'm going to say something like 'this is using printf' and we'll try to run that and it doesn't work we get an error because we haven't given enough arguments to fprintf and in fact the. let's look it up fprintf, yeah we need the file stream first. we can say standard error here's the thinking, here's why standard out and standard error exist and they're not quite the same quite often when we want to use these tools we want to process the output of one tool and send it immediately into the input of another tool but what about errors? well we'd like to see them still in the terminal, we'd like to send them to a different file you're compiler for example, might send - ahh what have we done wrong here? standard error undeclared? ah OK, great, that really did print. This is using fprintf. We can send things to these two different output streams and you too can make your own output strings by using fopen And also they have different bufferings What've we got here? I've shown you things like puts and putchar how do I print - use fprintf, for example, I can send it to standard eror, blah blah blah is standard error buffered like standard out? no! standard error immediately calls write, it doesn't try to do any buffering standard out is a little bit diferent. standard out tries to have better performance, so rather than writing every single byte, let's collect a few up and once we assembled enough bytes then we'll call write and make it appear standard out by default when you're just looking at things in terminal buffers until you see a new line so if we see a new line, let's flush that buffer! in other words, call write on the whole buffer and out it goes
let's prove this while one do nothing  right so we got the very first line over here from printing to standard error but we did not get the standard out line so look at my code, I said hey this is using printf and this is using printf exclamation point" the difference between the two is that one of them went to standard error and we saw that straight away standard out that text is still sitting inside my process inside the c library because we didn't include any new lines and now my process has got stuck inside this infinite loop so now when I control C the program never has a chance to flush that buffer it never has a chance to write it out if I did just exit normally, if I did just say return 0 here then as part of the exiting, the C library says oh look I've got some open file descriptors I will make sure that my buffers are flushed so it does that at the very end as the program is finishing right oh and one last thing here, if you actually want to print into a C string the best thing to use is sfprintf but I'm not going to talk about that today but that's assemble things into, yes quick question there is two different streams so it's up to the terminal at the end to combine it into one and display it but we could make it so that the standard error goes to a completely different file or goes somewhere else let's have a look at page two okay when you free a null pointer, nothing happens, it's a safe operation by definition of the spec being thinking beings, you want to see errors as soon as possible you can actually change it there's a call called setvbuff if you want to change it but that's the idea right okay so which one should we do here let's do these three, these are the funnest ones the first three questions on this you can see on the wiki book I want to kind of go through these, first of all let's write our most exciting system program today I'm going to use this fork and for that we need to include unitstd.h so let's do that so let's print something out in our little program here, let's find out what our process id is so I'll just do %d for now, that's good enough for this lecture let's call getpid to mean get my process identifier so we'll run this and next time I run it I'll have a new line as well so when I run it this time my program was process identifier 61 and in fact if you do ps on a command line you can see all these different process little numbers and we'll use that later because we'll control them this little virtual machine doesn't have much going on right but if I was to run it again, I'd probably get a different process number one hundred and seventy five, okay
so now let's do something exciting let's call fork() look, I get two different numbers, 188 and 189 I've actually got two processes running here's what happened: the moment you called fork(), your little process gets temporarily stopped for a nanosecond so the CPU's not going to execute anything in your code and we duplicate it we now have two nearly identical processes running and then we'll let them go so remember when I said, you pull a switch and you get an immediate doppleganger there's immdiately two processes now one thing you've noticed already is that they have different process identifiers another way that they're different is that one of them is the parent of another let's get that back to result, and let's say...fork gave me the following My pid is that okay, let's run that so, look at that! I got two processes running at the same time. one of them says hey! fork() gave me nothing. it gave me zero. and fork() gave me 203!" so these two processes are now running in slightly different worlds. one of them had a different return value. one of them had a non-zero return value and in fact, the return value is the child process! so as a parent, if you wish, you could create a child by forking and then immediately kill it but I'm not going to show you how to do that today instead, I'm going to show you what happens when we fork() too much while 1 is greater than 0 let's print that, let's not return, and let's sleep for one second just so we can kind of follow what's going on. actually, let's sleep for two seconds Are you ready? let's see what happens now okay! I've got two processes. OH! how many have I got now? FOUR processes. now I've got eight processes. now I've got 16. Each process, remember, sleeps for a second and then forks. it makes a copies of itself. so I've got all these running processes because say, I had 4 of them, and all 4 of them called fork(). oh dear, my system has crashed alright, eventually, my poor machine of course runs out of memory and it's unable to continue. alright. so, actually, at this point, the system does its best to preserve itself it does its best to say ahhh, I don't want all these children!" I cannot cope and so it prints out all the debugging information and then decides at random to start killing user processes. the idea being that that's the least bad thing that we could do in this case because we want to preserve the actual main operating system (the kernel running) and maybe we'll have a few processes left that are still useful so let's see if I've even got a- no, I don't got anything do I? no, it's dead but that is an example of a fork() bomb. as you can see, it's pretty mean to everybody else that happens to be logged in to the system at the time so, when you start using forks for the MP, good luck! and try not to write fork bombs and with that, we'll finish there and I'll see you on Wednesday!
your laptop before we release the official instructions ecetera but that is it. that is coming up alright, so, next question, who here is ready for section this week? and actually got a little working editor? alright, who here is still working on it? okay, who here is procrastinating and has not started yet? alright, okay, so note that if you raised your hand on that last question, you are definitely the minority. remember, the purpose of this work is for you to be on top of using these calls, understanding how memory works, understanding how to put them together so make sure you're ready and it's gonna be great prep for when we do the harder MPs right then so today here's what we're going to do. we're gonna talk a little bit more about C programming. I'm going to show you some more gotchas i'm gonna talk about getline I'm gonna talk about assert(), I'm going to show you some fun little demos and as usual, feel free to interrupt me and ask a question or two and as usual, most of this material is also in the wikibook. which was created last semester. So most of the lecture content, you'll see inside the wiki book alright, also, these lectures are now recorded so feel free to review them as well right so, let's have a look at our little handout. overhead!!... doo doo doo doo doo right! so here's something you can put inside your C programs. if you write line underscore and undersore or file underscore and underscore, something magic happens they get expanded by the C preprocessor into a number, as if you actually typed it, and a string, as if you actually typed in the file name that's currently being compiled so the value of line actually changes and the preprocessor knows which actual file line it is currently compiling so that can be useful for putting in debug information, so we can discover for example which part of our program is executing by printing this stuff out so, let's have a look, box pc okie dokie, so for example, I could say hey!" or, let's just print it out. I'll do printf "bad stuff happened in file %s at line %d" we'll put in, let's see I need the file and the string so that's a underscore. oops. can't get it back inside. thank you. file and line number. alright, so we will put a new line there...let's say exit our program so nothing else happens. okay, let's run this alright, so there we go, bad stuff happened in file program.c at line 14. that's pretty useful if we want to open our editor and go back to that particular point. so that happened at runtime. and in fact that idea is used by another macro called assert so you can imagine we want to be able to say things like look, if my pointer is non-zero" so I could say "not equal to null" or I could say "not equal to zero" or I could just say "if not p"  in other words, if its not a valid value print an error message and quit right? that's a pretty useful thing to do during debugging. just do a quick test. before I start using p, I may be crashing in really strange ways so I just want to check if the following expression is true so that is actually what the assert macro does. so, I can say things like look, I want to assert that 2 is greater than 1" let's check that. let's assert that 3 is less than 7 times 0 right, let's run this we didn't get anything, did we? and, I'm wondering why let's see, we compiled asserts include assert.h and we don't seem to be. AH. we want to compile it in debug mode okay there we go, right so this time we, haha, yes! this time we remembered to include the assert.h and assert is actually a macro. it expands to include that underscore underscore line thing and underscore underscore file so now, here we go, when we run this, it prints out program.c at line 15 inside my function main assertion 3<7*0 it's pretty useful. it actually shows you the expression it's a nice simple development thing to use asserts because then you can check that people that are calling your functions are actually giving you say valid arguments and you can check that your assumptions are correct before you try to write complicated code and, it kills your program. it aborts so that's assert now then, pretty easy to use, remember to include it, include...assert.h and then, and then inside your program you just say assert and write an expression you expect to be true like Hey! its wednesday!" if that expression is true, nothing happens and in fact, when you make a release build, this expression isn't even tested this compiles to no code so it's good for performance but then you realize that you've been living on the edge. it doesn't actually check it. and it's a macro, because we want to be able to print out the actual contents of the expression we're going to test. and also we want to print out the line number. and also it's a macro because we can make the contents of the macro disappear when we do a release build so, with that, let's see if you can write a version of string cat. and what you want to do for strcat is append the contents of another string onto the end of the first string. but, we're not sure that people are giving us valid arguments so how would you write this so that it aborts if either one of these were NULL ? what would you write? so see if you and your neighbor can finish this
this function it should at the end simply return a pointer to the beginning of the target and i'll give you a hint, how do you actually determine where a string finishes? You walk along the string until you find a null character so the plan should be walk along with a little loop until you find a null character and then start copying the bytes from the source at that point to keep copying them across until you get across a null character in the source and then you know you're done copying and then before you finish make sure the very last thing you put at the end is a null character to terminate your string see if you can finish that code in about five minutes and I'll walk around answer any questions you have questions? ice cream? popcorn? yes? if you wanted to check that these are valid pointers, we want to check that they're non null so actually we could just say assert dest you could even say dest and source, however, that wouldn't give you very much debugging informationÃÂ all you'd discover is that one of them is broken so personally I wouldn't do that, I would write it as two different things on two different lines so that when it does it break I can discover at least whether the problem was with the source or the destination address OK, right, so if I get past that I know that both of those pointers are non null. my next challenge then is to walk to the end of the dest I could do that using a little loop. I could say things like while star dest  keep incrementing dest so that would work, in other words whilst - when I read the contents that dest is pointing to - whilst that's non null keep walking and it will keep doing that until I end up on a null byte. I also heard people doing things like, let's just add into dest strlen dest in other words find out how many characters excluding the null byte, are pointed to at that destination and add that to dest so both of those would work now we want to copy. OK, how could we do this? well maybe I call string copy, but if I wanted to write this in a loop, let me write this little do while loop going to dest and do I want to go into there, the contents at source I can't spell source, nevermind. whoops, and then increment both of those. dest plus plus, source plus plus. there we go
alright and keep doing this while either one of these is valid okay what do you think about that code? hold on hold on you can't see it is this code correct? does it copy the null byte at the end? okay alright if your neighbor thinks it copies the null byte get a new neighbor right why does it not copy the null byte? because we've incremented the source pointer right so we copy a byte, we keep copying characters and then we increment the source pointer and then we say while source so we are checking the next byte, the byte that we haven't yet copied so no, that code doesn't actually coy the very last byte you see, C program is easy or actually C programming with bugs is easy, writing correct programs is harder and we wouldn't have spotted this if our destination memory had all been zeroed by some fortuitous accident so that is incomplete, we still need to copy the byte at the end so at the very end I need to put a null byte in so I could write that as zero, I could write that as backslash zero that means the null byte and then finally return dest okay what do you think about that code yes, so if source is just an empty string what would happen? correct, we put two null bytes at the end so that's dangerous right? our code would actually copy more bytes than say the standard specification so now we've got a bug that only happens when we copy empty strings what else? there's another bug as well. yes? I'm writing memory that isn't part of dest or source okay, so I haven't malloc'd a new buffer yeah. okay so let me first mention the error I was going to point out which is actually the specification of strcat says we should return the beginning of the string we are actually returning the end of the string whoops, so we probably should have kept a copy of what the original value of dest was as it happens, most people don't tend to use this return value and so your code might work in most places until the day it doesn't now let's get back to that question of oh we haven't malloc'd any memory so strcat actually assumes that the destination is big enough for all these bytes that we are going to copy it doesn't do any mallocing itself, it just says okay give me a pointer, I'm going to assume that there is enough bytes available for me to copy whatever is available at source and if that is not true, well let's hope this code isn't actually driving a car or an expensive robot or flying a plane or something inside your bloodstream so strcat is dangerous, you have to promise that you've got enough bytes allocated at the target and for that reason many people avoid it and use strncat instead which I'm not going to talk about today and that saves you from some of these gotchas so it's better but it's still not perfect you can still have problems with strncat but I don't have time to talk about it right now okay right so for your next serving of C, I've got some code down here that uses strcpy and strcat and arrays and pointers to stuff what errors do you spot? if this was say a code review or in an interview and they said hey look at this code, what can you tell me about this?" what can you and your neighbor find? what errors? what kinds of errors and how would you explain them? [long pause]
okay, alright! so, what do we got here I got three variables: var1, var2, and arrrrrayyy!!! alright, just to point out that this is an array. and they all initialized to hello world! bounjour!" now, there's a big difference between these and to point it out first of all let's talk about this very last line no, it is not possible to do this what this line is trying to do is say hey! I've got a pointer called array. make it point to the same thing that var2 is looking at" no, you cannot do that. if you use just the array name here, it's treated as a pointer but there's a couple of big differences first of all, you can't change it this variable is the beginning of the array you can't make it point to a different piece of memory secondly, if you ask the size of array, you'd actually get back the number of bytes of the actual array unlike a pointer where it would tell you the number of bytes required to hold a pointer so no, you can't change array and make it point to something else you can, however, make a pointer to a character point to a character array. that's okay! now you've got var1 holding the same address that array hold alright, now, what about these other things up here? okay, strcpy! I want to copy into the array var1 is that okay? if you said it's okay, you're correct! okay, why is that? well, here's what happens. we're actually saying I need an array and I need it to be big enough to hold the following data" (bonjour) and when we run our program, when we start the process, we have a little array, here it is, and bonjour is copied into this array so, our array lives in memory that you can read and write so if you want to copy other stuff into the array, yes, go for it. it will work. just remember that the array isn't an infinite length. it's fixed size. so you better make sure you accidentally copy too many bytes into this data structure so we're fine, we do strcpy into var1 so that's okay, what about strcat var2 into array one? that looks fine too, ary is mutable, we can change it okay, here's the exciting part. yes, we're calling strcat so we are appending characters onto our array but you and I know that this array is not going to be big enough to hold whatever it is hello world" we're gonna write the data w-o-r-l-d and a NULL byte past the end of the array who knows what's going to happen? woohoo. we don't know! it depends on how things are laid out in memory but I'll show a little demo in a moment just to show what happens whoops, what we have here is a buffer overflow. we had a buffer which is just our little array and we went past the end of it we wrote into memory that we should not have been writing into. we didn't own that memory. oops. and, I want to point out that this can happen not because you were just thinking about. you didn't think about memory slides. it can happen through typos. when you intended to say strcpy and instead your fingers wrote strcat bad things could happen. alright. especially if your pointer happens to point to arbitrary data at this point strcat is going to say okay! I'll copy this data for you. I just need to walk along this data and find a NULL byte" and off he goes! bye! so be careful when you write strcat strcpy, just take a moment to check you actually wrote the intended one. of course, I've never had that mistake hahaha. and, what about strcat var1 var2? can I copy from what var2 points to into what var1 points to if you said yes, at least say it confidently because you're incorrect no you can't. var1 and var2 hold the memory address of this constant so yeah, you can change var1 you can make var1 point to something else. here we go. var1 equals hey, point to this other thing. hey, hold the value NULL ecetera. I can certainly make the contents of var1 be different but in this particular case, what it's pointing to is memory that is read only so if you try to start writing bytes into that address var1 points to, ah ah ah! no, you won't. the hardware will detect that and say you can't do that" I'm only giving you read access to those bytes alright, any questions? yes! yeah. yes. the compiler will spot that so array names are special uh, it can be treated as a pointer. if you need a pointer, the compiler will turn that name into a pointer. and the pointer is at the beginning of the array alright, so, if you do things like ary+3, that will add 3 times however big each element is so if you point to an integer array, it will be array + 12 bytes if you're on a 32-bit machine with 4-byte integers alright so, remember, the compiler is just turning this into assembly code so it uses the type information and if its trying to get a pointer, it turns into a pointer okay, other questions. yes! uh, so var1 the variable itself is mutable. we can make var1 point to anything else. but yes, you are correct. I could now write strcpy var1 after this okay, so, this is okay now. because var1 is pointing to the array. so of course I can copy okay into the array alright, we should talk about uh, I forgot to free memory. we do not need to free these memories. these are not on the heap you've actually got more than just the stack memory and heap memory you've got static memory where you'll discover these constants go where also our global variables go as well so you see heap memory when you call malloc. alright, that's how you get heap memory we haven't done a whole lot of malloc-ing yet and you see stack memory when you make a variable inside a function alright so here we go
that is going to be inside my heap well we're not doing that right now. we're playing things which are either constants or declared outside of functions let's do a quick demo. right, good here is the code we've got. I don't want this right now but I've done one extra thing, is I've made another array called demo. It's got the characters 1 2 3 4 5 6 and I'm going to print it out twice. so we should see 1 2 3 4 5 6 twice, right but of course, because you know it's a demo, we're not going to see that. let's see what we get. oops, we have to turn off the asserts OK, we're not going to see that. this is what we saw instead. 123456. OK, so we've printed out the characters and then d and a smiley face. where did that come from? for some reason demo got obliterated by a d and smiley face and of course the null byte why? because first of all we copied var1 in and then we did a string cat and copied var2 into our array. but our array was not big enough to hold 'Hello..!' and 'World:-)' strcat doesn't know that, it merely copies the bytes until the end. and so it kept on going and it ran into the memory that is being used by demo and we could kind of prove that they are next to each other. let's have a look at where they are. so we can say, hey the array is at this address and demo is at this address there we go. so array is at some low address and demo is at another low address, but just next door doing the mental arithmetic to subtract those two numbers is left as an exercise to the reader. but it's pretty close, yeah? it's about ten bytes right, that's our little demo. let's go back to our sheet. so let's talk about converting things if I've got a string and I want to convert it into a simple integer, how can I do that? well here's the easy way. use atoi so for example atoi of a hundred gives you the integer hundred what do you think atoi of bananas is?  place your guess now it's zero! so here's the downside of using atoi, yes it's really really quick. it's trivial to write code, but you'd better trust that what you're going to get is a valid integer that can be converted into a standard c integer because if it can't it doesn't crash, it doesn't complain, you have no way of knowing other than the fact that you got the value zero so this returns a value of zero. so you don't know whether the user typed zero, entered zero, or whether it was invalid input so use it for little demos, quick hacks, etc., but if you actually want to check whether things are valid or not then it's time to use scanf because scanf will tell us how many things it successfully parsed. lets make a little scanf demo OK, three integers walk into a program. there you go x y z. and I've got a string that I want to extract some values for maybe this is some 3D vertex data for example and I could use this function called scanf to say 'alright here's my input and I want you to treat it as an integer followed by some white space, another integer followed by some whitespace and another integer' OK, how do I push that out? I need to give it the address of my variables. so remember ampersand means tell me the address of this thing OK and now if our program works tick tick tick tick, yeah! z is twelve! hooray! great, I've written a parser that can now read 3D data. watch out minecraft OK, what about 10 11 x? what do you think the value of z is now? well it's claiming that z is zero,but we should try something here. suppose we initialize z to be something else like 42 z is still forty-two. so what our scanf did is it started eating, started walking along that string, it got to a point where it said this not what I expected and it choked. it just gave up and stopped so what we should do to write robust code is see how many things scanf actually managed to bite out of the input so let's have a variable here called numread and we can now check to see how many things were actually read by scanf and then we can write code that says, hold on a moment, I died trying to parse this line now you can see numread equals two
extract out the x and the y and we failed when we tried to parse the third integer right, so scanf looks pretty easy and it is it is very easy to write bugs using scanf I've already mentioned one, okay so scanf - you saw that there are already different versions of it I was using sscanf because that allows me to start from the string which is good for demos there is also fscanf which guess what, starts from a file pointer so for example, I could read from stdin or I could read from a file that I've already got open and then we need the format string, okay so here's the first problem that you can run into this looks a lot like printf, printf's format string yes? I just showed you one with %d's and it is until it isn't it's actually subtly different, so the day that you actually need to write a scanf, open up the manpage and check the format specifiers because it's not quite the same for example floating points are slightly different so that's the kind of first gotcha. that second gotcha I've just shown you, which is that the number of items that you've read isn't necessarily all of them, so you should check that and then the third gotcha is guess what, we can put in addresses here and sometimes you want to put in an ampersand and sometimes you don't so I showed you one way we did ampersand y ampersand z because I actually wanted to know the address of my integer variables can you think of a time when you might not actually want to put in the ampersand? yeah, if you already have a pointer to the thing that you want to change so if you've got a pointer to an integer variable, there we go, let's put in pointer here and provided that pointer is pointing to something a variable I want to change, everything is fine everything is not fine if I was to write in ampersand pointer because now what am I changing? I'm changing this, I'm not changing the thing its pointing to and if you think this is complicated or confusing, it is! so my advice is don't write scanf code until you've had three cups of coffee, you're completely awake and it's the most important thing in the world to get it right and even then, assume that you've got it wrong scanf code is incredibly hard to write correctly and you can get nasty little errors just by missing an ampersand or putting an ampersand when you don't need one scanf is not going to detect that, you have to be extremely clear about whether you mean to talk about the thing, the address of the thing or using the thing that the thing is pointing to so it's not for the feint hearted and with that warning, let's carry on I can promise you I've spent hours debugging scanf code that I thought was correct here's some other things that will kill us or get you gets is easy to use, you just say gets and you give it a pointer to your buffer to some characters description, never use this function the reason I bring it up is because people like to ask about it occasionally in exams and occasionally in interviews it's a classic example of how to hack a program, hack a C program because gets like strcpy has no idea how big this buffer is how many bytes it can safetly write into whatever address you give it so if the data that it's reading from stdin happens to be bigger than your buffer, arbitrary things can happen now someone could use this to supply data that is longer than your buffer and start overwriting arbitrary memory locations and those arbitrary memory locations probably correspond to other variables so now someone can use your program to do bad things, to do things that the program is not designed to do so how do we fix this? answer: use fgets instead right and I'm not going to talk about that because there's some more fun stuff we can do down here let's do environment stuff, I don't think I've shown you environment stuff yet have I? okay right so every program when it runs has arguments and an environment  so if we do env for example, you can see that my program has actually when it runs, has all of this information all kinds of useful stuff like the current user is root, where the home directory is for example, the current directory is probably in there as well so I can get access to this stuff when I write my C programs so let's write a little C program that does this for example, I'll say I've got extern, environ, now this extern means that look, this thing exists don't allocate any space for it, but when we finally link all the pieces of my program together the compiler is going to look for this variable because we've simply declared that it exists somewhere and I want to use it inside my C program right now so let me put the contents of the first entry of environ and then we'll exit okay so you see we've just got a string a simple C string which is in the form of key and equals and a value and I could write a little loop to go through all of them and when I find once which is null at the end I know I've finished so if I want to enumerate all of my environment variables, I can use environ if I actually want to look one up that I know exists, I can use getenv, so let's getenv and say look for user okay so that will give me
uhh, an answer and I'll print that out. okay, so we can see that my program when it says getenv on the current user, it prints out root woohoo! so, environment variables are one way of passing useful things to your program. as we've seen, so say you can look at the current user's home directory and store your preferences there. or if you're mean, you can delete all their files so that's one way to get a general general environment. the other way you've seen of course, is that our main method has two parameters. argc and argv which is a character pointer pointer so, let's all look at this. first of all, some important points about them (come back!) the first is that the very first entry of argv is not one of the program arguments. it's actually the program name so I for example, could write a usage thing. blah blah blah blah and, if there are any other arguments, we can find out how many there are arguments %d our count alright so, it's program name, the way its actually executing we can actually discover from the program itself. it's the very first zeroth argument. and we've got one argument so this is like another kind of classic off by one thing again so if I have, you know, cats, it thinks its got two arguments what it means by that is that that array has got two entries and the first one being the program name the second entry being cats and in fact, that's not even quite correct either because it happens to be always one final entry at the end which is NULL so we could go through and look at all of the arguments so let's do that. we'll have a little pointer. let's make it point to argv + 1, in other words, we're not going to print out the program name this time (come back!) yeah let's get rid of that stuff okay, right, we'll stuff [something] we'll print everything we find at the pointer so I need a pointer to an array and a pointer while the entry is non-zero, let's print it out. and we'll add one! okay, so let's now try our little program. oh I forgot to follow the pointer. okay cats are cool alright, so, we can access each of the arguments that the program has
okay, hi. I'm gonna ask you to volunteer (student: oh okay) alright. I'm going to ask you to volunteer for something in a moment Okay! Good morning class! how are you? great! so, here we go, uh today we're going to talk mostly about fork() and exec() maybe we'll have time to talk about signals as well yes there will be an in-class exam/quiz coming up next week we'll see when it happens I guarantee it won't be Monday Or tuesday or thursday alright, more details next week. so first of all let's just start off with a little demonstration of how fork() works for that, I need a volunteer, yes! thank you! please come on down alright, so, um, here's my process and of course [something] today you're gonna be my process, right? so, a process to run of course needs some instructions to execute here we go, stand here, you're my process, right. okay thank you. and, here's the code that I've already compiled right into something the CPU can execute okay, we've got inside the process memory you've got a pointer called neurons and an int called capacity right and we run this function called init brain it's kind of complicated it does a lot of stuff when we pass in the address of neurons and the address of capacity, so there's init brain when it returns will set where the neurons being held and the number of neurons that we have so, it looks a little like readline, yes? and, manage to actually return a void pointer so we can actually use that perhaps okay so we're running this code, okay, and the next thing to do is think of a number, right? so, think of a number between 1 and 10 don't tell me! don't tell me... and then you're gonna print the number to standard out alright, so, this is my standard out here you can write a number...okay accept! oh you need a pen accept here's what we're gonna do, right. you thought of a number, yes? it's in your head. inside the process before you print it out, I'm going to change the program now in just here, I'm gonna call fork() okay? between thinking a number and printing it out I'm calling fork() so, what does fork() do? it doesn't not restart the process. no. here's what fork does: it says take a process that you've got and clone it yes? make an almost-exact copy of you! now I've scanned the audience and I've found the person who looks exactly like you I need my second volunteer. thank you, come on down [laughter] alright, so, at this point if you'd like to write down your number. so we've got two processes. don't show me your number and of course, thank you. so, we've got two processes and because we've cloned it, inside their memory, it should be exactly the same so if we now were to say to both of them, okay, continue executing, remember these are two completely different processes their own memory happen to be following the same assembly instructions here. the same code so if we asked them to print out their number, let's find out what they would say! here, hold them up and show the audience please look at that! alright, they're both printing out seven which is also what you wrote okay, that's a miracle. [laughter] alright so, well, a 1 in 10 miracle, not a big miracle, but we'll just leave it so this is how fork() works remember that this is what happens. it doesn't restart the process. it splits it so give our volunteers a round of applause, thank you very much [clapping] because we're going to use that now in C and remember anything you write in C could, in principle, be done in any other program as well. in any other script language like python python, for example, has a fork() but underneath, python's written in C, and underneath that, it just calls the fork() command okay so, I've got a little example of that in terms of code. here it is here we go, can we read that? okay, so here's my little example this srand() here thing, this says okay, system, tell me what time it is?" and I'll use that to initialize my random number generator so remember to actually generate random numbers, we cheat. we just do some mathematical bit shifting tricks so it appears to us to be a random number and it appears to satisfy some basic statistical tests but there's not really a random source here it's just a mathematical stream of numbers that appears to run all over the place so later when we call rand() we get back a random number but look at this for a moment! I've called fork() this time beforehand so the question is, what do you think will happen here? will my two processes. so, I have a new job process created. will they both print out the same thing? let's run this and find out. okay so what do we get? well each process is told to print out its id number so we get two different id numbers of course and look, my random number is 6! they both printed out the same thing! was it an accident? no. they actually both print out the same number so, why do you think that is? yes! at the back. thank you, yes, they both have the same random seed and the random state is part of the process so we've just cloned the whole thing so actually, you can use one process to guess what random number generators the child process is going to create as well because they are indentical it's like your cloned brother or sister or whatever your genetic clone knows exactly what you're thinking so this actually is potentially a vulnerability if you know, if you completely understand the state of a process, you can predict what it actually might do alright, so that's a silly example but I'm trying to show the idea that you start a process, you call fork() and suddenly, you have two processes continuing on past that fork() call
if I've got two processes how could I make the two process start to do different things? right now they've done the same thing, I want them to do different things here's how, we'll check the return value of fork because that is one asymmetry that we have to play with if child is greater than zero, so if the result is greater than zero for my fork guess what? it means I have a child! therefore I must be the parent so now our parent could just exit what's going to happen now? this time only one process gets to print out their random number, the child process we could make this more complicated and we could have our child calling another fork, for example. have many many many more children if we wished the main point to get here is the idea that you are duplicating the world at this point. you are duplicating the process by calling fork and you have two to play with let's put that aside for a moment and talk about that very first program. the very first program we've got here does quite a bit this is an example of quite a bit of system call programming. now we're actually calling system when we're making lots of different calls my question to you is can you explain every single line of this program? if you can, if you've been reading ahead in some of the manuals now's your chance to explain it to your neighbor. if you're not sure about something ask your neighbor. see if they know more system programming than you what is this program doing?  what does every line do? you want a handout? sure. this is the (cut's off) (speaking to a student) oh ok, what was the question? (still speaking directly to a student) we killed the parent process, but now the child process carries on yes, that is how we write the code. we say if I'm the parent just exit so the child carries on. yeah, sure anybody else missing a handout? OK, let's start with a quick demo. This very first line is close one, alright, so if I print something here, woohoo 'hi!' and 'oh no'. ok, right, let's run this we're calling puts, I could've called printf as well. I get 'hi!' but that's all I get, I don't get the 'oh no!' because standard out is gone, we've closed itl  so yes, puts might eventually call write but it's just ignored, that output doesn't go anywhere. I could've for example put printf here, I could've put write into one the following the bytes it doesn't matter, all of this stuff just goes no where, we've closed that file descriptor so one doesn't have any meaning anymore the system just ignores any attempts to send bytes to that particular file descriptor we've closed it, but then where'd my line go... we call open open says hey I'd like a file descriptor please let's see what this returns where's that return gone to, come back here and I'll print it out but I'll print it out to standard error and fd equals what error did we get? I better have some includes here. so if we check the man page for open and I need section two, we are going to need the following three includes. let's grab them so we printed 'Hi!' and we get back from open an integer one it's opened a file descriptor for us, a stream, somewhere we can send bytes. except this time rather than making it appear in our console we're going to make it appear in a file and we gave these options to open to say 'OK, I'd like to open please this file called log.txt, I need to open it for read and write, I want to create it if it doesn't exist, I want to append to it and then finally I'm going to give some options which I also bitwise or about who can read it and who can write it these options are saying that only I can read and write it so let's start printing some things out, like 'Hello', right and we'll run this
okay so we did not see hello in our output but if we have a look down here we'll see we've got a program called log.txt let's have a look at log.txt and it says oh okay it seems to be working, let's see if it appends to it and then it says hello hello alright so we're appending stuff to our log file we've changed the output of our process to go to this file now why is it that that happened? well if we were to read the man page carefully enough about open it says it returns the lowest non-negative integer for a file descriptor and we just closed one so when we do this, it's going to open file descriptor one which is what everything then uses when you call puts, printf, etc so we've now just changed our standard output to go to a file right then we call chdir, what does chdir do, it has nothing to do with cheese change directory! yes, our core process not only has memory for say the variables that we create we've got other things inside our process we've just seen one thing, which is it's got these file descriptors each process has file descriptors also each process has a current directory so when we say hey I want to open a file called log.txt and we haven't specified it's full path it's relative to its current directory so for example, if I had put up here hey chdir and let's change our directory to just kind of slash" okay, let's run this then slash is the root directory and if we look at the root of our disk drive, now we've managed to make a file called log.txt here we go and it's contents is just hello hello right so okay what have we done? we've done chdir. so we've said chrdir to usr/include let's just have a quick look inside there because what is inside ls /usr/include/ a whole lot of dot h files remember in your c files and your c++ files when you say #include std.io hash include this hash include that they are just files, here they are! so next time your friend walks away, why not edit one of them? uh do I have vim on this machine? maybe I have stdlib.h oh I need to be inside that directory okay cd /usr/include/ let's so stdlib.h and it's a bit of a mess but nevermind we can say things like whoops not working, not implemented anyways... we can do #define if while so if you hash define if while, that means anytime you see an if, it's going to replace that with the letters w h i l e very useful if your class is curved, right alright so we've talked about chdir and we've talked about /usr/include now we can have some fun, so we have this, let's just go back to my original directory uh hello, alright I'll reboot the machine right so we have this exec exec thing okay here we go what does exec do? alright suppose you were thinking about something, you're running a program inside your head exec says hey forget that program, do this other thing instead it's a complete mind wipe of your process whatever it was doing, whatever variables you created, whatever memory allocated, it's gone! you're saying this process will now actually be executing this other image right, load this other executable from disk and run that instead so we will run this right alright so when I run my program now, it actually runs ls it actually gives me the contents of the current directory which is just a dot now here's something weird, I can understand that the last argument here might be null to mean hey i've got no more things I want to talk about here" but why is it that I've got /bin/ls twice? okay, here's why: the first one is the command that you actually want to execute so inside /bin there is a whole load of commands here I think we've looked at them before but remember, when you run a command, you want to give it arguments so when I call say ls, so here it is exactly, I need to say okay what do I want to do? well I want to look inside /usr/include but that's not what the program sees the program sees the arguments you provide also its own name the name that it's running as so that's why you see the exec/ls twice because this is the program that we want to run and this is the argument zero that it will get inside main so we could probably change this to just say ls for example okay so that'e exec, notice that my program never printed hello world that's right, it had a mind wipe if exec works, we never return, we don't execute anymore code here so the only way to say print out hello world is to make it deliberately fail I'm pretty confident that that program, that image does not exist so exec will fail, it will return -1 and now it prints hello world it continued on and in fact we can actually print something useful by using perror my exec failed and we used perror it prints out your string a colon and a little message here so here we go, my exec failed: no such file or directory doesn't tell you which line it failed on but at least you have a hint as to the kind of error that happened
right so that's our program in a nutshell so, perhaps we can decide what its actually going to do as a whole time to interview you neighbor what do they think? see if they can describe it tersely in 10 seconds or less what does this whole program do? what does it create. what are the contents of that log file? [students discussing] okay! so we know that all standard output is going to go to log.txt we print out captain's log" to that file and then we run bin/ls let's see what happens I ran it, I didn't see anything on the output here, so presumably, there's something waiting for me inside log.txt let's have a look. oh yes! look at that! there is a whole long listing of .h files inside my log file how did they get there? well yes, when we call the exec we did a mind wipe and it's going to start executing the code of /bin/ls but standard out has already been redirected to go to a file so we change the context in which /bin/ls runs and we print. and because we changed the directory of this process to usr/include, when we said turn me the current contents of the current directory", we got the contents of /usr/include so that's our first significant system program uses all sorts of little commands I encourage you to play with it now, I want to show you a little challenge this is one of the. this is the only algorithm I know that was actually published on 4chan cesspool of the internet okay, so, my question is, what's it do and how's it work? so this is you versus 4chan. what does this program do? notice its got a fork() in it [silence] okay, I think it's time for a demo. see if your expectations are matched, right. so let me give you some values yeah lets do that. okay, here we go. yes, what we have here, ladies and gentlemen, is a sorting algorithm, system programming style it's clearly O(n), right? all we saw is a single loop yes this can sort integers. here I have another example look at that! isn't it brilliant? badum badum badum badum it's still calculating...ok. alright. so how does my order n algorithm work? alright so it goes by the name sleep sort" and like I said, this was invented in 4chan, it's not actually published anywhere else but it's a nice cute example of using fork() and atoi that we've talked about these things and sleep() so how does this thing work? well it makes a whole lot of processes in fact, remember that C tells us the number of arguments to our program so this is going to pause every single integer when it does, it makes a whole lot of processes that because we're counting down C, it makes enough processes one for each integer that we provide and each process gets a different value of C because it exits the while loop at different times so, each process ends up calling sleep() for the right amount and then prints out the number so, if you entered 1 it sleeps 1 second if you enter 100 it sleeps for 100 seconds
alright, the only other thing I want to say about this. this is the second semester I've presented sleep sort. Before that CS241 didn't have a sorting algorithm and it kinda felt lonely because 125, 225, every other theory class you take has a sorting algorithm. now we can proudly say, yes, system programming has a sorting algorithm right, so, questions about this algorithm? other than never use it! right so clearly it's got some limitations. sleep's going to count for a second in seconds etc and also it relies on the operating system to implement sleep so it's not truly an order n algorithm. the operator is just delegating all the work to the operating system to make sure the processes sleep the right amount of time. in other wrods, when you call sleep your process gets stuck, it's not going to execute anymore instructions until the operating system wakes it up. we'll be talking about how it does that when we talk about scheduling later on in the course let's go back to some more serious questions. what does the child inherit from the parent? all the money, right, no.  what've we got? what've we seen so far, what does it inherit when we call fork? what do you think it inherits? what do you get? i'm sorry? variables, yes! so you get a copy of the memory all of the processes memory you get a complete copy of that. ok, what else? that's kind of all in the memory, yes all of your c variables etc, the state of any kind of libraries like the rand. state of the random number generator. what else might you get? OK, I'll give you two. current directory and open files if you've opened a file you'll fork will also be able to read and write into that file. more about that more later in terms of the details in terms of what happens when both the parent and child read and write into the same file what's different between the child process and the parent process? here's a couple of differences. first of all, guess what, if you call getpid you get different numbers what else is different? the return value of fork  if the result is greater than zero you know you have a child and therefore you must be the parent oh yes there's something else that's different what do you think getppid does? yes! parents! hey I want to know the ID of my parent so of course that's going to be different you could probably write out a program to print the parent ID in two different ways. in the parent if fork returns a number it's easy, it's my ID. if i'm the child then I should be calling getppid to get the parent so if I've got these two processes and I've shown you that we can write an if statement so they can do two different things, how can I make it so my parent waits for the child to finish? easy, we call wait or waitpid. let's have a look at this I will write a little program that immediately forks if result is greater than zero..what? I'm the parent OK, what should we do with the parent? let's wait for our child to do something so how do we finish? for this we'll look up waitpid we'll say who are you waiting for? I could pass in minus one to say 'hey I'm waiting for anybody', but actually I care about my child finishing then I can find out what happened to them, so I can basically do a post mortem on my child here and I can pass in some options but I don't need them for this lecture so I want to put zero let's have an integer and notice that I'm passing in the address of the integer if I do that waitpid can write it's notes into that integer because I've given the address of the integer now we could print something out about the child. percent d... waitpid said ah, didn't save it our program get's result. what does our child do? our child does nothing. well actually it just gets to the end of the program, it finishes so the child says 'oh my result is actually zero so let me do what's down here. OK, nothing, I'll just finish, I'll just quit' we could write some special code for the child though. why don't we say sleep for a little bit like two seconds and then quit byeee
okay so if this works, then what we should see is the child will sleep for two seconds and our parent will then be paused also for two seconds because it had to wait for the child okay, so one, two, bye and then our parent can continue right? so we've made the parent wait for the child now there's a little bit more to using waitpid that actually there are some macros down here  here they are, that actually to put useful information out of this, I should use these macros so for example, we can find out the exit value of the child but only the lowest seven or eight bits sorry, eight bits, so if your child return a value 42, great we can see that if it returns a value 304, I'm sorry you won't see that as a value, you only get the lowest eight bits we can also check to see if it was terminated by a signal right, how can you generate a signal? pull our a whistle from your pocket, yeah but you could also press control c on your keyboard to interrupt a process and when you interrupt a process, you are sending that process a signal there's other signals that can happen as well so if your process tries to write into read only memory, your process dies how does it die? it gets sent a signal that in cannot ignore so as you can see, we can actually find out some things about our child and you'll be using that in this week's little assignment before section alright so let's make it print something out, right so in this case what we'll do is we will say if it exited, so let's check the value of status then we'll print out the exit value WEXITSTATUS we'll get those lowest bits and we'll make the child return 42 did it run? one error, what's my error? oh, okay so I have not included something.. one two yay, okay great so this time you can see our waitpid got some arbitrary value if you actually want to pull out the exit value then you should use those macros alright so if exited, then we know that we can actually pull out an exit status as well right, so how do I wait for my child to finish? waitpid! and on here how do I find the exit value? you should use the if exited then we can use the WEXITSTATUS macro and all these macros do is just pull out the relevant bits and do some bit shifting from that original integer okay, right so are you ready? page 2 how do I start a background process? well a background process is something that we want to run in the background right we don't care about interacting with it maybe I want to actually say compile a program in the background let's do it from the command line here so for example if I want to look at the contents of /usr/include/stdlib.h right, I could say that actually I just want to send that to a file but I don't want to wait for this to finish well I can just put an ampersand at the very end that means run it in the background and I can continue doing this whilst that copying happens we could do the same thing in C by not bothering to wait so I've got my fork here and I could do other stuff in the background  sorry I could do other stuff inside the parent and not wait for the child to finish so this is why fork is very powerful right? now I can fork and start a process to compile something. I could fork and start another child process to connect to the internet and I don't have to wait for these things to complete I can do things in parallel yay right, so now if you've got 4 CPUs you can use all four at the same time to compile different parts of your program for example there is a problem though good parents don't let their children become zombies suppose you created a child process and off it goes and it starts compiling stuff and then you the parent process finish, you quit what happens to the child process? it's still alive! ha ha ha compiling alive, it's still going right! but it has no parent uh oh, right, so, uhm, so here's what happens, if nobody is around to wait for the child when it finally finishes if you don't call wait on a finished process, you get a zombie so a zombie is a dead process that no one cares about so waitpid is like going to the gravestone and saying yeah I remember you let's do a postmortem  if you don't do that to a process, the system says well actually somebody might want to know about that process they might want to know its exit value for example so it's going to take up some system resources, not a lot, but a little bit to remember what happened to that child so that's what a zombie is, it's a dead process that nobody cares about
alright, doesn't sound too bad, right? but what would happen if we had too many zombies? eventually, the system says I'm not creating any more processes for nobody" yes? I will kill another process so your fork(), for example, would fail or another processes fork() would fail. okay so, you can do that. the child will continue and the child will do what it wants to do. okay? um, so, uh, the system has one thing it will try to do to prevent zombies. which is that in this situation if the parent finishes, and the child is left running that child is re-parented given a new parent so if it called get ppid(), it doesn't crash, it doesn't explode, no it has a new parent. I'll tell you who the parent is process 1 the ultimate of processes. the first process in your system. the first process that ever existed when you booted up: process 1 well, kind of the first process the first process with a process number anyway the ultimate of processes right? which classically has been initially or just initiate or just init goes by various names and it calls wait on the poor little orphans alright, to ensure that we don't get zombies. so, life is not too bad if your parent dies right? the children as they finish, they will get reparented onto init. then init will make sure it calls waitpid on any future children that die so, we run into problems, though, when we have a long-running parent. so let's say you made a webserver well the parent tries to live forever, wheeeeee, it's going to keep going around, hey! lets just run forever, right? and I'm going to serve the web request. and for each web request, I make a new child so if we have it so that the child does the work, each web request, each HTTP request we might run into a problem now because the parent is making all these children and never cleans up after them so in this scenario, when you've got a long-running parent, you've got to remember to call wait() or waitpid() because if you don't, you'll have a whole lot of zombies you'll have a whole load of exit values and other meta information about the process thats still just lying around inside this system okay, so, you must remember to call waitpid() to clear up or to prevent zombies okay, alright, so, we won't talk about signals today. instead, let's see if I've got some notes okay! right! just a heads up, we'll shortly be publishing this so, your assignment for this week is two-fold first of all, time to jump into android get the SDK and the NDK installed and working on say, your laptops or start using the lab if you don't have a laptop we want you to basically make something simple and [something] to get as many people as board with actually using the NDK/SDK if possible secondly, you'll be using fork() and exec() and the stuff we've seen today to make your own simple make" program which we've called "fake" instead of "make" so, let's have fun with learning to program fork() and exec() and enjoy your weekend! thank you very much! Questions come and see me now or find me in the coffee shop. questions come down and see me now or 5 minute coffee shop
good morning cs241 people. how are you this morning? great, how's everybody else? alright, let's try this again. okay, alright, yes, good morning! you've enrolled in cs241, for better or for worse, you'll learn a little bit about systems programming and for the next 50 minutes, we are going to talk about some new stuff, some old stuff, some [something] stuff, some blue stuff I lied about the blue stuff alright so, all I have to do is open my mouth and talk and type. all you have to do is open your brain and think how hard can it be? let's try again: good morning people, how are you? great!! good morning class. alright, so, the reason I do that is because maybe we'll get a few brain cells working before we actually dive into this stuff, okay? so, here's the exciting news. yes there are exams in this course. there's no single midterm. instead, there are multiple choice exams scattered throughout the course and the first one will be on Friday yes, so, please come on friday, bring your icard, bring a pencil, and look forwards to multiple choice questions which go over the things we've covered so far anything we've done in lectures or you've done in previous sections, it's fair game. okay, so I'm looking to make sure basically that you understand the basics of C programming so as a result, some of the questions we've got today are to do with [something] in C. alright so, where's my handout? okay, let's have a look at this first question then, right I've written a C process, or any kind of process really, that runs for a long time and it's creating other processes so for example, it might call fork() and then the child process that you've just created calls exec but we never wait for our children to finish but they do. but we never call wait on them what have we created? zombies! yes! we've created dead processes, processes that have finished but no one's cleared up after them now, if you see any zombie movies, you'll discover there's different ways to kill them. right. but, running away is usually what's recommended in most zombie movies but fortunately, what we do in C programming is just call wait, and when we do that, the system can kind of clear up the mess left by the zombie if we don't do that, then eventually, we're unable to create new processes. the system runs out of space alright so yes, we've created a zombie in this case so a zombie's a dead process where all we're returning essentially is it's exit status. but it's still taking up a little bit a system resources because we haven't finished cleaning up after itself and it only happens if no one ever calls wait so for that, I need a long running process so let's see what happens in the other case where my child outlives the parent. would you like a handout? we have a question that happens when the parent dies. okay? so that's why the question up there says long running parent". the parent hasn't died. it just doesn't care about its children the children have finished, alright, perhaps they've called exec" and done an "ls", perhaps they finished doing a computation, perhaps they finished serving a webpage to a client. the point is, the child processes, once they finish, they're still taking up space alright so, let's not have a look at a zombie. let's have a look at the other case that you just brought up which is what happens when the parent finishes first? ok, so, I've got a little bit of code here, and uh, first of all you could ask, what's it actually print? the answer being nothing! because actually if you look at it, you'll see this #if #endif those are preprocessor directives to tell the preprocessor to say well if this expression is true, then include this, otherwise don't" and, so of course right now, there is no main method. compiler would never actually see the code we wrote in here right, I could write garbage in here. like, alright, you know I could write superbowl" um, and it's not gonna find an error in there because the actual compiler doesn't check for the syntax. it keeps going until there we go alright um, so let's fix that, let's just say #if 1 okay, right, and we'll run this and a question for you is, before I run it, how many times is it going to print I am process" cuz you see it happens before fork() and secondly, who's sleeping? is it the child that's sleeping or is it the parent that's sleeping? if you made up your mind, tell your neighbor. see if they agree with you if you're not sure, at least have a guess okay! alright! so, who's sleeping? is it the child or the parent? the child! remember, fork() returns twice, if you like. because, when we call fork, after it executes, we've now got two processes. we've got the original process, and the clone the doppleganger that believes it really is the same original process because it can look back in its mind and say yes, I was born in kansas" right? it remembers all the variable states but its actually got a copy of everything (well, nearly everything) but there's one asymmetric difference which is that, if you're the child, your return value of fork() is zero so we are asking the child to sleep() okay, meanwhile then, both processes carry on independently, you can imagine them running on two different CPUs they're completely different processes. just like you can be running Minecraft and working on your chemistry homework at the same time and we print something out. we print out our pid and our parent's id. so let's run this...see what happens
alright, so, the first surpise is that we see 'I am process' twice that's weird, why did that happen? let's talk about in a moment and then second thing is one of the processes said: and my parent is 1 okay, how, why? well remember we made the child sleep. we made it sleep for an extra second. in that second it's original parent finished it exited. so now what are we going to do with the child now? who's parent should it be? and now's where the system says 'I know what! we will reparent you back to the ultimate process' parent process id one so that's what happened there. if we didn't have this sleep then we have a race condition. maybe the parent finished first, maybe the child would've finished first we cannot say for sure who would finish first so that's why we put the sleep in okay, but why is it that we saw 'I am process' twice? OK, if you think you have the answer wave your hand in the air like you just don't care. you care alright, very good yes. okay! so, a few people know. i'll give you a hint I'm going to change the program very slightly by putting '\n' in there and now you only get 'I am process' once. so by putting  '\n' in there I changed the output of the program quite significantly. what does '\n' do? yeah! thanks. in our little example here, C decides to flush the buffers. so there's abuffer inside the process and it's just collecting bytes. just collecting the characters to print out but it didn't bother to actually write them out to the system yet. it only decided to do that when we saw the new lines. so in this example we ended up callling write(), we printed it out, before we called fork() in the first example it was still inside the process so when we forked it was still there inside the child as well. the child says 'oh yeah,I've still got these bytes to print out. I haven't got round to it yet' so be wary about this. the other thing to note is that at the very end of the program part of the clean up that the C library does is says 'hey ok any open file descriptors if you have something to write out do it now because this process is closing. it's time to flush all the buffers' so it does that as part of the standard clean up process right, so that's a little example there. how much buffering actually happens depends partly on wheter your trying to send it to a terminal or a file if you're sending stuff to a file it will actually keep buffering beyond the '\n' so it tries to have even better performance by buffering stuff out to a larger amount before writing them questions about this example? yes? right, so if we choosed fprintf()  aha, OK, right, so puts() is equivalent to printf() %s \n. OK so that would've actually flushed it as well and so if I used fprintf() the same thing would've happened if I sent it to standard out because the buffer of standard out by default when I'm sending it to the terminal is to wait until I say new line if I send it to standard error, well lets just do it. we would have seen it once because the default for standard error is just to push things out. we don't want to wait, we're not trying to get high perforance. you want to know your error messages as soon as possible just in case the process dies very quickly alright, so, if we wanted... remember how I said we've got somewhat of a race condition? I've just put in a sleep for a second and that kind of works on this particular system if we wanted to actually wait for our child  then I can call waitpid(). so how's waitpid()? let's check the old man page. waitpid so, you see we pass in the pid we got from fork. we can get some status information and there's some flags as well that we don't need today so what we'll change now in our output? ok, what's our little error here?  oh I didn't declare a little variable. there we go OK so this time the parent of the child is still the, huh. OK. why would that be? so the parent is waiting for the - oh. okay, yeah we called waitpid() on two, we should only be doing that inside the parent, so let's do that for the parent. so if I'm the parent then  we'll wait for our child to sleep OK yeah now thats sorted, that makes sense. right, so, what've we got there? the orignal one is 198 and it's parent is 43 which is probably this little shell program here that's running and the child is 199 and it's child is 198 so we should have two numbers right which are the same this is the child saying 'oh look here's my parent 198 and this is our original program 198 saying my parent is 43' so, you can actually discover all the processes running on your system. this one doesn't have that many and I don't know if you've got pstree involved you can use ps and pstree to kinda get a hierarchal view of all the processes that a process has. there's different options to say OK, I want to know about my process or everybodys processes but don't worry that's not on the test, okie dokie...
so, now it's time to talk about signals unless anybodys got any last minute burning questions ok, right, signals are called. there's a lot to signals we're just going to do an introductory part today but signals are the software equivalent of hardware interrupts so, think about hardware for a moment  i can have things like a clock timer that goes off every say hundred milliseconds  and interrupts what the CPU is currently doing and when the CPU sees that it says 'oh I'd better stop doing what I'm currently executing' and run some additional code thats gonna cope with the fact that my little clock timer has gone off or I've got some bytes from the disk which are ready to read and I want to stop what I'm doing and execute some different code or some information on the USB bus has arrived like someone plugged in a USB keyboard or typed something and I need to handle those bytes right, so interrupts allow us to stop doing what we're currently doing and process some different code we could do the same thing with hardware and that's signals and, we can send signals to our children and we can get a signal back evern when one of our children dies, which is useful and we can have a lot of fun with them because they can do differnt things so, first of all, that's a list of all the processes let me send a signal to one of these processes so, uhh, ok, do I have a pid variable here? no I don't. okay so, let me just send -9 to say process 43. what've I just done? yeah, I've killed myself ok, the kill command says 'send a singal' and -9 is the ultimate of signals - hint hint - terminate this thing with [something] it can't stop this signal if you send this signal to a process that process is gone there's no way to protect against this signal this is the big weight falling on top of a signal. this is how you can kill processes so if you know - if you are a superuser and you know a processes id, you can get rid of it OK, so fortunately I have another processes here. let's see if this one works unfortunately I can't actually write any code so it's time to reboot my machine okay, so! we can do something similar in our programs as well let's pull up some example code here alright, we won't do that straight away, ok, so here's some typical fork exec() code the child decides to run /bin/ls and the parent will do something else so, let's first of all just start off with this. there's nothing new in this code, I just want to prove to you that the child runs exec() here and should print something out here we go, so yeah we'll move on it. the child runs okay now, what we'll do this time is I'm going to make the child sleep for one second because now I'm going to call kill() from my program here. I think you can guess what's going to happen here alright so, we'll check kill() on section 2 and you'll see that we can send a signal to a process alright so, we have the id that we wanted to call, there it is, it's called child, and what should we send it? well let's send it signal 9 oh, we had a sleep there. so this time you'll see the poor child never got to run /bin/ls, we klled it and it didnt' stand a chance we could also send a signal called SIGINT, in fact, rather than send it to the child, why don't we send it to ourselves let's do it straight away I wonder what SIGINT stands for ok, so the SIG is a standard thing you'll see prepended toward the singal of different names INT stands for interrupt remember how you can press ctrl+c and the program stopped? this is how it works the shell says 'oh look, look, someones trying to press ctrl+c, I will send SIGINT to the running process' and that's how we break our processes well, this is where the fun begins. I don't have to see my processes die when you press ctrl+c we can do other things for the SIGINT and for that we're going to look at SIGACTION SIGACTION allows us to register a callback function that's going to be run when the signal is given to this process ok, so, here's how sigaction() works. I didn't want to use sigaction(), I was going to use the simpler version yeah, let's use signal()  we'll talk about sigaction() later on in the course ok, this is what I wanted to show you. so our typedef here. is that large enough for people? can I make it larger? can you read that at the back?
okay alright so, we've got a typedef that say typedef void (*sighandler_t)(int)" and then this sighandler underscore t. let's talk about this for a moment. as to how to parse this alright, so we know that typedef just really means hey! I'm an alias" I'm just defining a new type and in this case, this is a function pointer so, we can [something] this by unpacking it from the inside out. so, we can have a function that takes an integer and returns nothing and, our type goes in the middle (between the parenthesis) so have a pointer to a function. in other words, just, where do we want to send the CPU to actually execute some code? here's our little function that's gonna happen and then I can install this handler for a particular signal so should a certain signal happen, run this handler alright, so, let's do that I'm gonna have a signal handle then. and I can call it noway. I can call it anything I want, really. remember it takes a void. call it agentsmith alright, you'll see why in a moment. and remember it takes an int so, at this point, we'll write something out. like, you can't stop me!" okay, how many letters is that? who knows? about 13 and, we want this to run anytime someone tries to stop this program so, let's use that signal() thing so we'll say signal when I get a SIGINT, run agentsmith and, then i'll have a little loop that does a. keeps itself busy. while(1) loop forever so, while true, keep going alright so, let's run this little program here okay, off it goes, and let's try and press Ctrl-C oh no! alright, you can't stop agent smith here. anytime you press Ctrl-C, that signal is delivered and fortunately, you can press Ctrl-\ and that should okay, there we go, alright. I can at least Ctrl-Z it so I can actually stop the program. so something else to show gives me the ability to pause the program. and if I wish, I could actually put that into the background. does it support it? okay, yeah, it does and now its in the background and now it's just running and using up my CPU if I do ps", there it is. it's running. it's used up 32 seconds, now its used up 34 seconds of CPU, I'd better kill it. okay, kill minus 9 106 it's gone! remember, SIGINT you cannot stop. so you could try to. sorry, SIGKILL or SIGTERM you cannot stop SIGTERM alright let's go back right, so let's first see what it's going to do with child processes. here's the whole thing. let's change our message to say child finished" and this time, we will make our message a string here so char mesg I can get a signal when one of my children dies so strlen(mesg) okay, right, so, write out the number of bytes that's in that message so now, rather than doing SIGINT, guess what, there's something called SIGCHILD and let's make this a little larger and this time rather than looping forever, we'll do our fork() and now when the child is finished running ls, why did it, oh, aha! that's not gonna be very useful, okay. we'll get rid of the sleep() there as well so, this time, the child runs ls hopefully, oh, no. SIG, oh, I can't spell yes, for some reason, CHLD is spelled without the I I guess bytes were expensive in those days? okay, alright so, hooray! here's what we've got the child ran and then the parent was notified asynchronously that the child finished so if you wanted to do some stuff in the background and you're worried about zombies, this is the perfect place to put that waitpid to say hey! I need to clean up my children" so that's in fact a very common convention with these kinds of programs is, if you don't want to just fork() and then wait() immediately, just write yourself one of these signal handlers and then we can put our waitpid in here so, we'll need to know the child id, we have a status variable, and a zero here, okay the last thing I need to do here is that child itself [something] out of scope here. so instead, let me declare as a global variable now, global variables in large programs considered [something] programming practices. however, you will often see them in small, single-file system programming examples because it's an easy way to communicate with signal handlers alright so now, okay, well, you can imagine if I was actually able to type, you can see that we're being good citizens and we're cleaning up our children using a signal handler
right, so, let's go back and up. what've we got? alright, what is a signal? It's a software interrupt. it interrupts what the current process is doing how do they work? that's a good question. there isn't a quick explanation of that that's any good I suppose a short answer would be 'hey we'll cover more in later lectures' but a slightly more useful answer would be that the kernel delivers a signal to the process  and I've shown you two kinds of examples an example where a signal where we can register a handler for that signal and we can change the default process the default example of the SIGTERM where you cannot register a handler and instead the system will actually destroy your process. will actually quit your process right, how do I send signals programmatically? remember? OK, so it's not signal(). if you call signal() - it's not the right answer - if you call signal() this registers a handler instead what you need is to say kill() seems pretty mean, right. all of a sudden we're having a bad day when they designed these things my assumption is that the very first signal that was developed that was useful was the ability to kill other processes because they got out of control and then this interface was extended to include other signals like  'hey my children finished' or 'hey I've got some bytes that need some processing' so with kill we pass in the process identifer and then a signal name such as SIGINT or SIGTERM how do I send a user defined signal? easy! we can call kill and ister them sigusr1 and sigusr2  why should I use signal symbols not the constants? well because the actual constant value varies from operating system to operating system exception being the early signals that were defined way back in the history before I was born and the one that everybody knows is that nine is the same as SIGTERM, just kill a process so it's a common idiom to say 'hey kill -9' meaning this process cannot escape, we're going to stop it and finally what's the alarm signal? ok, this is fun. when I make a process we can set up a process so that it gets a signal in so many seconds. so it can say 'ok I won't have an alarm in 3 seconds' so now I can have a little program here for - let's do it the old fashion way of C for i is zero, i less than something, i plus plus printf %d, i and we'll sleep a bit OK, so, we've set an alarm and then we just start printing out the numbers to start counting this is the evilist alarm clock you've ever seen. it kills your process! um, most alarms don't do this yeah, the default behavior for the alarm system is to kill your process and, where does the word alarm clock come from? that is actually the shell saying I'm going to call waitpid() on the program and then I'm going to use those wait macros that you've seen to determine why my program finished or what happened to it. oh look my program finished because it got a signal alarm clock. and so the shell prints out something useful to alarm clock we of course could do something different form that. we could register a handler for this ok, so SIGALRM - if I could spell it correctly ok, and I'll call it thanks void thanks() takes an int and I'll write one Thanks!" and how many letters is that? I don't know, about six, right? so let's run this now and if it works then in three seconds we'll get thanks hooray! good and now you see our program continues and now I need to get out of it so that's the alarm signal you could use this for example to give a child so many seconds to complete if it doesn't complete you could deliver the alarm signal to it questions? ok, page two! <pause> alright, so we did this. we did this, right? we talked about how this is inside the process it's inside the C buffer for standard out because there's no new line so when you call fork we end up with two processes which now continue and they both have I'm a process sitting inside the buffer waiting to be flushed, waiting to be sent
right, now then, let's say I want to review some C code let's say that you're trying to write a function called your version of strdup and it's purpose it to take a pointer to a C string and create a new C string by allocating some memory say on the heap or yeah, let's say on the heap and so let's have a look at the following code, perhaps we can figure out what's wrong with this code so, here's the code so far, we call assert() on source then we write a line of code which is going to be a, b or c then we say 'ok character p equals result' and then we have this idiomatic C loop here by idiomatic I mean here's a comon way that you see C code written where we want to copy things written from one side to another what's it do? and then finally we'll return p so, here's what it'll do, here's where you come in. I've got three different versions and also do you notice any errors?  anything you want to change in this code? ok, and two other kinda questions down here alright, have a go with that for five minutes. see if you can answer those questions. what happens for a, b and c and those other two questions. question two, question three. I'll walk around in case anyone's got any questions ok, so, that assert() call at the beginning. the nice thing about assert() in production code it disappears, there's no performance overhead. it's not even evalutated the macro compiles to nothing, so the purpose of this is during debugging I want to catch early if someone gives me a bad pointer right, so if we say character result, then anytime we use the variable result in the future it will point to the beginning of the array  sounds great, we can use up to 256 bytes, in other words a string with 256 pics, 255 letters and a 0 byte at the end which fits however, this is an automatic variable stored on the stack, which means it's scope is only for the length of this function and, if we try to store anything in here, that's ok, but it becomes meaningless after the function returns so, yes, we can return a pointer to this array, but don't expect that memory to be valid after the function returns so, that's no good. we need memory that's going to exist for longer than that so we turn to malloc() to say 'hey give me some memory on the heap please'
right, okay uh, couple of problems here. one is, size of source so this tells me the size of a pointer so that's either going to be 4 bytes or 8 bytes oops. I didn't want that. I didn't want the size of a pointer. I wanted the actual number of characters stored at the pointer so, okay, let's fix this, oh yeah, that should be a pointer in there of course I want result to be a pointer to some memory. so let's call strlen on source hey! keep walking along until you find that zero byte. what's wrong with that code? yes, we're not going to reserve enough memory. so, in doing the copy, we will put that zero byte into some memory that we don't own that memory might be being used for something else so, we have a buffer overrun there alright, so, and then, the rest of this code walks through copying bytes and it might seem a little unusual to put an expression like this inside that while(), but this is kinda of a common example in C where we copy a course of bytes from source to the pointer, we increment both, and we keep going until we've copied the zero byte and when we've copied the zero byte, the result of this expression is zero, so the while loop terminates many compilers, by the way, would require us to put an extra set of parenthesis around this. otherwise, it would give us a warning you will also see similar code inside if() as well. where we assign a result to a variable and we also use it to [something] an if-expression alright, how are we doing on time, okay, we should keep going. so what's the purpose of 2? to check that the argument is non-null. when will it have no effect? well, when a macro is a defined so its when no debug happens to be defined...whoops, and you can set that as part of an option to gcc and if you do that, then assert compiles to nothing alright so if malloc returned null, where would our program crash? would it crash at line 4? if result was null, would this crash? no, it wouldn't. p would just simply hold the result of 4 we haven't tried to follow the money okay, so we've got an address (think of an envelope) and we haven't written a valid location on it, but we're not trying to read that memory we're just pointed something bad. we haven't actually followed the pointer yet so, it would actually crash when we try to dereference it. when we try to write memory in. so, its when we actually try to write to that location, our program would crash so how do we fix this? we could say well look, if the result is not valid, in other words, if it is 0, then maybe print out an error message and exit or perhaps return nothing" just say okay, I'm sorry, I could not duplicate this" and hopefully whoever calls this code is checking to see if the value is also NULL right. so. okay. did I ask a question for this one? right, what will this print? let's see if we write this out. so we've made an array of ten bytes and we, copy in 'ab'. so we've got the following: we've actually copied three bytes: we've got an a, a b, and a NULL byte or a zero byte at the end to mark the end of the string and then we make a new variable called p2 which is p1+1 okay, so what type is p1? it's a character pointer. so p2 is pointing at this memory location, where we copied the b into now we do strcpy into p2 and we copy 1 2 so we're going to copy 3 bytes we're going to copy the 1, the 2, and a NULL byte so when we try to print this out, we're going to print a12 and then stop because we get to the NULL byte alright, oh I've got a few minutes, we'll be okay. alright, what about the next one? is the following code valid? what have I got? so I've got a pointer a and it's going to point to xyz I'm not copying it so think about this for a moment. when you load your program in, and it starts running this process, at the bottom of the memory that we've got, we've got the code! and then we have our constants okay so a is pointing to some memory inside this constant. the stuff that we've loaded off disk. the xyz. those bytes. a is looking at that address in there and then we say I've got a pointer to a pointer to a character" in fact we read this backwards, so b is a pointer to a character pointer and it holds the address of a so b hold the address of a. it holds the memory location of a. so I could use that, I could use b to change what a is pointing to, and that's what we do here so, why didn't what b is pointing to uvw" ? so what have we done? we've changed a. so now a is pointing at a different location it's now looking at a different constant inside our memory so we didn't actually copy any strings. we're just changing pointers around right, we'll do this one. what's special about sizeof(char) ? it's defined to be 1. a character in C is always one byte yes, uh, oh yes yes, I'm sorry I forgot to, yes, there is one bug in here. which is, we should've returned result not p okay, last two things: printf puts putchar and all those other C macros end up calling write() on stdout which is 1 and the final question for today: what will the following code print? we malloc 128 bytes. if it failed, if it gave us NULL, we just exit so lets assume it didn't fail, and then we do puts what will it print? okay, so we can answer this and say here's the most likely thing it might do" it's the very first byte of this might be zero so, that's just an empty string so, all that's going to happen is that it'll try to print an empty string. what does puts do? it prints out the string followed by a new line so that's probably the most likely thing to happen however, does malloc zero bytes for us? no! that could be anything in those bytes. it could print I love [insert your worst football team in here]" whatever! it could print anything! it could print out more than 128 bytes it could print I am agent smith" arbitrarily, what is in those bytes. and with that, have a wonderful week! and I'll see you on wednesday!
alright, good morning class, how are you? oh! good! great! how's everyone else? okay....fine...ehhh...middle of the week blah blah okay so here we go. in blehh try again so, in the next fifty minutes here's what we're gonna do: we're gonna make sure you have a good understanding of fork exec wait, we're gonna look at a couple examples. we're gonna start about some common gotchas and a reminder that some interesting things are due for tomorrow's section! so, you might say well hold on a minute, this week's section makes me jump into the deep end with android and commit somehow to subversion. no explicit instructions. yeah, welcome to the real world or at least, welcome to a simulation of the real world as we kind of say goodbye to CS125 CS225 ecetera, we lose the training wheels a bit so yes, we will give you more explicit instructions in the future, don't panic quite so much. I just wanted to give you an experience of saying look, this is what its like" yeah! It's evil it's tough. instructions are never as clear as you'd like them to be and something strange happens. people start looking at you as if you were the expert in the room just because you know a little bit more about say the other people working just because you've taken the time to say read the man pages or do twice as many google searches or just figure out the best way to work it and yes, in setting up things like android, it doesn't work first time so now, you need to be a hacker in that sense. of saying, what can I change? what can I break, what can I unbreak? perhaps I should try a different device. perhaps I should try plugging it in again. perhaps I should try turning off and on again, right? perhaps I should learn about uh, trying to, I've got a problem say it doesn't connect to android well. is it my device driver? how have I not set thing up correctly? perhaps I should I reread the instructions to see if I missed a step these little basic skills a software engineer has to have so, one one key skill that I hope you get out of this week's setting up the section is tenacity damnite you can be more stubborn than it that you can figure out ways to try and break down the problem. maybe I should try someone else's tablet. maybe someone else should try my tablet. maybe I should umm, uhh, do an experiment to see if something at the low level of the USB is noticing if the tablet is connected that kind of thing. maybe I should check to see if it's using the right version of java. etcetera etcetera etcetera. try to take a problem and breaking it down and using your brain cells to try to make progress. I didn't say it was going to be easy, yeah, welcome to the real life. okay, well, welcome to real life right, so, enough! let's put that aside. the next thing you'll need for section is to make make" or as we fall it, fake", alright so, why? because make allows us to build larger programs and at the end of the day, guess what? it's just a C program it reads in a set of commands to execute...and executes them! except it tries to do it with some sophistication so rather than, for example, compiling all possible programs, why don't we compile the ones which have already recently been edited? or let's make it so that we can make a debug version and a release version or let's make it so that it works not just for C programs, but with python. you can even use make" by the way, to generate thumbnails of images so next time you change an image, you can automatically generate thumbnails I used it in the videos because when I exported each of the little 7 minute videos as an mp4 file, I wanted to have an old version, I wanted to have a webm version, the basic 3 formats of video on html 5 these days and so I used make". any time I made a new version of the, uh, I, anytime I exported a new mp4 file, I produced make to say "oh! look! this source file (my mp4) is newer than the targets (or the targets don't exist)" then I get make to run a transcoding program to generate the other versions so make is very powerful and you can also set it up to do things in parallel which is fantastic if you happen to have, say, 8 cores, or 200 cores you can make things go much faster alright so, let's turn our attention to some code here. we're playing with fork() and we've got it set up so that after fork returns, I'm going to get the parent and the child to do completely different things I put them into two different functions so, remember, after fork returns, so let's write our little fork here you've now got two processes, you're writing code for two separate processes, isn't that cool? they happen to share a common ancestry so all of their variables currently have the same values for example (apart from the return value of fork) so, now we make them kind of have different futures. different histories. okay so, that's the kind of first important thing, first importantly to remember is that you're writing code once, but it's going to go for multiple processes. it just so happens that we can use return value of fork() to do two different things. okay so, I checked so that the value is greater than 0 if it is, then I must be the parent if it's zero, then I must be the child so let's run to the code. there's actually one other case. fork() could fail. if it does, what's it return? negative one, yes so, we should print an error to say hey, fork failed" what's the easiest way to do that? just use perror() ! so print perror prints out whatever you said, followed by a colon, followed by a completely cryptic error message which is completely useless to users but hopefully gives you a little idea about at what point your program failed. so as you start to write more complicated programs, it becomes important to check for the return values. and in fact it's quite usual (just read the man page) to discover that it returns, say, zero, or more likely negative one if things fail so when writing more programs, when it doesn't work, say oh okay! when did it stop working?" maybe I should actually check return values and discover when it broke
ok, so that's the beginning of my program. I've made some gaps in here and so perhaps you and your neighbor could fill in the necessary code on this program and figure out what we should write for the child and the parent in the child process we want to ask for an alarm signal please so we can say alarm() one, which means in one second or so the operating system will deliver, will send a SIGALARM to that particular process and once the - what happens by default when you send a SIGALARM to a process? it kills it, right! that's a pretty evil alarm signal, yes? but that's what the default behavior does we could stop that if we wanted by registering a sig handler, but today we're not going to do that. instead we're merely going to sleep for two seconds after we sleep for two seconds we're going to print something out and then we want to exit normally how do I do that? i just say exit() and let's give a return value like 0 so my child process is pretty simple now the parent is going to wait for the child to finish how do we do that? we can call waitpid() pass in the process id of the child we'd like to collect some information so status and we don't need any flags today ok, so how do we decide if the child has exited normally or not? well let's do that one, so that one was - what WIFEXIT or EXITED, I'll have to look it up in amoment and now we need the exit status so let's find out what it said
ok, we can also discover if the child exited due to a signal, so let's do that as well so let's say 'look if WIFSIGNALED then let's find out what singal it was okay so how do I pull out that? I think it's WSIGTERM? -TERMSIG, ah. ok and we can print out a helpful message right because not everyone knows those numbers so what is the number for SIGALARM? it's just this constant here SIGALARM right, shall we run this? let's try it. see what errors we have here ok, what have I messed up. SIGALARM, argh, right, let's try that ok, where's the mistake? line two hooray! ok, so it prints 'Hello World', starts up and then the parent says 'child exited due to signal 14 alarm clock' let's make another program over here that - let's see, I'll tell you what I'll have a pointer there we go, and it can be a random number just cast that into an integer pointer and into p we will write the value 42 will it crash? who knows what it'll do ok, so this time we go 'child exited due to signal 11' what's signal 11? well ok it's not going to get you invited to any parties but it's turns out signal 11 happens to be segfault so, we could keep going with this and say 'look if the thing was' - I'll just write it - 11. I could spend some time - oops, seg fault - write a better a program!" so you see those messages like segmentation fault and an error that commonly comes up that says 'segfault write a better program' right, so, you see those messages like alarm clock, segmentation fault, that kind of stuff. they dont' just appear in the terminal by magic, no! the shell is doing what we're doing here and that's what your fake program is going to do as well. that after a command finishes use these macros to discover what happened to your child and print out the relevant information so, questions about that? alright, so, now you actually have enough knowledge to write not only make, but a shell and we're going to have an MP based on that where we can take just user input, what you type onto a keyboard and then start executing programs so the shell that we normally see is either bash or a simpler version called just sh, but it's just a C program that reads input and then calls exec() based on what you typed ok, other questions about this? alright then, let's have a look at some other questions on here so, when I start my program and I want to find out what arguments it was given. so for example, suppose someone did this how would I actually discover the first argument?  it would be in argv[1] so what would we expect to see in argv[0]? argc it's ./program and i'll make this the right size it's just the name of the actual program itself and let me show you actually how - yes? uh huh. yes. what? yes. so a segfault happens because for example your program tries to write into some memory location that it's not allowed to and this generates a hardware interrupt by the memory controller to say 'ahaha, you are trying to write into say a kernel address space or into a page of memory that doesn't exist. this doesn't look good to me' at that point the kernel says 'this process is not behaving well, I'm going to shut it down. you never get the CPU again' and so the process is pulled away form the CPU, it's not allowed to execute anymore of your assemlby, anymore of the satemetns and instead the kernel makes a note of the fact that this is a bad process. we killed it due to a segfault. yes? yes.  the alarm can go off during sleep all the sleep says is don't allow this process access to the CPU for about two seconds there are actually some possibilites where it might come back early or - there's no guarantee it will be exactly two seconds we're not playing here with perfect real time operating system. it's to the best it can do give whatever load the system's under
and we'll talk about scheduling later on in the course okay so, just a quick little bit a fun here let's have a look at /usr sorry, /usr/bin alright, whole load of programs but I want to show you something slightly surprising about these programs, umm they're actually, they're all fakes the programs like who which ls, etcetera, they're all just pointers. they all point to something called busy box" so, the busy box program is written so to support all these different commands and the first thing it does when it starts up is it says what am I running as?" am I running as ls? am I running as wc? or some other command? in which case execute different code and so you'll see this in this little example here. you'll see in router boxes. you'll see it in your android phone, because it's a way to include a lot of commands without requiring lots of large programs all tend to do kind of similar things so it's a way to save some memory alright, so that's one use of argv[0] alright, what's special about argv and argc? it's a NULL pointer! so, next time you want to scan through all of the arguments, either just use argc to find out how many are there, or just have a little loop that keeps incrementing through those pointers and when you get to NULL, you know you've got to the end so typically, if this is the array, you're gonna ignore the first one because that's not a real argument you know the first one is the actual arguments it was sent so in this case it would be kind of file.txt" and then we'll have some other arguments that the user might have supplied, and the last one will be NULL. won't point to anything so don't try to strcat that, for example, don't try to read from that location or you'll get a segfault okay, let's do page 2! so why do shells exist? could we have an operating system without a shell? yes we could. but it would be hard to type stuff in. right it would be hard to execute anything and it would be hard to call things because before you could call things on the operating system, you'd have to write a C code and compile that in order to call the system calls. but what I want to impress upon you is that all of the commands that we might call from our shell, are really just more C programs well, they don't have to be C, but for the system programming stuff, they tend to be and some of those can be, tend to be, very very small so for example, you might stat that we'll see later to find out something about a file let me go back to my home directory okay, stat program and this tells me some basic information about a particular file on disk. when it was last modified. who owns it. where it is. what kind of file it is. etcetera. but guess what. this little program just makes use of system calls and if I was to call, find out the manual of stat, uh, you discover that on section 2, there's a call called stat" where I can pass in the name and pass in a pointer to a buffer to get all that information out so that stat program, fundamentally just makes this call and then has a couple of printfs in order to format the information inside the buffer so, the shell exists in order for us to basically make, uhh, to be able to do things efficiently without having to continually create new programs so how would we get our shell to print segfault" or "alarm clock" ? easy! see page 1 hello let's flip back over we've just done it! alright, call waitpid, find out how the process finished, and then take an appropriate action like hey! your child process just quit due to a segfault" or just quit due to an alarm message or just died because uhh, you pressed Ctrl-C and we sent a SIGINT to a process you can do that. now, just using a fork and exec alright then, so, here is an attempt of implementing a shell it's called the lol cat's shell and but there's a couple things wrong with it perhaps you could figure out why this is not a good shell. how many errors can you see in this code? [long pause]
 alright, so this is an attempt to write a shell it's attempting to get the users input one line at a time and then call exec() based on what the user entered the first thing you might conclude is that you need to fire this programmer and get a better one but let's see if we do better that. let's see if we can actually identify a few specific mistakes here let's see, does it even run? ok, so no we at least need to semicolon there alright fine good so enter your command and I will exec it. ok, great we've got a shell lets try it! we'll try ls try cat ok, this is not a particularly useful shell yet how can we make it better? for starters let's print out an error message here saying exec() failed and see if we can figure out what's broken with this OK, ls. no such file or directory. what? well try /bin/ls. no such file - oops, come back now it's just sulking. it always prints no such file or directory what did we do wrong? OK, so here's a couple points from this. as you know the first argument should be the program name so let's change args[0] to point to the buffer what is args? it's an array of character pointers so we can change the entrance of that array. we're just changing the addresses held inside that array it's a very simple shell right now and it's just set up to be an array, a very simple array it's just set up to have two entries the first one initially points to a character string and then second one is null we want to change it to it at least points to the buffer. and we'll try this ok, right, ls no such file - ah - ok /bin/ls no such file or directory Darn <rand chars> still not working, but like what I said, part of being a systems programmer is to be tenacious your code is no longer the most complicated thing in the room and if you don't get things right it will bite you hopefully it will bite you sooner rather than later then we have a chance of fixing it maybe we should test our assumptions like what are we actually sending to execvp() for example let's actually have a look at the buffer alright, so let's run something we know exists look it's printing it out certainly we're sending it the right thing I'll even get rid of the fgets() whoops we've got an error. oh yeah I'm sorry it's an array so I have to strcpy() into the buffer and that worked what is our error? if you think you know tell our neighbor ok, so here's our mistake. fgets() yes does read everything from the user including the new line and if I was to put a new line into here we would see the same thing and exec is very simple, it's looking for a program called ls with a new line that's part of it's name so this would now fail so what we need to do now is get rid of that new line okay how can we do that  well let's find out how many characters that we got into our buffer we'll assume for now that fgets() worked it may not, for example if someone closed standard in on us it would return null so we should do that when we want to write better programs right, so let's find out the number of characters in now the buffer how does it do that? it needs to walk along until it finds the 0 byte so for example we know that buffer[len] is the null byte yes? so we actually want to go back one byte and write in 0 or \0 the null character will this work? let's try it 
/bin/ls hurray! finally we've got a basic shell that takes a single command we can't give it any arguments yet but we can execute it and woah hold on a moment, it stopped! what happened to my while loop? perhaps your neighbor knows why it didn't work? [silence] okay we have another problem as well, in our assignment in running about that while loop, we've just written code which is actually kind of dangerous we made a assumption that the newline is always going to be there is that true? so it could appear to be true if we're testing it but it could be that someone is sending us data from a file and fgets simply returns because there is nothing left to read so a safer program might check to see what we're actually replacing so for example, it only make sense to do this if len is at least zero and the buffer[len - 1] is what we expect, a new line character okay so we've now got a safer program, it still works, but our while loop never happens, why? yes thank you, our little process has had a mind wipe  its assembly language has disappeared, it's variables have disappeared basically everything we might have put inside the processes' memory is gone to be replaced by the code associated with our program ls so how do we make a shell? how do we make it so that it can execute more things fork exec, yes! so our plan is to do this in the child and in the parent we want to play our standard waitpid and then the exited stuff so that we can print out useful messages when our programs finish and that is the basis of the mp alright so we're well on our way to having a working shell in real shells, you can execute things in the background, how do we do this? don't call waitpid, just in your shell go around again go back to your line that reads input, either fgets or readline  and let that child process carry on how do we make it so that we can read from a file? well we've got two possible ways to do that you could use say fopen or if you want to go low level, you could use open and then when you call fgets you can pass in the file descriptor you get from fopen and you would read from that file descriptor there is another way as well, which is to close standard in so you would say hey close zero and then call open and pass in the right arguments to read from a file and we need to read the manpage of open to look at how we can open a file readonly for example and when we do that, future reads at the C level will be reading from this source file how about this? suppose I want to execute file.c inside a child but now I want to redirect the output of this command to a different file how would I do that? so how do, ah right, so I'm not going to try and change cat, this is just a command, I want my shell to do this part I want my shell so that the output goes to a different output okay and where would I do that? here's a suggestion: you could after the fork, inside the child code, the child could close one, use open and then call exec we saw an example of this in a previous lecture where we made our program send the output of ls I believe to a log file so all we've really done is taken that idea and put it inside the code that we're writing for the child process and we've put it inside the child because our parent is going to go around that loop and execute other commands and we don't want everything to end up inside that log file, inside say output.txt, we only want the child to execute that code
what's POSIX? does anyone know what it stands for? ok, so, a long time ago back in the '80s the standards committees of IEEE were trying to formalize a standard set of interfaces for an operating system or what operating systems should support and it went by an IEEE number which was hard to remember so at some point, i think it was Stormunds said why don't we call it the Portable Operating System Interface, or POSIX for short so POSIX is just a set of standards and what do those standards talk about? well they talk about system of interfaces to the actual operating system in others words what system calls can I make to control the operating system or request things from the operating sytem and also it's a set of utilites that you expect to exist so for example, there should be ls in order to list files or cd in order to change directory and also it describes what you can expect on the platform like I can expect to work with files,I can expect to work with the network so a POSIX operating system provides an abstraction of the low level hardware I don't need to worry about the exact way to communicate with a flash drive I can simply say 'oh look well let's assume theres a file system on here' and I want to be able to read or write files to this and the operating system provides a lot of support for those different pieces of hardware it also provides security. so what kind of security does an operating system give you? does it give you a warm blanket and a teddy bear at night? no so what do we mean by security? if you were to design an operating system today, right now, what security features would you have? make it memory safe, what do you mean by that? why? ok, so what you're saying is you don't trust his programs? I'm sorry, yeah it's a fact of life. what we want to try to do is provide some insulation between different user programs  so that a malfunctioning program I'm sure you write fantastic code most of the time, but let's say a malfunctioning user program cannot bring down the rest of the system ok, so how are we going to do that? well one thing you've already seen is memory protection and if I read up on operating systems give us virtual memory so each little process runs inside it's own padded shell sorry padded inside its own padded room it thinks it can read or write any possible memory address it can think of of course if it tries to do that it might crash and we might just kill the process by the first flush one process cannot actually access another process they live in completely different universes so they are living in dfiferent virtual memory spaces ok, what else? yes? file permissions yes, so I can make it so you can't delete my file or append to my file but I will let you read it or I can make it so that my file is unreadable by anybody that's not inside a certain group interrupts, what about interrupts? ok, interrupts - i'm going to talk about processes because I thought that's where you were going to go that you can't kill my process you can't just call kill -9 on my processs so you can only kill processes which you own unless you happen to be root or super user in which case you can kill any process you want on your system so, yes, security in terms of process control the last thing here is scheduling try to have some fairness which is an open ended and debated term, but imagine your process tries to take the CPU 100% of the time and never gives it up. just has a while loop if we were not careful no one else would have access to the CPU, it wouldn't get any work done so the last thing we'll say in the closing part of lecture is yes there is a quiz on friday and here's going to be our next topic - how do we allocate memory on the heap and I will talk about this in a future lecture on monday alright, great, see you friday, be ready for the quiz thank you very much, have a good section tomorrow
Okay, good morning class, how are you?  Fantastic, right!  So here's what we're going to start doing now, we're going to start talking about memory. You could imagine if we went back into the early, early hours of computing, we had it easy, right?  Well, there's proper instructions here, and we'll use location 100 to mean this and 112 to mean that, and we won't have to worry about dynamic memory allocation; we'll just make all those decisions upfront as we actually design the program. Then later, we say, Well actually, we want to have functions."  And later, we want to have functions that can call themselves and be able to recurse.  So, for that we need a stack. And for that, then, as we make function calls, our stack pointer needs to move.  And inside the stack we'll store our temporary variables and also our point where the CPU should go back to when it returns from the function. So our stack... we'll start a lot higher up in memory and as we make more recursive calls our stack will get larger and larger and larger and larger, of course - until we run out of memory.  And then we said, Well actually, we don't want to decide what memory we'll need upfront either, we want to be able to have dynamic memory allocation, and we don't know when we're going to free up that memory.  We don't know when we've finished with it.  We want to make that completely dynamic and it's part of our program. And thus, the idea of the heap was born. The idea that at any point, we can say, Oh!  I need more memory!  And give it to me now and this is how much I want and I'm not going to tell you when I'll be finished with it." So it's very different from the stack memory.  Stack memory: you know you'll be finished with that memory when you return from the function. So with stack memory, you've got automatic variables.  They automatically disappear - no more work... With the heap, of course, now we actually have to say, Okay, give me the memory" and "I'm finished with it." So you've used the heap of course in Java and in C++ when you said 'new' and 'delete' in C++.  Typically, they go on the heap memory. I say 'typically' because C++ can do some amazing optimizations when you're not looking the compiler will quickly say, Hey!  You didn't need to write that!" Here!  I'll optimize your code, so that actually there's no code written at all." When you write new/delete you explicitly create, well, we'll just simplify it and say Yes!"  We're making things on the heap.  So we need some memory, so let's call malloc(). So malloc() is part of the C-library.  It's part of your process.  It decides where your memory's going to be. If you like, it says, Oh look!  Table of four.  Right, I need  four seats.  You can sit over here.  This table over here is free.  You sit over here.  Oh, you've finished with that table?  Oh, great!  Get out of there because I'm going to reuse this table for something else." Alright, so malloc() has to very quickly decide where it can assign you some memory. Now, it gets harder because we don't know in which order our memory is going to be allocated, and in which order memory is going to be freed. And even if you knew that order, it's an NP hard problem to do it well. Called the Knapsack Problem. So even if you knew exactly which order the malloc()s and free()s were going to come in, how would you do it efficiently is a non-trivial problem. That sounds computationally expensive, right?  If we made our malloc() perfect, it's going to take a long time.  Yeah, I could put this table of two here, but you know what there's a big order coming in in a moment and so I don't actually want to put them there I want to put them over there."  There's an infinite number of possible ways that we could arrange things in memory. So malloc() has to be efficient but fast. So this is the basic game we have to play. *picture problems* Don't write this down, this is just a visual.  You don't need to copy this down. Here's how it works: let's suppose our process has some memory to play with. You promise me you're not writing this down?  Good. So my little blocks here indicate 1 kilobyte blocks. And during the execution of my program it says, Well, I'm gonna make a linked list or I'm gonna make an image, and I need some memory."  So part of your code says, "I need say 2 KB." So malloc() now has to look through the memory and say, I tell you what, I'll give you these two blocks here." If anyone else calls malloc() I promise not to return any pointers that point to this memory in here. So malloc() is going to return the address of the first few bytes and internally it has to do some book-keeping.  It has to make a note that these first 2 KB are being used. And then your program decides to malloc() some more memory.  So it says, Okay, I'll have 2KB now please."  What should malloc() do now? Well, it can't use this area of memory.  It has a choice: it could put it here and here.  It's not going to allocate here and here, though. Why not? Why does it not say, I'll give you some memory there and there"? Yes! Thank you, we've fragmented the memory, but also when malloc() returns a pointer, your assumption is that all the bytes you've been given are contiguous.  You might want to use it as just a simple array, for example. So we've got a problem here.  We have to allocate memory that is in the same area so let's say we put these little x's in here.  And then of course someone says, malloc(2 KB)".  What happens now? We can't! right? We don't have enough spare memory.
Now if this was a very small... two things could happen: our program could just crash - malloc() could just give a bad answer.  But we want to be a bit more systematic than that.  So at this point we'll go back to the operating system and say, Hey!  You know that memory stuff that's really valuable?  Give me some more, I need some more."  So actually malloc() at that point has to go back to the operating system and say, "Hey, you know that memory you gave me?  I've run out." I need some more. I'm addicted to the stuff, right? So, I need more memory.  So malloc() can get some more memory from the operating system. there we go. How does it do that?  Well, classically it would call something like sbrk(). What is sbrk()? You can write this bit down if you want to.  Let's jump into the rabbit hole for a moment and think about our process where we've got all these memory addresses to play with.   So what do we find inside memory?  We've got our code, we've got our global variables or the static variables... up here we've got the environment and the stack...where's our heap live? Just here.  It starts off just here. So it can grow, right?  We can say, Excuse me, system.  I actually need some more space."  And that's what sbrk() does. It says, Look, you've got this watermark (this threshold) of what the maximum address is.  I want to bump it up, I want to play with some more room." So this means we could write a really, really simple memory allocator.  Here it is. Any time the program asks for more memory (x bytes) all we will do is say to the system, Hey!  I need more bytes.  This is the number I need." And anytime the program decides it's finished with some bytes, what should we do? Nothing! That's the simplest memory allocator we could write. It's not a very good one, though.  We're not re-using any memory. Because we're not keeping track of which pieces of memory are actually being allocated.  We're just simply saying, Oh look!  I've got some more passengers on my boat, I need a bigger boat."  Or, "I've got more people on my bus, I need a bigger bus." And not keeping track of how many seats are actually unoccupied. So it's really, really fast but completely inefficient.  We're very quickly going to exhaust all of our memory. And so this sets the stage now for our memory allocator.  We actually need to start keeping track of which bytes are currently being used and which bytes are available for suitable calls to malloc(). So we only want to call this sbrk() thing when we truly are out of memory.  When we have no way to allocate any more memory.   So the MP (which will be out maybe the end of the week or maybe next week) is actually going to ask you to write an efficient malloc().  And it fact it's going to be a competition. So there'll be a page with results and you can see if your malloc() is faster than your neighbor's malloc(). So remember when they step away from the keyboard to put a sleep() call into their code. Okay, so what's to stop you from doing this all the time?  Easy: the competition is actually going to put a hard limit on the amount of memory that you are allowed to play with. So now we have to start coping with the fact that memory's being freed. So if we are working with writing a good malloc(), let me show you a little problem that we might run into. Here's some memory that's been allocated.  Here's some other memory that's been allocated at different times.  And then our program says, You know what?  I'd like 2 KB." Now you can see from my little diagram that I've actually got 3 KB of memory which are unused. But I cannot give you 2 KB.  I cannot find any space which is 2 KB because my spare space has all been fragmented.  It's no longer in a contiguous block. So why can't I just take all the contents of this memory and just move it into there, and then carry on? Why can't I just move that? Why can't my malloc() just start shuffling stuff around? Yes, thank you! Yeah, I can copy stuff!  My malloc() can copy it to there.  However, the rest of my process is using pointers.  It assumes that the stuff that's inside here is where it is so it assumes that if I've got a variable that's pointing to a linked list that it's using this area.   So all those pointers will be invalid.
So malloc() by itself cannot do that. Java does a little trick here, by the way.  What Java does is its pointers are actually pointers to pointers. So remember when you had a pointer to something, like an object pointer?  And next time someone says, But there are no pointers in Java!"  And then you say to them, "Well why does Java have a 'null pointer exception?" So how does this work internally? This pointer points to a pointer which points to the actual memory that Java's using. Why does Java do that?  So that it can shuffle things around.  So that it can deal with this fragmentation problem. So here's what we're trying to solve here is fragmentation. And the reason I mentioned this thing about Java is because when you are using the JNI, on the Android NDK, you are going to discover that you have to pin and release things. As part of your C code.  And what you're doing is you're saying (to this intermediate pointer), Oh no no no, I've got a bunch of C code right now that is using this data, so you can't start moving these things around.  You can't shuffle this block of memory around right now because my C code is using it." So Java uses a counting mechanism to note that C code is currently using these pointers and can't shuffle the memory contents. You'll discover this stuff when you start working on the Android NDK challenge. Right, so, our game then is to try to avoid this fragmentation. This fragmentation's bad, right?  Now we have memory that we can't use for large allocations. Our game is also to do this efficiently. So, here's where we're gonna look at three little problems. So this is actually an exam question.  It's one of the easier exam questions.  And what we're gonna do is forget for a moment this whole stuff about sbrk() and going back to the system to get more memory. We'll just say that we've got a heap initially of 13 KB. And we've got an order of calls. So as new calls come in, we can decide where to put them.  And here's three different placement strategies. Best fit, worst fit, and first fit. And we'll see as we do this that they lead to different assignments, that our malloc() will decide to place these requests in different parts of memory and so we'll have different fragmentation so that if our program continued, we might discover that future large allocations are impossible. ok, so what do we need to know about this? First of all, if you've got a choice, you choose the earliest segment. Okay, so what that might mean is let's say with best fit, let's say I've got space here of 2 (which happens to be a perfect fit; in other words, I'm trying to find space for 2 K, then I would just choose the one with a smaller memory address. Worst fit.  Oh, how contrary can you be?  The idea here is that if I've got a space which gives me the maximum amount of space after I've done the allocation, I'll use that. Okay, so let's have a look at worst fit, where I've got a 2K space here and a 10K space there and I'm trying to allocate 2 KB. Worst fit would not put it in this spot here, it would break apart this 10 KB space and say, I'll tell you what: here's how we'll change.  I'll allocate my 2 KB there, giving me a remaining space of 8." What do you think first fit does? Pretty obvious, right, from it's name.  We're simply going to walk along our free spaces until we find the one which is sufficiently large, and use that. So, if I'm looking for 2K, oh look!  There it is, I'll use that one.  If I'm looking for 3K, oh, it's not gonna work for me, I'll have to keep searching. Okay? So they're very obvious placement strategies (from their names).  Now, it's up to you to actually run them. So here's the actual order of calls to malloc() and free().  Where do the allocations end up?
There was a question about best fit.  Best fit will scan through, looking at all the possible holes.  Obviously we can ignore all the holes (or spaces) which are too small. And it will use the space which is at least as large as the request, but hopefully no larger.  And if it so happens that there's two spaces that satisfy that search, then we use the one lowest in memory. So, question? You would split it at the beginning. Right so, anytime you've got a space, you do the allocation at the beginning of the space. *nothing happens here* *again nothing, class discussion, Angrave filling out sheet* Okay, so.  Let's have a look at this.  So first fit: I've gotten as far as filling out A, B, and C and now I've called free() on B, and now I need to allocate another 3 KB.  Where could we put it? Well, we've got space here and we've got space at the end.  And we're trying to do best fit.  So best fit is going to put it in here because it's a perfect fit.  If I put it starting at 3K, I would've had a space of one left over, so that's not quite as good. And then we free A, and we allocate one KB.  Where could we put this?  Well, there's only one place.  There's one big giant space over here. So we'll put E there. What happens in worst fit? Nothing changes at the beginning here.  C, C, C.  Okay, so.  Now we free() B. And we allocate 3 KB. So: where's our choice? We could stick it here, or we could stick it at the end.  Which one is worst fit gonna use? B, yes! Because we have the largest space if we allocate it there. So let's put our D in here. And now we free() A. And we want to allocate one byte.  So what are our choices?  We've got a space of 3, space of 1, and space of 3.  Where's worst fit gonna put our final allocation? Yeah, it's a tie-up between the first few blocks here and the last few, so we'll put it just here. Okay, and first fit Okay, let's do this quick.  Right, so, we'll do the D.  3KB.  First fit is the Scrappy-Doo of fits.  As soon as we find enough space, we'll stop.  And we've just cleared out our space of four so yes, we can put D in here. And now we'd free A, and finally we allocate 1 KB.  So we run along our spaces - oh, look!  Here's our free one.  And we'll stick E in here. I'm sorry, yes, you're right.  We'll stick it just there. Okay, so this was a pretty trivial exercise.  But what I wanted to show you is the mechanics of these programs, and that they also lead to spaces in different places.  Also, there's a little thing that we did quite easily but you'll have to remember to do in code, which is: look at this, we had A and B, and at some point we freed up two allocations next to each other.  And so we had to go from thinking that this is a space of two and a space of four into think that this is just one big space of 6.  And if we didn't do that, then if somebody asked for a malloc() of 6, then your algorithm would say, I'm sorry, I don't have space to allocate 6B because counting will keep this as a space of 2 and a space of 4." We could coalesce those two free areas together into a single block, and so that is a common gotcha when implementing malloc(). That you have to look at the space beforehand and the space afterwards to see if you can coalesce them.
Right, um.. No need to need to remember that until you actually write your own allocator Okay, so let's just think about some of the comparisons of these then So what we'll do first here: what's one of the advantages of first fit? It's fast! As soon as it finds some space, hey we're done! We don't need to do any more Okay, what's one of the advantages, say of best fit? Or any disadvantages? Yes? Okay, so, think it's least amount of fragmentation Because it's ideal! Okay, so that is uh, do we know that for sure? It appears to be from this example, right? But is it true? In all possible uses? What about disadvantages? It's slower than what? first fit Because we have to check all spaces Okay, let's do worst fit and I'll come back to this one Right, what about worst fit? Yes, it's slower than first fit again because now we have to go through Any advantages to it? Any other disadvantages to it? Let's think about what we're doing for a moment. So worst fit is always going to find the largest space and use that So that means in a longer-running program, if you've got a giant space, it's going to quickly be eaten up So with worst fit, what you find is that you end up with lots of kind of medium-sized spaces Yes? Uh yeah, we can always go back to the system and say, Hey, system, I need some more memory" But what we're trying to do is see what our fragmentation looks like given the space we've got Okay? so, because we keep attacking the largest space, means that we don't have one large area should a giant allocation request come in Alright, now we've got these medium-sized holes, these medium-sized spaces, scattered all over our memory space So we cannot satisfy very large requests Yes? But we keep attacking that large block, right? It's um I'm trying to think of a good analogy, but uhh You always can say, Oh look, I've got this really really big block at the end, I'll keep using that" Now what we haven't talked about is think about the fact that our memory gets freed up as well, okay? So, this large block keeps getting attacked, and we end up with smaller, medium-sized blocks scattered through our memory if we run this process for long enough We're always attacking the largest space, we're always kind of nibbling bits off it So best fit seems to be, Hey, we're not going to get much fragmentation, we're always trying to find the perfect jigsaw puzzle" The problem with, yeah? Yeah, yeah there are some interesting caching issues, yes Okay, okay, okay, so the question's about, hold on, we've got virtual space, with virtual memory you can actually do some interesting mapping to real memory" Yes, that is true However, that mapping happens at four kilobyte chunks Um, so, we can't completely get away from our fragmentation issue So, yes, underneath this for the real memory, we can avoid some fragmentation Given that malloc actually has some space, you know it's got a low address and a high address, our question is how can we efficiently use this memory? Right, so, I want to address this least fragmentation thing It appears to be ideal. It can be, if you set up your simulation correctly, but when you, uh, run it under more realistic conditions, what tends to happen is you end up with lots and lots of tiny, tiny, tiny little holes. Or tiny pieces of spaces. So you could imagine that you've got, say, a request comes in four 15 kilobytes and you happen to have a 16 kilobyte space free, so you'll use that Now you end up with this tiny 1 kilobyte unused space So, in practice, best fit tends to give you these tiny, tiny spaces which are difficult to reuse So, quite often, some variant of first fit actually turns out to be a pretty good choice What first fit tends to do is the size of the holes tends to vary as you walk further down your list of free spaces So, this is actually often a pretty good choice Okay, so that was placement strategies Let's talk about a few other things with memory So we talked about where it's stored in memory It's stored just above the code and the global variables And we can call sbrk to say, oh we need some more space" So what then are the challenges of actually writing a good malloc? How are we going to keep track of which parts of our memory have been allocated and which parts are free? What would you use? If I said to you right now, Okay, start writing a malloc", how would you keep track of Say again? An array of what? Okay A disjoint set of regions in memory, okay Okay, so here's what I'm going to ask you to start with is just a simple linked list We can start with just a linked list of what's been allocated And what's been freed
So if we go back to our picture that we were drawing To say 'Oh, look, this has been allocated, this has been freed, this has been allocated, this has been freed.' What we need is a way to say, 'Okay these are just entries inside a linked list.' And I can walk along these looking for blocks which are, say, large enough.  And then when I find a block (let's say I'm going to use this one), I need to update my data structure so that I've now got an entry to say 'Hey, this part has now been allocated, and' 'I've got some remaining space.' And we go back.  So we can choose to take a block out and turn it into some space and some remaining free space.' Which of course if that's zero, you don't need to have this entry. When you call free someone's going to give you a pointer to one of these used areas.   And we have to go through our linked list then to update our counting - to say, 'Okay let's turn this now into some free area.' Remember how I gave a little advert about coalescing blocks?  Well, our work may not be done because you can imagine that, over here, I've got a free block, and on this side I've got a free block. So I now need to update my counting on my linked list to say 'You know what this is now just one giant block if I've got it on both sides, a huge block of free space that can be reused.' We could do this really, really inefficiently by having a linked list and then when someone says, 'Oooooh!  Free a pointer.' I'll just walk through my linked list until I find my entry that corresponds to that pointer.  Oh my gosh, that'd be really slow.  Okay, I'll tell you what, I'll use a hash to speed it up.  I'll have a quick hash so that I can find my pointer and go back to my pointing structure and update my linked list structure correctly.' When actually we can do a lot better than that. We can store our linked list structure as part of the memory that we allocate. Here's a clever trick. Let's allocate some memory and we'll allocate a little bit too much. So if the user says, 'Hey, malloc() 100 bytes we're going to malloc() say 120.' And we won't tell them, okay?  As far as the caller is concerned, they're just getting 100 bytes.' But the reason we did this is because we're going to store some secret information back here that's actually our linked list information (our pointer to where to go next). Wheeeee! When we return, don't return the pointer to the beginning of here.  No, make sure you bump up the return value so that the return value from your malloc() actually says, 'Okay, user program: here's a little space, here's the 100 bytes that you wanted.'  So we'll add our twenty bytes or however large you made it. And when the user later says, 'Okay!  I'm done with my pointer.'  When they call free(), we have to play the other trick and go the other way and say, 'Okay now where did that block REALLY start?'  Let's subtract our 20 bytes again. And if we do that, we can find our pointer.  Our linked list structure. So we're hiding the link information inside the allocation.  Pretty sneaky, huh? It gets even sneakier than this. We're going to do two more little things to make it really, really sneaky. First of all, we'll discover that we actually need to be able to go the other way.  If we start with a block over here, I actually want to be able to kind of have a doubly linked list.  I want to be able to go back to the previous block. So not only do I want to store the pointer to the next, I want to store the pointer to the previous.  So I'm going to put that over here. And I'm also going to actually store this information at the end as well.. So that if I come over here, I can always look at the previous block and say, 'Okay, where are you?  Where's your start?' The other thing that we can make use of is rather than storing actual addresses (pointers), we can just store numbers.  We can store the number of bytes and then use pointer arithmetic.  If you know that this is 120 bytes long, and we're looking at the beginning here, then we can just add 120.  We can just store 120 as the size of this thing. And we can jump to the next entry. Or if we look back here to the previous value, then actually we're looking back at the previous block.  And if this makes a note of how big it is, like this one's 200, then we know that we can jump back 200 bytes.
This sounds really easy when I'm presenting it in lecture. Writing malloc is a rite of passage Meaning that you too can have gray hair and fuzzled eyes and look just like me...no What I mean is that it's tricky because now we have to start dealing with pointer arithmatic Now we have to start dealing with multiple pointers A little error like writing pa instead of pb or adding instead of subtracting can bite you big time And worse it won't bite you in an obvious way For example suppose that you didn't actually add enough bites You didn't add 20. You added a smaller number. Then the user program just overwrites your pointer values, KABOOM! Of course it crashes Later when someone calls free and you try to read these values and these values are just garbage Like what happened to my values! Why aren't my values correct? The only thing that can bite you is... sizeof So remember if you've got a struct for example That you've set up to hold these values Or an array The sizeof an object or struct is very different from the sizeof a pointer to something Or sizeof a pointer to an array is different from the sizeof an array So one little character here can really really bite you So my advice is to get started early when we put this out and to program slower than you've ever programmed before Make each line a work of art that you would trust your life to It still won't work, but at least you've tried really really hard Yes Question sizeof doesn't work like that sizeof is a compiler thing that runs at compile time so it uses the type ok so sizeof says oh look I'm looking at a pointer" Pointers on my machine are 4 bytes or 8 bytes Ok it does not do anything at run time Alright how are we doing for time Ok We will finish with something really really easy. calloc and realloc calloc and realloc easy after you've done malloc These are easy. You can implement them in terms of malloc and free So realloc says guess what...I need some more space" Here's a pointer that I previously got from my malloc call or calloc call Basically a heap pointer, a pointer to some memory. And here's how much memory I need now on the... I've decided that my array needs to be larger Realloc will do that for you But be careful, here's how realloc is supposed to work It says look, I'll try to find some bigger space. If you're asking for more space, then if necessary I will copy everything across and return a pointer back to you If it fails however, it returns NULL So be careful when using realloc. Always check it's return value. Because it may have decided to shuffle things around for you. I couldn't extend this. I have something else using the memory just next to you. So I had to allocate a new block. But you can implement realloc directly just using malloc and free Calloc Calloc is very similar to malloc What calloc does is it zeroes memory So it's a bit slower than malloc Also you give it 2 parameters You say this is my element size and this is the number of elements And so the amount of memory it's going to allocate is size times number Why somebody thought calloc needed two arguments, I have no idea They should have just made it with just a single argument The first thing it does just multiply these two numbers together, that's it Except it has to do it the hard way because you could get integer overflow But anyway, calloc is essentially malloc plus it zeroes the memory Fastest way to zero memory is to use memset And we are out of time. Yes! And with that it's 11:50. Have a wonderful week. I will be going down to the lab now. After I've answered questions incase people want to help setup the android ndk
morning cs 241. how are you this morning great. okay. so here's what we're going to do today. we are going to talk about memory allocation we're going to look at some code that some ta's wrote last semester and then we're going to jump into a new topic called threads and this is where we can actually get more than one CPU to work on our process at a time let's start with this. let's have a look at this code that the TA's wrote they actually wrote a version of malloc() and free() i want to show you that it is possible to write some code that works and we'll see how it goes first we'll define a struct and we use typedef because we're lazy and we don't want to have to keep writing struct everytime we refer to this memory object and so in the future we can just say metadata_entry_t, that's just a shorthand typedef is just saying here's an alias and this is what we're going to have inside our little struct. we have a ptr that we'll be using for the user memory we want to know how many bytes to use we want to know are we talking about memory that's currently in use by the program or is it free. is it available for a future malloc() and finally here is what we're using a linked list so we can walk through these things so this is going to be our metadata, our information about what memory our malloc() has actually created or freed and so this will be the beginning of our linkedlist ok, so now let's have a look at the malloc() implementation we want to know how many bytes do they want. so we're going to look through our linkedlist and look for the appropriate block that we can reuse let's walk through our list and we can obviously we only care about entries which are free. we don't want to use a block that is currently in use that's currently been allocated for some purpose but i've missed out some code here so it's going to be your job to figure out what code is here also what placement strategy is this using. remember we talked about different strategies in the last lecture which one is this using and how do we change the code to implement a different placement strategy so you choose a different one and then figure out how to alter it and then there's more code down here. so what's this second half of the code do so that's going to be our challenge for the next 5 minutes: what's the missing code change the strategy that this is using and what does the rest of the code do. why is it doing what it's doing? and you may also want to have a look at the free() and i'll walk around and answer any quesitons  on this or this week's assignment silence
silence so here's how this works we're calling malloc() and we're going to look through all the previous allocations that we've ever made and we're going to see if any of those allocations we've made are free so we want to check if they're free and we want to make sure that the block of memory is of sufficient sie so let's check into our entry that size is at least equal to the requested size if it is, then maybe we can use that use that block. now we could at this point say hey great i've found a block but instead we're going to change our chosen pointer if the following is true either we haven't chosen anything yet or the size of the allocation we're looking at is even smaller then the previous block we've found in other words what kind of placement strategy are we using best fit! yes, this is best fit if i was using a tinder analogy, this would be like a best match you go through all the matches okay yeah of course sometimes you don't want to take that long and we could do a first fit: oh, yeah, that'll do so at that point we could say break out of this loop as soon as chosen is non-null so we could change our code somehow so for example if i were to put break in here then i can break out of the loop or i could have changed the conditions of the while loop to say while chosen is non null but yeah this is best fit and we go around and look at those allocations until we've actually exhausted all of them so it could be that we've found some space some previously allocated space that is not being used and in which case life is easy so if chosen is free then all we need to do is update that entry to say actually it's no longer free its being used and we can immediately return and we'll tell the user code to use the memory found at that pointer so that was the easy case let's take a break for a moment and now let's look at how free works because later on when the C code is finished with the memory, it's going to have to do the same trick again once with the meta data, so here we are going to that linked list eventually we find the entry that the user was using and we can mark it as available this works but its not very efficient. you can see that as we have more allocations in our linked list this code is going to get slower and slower our free is order n so this is not a very good implementation. which is why you get it for free maybe we can do better than this. rather than having a separate linked list maybe we can actually come up with a better solution. but anyway, now let's go back to our malloc now let's actually see what this code does. if we weren't successful in finding in any memory instead we call this sbrk() thing we say okay if chosen equals sbrk then sbrk and we pass in the size of the struct whenever you use sizeof() stop and pause and think come back come back, are you actually pausing in the right thing to sizeof() sizeof() works at compile time. the compiler uses the type that you give it the sizeof a struct is not the same thing as the size of the pointer to a struct and it's a common error to pass in the wrong thing sizeof() an array is not the same thing as an entry of that array
alright so here's what these two lines do they're basically saying hey operating system, I need some extra bytes heres how many talking to your operating system is very slow thats gonna take several microseconds to complete and then we're gonna say here, chosen im going to set this pointer to be sbrk and then call sbrk on size guess what that does. that also says to the operating system i need now size bytes they're actually calling sbrk 4 times to say alright give me some byte not only for the struct but give me some bytes in order for to satisfy the users request and what we're doing with the asterisk each time is raising the rule to mar raising the threshold for where our heap finishes so now we're gotten set up our little struct we'll set it's size we'll set that it's free and we'll set the next pointer to equal to metadata and we change the metadata chosen to the pointer so what we've done here is insert our new entry into the beginning of the linked list so the next time we call free or malloc we're gonna see this newly created entry inside our linked list and then finally we say back to the user here's the memory of size bytes that you needed questions about this code? yes? if chosen is bigger than the amount of space that you need yes so what this code does not do is do anything without spare space it's got a very simple view of the world its view of the world is yeah i've got a block here that was previously allocated, a block here, some memory here and if you want to say to this much memory then it's obviously not going to give you that one and it would give you say this block and you'd say well what about this space back here can we use that should we add another entry because maybe in the moment someone will malloc and attempt to make a smaller space ah too bad okay so we've got some fragmentation inside each of these allocations if we dont have a perfect fit yes? ah right okay so before this line we've got metadata pointing to our first entry yes this is my little struct now which then has a next pointer which points to another one which has a next one which points to another one and so on and so on and so on so what we do is  we set up our new struct so its next pointer  points to the old beginning of the linked list alright so when you see equals just remember your copying bit patterns you're just changing one pointer to look at the same thing as another pointer and then the next line is meaningful we've changed that variable metadata to look to our new brand link any other questions alright then so okay yes get your spectacles on i did this too small today and it was tiny when can a system use COW moooo that's a moot point no COW cow stands for copy on write here's the idea you and I can share a resource providing neither of us actually tries to change it and we can do that very quickly well the day that one of that you and i actualy need to write to that resource, that's when we're asked to duplicated it we'll do it very quickly before the other person notices so you can defer the actual copying process, the duplication process, until a change or modification happens ah this is a common idea for performance because quite often it turns out that we don't actually need to write to something or modify something so if you can detect when something is about to change maybe you're writing an alloc class or youre the operating system we dont actually need to initialize stuff or copy stuff until it actually is required and so a little brain teaser i have to today is how can we improve calloc performace here so COW is just copy on write so its a way to have shared data structures until something mutable happens until a change happens, and that way, we can use our resources efficiently right lets just see what you remember from previous lectures what's realloc it's when you change your mind you say, oh okay remember those bytes i malloc, actually i decided i need more bytes so we can use realloc when i say i'm creating an array and i keep going around a loop and i decide to say remember that array i made turns out it's not large enough okay so realloc works but there's a big caveat as you've just seen how malloc actually places things it could be that we can't keep the user data inside the same memory address anymore so when you call realloc be prepared to update your pointers with the return result of realloc so if i've got an array that i previously created say from realloc or malloc or calloc then don't just say you know what im gonna make it larger i'm gonna make it say 100x 100 entries larger infact, let me just change this code a little bit let's say that  you called calloc and i've got like a size of thing something and i've got like 50 entries here and then you say you know what actually 50 wasn't enough im going to double my space i've just managed to write two errors in 2 lines actually both of those were in the second line
so here's two gotchas the first is that my variable, array i didnt build it to update and so it could be that during testing everything is fine but later one it turns out that im trying to change the size of realloc and actually had to move my array to different memory and i didnt update it so make sure you use a return value this second error is awful and im going to tell you know its because life is short and please please never make this error unless youre trying to confuse someone else this is a fantastic gotcha does that code really allocate enough things for 100 entries no it allocates 100 bytes what we forgot to do was multiply it by the sizeof() our entries so don't just plug in N here or number of items remember that calloc realloc and malloc work with bytes and we didnt allocate enough bytes which means later on when we start putting things in our array we're going to go past the end of the array and exciting things can happen called segfaults and data corruption so start and pause whenever you see realloc are you actually passing the right number of bytes and when you see sizeof() are you calculating the size of the right type okay thankfully now no one in this room is ever going to mkae that error again we'll just let university of whatever make those errors okay so what do remember about calloc? what does calloc do okay it takes two arguments and it multiplies them together to determine the number of bytes what else? how is it different from malloc? it clears the memory yes calloc now only gives you back a pointer to some memory it zeros out all that memory as well for you so we go back to java arrays we said hey i need a new integer array a great way to implement that would be to use calloc so of course then calloc is much slower we actually have to write to all those memory locations and you remember talking to memory is really slow especially when you need to talk to lots of it so the reason that we dont necessarily always call calloc is because sometimes we know that our program is going to write into every memory location we don't even need to waste time zeroing it out first so it zeros the bytes so you can write a loop to do this but ill give you a little hint if youre ever writing a calloc and you want it to be performant then remember when you do the operating system and say hey i need some new bytes i guarantee you those bytes will be zero because the kernel the operating system does not want to give you some memory that is being used by a different process maybe its got a password in it maybe its got a secret key in it maybe its got stuff that you shouldnt have access to so for security you will get bytes which are zero so if you know that you're getting new bytes you can reliably you dont actually have to zero those out but only if you know that youre getting them fresh from the operating system youre not just using memory thats already part of your process boundary tags we haven't talked about much but we have talked about indirectly the last lecture i gave you an idea about whenever we did an allocation we could actually store the size of our allocated area at the beginning and the end of each part so rather than having a separate struct like we saw at the beginning of this lecture we could actually hide inside here how many bytes this is so this say is 16 bytes put 16 here this is 20 so if we do these tags at the beginning and end then when we come to do something like a free i know that because these are like train couches becuase theyre next door to each other if i just go backwards enough bytes i can actually read how big the previous allocation was and that allows me to manipulate these values and to maintain a list what's been allocated as part of this train as part of these tags which are next to each other alright so when actually return from malloc we wouldn't return the beginning of the carriage if you like, no we look a few bytes in and say okay here's that area for you to play with you can put whatever data you want inside this bit here because you asked for 8 bytes in the middle but becuase the users code was broken it kept going say someone didn't actually request enough bytes so as a result of that the user code just destroyed our metainformation inside here in fact it could've kept going as well things might seem to work until the day the code calls free becuase now you're free implementation assumes that it can read these values correctly but as we've just seen the values here are gone they've been replaced by whatever the user code happened to write in there or the rest of the program actually did so now you linked list manipulation and your calculations ha ha ha might be updating arbitrary pieces of memory and you're adding whatever the values were in here heres an example where a buffer overflow could make your perfectly reasonable code do bad things now it could make it say write arbitrary values into arbitrary different locations which is why buffer overflows are so dangerous of course most likely whats going to happen is when you call free your program crashes so when your program crashes during free its probably because something bad happened earlier to the heap so how can we stop that? what can we do? lets say youve inherited a program where it just crashes strangely on free how could you try to figure out what's going on?
OK. So, programmers took inspiration from miners. When you go down in the mine you take a canary, yes? The nice thing about canaries is they die before you, if there's poison gasses. Or at least then they stop singing as all is well. So here's what we can do. We can actually put some values into our heap barrier. And then we just check that those values are still correct. like there special hexidecimal values, like deadbeef, deadcode, or a value that is a quick hash of the values we want to store. So we can at least verify that things haven't been overwritten. So debug versions of malloc and free will do this. They'll take some extra space to write begging and endpoints. And then before they do anything, they'll check those values to see if they've been overwritten. So we can't stop the override, but we can at least detect it afterwards. Any questions? By the way this idea of putting the size inside as part of the allocated area, this was developed by, I think, Donald Knuth, many years ago. We've been living inside the user process. Now let's step back a moment and talk about virtual memory. What do we mean by virtual memory? We've virtualized memory. Ok, what do we mean by that? We mean that the addresses that our processes uses can have very little connection with the actual addresses that the RAM sees. That, in essence, there's a mapping. So ya, we can keep talking about the process address space. It goes from zero up to some high number, let's say 7fffffff. And we can think of it in terms of little blocks. And in fact, our virtual memory likes to work with pages called, and there typically about 4096 bytes, or 4k So, anytime you read or write into your virtual memory, we've got to take that address. Some magic happens. And say ok, which piece of RAM, which physical address, should I read or write to? This side will have virtual memory, and and this side we have real addresses. And it's the MMU, the Memory Management Unit, that has to convert one to the other. Now today we're just doing the quick two minute version, because there's a lot more to say about this I just want to give you an idea we can actually step outside the matrix. Once we start playing these tricks, there's some amazing things we can do with this, as system programmers. This is a fundamental piece of any reasonable hardware that runs a modern operating system will have a memory management unit, in order to convert virtual memories into physical addresses. And here's the cool thing is that now these don't need to be contiguous. That this mapping can be all over the place. So this 4K can go to some lower memory and this 4K can go to some other piece of RAM. So this allows us to use our physical memory much more efficiently. We don't have to worry about fragmentation, now, and having holes or having spaces inside our physical memory that we can't use. [So if it's stored on the hard drive...] Ah yes, I wasn't going to mention that but ya. Here's the cool thing is that now we can now say to every process, Hey! you want 4GB? No problem!" You want 4GB? No problem! You want 16GB? No problem!" Ok my machine only has 1GB but don't tell them. Because what we can do is, ya, we can actually secretly store some of the information they want on the hard drive. It's basically like this, imagine only the bits of the world your currently looking at exist. Any time you turn around and look behind you, I'm going to put you on pause and quickly recreate everything that you intended to look at. When I finish doing that, I'll release you again. So that's what the virtual memory, that's what the operating system does for you. You think you got 4GB of space. I just promised you that. Promises are easy because I know you can't actually look at it all at the same time. I'm going to intercept any time you try to read or write memory to make sure that what you're trying to read or write actually appears to be there inside RAM. But it's all conjuring. It's all fake. And it's up to the operating system to do this for your process and any other process that's currently running. Right, that's enough of virtual memory today. But it's a wonderful system. It's one of the best parts of an operating system today, I believe. Instead, let's talk about something which is just as powerful and is going to separate your programs from mere novice programmers. And that is being able to use threads effectively. This is the beginnings of the major part of this course here, is to understand how to work with synchronization and work with multiple threads.  This is the coolest bit so here we go. Let's put on some basic ideas here. How many heaps does a process have? That was easy. One. Inside your process memory a heap is used for all those malloc and free calls and there's only one heap.  So it's just a BIG area of space that anytime you want memory from you can just call malloc, or calloc or realloc. But you can just say Hey I need some memory and this is how many bytes I need. It's stored in the heap. How many stacks? When we first introduced our program modal we had just one We said, What's a stack?"  Well, anytime you call a function I need some space for those automatic temporary variables And also a bit of space to say where the CPU should go back to when it finishes calculating anything we need to do inside that function. And if the function is recursive then my stack is going to get lower, bigger and bigger, because I'm going to keep calling myself and I need more space on the stack. And if my function calls other functions, ya agian, my stack is going to get bigger. That's a stack. What if I had two CPUs working inside my process at the same time? Each one needs a stack. Yes? Because each one will be inside a function; that function might be calling things.
So here is the basic idea I'm going to have one per thread [gibberish] So our processes have at least one thread of execution And it would start in main, as far as we are concerned And finish when you either called exit or returned from main And now I'm going to show you how we can have multiple threads going inside each process So let's start on the stack. All the automatic variables, also known as temporary variables, (the reason they are called automatic is because they automatically disappear when we return from a function and our stack gets shorter) You'll find the return address for the CPU, in other words what code you want it to execute when it finished calculating the current function and the last thing we'll see is the previous stack pointer, or the previous SP Because we want our stack to shrink when we return from the current function So what happens if our stack gets too large? It's.... Stack Overflow. Yes! You've probably heard of the website called Stack Overflow. I actually registered as the username Infinite Recursion, I couldn't believe it wasn't already taken So we have a limited amount of memory so in a single threaded model, our stack would meet the heap. Kaboom, and we're out of space Our program crashes. In fact, by the power of Virtual Memory, what we can do is set up little pages of memory that are like quicksand If our program attempts to read them, then it will crash the program deliberately, we send it a Segmentation Fault. Yes?  [Student asking question] Can you sbrk more memory for the [stack]. No, no you cannot. Sbrk represents the top of the heap. [Another student question] No, but where they meet depends how big your heap is and how big your stack is What we're going to do is make multiple threads though, supposing we have multiple CPU's working at the same time So what we'll have to do is make our stack start in different places So there is actually a possibility of one stack hitting another stack if it gets too large Now let's have a look at some code, let's play with some code Here we go. C'mon. Great. We are going to be working with a thread framework called pthreads It's very popular, you can run it on Android machines as well Here's the plan: We are going to make our program do some CPU cycles We agree that our program will never print Hello World, it will just go around this loop forever But what I would like to do is have a second CPU working on my machine And for that, I can call pthread_create There's four arguments, let's have a look at them First, we have a pointer to pthread_t, some attributes which can just be NULL, this scary looking thing and finally an arg Let's talk about each of these First of all, this is a function pointer. It looks pretty scary, void star start routine ahhhhh! Here's how to read this: You see where it says start routine? Just interrupt that as the name of your function and then work backwards. It's going to return a pointer to a void* and it takes an argument void* And then we wrap the name of the function with an extra set of parenthesis. Let's take this and write our function Cool beans Alright, what should we do inside cool beans? Let's sleep for 2 seconds, then we will print out the pointer And a new line. Ok, so now let's call pthread_create We can have a pthread id. So we pass in the address of that stack variable, we aren't doing attributes today Now we can just pass in the function name. If you ever pass in a function name without the parenthesis, it means Tell me the address of this code" And finally we can pass in a void *, so we write (void *) 12345 Let's write something in hex. I need a hex value. How about 0xdeadcode?
okay right lets run this, see what happens and it wont quite work, cus uhhh gcc will say hey I've no idea.. what" uhhh doesn't know what sleep is, and shouldn't know what pthread is either so lets fix this we need uhmm pthread.h and also on our options down here we have to tell the compiler please I really wanna compile with pthread there we go ... what. okay!  right great so it printed out.. dead code.. so what I want to show you is... look we passed in a pointer to something over here and then inside our function called beans, we just printed the pointer value we did not try to follow the pointer value if I tried to print out the string of deadcode my program will probably crash thats probably not a valid memory address to read okay  and now my machine is getting hot why? because there a cpu we're running uhmmm it it it, my program never finished right, the first cpu is still running so what have we just proved we proved that we can do two things at the same time inside one process what do you think happens if I make a hundred threads my machine  might only have say a couple of cpus so how is it going to run those threads if I've only got 2 actual cpus. yeah? so what I do, is it lets one thread run and when it finishes it says next thread I know youve been waiting for a while you can have the cpu next actually its cleverer than that every 10 milliseconds or so a little hardware timer goes off and the operating systems scheduler comes up and it says you have been having chocolate for too long. in other words you've been having the CPU for too long Im going to put you on pause and let this other thread that has been waiting for a while have access to the CPU and so that thread gets to run so the operating system treats memory, the cpu and other resouces as scarce resources and tries to allocate them very efficiently and the different parts of the running system that wants to have access and how we schedule that  is actually an area of research so we have passed in something. you've seen that what we have passed in here arrives as the pointer though here lets make our program return something so  I'll return another void pointer lets call it one two three four how do I get that from another thread? Well, this time I'm going to pthread join so pthread join is a bit like wait it says don't continue until this thread has finished and uhh lets just grab it okay here is the thread I care about so lets just pass in the id number that we have before and uhmm I better have somewhere to store it right so now I just need a void pointer and I need the address of that void pointer and so lets finally print out the value of that okay, so what did we see of it here we still have two threads then the new thread the second thread slept for 2 seconds meanwhile, the main thread the first thread say okay I'm just going to join so it gets paused because its waiting for that second thread to finish and then the second thread finally prints out something prints out what it is given and then returns a vlue which we can then get back fromthe first thread using pthread join theres another way to exit threads and that way is called pthread_exit right so lets exit with something uhhh lets exit with ohh I dont know hello! oh, wrong way did I... ohh, yes okay and we'll cast it as a void ** pointer there we go if you call pthread_exit you're never going to execute, that thread is never going to execute more code after that point. you're telling the system Im done with this but my cpu for this thread does not need to execute any more so this time my thread called pthread_join prints out hello world and hello instead of the other return value soo pthread_join the exit here basically says I'm done and with that we've finished have a wonderful section tomorrow if you have any questions about it come down and ask me now there were three students that failed to put their exam key and by the way your quiz scores are in your subversion if you are one of those students that didn't buble in your exam key come down and we'll sort that out now
Ok, it's 11 o'clock. Good morning class how are you? Alright how's your shpar looking? I imagine some of you are celebrating that shpar is finished. Except of course you know it's not, because what we expect you to do now is actually not just make code that appears to work, but code that you are proud of. Code that is probably commented, code that has nice variables, code that you give someone else and they could maintain it. Some of the worst things about writing sloppy code is someone has to come back to you and say, What was this going on here?" "I have no idea I wrote that yesterday." Now's your chance to put your coding skills to test, not just to make something that works, but to make something that works well. And we'll do a finally code review next week on Thursday. We'll have some other things for you to do before that, but we'll announce that via email.  Here's what we're going to talk about today. We're going to talk about using threads. Threads are cool because we can now make our single process do multiple things. And threads are cool because they allow multiple threads to share the same memory and the rest of the state of your process. So if you've opened a file descriptor in one thread, you can use it inside another thread. The exciting thing happens, though, when you have to wait for one thread to complete something. And for that, we need to worry about synchronization. And that's what sets your programming apart from things you've seen inside CS 225 and 125, earlier courses and other people that might have just picked up some programming. The ability to work with multiple threads correctly so that it always works when not just ten users are on your website, but a thousand users are on your website or you've got multiple CPUs inside your tablet, or your phone, or your watch, then that's where synchronization comes in. But anyway, let's get started. Little question, little memory question for you. My thread calls pthread twice, pthread_create twice, how many stacks does my process have? Ok, let's pick someone at random. Hi! What's your answer? If you said one, guess again. Any advances on one? If you said two, thanks for playing, but almost correct, off by one. It's three! Why? Thank you, yes! We get a thread for free at the beginning. One thread must be calling main, our CPU must be executing code at main All we did by calling pthread_create twice is we got ourselves two additional threads. And remember, each thread needs a stack. Why? Well we're calling functions. We have to put those automatic variables somewhere. And, when we return from a function, we have to remember where we're going to go back to. So again, that goes on the stack. So for each thread there is a stack and we have three threads in our process. So if my code called created twice, that means I could be doing three things at the same time. Ok, so I've been talking about processes for quite a bit, and talking about threads. What are some of the differences between them? Which is bigger? A process, yes. How much bigger? It's HUGE! Our process is a massive object! It's got file descriptors. It's got a big virtual memory space. Threads are tiny. they live inside a process. If you killed a process, that's it for all of your threads. They don't have anywhere to run anymore. So your process represents the sandbox. Everything that your threads can do will live inside a process. So our process has security. It's got virtual memory. It's got an exit status. Threads live inside a process, and they just represent what you want the CPU to do. They represent the code, the position in the code that is currently being executed. So that means if you kill a process, ha ha that's it. All of your threads are done. So if you send, say, an alarm signal to your process, all of your threads will disappear. If the process disappears, all of them have gone. This is an important point. They just live inside. So if we've created all these threads, perhaps we want to stop them. Guess what, you can do that and here's what you'd call. You'd call pthread_cancel. Let's have a look at pthread_cancel. How could I cancel a thread? Easy, just send in that id that we got from pthread_create and you can cancel a thread. I don't want to spend too much time on this because, in practice, no one bothers to use this. Here's why. Imagine you are making a fantastic meal for Friday night your potential boyfriend, girlfriend, dog is coming over, and your cooking like a storm here. And then suddenly, BAM! your activity is cancelled. The kitchen is in complete disarray. It hasn't been cleaned up. What a mess! It's extremely rare that we can just cancel something and not have to clean things up. So what examples might we have. Well let's say you have a thread that's kind of calculating new digits of pi, or discovering prime numbers, or trying to mine bitcoins like you've come up with a new currency called CS241coins or something. You can probably cancel that. It was just a CPU intensive job. But if there's any kind of resources, then maybe we shouldn't just call this cancel and leave everything in disarray. So in practice what we tend to do is actually make a variable to tell our threads, Oh by the way, you should stop at some point." And if you call this pthread_cancel, things don't even stop immediately. Typically they will stop when that particular thread makes a system call, like open or read. We can discover all of the calls just by looking at the man pages. So this will be like the moment that your chef opens the oven door we say,  ok, you're out of here, we've quit you, we've cancelled you, no more work for you." So what a mess. We don't tend to do that. So let's write something that can be cancelled. We want to call pthread_create. What do we pass in? A pointer to our little identifier. We don't need any parameters. What's next? Oh yes, the function. I called it my funct, and an initial value. Let's just pass in NULL to begin with. And this will go on forever.
Alright, so, this little function can say initially we are going to just sleep for one second and then put something like HI!". Ok, right, so its gonna print HI!" So, now, I've got a program that is going to use two CPU's, if I have two CPU's. Uh oh, what happens if I only have one CPU? The scheduler!  The Linux Kernel is going to say okay, you get access to the CPU for say 10 milliseconds or 100 milliseconds and after that amount of time, I'm going to take you off the CPU and let the other thread use it. And if we do this faster enough, like 10 milliseconds or so then those slow humans will never notice, that actually only one thread at a time is on each CPU core And if it turns out that you make a system call like open" or "read" and it takes time for us to read that stuff from the disk Then you don't need the CPU because you are waiting for stuff so I can give the CPU to someone else. So the scheduler has to make those decisions and make them well. Ok, so for example this sleep, you don't need any CPU to sleep.  I can let another thread use that. So, what were we going to do here... Oh yes, let's change this so we can cancel our little HI" function. We'll sleep for 3 seconds here and then change to something like please_stop". And then I will just loop forever. So, what do were want to do here?  We want to say while (!please_stop)" keep going around. And finally, let's have a global variable...there we go. We know in C that our global variables are initialized to zero. Let's run this and see what mistakes we made. (waiting) Ok, alright.  Whoops, we didn't declare the thread id.  So, what's that?  pthread_id" I believe. (waiting) (grumbling)  Oh, I just put a t"  How about that?  Yay!.  Ok, alright.  So we print HI!".  Our main thread sleeps for a bit and then calls "please_stop" And our little thread that is going around the loop says oh, look at that global variable, I better stop". Now I use global variables for a quick demonstration. Obviously we could put that inside a struct. We could pass something to the working thread inside here and we could use that to communicate with the other struct so we could have some control if we agree to share some memory.  Now I can hear my CPU fan going. (fan noises) Do you hear that?  Good. Because the CPU is constantly doing that little while loop in the main thread. So let's do something better than that.  What we would like to do of course is wait for the other thread to finish. One way to do that is to say pthread_join" and say "here is the thread that we want to finished" And we would like to know it's exit value. There we go.  We can find out what it is. Alright, here is my exit value and we can say return something here So what when we call pthread_join" again, this second thread is going to not require anymore CPU time. Because not it is waiting for the other thread to exit.  So that is one way to write this program.  I can also talk about pthread_exit" Let's write a very dangerous program. This is the _killer_monsters_take_over_the_world". You will agree that we probably should not run that function, yes? Well that's okay, because I am going to call pthread_exit before it. And I do not need a return value. pthread_exit()" says "hey, I am the chef and I am done.  I'm leaving the kitchen for good". If you call pthread_exit then, you are saying this is the thread's return value" and no more code will be run by that thread. _killer_monsters_take_over_the_world" will never happen.  This stuff about having exitvalue" and "pthread_join" in this case, that is never going to happen. pthread_exit()" simply means "I am done".  A little bit of knowledge for you, if you call pthread_exit()" inside the main thread, the original thread, like we did just did the rest of the process will actually keep on running. The pthread library actually says you know what?  I am actually not going to quit this process immediately I am going to wait until ALL threads have finished.  Let's prove that.  Let's call pthread_exit()" here.  I'm going to comment this out so it compiles.  Instead I will call ... nah, this is good. So then, what will my program do now?  That's right, it is just going to keep printing HI!". It is not going to take over the world. Instead what we did is we created another thread and our main thread exited.  So, let's go back to this.  Let's answer some of these questions. What is the difference between exit and pthread_exit? What does exit do? It kills the whole process. Yes, it says Hey, this process is done and here's the exit value. By the way, it also does a little few extra things for you. If you've written to the C output buffers, like stdout and stderr or anything else those get flushed and those file streams get closed for you.  So if you call exit, all of your threads are gone. We're done" Your process is done.  And it doesn't matter which pthread calls exit(). You are saying This whole process is done. Wrap up the shop, close all of the kitchens.  We're gone."
pthread_exit that just means no more for this thread that particular chef has walked out of the kitchen and will never come back so before you call pthread_exit make sure your thread has cleaned up any resources that it might have acquired questions? yes? ok so umm when a thread finishes it can finish in two different ways, it can.. call pthread_exit or can return in fact, they are actually equivalent so this is a way to send some information back to the rest of the process and we had an example down here calling pthread_join and saying what did that thread say at the end?" and you don't have to use this mechanism is actually common to make a struct and pass that to pthread_create That's the purpose of pthread_exit and this return here is that you can get the exit value let's say that you wanted more than just a void pointer what we can do here is define some sort of struct umm i won't bother the struct definition i'll say hey, let's have some memory and i'll call it my to do struct" ok so calloc( sizeof(todo)) and i just need one of them and then i would set..oops set things up on this hey like..umm.. you know.. start.. blah blah blah please stop..umm zero exit value in here, etc. so i could use this struct because both my main program and my thread that knows about this struct cause i can.. pass in it so that allows me to assemble a whole body of information that i want to pass to the other thread ok let's get back to our little questions here why would you call pthread_exit in your main method well, this is typically done in kind of simple or small programs where we say most of the work is actually going to happen by all of my other threads and my program can finish after all of those other threads have finished so we would do this if there was no clean up in the main thread and we'll be happy just to wait until all thread are done so this is equivalent of saying hey last person out of the kitchens turn out the lights and the process will finish so I gave you two ways that a thread can be terminated just now, I said it could return from its function so.. we could .. return a value and i gave you that 0x12345 thing so.. if you return from the function that was originally started by the thread i also showed you that you could call pthread_exit but apparently there's four ways What other two ways might a thread exit? and i have mentioned them already in this lecture yes! yes! if someone calls pthread_cancel() on that chef they're done, okay yes so if a thread is in a cancelled state, it may exit and how else might a pthread ... yes?! yeah, the whole process dies so if another thread for example, segfaults that's it for all of your processes segfaults if like blurring up the entire chemistry lab or the entire kitchen the whole thing is gone the whole process is gone we need a valid process in order for our threads to finish let's talk about pthread_join it actually has two purposes.. we can wait  for a thread to finish and get its exit value the other thing it does is..free up resources okay what resources might that be? well every thread has some space in its process memory for its stack and every thread has an exit status, an exit value the library is going to keep them around because who knows, someone will call pthread_join on the thread so we can only release those resources after pthread_join has been called if you're writing a short simple program and you don't about these things then fine but when you want to write longer running programs that don't have resource leaks you should call pthread_join on every process, i mean, every thread yes so pthread_cancel, you're giving a chef another thread the marching order to say hey leave okay. I'm canceling you, i don't want any more of your work I'm canceling..you know that stuff i told you to do? don't do it anymore, okay? so.. pthread_exit says i'm done and by the way, here's my result and i .. so it's an act by the thread that says i don't want to do anymore work yes? yes! oh okay, right the point i was making here is.. that you know that when you return from main, the process is done you know that when you call exit, the process is done okay pthread_exit has a supple part of the specification that says the main threads is finished, but the process continues until all threads are finished corrrrrrect! yes so, if i called pthread_exit() after printing Â - eh hi right? now the process is done so it's the last chef out that turns out the lights to the whole process
So, i have thrown pthread_exit at you, pthread_join, pthread_cancel, etc This is an exposure to the words in the vernacular, this stuff is not going to sink until you play with it So, i encode to play a lot with these things and to write little programs and see what happens Okay, if we don't call pthread_join on a thread, we get a resource leak And eventually We wouldn't be able to make anymore threads We can't reuse the same memory address from the original stack We are still hanging on to the exit value so we are using up more memory Okay so the next thing Take a look at this kind of typical kind of code here And the...this..something wrong with it What question is: What? And how could we fix it? How could we make it valid? Now your first instinct might be .. HOLD ON IT TAKES A VOID STAR POINTER That's okay All i'm doing is passing in a pointer To start So that.. My new thread can read a value Presumably, this 42 So, what do you think might be wrong with that? Just take a moment to talk it over with your neighbors or neighbor and see how we might fix it I'll walk around in case you got any questions - [silence] What did your neighbor say? What did YOUR neighbor say? *whisper from student*  - It was out of scope Ok we got a scope problem Yeah, so, first of all there is no security It's okay for one thread to access another thread's stack, it's not like we're going to get a segmentation fault The hardware doesn't know or doesn't care two threads are stomping over each other's stacks But we do have a scoping problem And it's this: we're passing in the address of start And start, as we know, lives on the stack How long is that address going to be valid for? Answer: Not very long, we're about to return from this function So, when will my funct start? Answer: I don't know, it's up to the kernel to eventually decide get around this other thread Maybe we'll put this first thread on pause beforehand and give pro to the new thread Or maybe this new thread will start much later on .. 100 milliseconds time By which point, what will be at this particular address? Could be anything right? It could be our original value, it could be being reused by a completely different function at this point So our problem is with time Our problem is that we gave the address something and that variable is no longer in scope Alright, how can we fix this? Well One trick is to say: I'm going to put this magic word static in here And if I do that, it's no longer an automatic variable It lives just once as a global variable inside my whole process But that is pretty heavy handed Alright, now I only use this start variable and I better keep its value until i'm sure another thread is run How else can we fix it? We could use malloc() And allocate some memory in the heap We would have run into the same problem if we immediately called free In this thread Because we would have created some heap memory Passed a pointer to it and immediately freed it. OH NO WHOOPS I didn't give my new thread any time to actually read that memory So if you do use malloc()  Don't immediately free it, instead.. Let this function Free it after it runs One thread can create heap memory and another thread can actually free it That's perfectly fine, they all live inside the same process And there's one heap I think another way this might be valid is before we turning We could call pthread_join On the thread If we did that, we know that the new thread that is going to run my funct will actually finish before this function returns So we've solved our timing problem We've made sure that we don't finish that this variable doesn't go out of scope Until the other thread has finished We have just encapsulated from a time point of view The running time of this other function and made sure that the running is within the scope of this start thread's function
Yes Yeah Ok right. So what happens if you put static inside a function? Yes, so the variable itself lives forever, but static makes it a secret variable. yes the scope of it, the name start, is only available inside that function but the actual storage of that variable is for the lifetime of the process thats like one of those awful interview questions hey whats on page 37 of the C standard? i dont know. I didn't write it Knowing precisely how static works is an exercise left for the advanced C programmer But by defining static, the life time of the memory is for the duration of the process. other questions? yes? To cast an int to a void pointer, no that's the other way of solving, if you're sure that a void pointer has enough bits to represent the parameter you're trying to pass in You can also just say, look void Let me choose a different value like 71 That means, I gotta type as a pointer to some memory I'm not going to say what kind of pointer yet Im going to pass in this value 71 you can do that providing you write the code to the other end to simply cast it if you attempt to read at memory 71 oops, you'll get a segfault I will not talk about that right now, but yes, that's another way of solving this problem How about this one? So what I want to do here is that I want to send my value of i from 0 to 9 to some new threads So each one can get a value Why does this code not work? So take a moment with your neighbor to review it and I'll start writing it up as a demonstration - [silence] Ok so here's a version of that code The first thing we might comment is what might this code print out? It might jsut print out hello world and nothing else it could be that we return from our main before those other threads ahave  a chance to start up Before those chefs can be employed and waltz into our kitchens, the process itself is exited because we've returned from main alright, how should we stop that? Well we could just call pthread_join on every one of those ids But you and I know we can call pthread_exit() here and leave it up to the system to finish a process when all the other threads have exited. ok right, so let's run this And this is the output we get Im printing out the value that's actually sent to each new thread and also the actual pointer we've got as well the first comment is look at all these numbers! They're all the same And it seems to work. If we only tested this with 6 threads, we think our code is fantastic! look at the all the threads I'm starting But instead I get 0,1,2,3,4,5 and four 10's. Why? yes? Â So the for loop finished So, for the early threads, what happened? well we ran our loop, we start a thread.Â well we ran our loop, we start a thread.Â well we ran our loop, we start a thread For the remaining threads, it so happened we went around the loop and those threads did not start.  They weren't scheduled on the CPU They're going to be. It's just they didn't start straight away Eventually they do start And theyre all given the same address the address of i it just happens to be a stack variable in my main thread by the time they started, we've already incremented the value it had already been incremented up to 10 and we saw that they really are looking at the same variable because we've printed out the variable that was given to us and that address, 7fe blah, blah, blah is just part of the stack of the main thread So let's to fix it We could make a struct for each of our threads using malloc() Or we can make an array in global but let's do the trick that you suggested lets just cast this to a void pointer because we're C programmers and we know what we're doing. said every C programmer. and what do we get? whoops Absolute garbage, yes
Ok, so this time, yeah, look each address that was given to our program is valid. But we shouldn't try to dereference it.  We should actually just try to say,  look, I know you gave me a pointer to some memory, but I was kidding. i'm not actually interested in  using as a pointer to some memory I just want to cast it back. Change that current bit pattern you got as a pointer to a bit pattern that now represents an int. Do not pass go. Do not attempt to read memory at that location otherwise bad things will happen So, here's another way of actually getting the right results. So there we go. Now we have all of our numbers And something you might notice thats surprising is that it doesn't count up 0 8 7 6 5 4 3 2 1 9 Why? Does someone dare speak that hasn't spoken yet in CS241? Yes, in the back! Yes, thank you. There's no guarantee when that thread is going to stop. and in fact it might be paused half way the scheduler might say  actually, I know I was going to give you the  kitchen I was going to give you the CPU, but actually I've decided to give the CPU to another thread, so  we don't know when they're going to start, we don't know how much time they're going to get because the scheduler is part of the operating system is trying to make best use of all possible resources so we have something running but we don't necessarily know in what order those threads are going to run. yes? if I had 10 CPUs it could be that every thread is given a separate CPU of course it depends on what else is happening on your system, right? it could be that I've SSH'd into your box, it could be that your tablet is also using one of those threads update the screen at the same time. maybe check your email, etc. so it is possible to try to schedule threads on different CPUs, but in practice it doesn't always happen the way that you actually specify it. yes? yes, you can set the priority of different threads. anyway, enough of this, let's have a look at page twoÂ  there are various C library functions that you've probably played with already like strtok() when we wrote our shell, or hey I actually wanna know what the error number is as a string" and if you read the man pages of these, you'll say oh they're not thread safe". ok everythings broken. what does it mean that not everythings thread safe? it means here be demons. here's where you can write code that looks fine, pases code reviews, passes simple tests and breaks when you put it into the next hart monitor so let's see an example of this here's some kind of typical code, let's find out if it's thread safe or not and perhaps you could figure out what might happen if this little two message function was called using multiple threads. so what might happen if two threads happened to call this function at the same time? why's it not safe? why could bad things happened? yes? [silence]
So if you don't have enough CPUs to run all the threads, the scheduler says I've got this stuff to do", and puts them in a queue. And we'll  be talking about that when we talk about schedulers. Every thread, every process from the scheduler's point of view is either in a runnable state or running, or finished, or about to start so part of its job is to keep track of that Okay so we've got a little function. Its job is to turn a number into a string, and we wrote some implementation, we've got some memory, and it's not thread safe. Why? Yes, at the back? Yes! So if you make something static there can be only one. This is the highlight of the variables. So we've got a single piece of memory, called result. And all threads if they call this will therefore be writing over the same piece of memory. So if you have two threads that are doing this about the same time then they're going to corrupt each other's result. It's like you and I trying to share a secret piece of paper, and I come back to it and I'm like what's this writing on it? I didn't write it before." We need to make sure that doesn't happen in our program. So we've got a problem here. How can we fix it? I know! Let's just make a temporary variable, an automatic variable, and be done. Yes? It's Friday, the best code is always written on Fridays. It's actually not true. You can actually do data analytics on check-ins and see how many bugs are generated by code on Fridays. Fridays and Monday mornings are the worst. So what mistake have we made now? Okay yes we are returning the pointer to some local memory and after the variable goes out of scope that is not longer valid, that area on the stack is going to be reused for other functions we call So we can't just do that Okay, so how can we fix this? Well one thing we can do is not use any memory inside here at all. Instead we'll change this to take a pointer to some external memory. And if you look at the c-library, you'll actually see this has happened over time. There were early versions of functions which just declared things, say, using static. The nice thing about that is it's cheap. We don't have to wait for malloc() to find us memory.  But the bad news is that it's not thread safe. So later versions of similar functions allow us to pass in a pointer to some memory that can be used.   So I'll come back to twelve in a moment. First of all, there's a quiz on Monday! What? What? Yes, it will be about fork(), exec(), basic synchro stuff and I/O.  Here is a hint about some stuff that might be on the quiz, and you can find references to all these things inside the wikibook. Is it comprehensive? I'm not quite sure what you mean by that. Will there be things on there which are challenging questions? Absolutely, yeah. They will include gotchas so know the difference between sizeof() a type and sizeof() pointer of a type. It will include code that is good and bad, you are expected to notice when it is bad.  I have a habit of writing multiple choice questions which state things like hey which one of the following statements is not true?" So that means you have to recognize false statements which are not true Right, let's just finish of with these then. The advantage of threads over forking processes: Hey, they share memory, so it is easy for us to communicate between threads. Very very easy They're also very cheap. And you too can create a new thread, just call pthread_create()! It's trivial, it's easy! So can I fork a process with multiple threads?  Yes, but don't.  Unless you know what you're doing. Unless you're really sure you know what you're doing. Unless you're crazy and you're really sure you know what you're doing And you want to maintain this code for the rest of your life So here's why: when you do this, the only thread which survives this cloning is--you know how I said Fork, you're gonna clone everything"? I lied! --the one thread that calls fork() continues.  In the copy, in the clone. All of the other threads have disappeared. They no longer run So now all of the other threads in the clone that were doing things have just disappeared. They may have been in the middle of calling malloc(). They may have been in the middle of doing something important. And now the good work that they were doing has disappeared. So that's why in practice it's extremely difficult to write good programs that fork() AFTER they've created more than one running thread. So yes, if you want a world of pain.  Otherwise, try not to. So let's finish with this: condition variables, semaphores, and mutexes.  This is the meat of the couse This is the cool stuff. This is the stuff that is going to make your head explode These are the primitives we are going to learn about so we can communicate with our threads. So we can make sure that our threads pause while another thread finishes its work So that we can make sure that threads don't step on each other's memory structures. So that we can have ten threads write to a single structure and know that the result is valid at the end.  So that we can have threads that don't fill up buffers then spin and use up CPUs, instead intelligently use the CPU And we'll be talking about those next week. Have  a wonderful weekend.  Look out for an email from me about the next assignment and the MP. Thank you very much and I'll be here for questions. For those of you that forgot to write down your exam key on the last exam we can find your exam script right now. I know there was like two of you. One percent of the class failed to write down their exam key. So let's fix that
[background noise] good morning you gin lads and welcome to the bountiful C the wonderful c, the giver of life, the platform that allows us to compile our codes on new hardware you wanna take a program, you wanna put it on your new hardware, don't worry you just need to make a C compiler the wonderful C perhaps you've written it in python, doesn't matter, python itself is written in C perhaps you've written Minecraft ahhh,well don't worry about that, that's written in Java, well Java of course is written in, well c++, but nevermind, it's almost C perhaps you've written a ruby program, well guess what? ruby the interpretter is written in C yes, so C is underneath it all and that is partly why C is such a powerful and potent language it is also a fantastic langauge for working directly with hardware because we can create memory structure that map directly onto bytes and bits of our hardware so C gives you tremendous power because it's so close to assembler but a lot easier to write than assembly code alright, so we've been talking about making our c programs run with say two processes or doing two things at the same time well this is where things start to get interesting for example, let's count our gold  I've got a little function here called countgold() and you can see this is going to effect  so let me run this, i'll make a separate thread to do it alright, how do I do that?  well I need to pass in some sort of identifier and then I've got some options I don't care about what next? and then the function countgold and finally I want to give countgold a parameter of nothing, so I can just pass in null here and of course we want to wait for this to finish this time I'll call pthread_join() because I don't want to just finish at this point, I want myself to print out the value of the sum great, so, let's wait on this and I can, I'll have to put my little pthread_t type in here tid1 and I can actually have an exit value as well so what did it say? that can just be a, whoops, void pointer and I'd better give it the address of that thing so let's compile this and see what we get arlight, argh, sum is zero now why was that? that's a good question, why was that?  we should've waited on this so let's first of all check that I'm using this correctly so we'll check the value of tid and see what it is and we should have  ok we've got a valid value so why did pthread_join() not  join terminate OK, alright, so at this point OH, yes, hahaha what did I pass to pthread_join()? the address of tid1 not the value of tid1 so, we needed the address up here because we wanted pthread_create to push the id into that variable but pthread_join() we just said here's your address and pthread_join() says thank you very much for that address, I'll take that as your thread identifier no, we wanted the value ok, so normally because that would take us about four or five days to discover good, so this time now it's waiting and finally it prints out the sum is a million fantastic now let's not just have one part that's going to count the gold, we want two so we'll have two threads going  they're both going to run the same function, but you and I know they both have their own threads so they both have their own stacks so each thread has it's own value of i OK, so, we'll, of course if we didn't do any waiting ah, thank you we didn't do any waiting, then our value is just some other value happens to be 56,000 in other words we had two of these other threads running at the same time and our main program just decided to carry on and by the time we actually read the values  those other threads had already incremented it so we'll change this now to actually wait and any time that we copy paste code be very very careful to make sure you change everything you need to change I don't need two exit values, I don't care that both of them are going to write from the same thing so, now my program says OK,wait until the first thread is joined and then our main thread says now wait for the second thread to join and there we go my sum is about one and a half milliion whoops, I did not get two million even though both threads were just adding one to the sum perhaps you can see why we'll surely then we can fix this by saying rather than sum plus equal one, I'll just say sum plus plus
ok, what would our value be now? again, about 1.5 million, certainly not two million our pyrax cannot count OK, so why did it fail? why did my sum not get two million? thank you! yes! two threads are touching the same memory location so even though we wrote sum++, sum++ is not an atomic operation now life would be easy if our threads were like gorillas if they walked up to a memory location mine! they changed it, they added one to it they asked it any other thread and they threw it back ok, but that's not how it works of course, no instead we're copying bit patterns we're copying bit patterns from main memory into the CPU  we're running through our model adding machine and then we're putting the value back into memory during that time another thread may have come along and coppied the original bit pattern from memory and done it's thing inside its CPU and then put it back so hopefully you can see that it's possible that the value could be less than two million if it turns out that are trying to add at the same time in fact it's possible for  the value to be much smaller than that but let's talk instead about how we can actually fix this we've made it deliberately interesting by making sure that each threads are touching the same memory it would be pretty boring if they were working inside their own stack space or we'd give them different memory locations to play with, say if we'd give them sum one and sum two then of course everything would be fine life gets interesting when we actually have two threads competing and working on the same memory so what we'd like to do is say 'oh I've got a problem and here's a piece of my code that I only want one thread to play with at time' in other words, I've got a critical section and inside this little example here this single line is my cirtical section it's the piece, it's the lines of code, where you say 'I only want one process or one thread to read this memory or modify this memory' because if I have two threads working then they may see things or leave things in an inconsistent state now we're programming with a very simple exaple with integers and sums but now think about your other data structures you wrote in say CS 225 where you've got multiple memory structures, you've got pointers to arrays, integers which reperesnet the number of things in an array if you didn't write that thing directly than the STL library did it for you all those things need to be in a consistent state if you wrote linked lists then you'd better make sure that you're sentinal value is actually present and there's a few nanoseconds where that's not true so whilst you'll updating a data structure you don't want anybody else to touch it you don't want anybody else to read it and you certainly don't want anybody else to try and update it at the same time so that's where mutex locks come in  so a mutex is a very valuable thing it's like having a girlfriend or a boyfriend or a dob it's yours and you're not going to let anybody else own it very objective thing it's mine, I'm jealous don't let if you are holding a mutex, you don't want anybody else any other thread to try to lock that mutex if they do they have to wait until you've finished with it now to be procise we are locking and unlocking I just wanted to give you some ideas so that in your next jealous outburst you can remember this lecture alright, so, let's have a look to see how we can do this, what we'd like to do is around this critical section we'd like to lock a mutex and afterwords we'd like to unlock it unlocking doesn't take anytime at all locking usually doesn't take anytime at all unless somebody else has locked the same mutex in which case you're out of luck it's a bit like trying to walk up to a counter, the clerk is currently busy, you'd have to stand there and wait and twiddle your thumbs in fact you might actually use up a bit of CPU time while still twiddiling thumbs, it's often called a spin lock which is how this thing is implemented underneath but we don't need to talk about that but essentially we've got a little piece of code that says ok, i have to wait i have to wait i have to wait i ahve to wait until the mutex lock has been unlocked but they're designed to be efficient for when you want to lock them and unlock them in the very near future so let's actually have a look at the code for that, how do we do that? we'll it's part of the pthread library and we can say I've got a pthread_mutex, here it is, it's a pthread_mutex_t type and I'll just call it my mutex one so now we want to lock it how can I possibly write that code if pthread_mutex_lock() what do I need to give it? the address of the mutex and guess how I unlock it you write pthread_mutex_unlock() OK, so now we think we've got working code let's try it and just for fun I'm going to reduce the number I wrote by an order of magnitute to make it run a bit faster tick tick tick suddenly we noticed even though I made the for loop to help with the speed I think it returned OK, heres, here's to the first surprise, it shouldn't have worked [laughs] it appeared to work, but that's just lulling us into a false sense of security the second surprise is that it took a bit longer so at least I'm sorry I took the loop down by an order of magnitude yet it still took a long time so this is a not free the lock and unlock are not free, it takes a certain amount of time especially if you look at how much overhead we're doing in this example we're just incrementing and getting them out of a loop. so they don't take a small amount of time to run the second thing is that they may not work if you've forgotten to initialize them and this time for a lecture demonstration i was unlucky that it did work what we should do is make sure that our mutex locks are properly initialized alright, so how can I do that? well before using them we should call pthread_mutex_init and let's look at the man page we can pass in a pointer to our mutex as some attribrutes if we'd like as well so I can say 'ok initialize my mutex and here's some additional attributes I could set up for them as well
ok there's another way to initialize them which is to actually set an equal to this magic macro pthread_mutex_initializer ok, so, if I do that then I've got an initialized mutex and now I've got this object not in a c++ cense, but in terms of something conceptually I can think of as an object that I can lock and remember, the lock means that no other thread can lock the mutex so I'm using it as a way to serialize who gets access to my sum variable if your thread comes a long and tries to lock this mutex one then it has to wait until I've finished with that mutex and similariliy if you've locked mutex then I have to wait yes? then we go back to the original problem we have arbitrary values ok, so yeah, we could do that, we could have another little loop down here for example yes and we're back to our same problem that the CPUs are now stepping over each other in trying to read and write to this memory location pthread_mutex doesn't give you any magic, it's a very low level way just to stop two or more threads form continuing it's up to us to do some code analysis and say 'yeah, actually I've got a problem with this code' I forgot to put a pthread lock around that other loop [student question] correct, yes, you can just think of it as a very simple little busy loop the lock thing says 'hey whilst it's mutex is locked by someone else I'm going to wait' that's all it does it doesn't magically say and the code in here is amazing and bug free it doesn't say that other pieces of memory are especially locked, it's just a loop it just happens to be a clever loop to be sure that there can only be one  if two threads called mutex lock at the same time only one of them wins only one of them gets to go to into the bathroom the other one has to wait a bit but eventaully that first thread will presumably unlock the mutex at which point the waiting thread can say 'oh great, it's my turn to lock it' and continue so it's a busy loop, it tries to be efficient in the case that the lock is unlocked because most of the time there isn't a conflict most of the time it's pretty unlikley that two threads are reading the same data structure it's just that one percent of the time or .1 percent of the time we're lucky and our CPU, or two or more CPUs are trying to read the same memory when we don't want them to yes? [student question] yes, in this tiny example we would actually get a better performance if we did that if we just locked the whole thing for the entire time in other words for this silly little tiny example there's absolutely no point running two threads yes trying to have two threads accessing the same memory we might as well of just had a single thread that weant up to two million ok, so the parallelism in this case or the speed of it just isn't worth it the reason I've chosen this example is because it's trivial to show a problem with two threads incrementing the same piece of memory it would not be a problem if sum was the local variable because local variables are stored in the stack and the stack is per thread and so presumably they'd be updateding their own variables what happens if you forget to unlock? ok, imagine this, imagine the person in front of you goes into the bathroom and never comes out what we've discovered ladies and gentlemen is something called dreadlocks - nah - no, actually deadlock nothing to do with dreadlocks or bad hair or goodhair if you like dreadlocks so we've got a problem of deadlock we've got one thread waiting for another thread to unlock a mutex and it never happens right, our poor thread is stuck alright, so let's do that to our poor little program and you can tell me how quickly my program will finish three years later we're still waiting what happened? well I had one thread that locked the mutex and a second thread that said 'ok, i'm going to wait because i need to lock this mutex'  so it never proceeds, it never gets into the for loop meanwhile our main thread is waiting for both threads to finish when does that happen? never so if you think C code and programs have been hard to debug so far you ain't seen nothing yet. baby no because our program stalls, it gets stuck if we were to debug this we'd discover that the main thread is here, it's waiting it's waiting for soemthing that never happens we have to say while why is it waiting? what happened to that other thread? so like sherlock holmes you have to say look this thread ever unlocked a mutex yes? are you taking about the mutex or the sum variable? so in the - we had the code before ok, so the code, the code as written right now allows one thread to work through the whole for loop and the other thread is just spinning there waiting for the mutex to be unlocked before it can lock it so it doesn't do anything now you've got the case where each thread before they can increment the sum had to lock the mutex has to own that mutex
ok, only one of them will win that fight if they happen to try and lock at the same time one of them still wins and the other one has to wait if the other thread comes around and tries to lock it whilst you've got the lock it has to wait and it keeps going around, yeah, so you take the lock, you increment it and give the lock back goes around again, yes yes? [student question] yeah, it's not a very good program I agree correct, in some cases the only reason to do parallesism is simply to add it to your resume it may not actually give you a speed up and this is an example of that. it's just a silly little example we'll get to to more complicated examples soon in the course where we talk about multiple threads spawning to read and one thread wanting to write now, I'm showing you code but I want you to stop for a moment and think about this conceptually we're talking about threads, but this could apply to real life. this could even apply to processes now I'm not going to show you any code with processes but there are certainly times when multiple processes are asking the operating system to do things at the same time 'hey I'd like to write to disk at the same time' sorry, I'm not going to let you do that 'oh I want to open a file descriptor at the same time as someone else' now the operating system has to play these same kinds of tricks to make sure that the data structures are valid whenever a different process tries to read it so the operating system is full of code like this to make sure that we correctly work with our data structures even when different processes are trying to run, or use them or read them or write to them at the same time right, so, the other thing we can do is talk about this pthread_mutex_lock() yes, it's just a little data structure here pthread_mutex_t but behind it there's additional resources this elusive thing I just called a spin lock is behind it and so we're tying up system resources in creating a mutex lock. not much, just a tiny bit so good C programs will free up a mutex when they've finished using it OK, so, down here we can call pthread_mutex_destroy() and pass in our mutex that doesn't do anything to the C variable, but it does say to the pthread library 'hey any resources you've connected to my little C variable can be released and reused'. a question? [student question] aha, that's a great question if one thread locks a mutex, can another thread unlock it? no this is where the bathroom analaogy is great. if you lock the bathroom door you don't want anyone else unlocking it no, the idea of a pthread mutex is that you lock it and then a few nanoseconds later you've finished updating your data structure and then you're going to unlock it it's an error for another thread to actually try to unlock it also with a simple mutex like this unless we give it additional options it's an error to lock it twice if you try to do that the most likely thing to hapen is that the pthread library will say 'that mutex is locked, I'm just going to sit here until it's unlocked' but there's a problem becasue you locked it so it's never going to be unlocked, so now you've got code that's hit a deadlock again that this poor little thread is waiting for itself but it can't continue because it can't execute anymore code because it's waiting for the lock yes, so don't try to lock it twice you can give more arguments to pthread mutex locks to say add some more debugging and checking and it will complain to you if you do things like that but in practice we don't do that because a) it slows our mutex locks down and b) we should just write correct code anyway right, good luck with that yes? [student question] aha, ok, let's suppose the mutex is locked and you try to call destroy the answer is, don't do that it can lead to undefined behavior  the exciting thing about undefined behavior is that it's undefined! it can do anything! it could start world war three, it could change your facebook status to single ok that was a joke um, it could update your tinder profile, whatever it could - so, so - don't do this  these primatives are designed to be extremely high performance so as a result there's no safeguards so look back with nostalgia at Java where Java would say 'excuse me you've gone past the end of the array' I'm going to politely shut down your process and throw an exception this doens't exist anymore, you are ice climbing here and you'd better make sure that every line of code you write is correct so write code slowly, especially code that deals with locks especially code that deals with malloc and calloc and free and realize the lifetime of functions now can be very diferent so for example here's a student error I saw once where we had some memory  ok, so calloc sizeof an int, lets have enough memory for say a hundred of them. we'll pass this in as a parameter and then we'll free our memory not a good idea alright, because if my count gold function is now using that memory the code I've just written assumes that I can free it straight away well hold one, we don't know when countgold is going to end so just because we don't write anymore code in our main function that uses this memory doens't mean we can immediately free it no I've probably got another thread that's going to use that memory so now we have to think of the lifetime of our threads as well and how long their going to run so like I said this is like ice climbing, you do it carefully and think about each line of code and the lifetime of your data structures and whether they - what happens when two threads try to work on them at the same time alright, any questions about mutex locks? ok, so, I'll just reiterate the main points again they're not magic they're just little loops a pthread lock is basically just a little loop until that lock is available so it's up to you to use them as such
yes, if you had two threads using two different pthread locks that doesn't help you at all you're going to protect some memory use the same lock to protect that memory everywhere you access that memory right, are you ready for slide two? k, slide two yes, in todays lecture I'm not just giving you one synchronization primitive, but you get two synchronization primitives yours for just 19.95 yes, so we're going to talk about counting semaphores here's an idea mutexes are a little constrictive, right? first of all I can only have a lock and unlock from the same thread and they don't have any internal state other than whether it just locked or not so sometimes we want something which is a bit more general and this is where a counting semaphore is very useful because it has the idea of a count and everything is happy providing that count is at least one but where we get down to zero or lower it stops it doesn't let you reduce the count  so it behaves like a resource counter the integer that we're going to put inside this counting semaphore and if you try to reduce the count you can't, you have to wait so I have a little example  so what's the code look like in terms of the counting semaphores? well what you'll see is this sem_post and sem_wait and fundamentally what they do is they increment or decrement the count inside the semaphore you never see the count directly and in fact it's quite common to increment and decrement - sorry it's quite common to set the initial value as say zero or one so imagine a pizza box with slices of pizza in it and anyone, any thread can come up and say 'yes, I'd like to eat a slice' unlike the counting gold code I gave you, I guarantee you that each person will get a slice and we'll keep track of the number of slices in each pizza box so you can come up and eat a slice of pizza if you try to eat the slice of pizza and there's no pizza left, you wait here's the nice thing about semaphores that you don't twiddle your thumbs no, your thread is put on suspended animation, you're not going to use up any CPU time so if you want pizza and you ask for pizza and there's no pizza left, I get to freeze ray you and you're not even conscious of the fact that you've paused, that you're stuck now, is this the end of the world for you? no because here's the good news other threads may come along and put pizza back inside the box they can increment the count when they do that I can wake you up and say 'hey guess what? there's pizza now!' and you say 'oh thank you very much!' and take your pizza slice and carry on your way right, so this little analogy is what these sem_wait() and sem_post() calls do so how do we use a counting semaphore? here's the basic idea, we're going to say init and we want to say how many slices of pizza do we want inside of our box our what's the intial value so for example zero might be a common idea or we might say actually I want say three slices of pizza and then we might call wait I'm decrementing those counters, if there happens to be pizza inside the box, if there happens to be a non-zero value inside my counting semaphore these can return immediately OK, so I can call wait three times and they would immediately continue but if you call wait a fourth time your thread gets stuck inside the wait call doesn't need to use any CPU for this because your operating system is now going to take control of that thread and say 'Im sorry, you cannot proceed, there's no pizza left' ok, the good news is that on another thread we can call post post does not block, post will return immediately but post is the plus one effect, it says I want to actually increment the number of pizza slices inside this counting semaphore so when you do that anybody waiting to eat a slice of pizza can now continue, they will decrement the count themselves and continue we're going to use this counting semaphore for some more advanced examples, but one thing I want to show you or one thing you should notice is the way you post now they, they don't need to be inside the same thread. they could be, but they don't have to be right, questions about counting semaphores? yes? [student question] ok, right, so, let's imagine you've got any empty pizza box two threads walk up and say I'd like to split a slice of pizza. we've put them in a state of suspended animation and then you walk up and you call post on this pizza box here's what's going to hapen first of all you get to walk away straight away, you can carry on whatever you were doing one of the two threads that were waiting will win, ok? one of them will get to return from their wait call now of course, what's left inside the pizza? because you posted but another thread immediately waited on that and stole that slice of pizza so the count is still zero, so any other threads that walk up and try to eat pizza, theres nothing left in the box but we've released one of those threads
[nothing] yes? correct, it's not necessarily like a queue it's actually operating system dependant we can give hints to the system as to how fair it should be for example, you might say that the thread that's been waiting the longest should have access to the pizza, that seems pretty fair to me but actually we have different definitions of fairness for example, the surgeon that is waiting to eat the pizza has a higher priority than the non-surgeon so we can actually assign different different priorities to our threads but that's some more advanced stuff that we don't need to worry about for today. for now just assume that you don't control it, the operating system controls who gets to eat the slice of pizza I don't know about you, but I'm going to be pretty hungry after this lecture so, yes? haha, great question! can you use this to implement lock? that's such a great question, I was about to ask it to! can we use a counting a semphore to implement a lock, a mutex lock? in other words, if I hadn't told you about the mutex lock, could you do it with a counting semaphore? that's true, yes, so counting semaphores are more versatile in that sense but in terms of the counting gold example I showed you at the beginning of this lecture could you do it using a counting semaphore? well the answer is yes my next question to you though is what should be the initial value of the counting semaphore? so if we were to go back to our code here and we didn't want to use lock and unlock, but we wanted to replace this with a counting semaphore ok, so, before entering our critical section we should try to take a pizza slice, we want to grab a slice of pizza ok, how do I do that? I'm going to call sem_wait() on my counting semaphore afterwards I can give back the slice of pizza yeah, sem_post() so how does that work now? if I have two threads trying to call sem_wait() at any one time I just need to make sure one of them wins so therefore how many slices should I put in the pizza box at the beginning?  just one! yes, so one thread get's a slice of pizza and can continue if I put in zero slices of pizza when I initialized my program what would happen? deadlock, yeah! no one gets to continue if I put in two slices of pizza or more I have a race condition again now I've let two threads continue when in fact I only ever wanted one thread inside my critical section if I'd put in two slices of pizza then two threads would've been able to proceed past that sem_wait() at the same time and that as we say lead to data corruption ok, so I think I have my sem_wait man page search so, when you initialize a semaphore the last thing you're going to pass in is it's initial value, in other words the number of pizza slices inside your counting semaphore questions? so one of the powers of the counting semaphore is that you can call sem_wait() and sem_post from arbitrary threads and we'll see that when we want to make a simple queue or stack work with multi-threaded code now, the queues and stacks that you've made in past classes did things like 'oh look I've ran out of space, I know iI'll just allocate some more memory and I'll make my list or linked list longer' I'll double the number of spaces we can do better, what we can do is say I will stop thread from putting anything else into my data structure I can pause it because when it calls sem_wait() we know that it's going to be put on ice so it's unable to continue, it's unable to put anything else into my data structure until the space so now I can think of my processing in terms of pipes and I don't have to have an infinite amount of memory if part of my computation is generating results faster than the rest of my computational process
so I can say to a data structure given the next item, if the data structure's empty that call can just block and it can block until there's data to be retrieved so these become very powerful primitives in multi-threaded code and by the way you can use semaphores as well to even work with multiple processes, but let's not worry about that today still I want to show you this little example here where I'm going to use sempahores with signals now a quick comment, semaphores don't work in mac os x so if you happen to have an apple machine in front of you please go intern at Apple and fix this don't worry, we'll work at how to get around that in a different lecture, but you can check to see if it works by looking at the return value of sem_init() so remember typical posix calls return -1 if they fail so it's a good idea to find out early that our semaphore failed instead of just carrying on and assuming it wasn't a problem so I want to show you a common way of using semaphores, and that's this let's have a thread that's going to do some clean up for us and the first thing this thread does is call sem_wait() alright, so I've got a little method here called sing song and the clean up is going to do sing 'yo ho ho ho a pirates life for me!' which you can imagine in say your java virtual machine there's a whole lot of clean up you might want to do before it exits and so this is a perfect example of how we can use a semaphore we're going to call sem_wait() which means this thread blocks, which means this this thread cannot continue because there's nothing in the pizza box right now now, I'm going to set up a signal handler so that when I press ctrl-c I call my little handler here's my handler so when I press ctrl-c I call sem_post() hold on a moment, why couldn't you've just printed 'yo ho ho ho a pirates life to me' directly from my signal handler? and the reason is because printf() might actually allocate some memory and the number of functions you can call from the signal handler is actually quite small sem_post happens to be one of the few functions that you're allowed to call from within a signal handler, printf() is not why? because there could be race condition it could be that malloc is being called from somewhere else in our code and the internal data structrues may not be correct, it may not be ready for another malloc call to run at the same time so that's our trick, right, inside the handler we put an extra slice of pizza inside our counting semaphore we increment the count from zero to one and in doing so and a moment later sem_wait() can return at last that thread can eat! at last it can take a slice of pizza alright, so, let's run this so, you can see I'm using gcc. you need to give the option -pthread to say include the pthread support and because I didn't specify an output file it's just compiled to a.out so let's run this nothing happens of course until I try to press ctrl-c in which case it now prints 'yo ho ho ho a pirates life for me!' we caused the signal handler to run which posted the semaphore which let our other thread go
[pause] okay good morning and welcome to a very cozy edition of CS241 it's eleven o'clock according to siebel 1404 so let's get started here's what we're going to do today we're going to look at something called the critical section problem this is a fundamental idea of how we cope with doing two things at the same time or to be precise, how do we stop two things from happening at the same time we played around last lecture with counting gold remember?  and we saw that if we let two threads access that global variable then our count will be wrong and so our messing around reading or writing that piece of data we solve the problem via putting a mutex lock around it and we said okay right but if we do that then only one thread can continue and change that variable and the other one has to wait so what we did is we identified a critical section of our code where only one thread or one process can manipulate that memory at a time so what we're going to do now is step back from thinking about mutexes and locks and think about it in terms of some pseudocode and also think about what happens might you implement say mutex lock and mutex unlock and that is what we're going to do right so here we go it turns out for example that someone forgot to implement mutex lock and unlock and so, here's my idea of how we could actually implement those two functions okay so remember the game here is that if two threads called lock only one of them should win and the other one has to wait it's the you know any one person in the bathroom at a time type of rule here so how's the code work? right so when you call it you pass in a pointer to this mutex object inside that data structure I've got something called lock which can just be an int so if someone else has already entered, in other words, if they have already set the lock then my code does nothing it just goes around and says okay is it unlocked now is it unlocked now is it unlocked now is it unlocked now? so it's going to busy wait, it's going to just keep testing that variable once it's unlocked, my little thread is going to say okay great now I can set the lock that means if any other thread at this point tries to lock it, they are going to have to wait they are going to be inside that busy loop because I still have the lock and of course eventually when my code finishes I can then just immediately set it back to zero I don't need to have any loops here, I know that I'm the only thread that could of set this lock so the code is simple, just unlock the door and walk out right so that's my first attempt at protecting my critical code, my critical section so that's my first implementation of how lock and unlock might work is it any good though? will it work? perhaps you and your neighbor can figure out why this proposed code is actually not sufficient  what race conditions could you see? what would happen if two threads happen to call it at about the same time? so here's what we have to do, you have to look at that code with two parts of your brain and imagine two different threads were running the same code what could happen that would be bad? [pause] okay so what have we discovered? is this implementation any good? what do you think? no, why not? no okay too scary, alright so here's our problem, our lock needs a lock there's a potential race condition here what would happen if two threads called lock at about the same time both of them would see that the door is unlocked yes? both of them would see that the variable is zero. great they say, I don't need to be inside my while loop anymore and they continue at the same time so now they both set the lock equal to one and they both return, they both continue so both of them, both threads are now able to enter the critical section which is precisely what we didn't want we wanted to make sure that only one thread at a time could escape from our lock does that make sense? because this is the easy one, this lecture is designed to blow your mind and to make new connections that didn't exist this stuff is really hard to think about if you have a human brain
so your homework for this week is to go and upgrade please go and get one of those uiuc brains please um because this stuff is really hard, we're looking at one piece of code but thinking about it for what could happen when two different threads happen at the same time and you're thinking about the sad days, your thinking about what could possibly go wrong we're not thinking about oh my code works great, it's no no let's look at this really really critically yes so our problem would be if two threads came along called lock at the same time and they both read a value of zero for the lock value before either of them had a chance to change it to one not very likely but that's not good enough, we're trying to make code that actually works that doesn't make us lose money or corrupt our data structure at the end there can only be one thread that gets through this alright I talk about threads because that's how we program this stuff but if you read the historic literature, it talks about processes that's because we're thinking about this actually in a more abstract sense not about pthreads and c structures but just how do we actually do this so that it works alright so this is broken, the only way that we could have made this code work is if we had somehow done all of this as kind of one operation but we can't do that in c you can't say okay I'm the gorilla, whilst I look at this lock, don't let anyone else look at it or touch it, alright? how do I do that? easy, make a lock, oh wait that's what I'm trying to do right? so that's not going to work for us okay so that failed, what we failed at was mutual exclusion we only want one thread or process if you're talking historically inside our critical section so let's try a different solution, let's try our first real candidate solution we'll have um. we'll agree on the following now before you panic, the code written out here, the pseudocode is the same as the pseudocode on the right hand side the reason we wrote it twice is because I want you to think about two threads or two processes trying to execute this at the same time and see if we can actually kind of prevent bad things from happening so what we'll do is we'll have some flags we'll say look, I'm going to just wait until your flag is lowered and your thread will do the same so if I see that your flag is up, then I know that you are inside the critical section in which case I'm just going to wait once I decide that your flag is down, I'm going to raise my flag, I can do my stuff and then I'll lower my flag now we can say what happens if I have three or four or five or more threads in this, let's not let's just worry about what happens with just two threads or two processes trying to do that this is hard enough with just two alright so does this work, does this suffer from the same problem? or not? okay you decide and see if you can argue it with your neighbor [silence] okay! so, does it work? yes it does great, end of lecture no of course it doesn't work right? so does it work? no! why not? let's hear from someone over here, yes they both could be waiting forever, uhhhhhhh, I think that might be hard, I think we can assume that their flags are initially down alright so how will they get to have both of them up? come on keep going alright so we have a potential problem right? yes that both people or both threads could see each other and say oh look his flag is down great I can continue, at which point we raise our flag and say alright off I go and they do this at exactly the same time, or about the same time so hey i'm going to wait until your flag is lowered and I'm going to wait until your flag is lowered they check each others flags they are both low so they can both proceed they raise their flags to say okay I'm going in but it's too late, they've both gotten past this little loop! so they both go into the critical section so what we have failed on the mutual exclusion principle game again we did not get mutual exclusion we wanted one person inside our critical section at a time thank you very much and we failed so when we're looking at these solutions, we've got to evaluate them a little bit carefully because it can happen more than once you could imagine you're going to wrap this around some data structure update like hey I want to add something to my linked list or add something to my hash and I don't know where I'm going to do it but I do know I'm going to say insert things into my hash or read my hash multiple times right so, let's be sneaky, let's be guided by what we did before and this time we're going to raise our flag first that way hopefully, we can stop this mutual exclusion problem okay what's wrong with this solution, right so again the code here is the same as this code here you could just imagine that this is person A and person B or thread A and thread B what happens now? what could possibly go wrong? again take a moment to argue this with your neighbor and even if you don't agree with them perhaps you can persuade them that you're right [silence]
okay sounds like we got a little situation over here okay what have we got? you put your flag down. no, you put your flag down! it's a Mexican standoff with flags! It's a Mexican standoff with flags! okay... uh so what do we mean by that? what could possibly go wrong? okay right yes exactly, both of them could raise their flag at the same time not very likely I agree, but it could happen right? both of them could raise their flags first before continuing and then they check each others' flags  oh look over there that other thread has their flag raised, i better wait and they both do that both threads or both people now just are stuck forever waiting for the other thread to lower their flag this would be an oops moment right? so clearly this is not going to work for us this would not be a good implementation for mutex lock and unlock we can get stuck what have we got? so this will become deadlocked we can't make any progress right so let's try this one. alright that um this time we're going to have not some flags because they don't seem to be working for us let's have the british solution we'll say no after you, okay? so we're going to say something like look we'll have this shared variable so turned is shared between us so we can take turns and i'm just going to wait until turn is set to my id and then do the critical section stuff and similarly you're going to do the same, you're going to check the shared variable that you share between us so there's not two turn variables there's just one in global memory somewhere and see if it's set to my id and I'm going to wait until it is okay and when it is I can do my critical section stuff and then i'm going to say okay it's your turn right what do you think of that solution is it any good yeah we're just considering this for just two threads right we'll worry about generalizing this to more than two later [pause] okay so could this lead to say data corruption? could we have two threads inside the critical section at the same time no, right it's impossible to continue unless you have the golden chalice  unless the turn variable has been given to you so hurray we have mutual exclusion again it's satisfied! alright but our critical section now is only going to have one thread at a time inside the critical part of the code two threads are not going to try and update our goal value or change the data structure at the same time or try to read it whilst another one is writing it. fantastic! we're done. but what's wrong with our solution? yes? okay it's not going to work if we add more threads to it uh but it is something that will run with just two threads uh if they try and update at the same time, let's have a look, so we'll let the first one go through and then a second one comes through but you're along the right lines, it's like what will happen if this thread actually wants to continue it can't! it has to wait for the first thread to actually do something yes, they become rate locked it's as if you and I have to use the bathroom at exactly the same rate, no it's your turn... oh i have to wait I have to wait to use the bathroom... no one's in it yes? but I still have to wait for you to use it there is something broken with this picture, yes? so what we have is a problem of uh, let's see I think... uhhh I have to look at the definitions, just a moment oh yes, progress there's no progress if no one's inside the critical section, I should be able to enter it so in fact there's three desirable properties that we need here and we've touched on two of them so what we'd like in our solutions is mutual exclusion, that one's pretty obvious yeah? we only want one thread or one process to be able to continue into the critical section the next one is progress so if there, I'll write it in terms of threads, if there are no threads inside the critical section we should be able to enter immediately or with the bathoom analogy, if there's no one in there I should be able to just use it I don't want to have to wait for you to give me a chain of keys each time, right? the resource is not being used, I should be able to use it the last one is something called bounded wait and I'm going to give a non mathematical definition of bounded wait, there's more technical definitions that you might use in later courses that I should be able to get into the thread... the thread can enter the critical section in a finite amount of time
okay so that's a little of loose definition other definitions talk about the number of other waiting processes or number of waiting threads that I don't want a little four year old running between my legs running into the bathroom and getting there before me that's going to be really annoying right? they should stand in line as well. There should be some kind of principle of fairness behind this that it shouldn't be the case that I'm just stuck there waiting for an infinite number of other processes to finish and they always get in front of me, they manage to somehow jump the queue, that's just no fair so we have this idea of bounded wait. yes? why does candidate three not have progress? because suppose you want to update it faster than the other thread wants to enter this critical section so we're stuck there waiting for the turn, waiting for the golden chalice to be given to you now, maybe the other thread may eventually call their code and update the critical section, do something inside the critical section but until they do so, you're just stuck there waiting so you could imagine I've got a thread that's writing into a an associative map  you've got a thread that's reading from it why should your reads have to wait for a write to come in? if no one's modifying the data structure, you should be able to immediately get in there and use it so this is the fact that you might want to say come in here twice as fast as this other thread is going to run, yes? yes, it's not efficient, but worse you don't know when that other thread is going to make that call so imagine you had one thread that it wants to walk through a linkedlist structure and another thread that might be changing that linkedlist structure you don't want to modify it whilst one is walking through the links okay? you want to get in there eventually, you don't mind waiting but it shouldn't be an infinite amount of time right, it's not fair if another thread continually just jumps in front of you and you never get a chance to use the resource for example right, so I've littered this lecture with trying to make concrete examples of why we care about the critical section in terms of accessing data structures but these are the three formal thing that we care about for solving the critical section problem. So if you care about reading the literature about this.. these are the properties in which we judge our success or not of our proposed algorithms so let's take a look at another one here we go so a reminder that we're not going to be executing this code all the time but the threads are going to execute this code more than once so we do other stuff and then repeat sometime in the future so now it's your turn take a look at this code and decide how could it possibly go wrong? This is tricky [silence]
okay let me tell you how hard this example is for giggles, when I wrote this little problem I challenged a faculty member assistant programming senior professor five minutes to find the problem with this and after three minutes neither of us had actually noticed the error yet so I'm pretty sure there's a problem with this but it took us more than 3 minutes to see it I'll give you a hint though, it does not satisfy mutual exclusion the question is how could that happen then? [silence] okay, so, before we talk about this code in specifics, I find that it's absolutely fascinating the fact that we can write something that just has a couple of booleans, just flags, simple flags [something] and a simple switch variable and a little boolean that says your turn or my turn and we've built something that couldn't be much more complicated and it completely fails to be handled by our poor little brain we have a really really hard analyzing this really really simple code for spotting it for synchronization problems and concurrency bugs so, anyways, let's see if we can kind of walk through this and do it carefully let's suppose for example right now that only one thread kept on using the resource, use this critical section here can we have progress? right so if we only have one raise my flag! wooohooo, if your flag is raised, it's not, great! I don't need to wait, I can continue to my critical section and I'm going to set turn to you okay, do I have a turn variable? yes here's my turn, wooo! right and lower my flag okay right a millisecond later, I want to do some more stuff for this critical section so what do I do? raise my flag! is your flag raised? no [something over there] right great so I don't need to wait, I can enter my critical section, I'm going to again set the turn to you and lower my flag so that seems to work, I'm able to enter the critical section if no one else is using it so progress is good right mutual exclusion let's see if we can argue that it works and then we'll argue that it doesn't right so raise my flag and is your flag raised? then if it's not I'm going to continue to the critical section meanwhile another thread comes along. alright so [noise] there's my flag, right. another thread comes along and says oh um I see your flag is raised then I'm going to just wait until it's my turn eventually that other code finishes and passes the golden chalice, this turn, to me! so now I can continue but they are only going to pass the turn variable to me when it finished, so the code works! right? oh what happy little brains we have because we're so happy excited to see that our code works um, no, it doesn't work the way to analyze this is to say okay I've got this turn variable so I actually have to do this analysis twice I have to say suppose the turn variable was set to the first thread before this stuff started or suppose the turn variable was set to the other thread before this mess continued and if you do that, then it is possible to break mutual exclusion here's how then first of all we'll set turn equal to two so there was some prior instance when we'd run through this code and turn ended up being 2
right that this is the solution then let's um, look to see what order things happen okay so I'm going to raise my flag and then I'm going to see if your flag is raised it's not, great! I can go into the critical section then the other thread comes along and says okay raise my flag if your flag raised? yes it is okay wait until it is my turn oh look at that, it is my turn so, enter the critical section three four five six, whoops so, by trying to introduce this turn flag to ensure progress we broke it, we broke mutual exclusion we have a situation where because of the prior value of turn, our code allows one way for mutual exclusion to be broken don't feel too bad about spotting this, there have been peer reviewed published papers in major conferences, in major journals that failed to solve the critical section problem yet claimed they did so in trying to solve this, in trying to come up with algorithms that actually solve this it actually advanced the state of the art in terms of how do we analyze concurrency and how do we analyze programs that do two things at the same time right so this is broken, it failed to satisfy mutual exclusion alright then, here you go, what do you think of candidate 5? see how far you can get in five minutes for this one [silence]
[silence] what's up? which one are you talking about? yes? mhmm. uh why is not your turn? no there's just one variable, ok. correct. okay just to read this code, there's only one turn variable  so when it says turn to win it's still the same turn variable okay so what I asked you to do is actually impossible this is a solution to the critical section problem this was the first published solution by dekker so let's see if we can understand some of the logic behind this as to how it tries to work ok so first of all, before we do anything else, we raise our flag, we are kind of signaling intent okay, I want to be inside the critical section so think about this flag as an intent, I want to go so then we have this while flag is raised right didn't we have this at the beginning of the lecture? yes we did and we saw how we could run into a problem of deadlock where both of them were waiting for the other thread to lower their flag but of course it never happened because thread one was waiting for thread two and thread two was waiting for thread one so what we do is to have a little bit more of a complicated logic which is to have a standoff and one of us will win and we take it in turns to see who wins in this potential deadlock so that's the purpose of this, so if it's your turn to win, then I'm just going to lower my flag and wait while it's your turn in other words, you've won! you've won this competition. I'm going to let you go so at some point though, you're finished and you've set the turn back to me, you'll give me the golden chalice or the trump card if you like what do I do now? well I don't continue immediately.  instead, I play another game with you. i say okay I'm going to raise my flag,  I've got this intent again to go into the critical section. but I'm not going to go straight in  I'm going to first see if your flag is raised so it's a bit like playing trumps except that we're going to take it in turns to see who wins if we do that, then we've solved the critical section problem namely that we have mutual exclusion only one thread or one process at a time can be inside the critical section we've got bounded wait, what do we mean by that? well a rough definition is that I only have to wait for a bounded amount of time a more precise definition is that I only have to wait for one other thread or process to enter the critical section and then its my go and we've got progress so if the other thread or process is not inside the critical section, I get to play immediately, I get to use the critical section, I get to execute that code it took many many years to come up with this solution and it took even more years, several decades before another solution was published, here it is between those times, there were many incorrect solutions published and so here is the last solution I'm going to show you today the original article from peterson  this might look like it was from the 1960s, in fact it was from 1981 that's how long it took to find a simple solution to the critical section problem that's how poor our brains are at how to cope with multiple threads or multiple processes it's incredibly hard to reason about this stuff right, I'm not going to talk about this but I will say the following first of all every systems programmer knows of peterson and dekker in terms of the critical section problem it's the kind of thing that should roll off your tongue in an interview secondly, yes I may choose to add a multiple choice quiz question based on these two solutions for example, does this code... is this code dekker's solution? or is this code a version of peterson's solution thirdly, I may choose to make other code which fails and I'm going to ask you in an exam quiz to work out whether it fails mutual exclusion, progress or bounded wait and with that, that's the end of today's lecture, if you have questions for me please come down and see me! thank you very much
[Om Monk Chant with Transcendental and Tibet Bells] so, what do we got. overhead. right so, here's our requirements that we'd like know that first of all, we only want one process or thread to be inside our critical section at a time what do we call that? mutual exclusion in other words, if you've taken cs241, I don't want to see you taking any other courses yes, your time is mine! said cs241 right, what about this then? if waiting, then another process or thread (if you're talking about threads) can only enter the critical section a finite number of times what do we call that? this is a better definition of bounded wait if you're waiting to use the resource, if you're waiting to be inside the critical section it would be unfair if another thread just kept on jumping in front of you in front of the queue so we want a solution where eventually we get to go in alright and then if no other process is in the critical section then the process or thread can immediately enter the critical section our code should be efficient. it shouldn't have to pause. if there's no one inside the bathroom, I expect to use it straight away alright, so, what's that called? progress! yes. so those are our three desired properties that we're going to evaluate alright. now there's um, one more thing that I think that I should mention is that we're talking about pseudocode right now. but today, if you were to look inside say, mutex lock, and you were to drill down to find out exactly how it worked, you might discover that it uses something called the exchange instruction so many processors today will implement either test&set or the exchange instruction what do you think the exchange instruction does? okay, it exchanges something, yes, very good, but what might it exchange? how about a value inside a register and the contents of memory so it swaps them but here's the critical part: is that it does this atomically. it does this in the guerilla fashion. it walks up and it exchanges your hats actually no, I'll take your cellphone, that's more valuable, right? for the microphone oh yeah and in doing so, no other CPU is allowed to interrupt that process it completes as one logical step. here you go, you can have your phone back so that way, we can actually use it to implement our mutex lock because only one thread will win we can make sure that only one thread gets to put a certain value inside it so, it's an atomic instruction, why is it useful? well, to implement locks! we don't have to worry about officially catered code down here and it works even if I got say more than two threads trying to compete to lock something okay, alright, next thing we're going to talk about is condition variables I'm going to introduce them now, we'll let that simmer in your brain and then the second half of the lecture we'll come back to them so like I said, this is the cool bit condition variables sound like they hold some sort of clever value they don't uh, their name actually is very good at confusing beginners the way to think about condition variables is that you can make your thread meditate what an exciting lecture isn't it? okay, right! so we can put a thread to sleep... and then....it will stay until another thread decides to wake it up. now, you don't need to actually scrumple up a piece of paper and throw it at the other thread the system will do that for you you can just make a call, you can say hey, signal!" and, at some point, you know that the meditating thread will be woken up by the system so it's a communication pattern. it's a way for one thread to wake up another so we can use this and we can use this so that our thread can wait until something is true, but we need to write that, so that's the idea of variable comes in. we are actually going to write a condition. a truth that we want to be true but, until that truth happens, until that test happens, no magic is going to happen. we're just going to write a little loop (a little white loop) until that truth has happened we're just going to put our thread into a meditative state alright, that's the idea they're not very complicated. they're not fantastic and clever, they don't know what the condition is going to be. we're just going to write a little while loop that says ok, while there is no good coffee at bervandes, meditate" it'll be a long time
alright, but at some point, we'll write another thread that says ok, guess what? I've delivered great coffee to bervandes, and you saw it, and you wake up your meditating monk, aka your thread" at this point, the monk wake ups. okay, I better see if there's good coffee at bervandes now alright, now, there's a little gotcha here, which is that sometimes monks wake up by acident this is called a spurious wait in other words, we'd like our monks to meditate forever until we do the little tip symbol, yes? ding! wake up unfortunately, it's not a perfect system. they may wake up by accident. but that's okay, because we will write a little loop to say, okay! before you attempt to purchase any coffee, actually go and see if it's any good" and if it isn't, guess what I'm going to ask you to do. go back to sleep. continue meditating" alright. now, there's a little bit more to this course. for starters, I've suggested that you can signal a waiting monk. you can throw something at them turns out that actually normally you can use wake one monk you can get the largest gong you can buy ebay and bash it like hell wake up all of them because maybe you want to wake up a lot of monks so that's a design decision. we'll see how we can do that in a little bit alright so that's the beginning of condition variables we'll let that simmer into your brain we'll come back to that in the second half because right now, hahaha. I've got some more critical section problems for you to look at I've written four potential solutions to the critical section and remember, what are we trying to do here? well, I've got some code here (my critical section stuff) that's only going to work if I've got one thread or one process at a time inside that code so I want to make sure that if I happen to have two threads or two processes attempting to get there, that one of them will lose one of them will have to wait until the first one has finished and remember, all code runs more than once so you can think of the critical section, for example, as using a data structure or updating a data structure. you don't want these two things to happen at the same time. I'm not quite sure how often this code is going to be called. but we do have our three desired properties. we want mutual exclusion so only one thread or process can enter the critical section at a time, bounded wait, and progress so, I've got some problems here, and this is where your neighbor comes in, because I'm going to ask you to actually evaluate these in terms of those properties and see whether they are good solutions to the critical section problem or not and I'm going to come around and answer any questions you might have [long pause]
[long pause] okay so let's have a look at the first one we have a flag and in this case, our flag represents an intent to go into the critical section because inside this while loop, we actually may lower our flag. we actually may say yeah, well, I give up. it's your turn" so if I see your flag is raised, then if the turn variable is set to you, then I'm just gonna say okay, actually I'll let you go ahead" so I'll lower my flag. I know then, therefore, that the other thread gets to win! they see my flag has gone down so they can go into the critical section but they're not going to raise my flag so before going into the critical section, my flag will always be raised alright, now I go around again so, let's go around again now, if it turns out that I've actually had to wait like I just did, then this time, it's my turn to win. so I'm not going to back down the second time. I am just going to now keep waiting until your flag goes down and because the turn variable is set to me, then I win this round I win this second time so I know that I can continue at some point at some point your flag will go down either because you've finished this other critical section or you've deferred to me so in fact, what we're looking at here is dekker's solution. so this was the first solution to the critical section problem and we're looking at, of course, the version which works for two threads but I hope you can see that the flag represents kind of an intent to be inside the critical section right then! so what about version two? yeah, we're raising a flag and this time, it's a kind of no no no, after you" so now we have a little loop that we keep going around. if your flag is raised or its your turn, I'm just going to wait what do people think about this? candidate solution? no progress? no mutual exclusion? no bounded wait? no progress did someone say? alright so let's have a look. so, if I set the turn to you, and then I'm going to wait if its your turn well that's, that's like walking to the resource and just standing there because no, I want someone else to go in front of me. I'm scared" I should be able to use the resource if its right there and no one else is using it. I want to have that piece of cake. I want to be able to enter the critical section so we've already identified that it fails at least in terms of progress there's no progress here it gets stuck waiting for the other thread to come along and kick the turn variable back to the first thread or first process so, we've found a problem here: no progress alright, um, what about the third one? I'm gonna raise my flag, this time I'm being selfish, hey! it's my turn! this is the toddler version of the critical section solution I see the cake. I want to eat it. it's mine. I saw it first alright so, I'm claiming set turned to me, and now I'm just going to wait while your flag is raised or it's your turn what happens here? so you could imagine, that we do one, two and three, alright, so if there was no other thread, then great! we're going into the critical section alright, now we've cured the problem of no progress here. so let's see if we can make it a bit more interesting. suppose another thread comes along and raises the flag now we have to decide who's going to set the turn variable last ok so, for now, let's try like this we'll set turn to me, and then the other thread says set turn to me so what happens now? the first thread says oh look! your flag is raised! I better wait!" and what does the other thread do? oh look! your flag is raised! I'd better wait!" it's like a four way stop sign in Wisconsin oh! I see you've arrived! I'll wait for you!" that was not a Wisconsin accent, but you get the idea we start talking about cheese perhaps. but we got a problem that now both threads have claimed its their turn but we've reached a problem where they're both looking at each others flags and so we get stuck so we actually have deadlock. we've again showed the problem of we try to fix progress but we failed there is no progress here I'm going to make a little change to this program I'm going to say what would happen if this was an AND?"
and, if we do that, we actually have Peterson's solution so now Peterson's solution says I'm only going to look at your flag if the turn variable is pointing at you" otherwise, I'm just going to be the bully and walk in now, I'm not going to spend twenty minutes to prove that this works because we'd actually have to look carefully at the possible different sequences of how this could work well I'm going to kind of just do a little bit of hand waving which is - I think you can agree that by the time we get to the wait loop, one of them has set the turn variable so the turn variable is either pointing at process 1 or process 2. one of them has finished doing that most recently so, one thread will wait. and the other, will continue. so we've solved the progress problem right, so dekker and peterson are two solutions to this and every systems programmer should be able to kind of recognize how these solutions work sorry, at least be able to recognize these solutions you'll notice what peterson did, what peterson noticed was this. was setting the turn to me before the wait that was his insight to say oh look! if I change the turn variable to me, BEFOREhand, I can actually write a really really simple solution" and like I said, that wasn't actually discovered until 1981 okay, what about the last one? does this work? what about algorithm 4? or solution 4? no progress again! yes, we can have a case where both sides are seeing each others flag being each others flag is raised and so we get stuck alright so, we've worked out two possible solutions. dekker's solution and peterson's solution here. through that minor change here how about enable us to actually implement a mutex lock and unlock? what part of the code would you put inside mutex lock and which part would you put inside unlock? alright. it's actually not that hard, right? let's use dekker's solution. we'll say this is the pseudocode I'm going to put inside the lock and this is the part that we'll put inside unlock and we better write some documentation to say that our code actually only works for two threads and if you want to use this for more than two threads, you better pay me more to think real hard about how to generalize this okay so, not bad for a morning's work! look, it's only 11:25 and we've already figured out some code to write mutex lock and mutex unlock. unfortunately, we come back a moment later and people say, wait, you know what? okay, it failed! what do you say? this is impossible! I learned this in class! this is a correct solution. I even proved that it's correct it doesn't work it does not work on modern hadware here's why the C code that we write even the assembly code that we write, does not always correspond to exactly what happens in the hardware we try to make our hardware run as fast as possible. so, here's some things to abide to first of all, we can have a cache problem that what CPU thinks is in memory is being provided by the cache on the chip, on the CPU so if we've got two distant CPUs, they may not update the memory and notify each other that the value has changed so all this stuff about testing a turn variable and looking your flag, I might actually be looking at stale values that have not yet propogated from one CPU cache to another CPU cache a second problem is that actually our CPU can execute instructions out of order now before you panic and say oh! whats gonna happen to my code?" don't panic too much. actually all the stuff we're going to do with pthread_mutex_lock ensures that the all the instructions up to that point are fully executed and completed so, I'm not going to talk anymore about how this can bite you. other than don't panic because guess what, we've got the exchange instruction that we can use at the lowest level to make sure that we really do have a complete round trip to main memory as opposed to dealing with stale values in the cache okay, right, any other questions about these? when we have an exam, when we have a quiz about this stuff, I will be writing these kinds of problems and asking you to figure out if its a valid solution or not. or if it is a valid solution, whether its dekkers solution or peterson's any other questions? good! we have round two! here we go, condition variables! alright, we're gonna write some code that actually uses a condition variable okay so, along the way I'll write some pseudocode I'll turn into real code and I'll talk about some gotchas so for example, one common gotcha is that we forget to actually initialize this stuff if you forget to initialize it, then yes you still got some memory reserved but it may not be connected to any actual real system resource that does some of the work for you so calling your mutex lock unlock may just silently fail because you never bothered to initialize it correctly so that's just a common gotcha so, if your friend leaves their workstation or their laptop open for a moment, just quietly walk over and delete their initialization code. they'll never know and they'll be stuck for hours alright, so how do I have these things, how do I create these things in my code? guess what? the pthread library gives you one, here it is. I'm gonna have this little variable called cv and you might notice in this code I've got a mutex lock as well it turns out that whenever you need a condition variable, you are going to need a mutex lock as well it's like the little side kick that comes along to the party you can't uninvite them. I'm sorry they just won't come together as a pair you're gonna see a mutex lock and a condition variable together why? because a mutex lock makes our lives much simpler the mutex lock allows us to reason that one thread at a time is doing things inside a critical section
and remember, that makes our life much easier. when we can say, oh look! i've got multiple threads happening somewhere in my program, but in the stuff that's really complicated, when I'm changing data structures or reading data structures which might be changed, I just want one thread accessing this stuff so that's what my lock is for alright, so here's my incredibly complicated data structure, it's called an array, here it is and I've got the count that counts the number of things inside my array and as they are global variables, we know they are going to be initialized to zero okay, so, here's what I can do to my data. I've got something to add something into my array, to push some data in, and I've got a method to delete something! which all it does it just reduce the count and hopefully we'll assume that no one tries to delete more items than there are ok, I'm also going to have a getLast() method so getLast() we could, if we're inside cs225, say, I'll tell you what, I'll just return a bad value if nothing is actually in there already but no, what we're going to do is make getLast() wait we're going to make sure that it doesn't continue until there really is at least one value inside our datastructure alright so, here's the game we're playing there's one thread that's going to be calling push data and delete and it might do it several times. I've got another thread that might call getLast() several time right, so we're going to develop this code slowly but here we go. so, here's the plan. any time we want to deal with condition variables, we're going to write something incredibly incredibly simple. just a busy wait. just a simple while loop that keeps testing something right so, this is the code that I'm scared about. right. I'm going to try and get something inside my array but what would happen, for example, if the count is oops this should be count - 1 here we go what would happen for example if count was zero? it means my array doesn't have anything in it so, I need to say the following look, while count is zero, don't carry on." so while count is zero, just go around and, who cares about burning up my battery on my cellphone. alright. it's easy code to write this is the kind of code you might write if you didn't come to cs241 you know just [something] count is zero, doesn't matter, just keep going around" eventually, at some point, count will change and that's fine of course, that code might execute a billion times and used up several milliamps of current or milliamperes of power and um, but it's the best we can do, right. I'm going to show you how we can do better so how can we fix this code? well first of all, we can see there's a race condition, right, that I don't want these methods to run at the same time so I'm now going to put my locks in alright so, here's what I wanted to do. I'm going to call my pthread and pthread's a lot to write so I'm just going to write p pthread_mutex is a lot to write so I'm just going to write m lock and, pass in the address of my little lock structure and at the end, call unlock and, suddenly our code is easier to read. we don't need to worry about say, two threads calling pushdata at the same time even if the problem says that never happens my code now says because of that lock, only one thread can ever be inside that little piece of code" and similarly, here, if I lock on the same lock I'm conpletely confident that even if you tried to call pushdata and delete at the same time from two different threads, the code would still work one thread would have to wait one thread wins the lock and can continue and change the value of count. the other thread has to wait until the mutex is unlocked and then it can lock the mutex and carry on alright so, the lock call may take a bit of time if someone else if currently in the bathroom, you're going to have to just twiddle your thumbs and wait until that lock has been unlocked we're good, okay, we're fine so far right? this is not complicated so far. this is easy stuff, yes? yes? I know it's a monday and the weekend was great but come on, this is not too bad alright so, now, haha, right, now let's see what we should do over here um, before checking this count, I should make sure that no one else is touching it alright? that no one else might be, say, changing its value halfway through so, um, before doing anything with these shared variables, let's put a lock call in at the beginning. there we go. we see how our code is becoming littered with these lock() and unlock() calls, yes? alright, so we write this code, what happens? if we tried to test it at this point? this is the, what, freddy mercury who wants to live forever code? alright so my. I'm fine if I'm just calling pushdata and delete things can bad though, the moment I call getLast() because, getLast() locked the mutex, so what would happen now, to any other code that calls pushdata and delete? they get stuck! yeah, they get stuck inside their lock call waiting for that lock to get unlocked which as we can see from the code is never going to happen. wahahaha. alright, so we've got a problem we can even imagine as well that this count, if this was zero, then we can get stuck inside this loop, and because we don't unlock it, pushdata will never happen so, here's how we're going to fix our code now we're going to unlock the mutex, meditate, me-di-tate, with our condition variable after we finish meditating, lock the mutex again
so if our count is zero, go into a restful, peaceful state, but you say how can I wake my monk up if its meditating?" okay, when should I wake it up? do I need to wake it up in the delete()? no! because there's no way it could've fallen asleep then. it's going to fall asleep if the count was zero so, when should I wake it up? after I've incremented the count there's no point kicking the monk before that point, yes? because if I do, the monk will wake up, come out, eventually it'll be able to lock the mutex, it'll check the count again and say oh!" so I'm going to write the code like this. I'm going to after here, after we're kind of ready, kick the monk of course, if you're not feeling so violent, you can have one of those little bells. ding! and signal the monk to wake up alright so, we kick the monk! they wake up out of their meditation! they attempt to lock the mutex, but they can't because guess what our other thread has currently got it locked, so they're stuck in the lock call but in a moment's time, we will unlock the mutex. when we do that, the monk on this side is able to lock the mutex and continue. the go around, back to their while loop. hey look at that! count is no longer zero! great! I can continue! quick, get the array! get the last entry of the array! fantastic and return it alright, is my code complete? no, I've forgotten to do one last thing which is at the end, unlock() the mutex notice I put this after reading the array why? because I want my life to be simple. if I'm going to look at the array, if I'm going to look at the count, I want to make sure that I'm the only thread that can do so how do I do that? by owning the lock any other thread that attempts to say push more data in" or "delete stuff" has to wait because they have to get the lock first. yes? you could do the kick after the unlock() almost, but there's actually a subtle race condition that I don't want to talk about today. so for now, just put it inside okay? alright, now, some comments on here. so this is how I want you to think of a condition variable. look, there's always three steps we better unlock stuff, because if we don't then I'm going to be meditating forever the rest of my code can't continue. it can't do its stuff to the array structure, it will never kick the monk because it will never get the lock so we must unlock it then we meditate and then, because we want to check our variables, we better relock the mutex alright? now I have some wonderful news for you all three of these things that we do here, happen inside cond_wait() actually, it's just one call so the most important thing in this lecture is to remember that cond_wait() actually does three things. before meditating, it's going to unlock the mutex that you give it why? so that other things can actually access the data structure and do things and the POSIX call is not called kick the monk" or "ring a little symbol" it's just signal or cond_signal, to be precise and you pass in a pointer to the condition variable so here's what happens. when you call cond_signal, you're saying to the operating system please, at some point in the future, find a monk that's meditating and walk up and do the little symbol. ding!" wake up the monk if you call cond_signal, the operating system's only going to do that to one monk if it can find it. if there's no monk's meditating, it won't bother it is also possible to bash the gong and wake up all monks which are meditating but we don't need to. well, we don't need that today. we know that from the problem specification, there's only going to be one thread inside getLast() later on, we'll see examples which do that
okay, right, so, now, this is where you come in remember how I said, OSX doesn't implement semaphores? well guess what, it's your lucky day! you are at Apple and in the afternoon, they accidentally left you access to the source code so you decided to actually implement sem_wait(), sem_post() ecetera for Apple so we can actually get these things working alright, and we can use condition variables. condition variables are more general, they're more powerful than semaphores because we get to write any condition that we want inside the little while loop so, how would you write these things? okay, how do we implement our semaphores? okay, so what do we need inside our semaphore? well, we need some sort of count to remember when that count gets to zero, then our sem_wait will wait and presumably, we also need some sort of pthread_mutex_lock there we go. and we'll have a pthread_cond variable there we go so with both things inside our semaphore, now we can figure out how to write sem_wait() and sem_post() so, what's the first thing we should do inside sem_wait? we're going to be accessing our count variable so before we do that, we want to make sure that we have sole access. exclusive access to it. alright. so what should we call first? yes! let's lock our mutex alright, so, pthread_mutex_lock, and passed in a pointer to that structure so we'll do s, get the lock um, we'll make these little pointers just for speed today. right, and at the very end, we are gonna unlock stuff as well so, when did we need to actually meditate? when did we actually need to pause? so if the count is zero, then let's send this monk to sleep. let's send this thread to sleep. so now we can call pthread_cond_wait and you'd pass in a pointer to the condition variable and a pointer to the mutex and remember, that does three things for you. it unlocks the mutex, sleeps on the condition variable, and when eventually where it wakes up from that meditation, it's going to relock the mutex before returning so one way to look at this code is that inside this code, at all times, the mutex lock is actually locked in terms of the code that we writing. in terms of say, checking this count. we know that that mutex lock is always locked it's only if it actually goes to sleep inside this cond_wait will the mutex lock become unlocked alright so, we get around there. and the last thing we need to do in our wait call is to reduce the count so, in our count structure, reduce it what would happen if two threads called sem_wait at the same time? doesn't matter. our lock would ensure that only one of them wins. that only one of them executes at a time so maybe the first thread will successfully call sem_wait() and continue. the second thread, though, calling sem_wait() might see the count value zero and then it's forced to meditate alright, what about our post? our post is not going to do any sleeping. it will increment the count okay, oh! look at that! I've touched part of the structure. I better make sure that what? what should I have done first? get the lock! yes. okay, so pthread_mutex_lock() and pass in a pointer to the lock that everyone's playing with there we go so now I know when I get back from this that I've got exclusive access to this data structure because all the code I'm writing always locks the same lock and now, I can call pthread_cond_signal() on the condition variable and finally, unlock the mutex. so this code would work but we can do a little bit better which is that our post is always asking the operating system to find a sleeping monk and ring the bell and, we could do a little bit better reasoning about this, we can say well hold on, the only time that there could be a sleeping monk is if the count is actually already been reduced to zero so if I've just incremented the count, then I'm going to wake up one monk so if the count has just been incremented to one, now I know that I should try to wake up a monk. if there happens to be no monks waiting, doesn't matter. that's okay, that's not my problem but for the other times, if count says greater than one, then there can't have been any monks waiting. there's only going to be monks waiting if we've reduced the count down to one. alright and in here we write the standard code to initialize our mutex lock and our condition variable okay, and with that, we're out of time! I will see you on wednesday and you will have a quiz on friday! more about that on wednesday a reminder that malloc part 1 is due today come down and, it is isn't it? come down and see me if you have any questions! welcome to condition variables
Apparently my head cold managed to confuse me so therefore I confused you and I gave you an incorrect delta to those examples to show you peterson's solution and what I did was incomplete this is peterson's solution it is in the book, the wiki book the wiki book is very new  I only started creating it last semester it is an experiment to say what would happen if I after every lecture I wrote some notes and rather than just put it in a pdf, actually make it a wiki page so the wiki book is yours to edit and to add to eventually we'll actually turn it into a hard copy and I'll charge eight hundred thousand dollars for each one right no I'm not going to give it to Peterson or any of those other vulture companies I'll eventually have a hard copy and basically sell it at a bit over cost but until we do that it is available on the web you too can edit it, you too can improve it and in fact i'll be talking partly about that on Friday there is a conference where we talk about educational technologies and I've got a talk about that and also about the linux in the browser project which you too can play with and it's all in the cs 241 home page and you too can help develop it if you wish so i have several people doing improvements on that project as part of their senior projects for example I also have another group adding subtitles, captions to lecture videos and are looking at crowdsourcing for that so lots of good stuff right so we've talked about that i'll tell you about some more news in a little bit right now let's turn our attention to today's little challenge here the first challenge is relatively easy but it's still nontrivial what we're going to do today is make a barrier so we talked about okay we can create all these threads and one way to program them would be to say create a whole lot of threads which work on a little problem and join on all of those threads and we wait for them to finish that's a perfectly reasonable and simple way to use threads but we can do better now that we know that we've got these primitives that can stop and wait we can make our threads wait for each other  so before going to a part b of an algorithm let's wait for everybody to finish part a so this is basically like before closing the door of an elevator and going down to the next part we want all of our other threads to finish so that's the idea of a barrier we can implement this using semaphores and we can say that we're going to look at using condition variables so remember what is a condition variable? it's nothing particularly special it just allows our threads to go into a meditative state and not use any cpu until we wake it up but it's called a condition variable because we've put this inside the loop that tests for some condition so let's look at our little story here and see what we can do here there we go right so I've set up a typical little problem here that hey I've got a lot of data here it is a big array it's in global memory so that makes life easy and I've got a calculation I want to do on it fortunately I know about threads so I'm going to split my big array up here into chunks and if I've got two hundred and fifty six blocks why don't I split it up into sixteen chunks for my oops I'm just looking down here if my x so this is now x and this is now y, nevermind so my x values are going to be rather than one thread going from zero to two hundred and fifty five I'm going to get each thread to work independently on a segment of this matrix alright so if we have a look at this  this is what we've got here in my main I'm going to fire off N threads okay so we'll define N to be say sixteen wouldn't it be nice to have a sixteen core processor well you too can right now either just spend a lot of money or wait three years and it'll be easy so it'll be cheap so then we'll start say 16 threads I want to ask each one of them to do a chunk of the work one sixteenth of the total amount of work okay so great we've called pthread_create what's the first argument we pass into pthread_create? yes we are actually going to pass in the address of that the address of where we want pthread_create to store the the thread identifier so how do I write that I could say ampersand okay here's my little array and I want the i one that's probably the most readable way of writing that an equivalent would be to say ids + i is that true? so think about that or test it part of it becomes what's the size of this what happens when you add to it I'm not going to write that today I'm going to go with this right so we've got the address of where we want to store that identifier we don't need to set any special parameters for our pthread_create we're going to pass in this calc function that actually does all the work for us and finally we say (void*) i right so what are we doing here we're taking that little integer and we're turning it into a pointer you can that in C, remember it's just a bit pattern being converted into a similar bit pattern but we're saying that the type of it should be treated as a (void *) pointer why do I that, that's because that's the argument type and that will be okay provided we don't actually try to follow that pointer into memory remember it's just a value 0 1 2 3 4 5 6 7 8 9 10 11 12 13 15 okay so at the end of here I'm going to wait for my threads to finish okay so here I'm just going to call pthread_join and this time pass in the value of my little identifiers and I don't actually care about the exit value otherwise I could have passed in a pointer to a void * to grab that and then I would write some code to print out the result which I don't care about so that's the outside of my algorithm, start all these threads, off you go, sixteen people start doing your work I'm going to give each one of you a unique number and then wait for them to all finish by calling pthread_join now the main part of this puzzle starts okay we're going to write our little calc program we know that our pthread functions take a void* and return a void* so I've got some pointer, I don't actually want to use that variable as a pointer though I just want to cast it back into an integer so no memory lookups were used in this casting  it simply says hey I know you treat me as a pointer, I lied I just want to treat it as an integer and I went through those hoops just to make the compiler happy and I'm confident that a void* pointer can hold the integer between zero and fifteen right so that's going to be my starting point my end point exclusive would just be the starting point plus sixteen so now in my little loop x can go form the start almost to the end and my y is going to go through all of the remaining 8192 entries right and then I do my calculation that's going to take a while now you might say really all sixteen threads are going to run at the same time so they are all going to finish at the same time well that's not quite true it could be that one of these threads starts very very late it could be another thread starts completely earlier  it depends on how the operating system decides to schedule these threads it could be that a cpu is temporarily stolen to do some other work like process an interrupt because you pressed something on the keyboard something arrived on the network something arrived from the disk so you're not guaranteed to have the CPU for 100% of the time so we're not quite sure when all of these threads are going to finish so that's where we come in now we're going to try and write some code in here so that we can make sure that we don't continue the second calculation until all sixteen threads have finished so what are you going to do how are we going to solve this? what do we need? I need some ideas we could potentially do this with a semaphore kind of, what other ways could we do this though? okay yes we need some sort of global count variable just keep track of how many threads are currently running we're not going to try and directly query these threads we'll just have some sort of global variable that all the threads can decrement to say oh yeah I finished okay so up here we'll have an int remain and we can set that equal to sixteen or N if we want to so when I actually finish my work, each thread will decrement remain now notice what I just said when each thread finishes, it is going to decrement remain at this point, alarm bells should go off okay very quiet ones inside your head because I've just said that more than one thread is touching a data structure so there's a potential race condition two threads might decide to decrement remain at the same time whoops we don't want that we want each thread to have exclusive access to this remain when it's actually manipulating that so how do we ensure that happens yes bring out your mutex lock maybe it looks like a giant padlock or anyways nevermind so yeah we'll call pthread_mutex_lock on our mutex okay so this takes a pointer to that data structure at this point alarm bells go off and say oh hey did I actually remember to initialize the mutex and the answer is yes yeah you did if you actually managed to write the correct function these are pthread_mutex_init is one way to initialize your mutex lock right so if we do a lock, we know that any other thread that comes in here has to wait it could be then that those other threads that have not yet finished in which case the thread that is running this code  we want it to go to sleep okay well let's suppose I didn't know about condition variables then I might say something like while remain is greater than zero do nothing wohahahahaha we laugh at that code wohaahaha why? because we do know about condition variables, but why else? yeah the first thread that gets in there is just going to spin around and round and round and round it goes the second thread when it finishes will attempt to lock the mutex are you prepared to wait? yes i'm prepared to wait right then the second thread that finishes will get stuck inside pthread_mutex_lock waiting to lock that mutex, but we can see from this code that that mutex lock is never unlocked the second, third, fourth and fifth and the remaining fifteen threads will never get past pthread_mutex_lock because that mutex lock is never unlocked wohahahah alright so how can we start fixing this code well here's what we are going to do rather than just having a busy loop where we continuously burn up CPU time we are going to call pthread_condition_wait and for that you pass in your condition variable and pass in a pointer to your mutex lock and every good systems programmer knows that is when your thread meditates it goes to sleep but before it goes to sleep what happens? what do you get inside here? for free, what's it do for you? hint, we have to pass in the pointer to the mutex why? because it's going to unlock that mutex for you and then go to sleep alright so one of our threads arrived here early and said look remain is still non zero, I'm just going to sit here and chillax" yeah i'm not going to do anything, I'm just going to go into my meditative state the very last thread, the sixteenth thread that comes in says oh look remain is finally zero, I don't need to sleep, I can continue!" so I'll unlock and off we go and the sixteenth thread to arrive will then do the second calculation right so that's not a very good barrier right? what do we do? we wait until the sixteenth sheep finally arrives that was enough weight to tip the balance and the sixteenth sheep could continue and all the others are left there waiting, sleeping, yes? we'd like a way to wake up those meditating threads how do we do that? yes broadcast, we want to not just wake up one sleeping thread with a little bell, ding right, if you call pthread_condition_signal the system will choose one arbitrary sleeping thread and wake it up we don't want to do that, we want to wake up everybody so this is like running over to FARPAR and shouting free ice cream right? everybody comes over actually any free food at FARPAR will work but so how can we do this? well here's what we'll do inside our code, we need to call broadcast now I could do it even before the while loop here I could say okay pthread_condition_broadcast" and here's the way we're going to wake up, anybody who is sleeping on this particular conditional variable now will this work? yes, here's what happens you wake up everybody in FARPAR and they check and discover that actually there is no ice cream so they just go back to sleep okay so that's a silly analogy, but what happens in the code is that we wake up everybody inside the condition wait and see look we wrote it inside a while loop so everybody wakes up, eventually they get to run on the CPU, and when they do they'll say oh look remain is actually still greater than zero" so this code will keep waking up every time a thread gets to this point, it would run it so we could do a bit better than that we actually don't want to always wake people, we actually only want to call this when we know that if remain is now zero, actually bother to wake people up alright so if I'm the last person in the gate, wake everybody up there's no point in waking other people up beforehand because they will simply check and discover that remain is actually still non zero and then just go back to sleep so that would work, it's just not that efficient this is more efficient, don't wake people up until remain is zero so that is a barrier, yes at the back? well the last thread will see the value of zero so you'll never actually go into this while loop yes I could have written it afterwards, it's still a good idea to do the broadcast inside the lock and unlock there's a subtle race condition we can get if we don't right and the other thing to remember is that condition wait actually does three things after being woken up from its deep sleep, before it returns, it waits to acquire the mutex lock again so that means you've woken people up but they won't actually start to execute this code they won't be checking the remain value until someone exits until someone unlocks the mutex so in this case the sixteenth thread will come in, see that remain is now zero, wake everyone up but now they've woken up but can't actually continue on this code yet because we're still holding the mutex lock so eventually we unlock and then another thread in here will say great! finally I've woken up and finally I've managed to lock the mutex thread and I can continue and what's it do? it just unlocks the mutex and continues and so on and so on for the remaining threads so this is really really powerful this is a very very powerful paradigm now because now you can make your threads do a whole lot of work, pause for each other, wait for each other and then continue to do more work, etc now you can write pretty good performant code in a way that you couldn't before okay any other questions? I'll give you a hint, I like to do things like show you code and say on an exam or quiz and say well okay does this actually work? is it efficient or not? or when might it break?" so you could imagine for example if we only did signal here instead of broadcast, we'd only be waking up one thread and the other fourteen of them would still be sleeping aha right so when we come to test this, A will be compiled so let's fix what you said pthread_cond_t there we go and then when we come to test it, it doesn't work what did we forget to do? initialize it, yes! remember with these things, we've actually got two steps you've got to A. make some memory somewhere of enough size and B. actually call init on it so inside here we need to do pthread_cond_init and if we were writing robust code, that's a null as well, we would check the return values of these
right, let's try this you should be able to write this code yourself and understand how it works now we're going to talk about the Reader-Writer problem the Reader-Writer problem crops up in all sort of places maybe in a web server, maybe in a database server and anytime you've got a data structure where you want to read it and update at the same time, you're probably going to run into the Reader-Writer problem so the problem is this I might have multiple threads that want to read from it and multiple threads that want to write to it if I've got a writer that is updating my data structure everybody else needs to wait I can't have two writers trying to change my data structure at the same time it's like two surgeons trying to do the cardiac stuff at the same time. it's not going to work it's going to end badly so we want to make sure that anytime we update data structure everybody else has to wait so if there's multiple writers waiting hey get in line, just one at a time please" however, most of the time we don't actually need to update the data structure most of the time we want to allow our readers to read the data structure we want it to be efficient, in other words more than one reader can read the data structure at a time sounds easy, yes? the reader writer question is a popular question in internship interviews by the way let's have a look at some proposed solutions and see what happens and by the way, another thing you can expect in interviews is hey, what's the producer consumer problem?" or how's it different?" OK, so how is it different? first of all, the reader-writer problem is harder! the producer-consumer is just hey, I want to throw some stuff into this data structure and I want to pull some stuff out of the same data structure and if the data structure is full then you need to wait and if the data structure is empty then you can't pull anything from it and you need to wait and we can implement that with semaphores or conditional variables as well but we'll see that later the reader-writer problem I've got multiple readers running at the same time N readers, that's OK but I only expect one writer at a time anytime I've got a writer everyone else has to stand back, the readers aren't allowed to access the data structure either great, I've defined the problem. let's see if this code works here's some example code, perhaps you and your neighbor can figure out if it's any good or why it's no good [students working, long pause] OK, so let's talk about one kind of common gotcha here is I've been giving you examples where I've made p_threads, mutex locks and conditional variables just as global variables you don't have to do it that way, you could actually put them inside heap memory for example, if we called malloc, we might say now give me the size of a p_thread mutex pointer" is that OK? no! I've just asked for the size of a pointer, that's going to be say 4 bytes on 32-bit system and 8 bytes on a 64-bit system I don't want that. I actually wanted the size of the data structure and unfortunately no one is going to tell you that you got it wrong it's just going to crash at some strange point in the future of the program so watch out for your asterisks  a pointer is not the same as the structure and good that we've initialized these things, presumably we have to make some more memory for the write lock as well how does this work? well anytime a thread wants to read, it first grabs the read lock and does reading stuff and when it's finished it unlocks how does the write work? anytime it wants to write it grabs the write lock, and it grabs the read lock! so it can only get through this stuff, it can only get to actually doing any writing, when it has both of these things so that means that no other writer can be writing at the same time, right? because I've got the lock and if I have the lock you that means you don't have it! You must be stuck inside the write lock so only one of us can actually do the writing this works great, yes? no, of course it doesn't, it's the first version! how is it broken? yes, our first problem is that only one person can read at a time. we wanted multiple readers to be able to use our data structure this is insufficient it fails in terms of allowing multiple readers it does a few good things though. it ensures that if a writer is writing then no one else can do anything so that seems pretty good let's have a go at version two and in this version we are going to have a couple of integers, which if they are on the stack I'd better set equal to zero and we'll keep track of how many people are really writing should read be locking write? it's not necessary the question is should the read method actually call write lock as well?" it's not necessary because the write also grabs the read lock so the writer cannot continue whilst anyone actually has the read lock good question, thanks we'll keep track of this somehow whether reading or writing is actually happening what do you think of candidate two? is this any good? [long pause] so you could be doing reading while writing OK, let's have a look at the logic that inspired this and then we'll see why it's broken so the logic behind this is trying to say, while someone is actually doing some writing, I'm not going to touch this. I'm going to wait so then we can carry on and I'm going to raise my little flag to say we're doing some reading" and then I set reading to false what's the logic that I did behind the writing is to say  while anyone is reading or writing, just do a busy loop. we'll burn up some CPU nevermind that, CPUs are cheap and then when we get past here we'll raise my flag I've got writing to do. I'll do my writing stuff. I've raised the flag so anybody else will be stuck inside their busy loops because I've set the flag to true then the readers will be waiting and any writers will also be waiting inside their while loop the code is fine! what smells a bit? it's not fine! we've got race conditions, just like we saw with the critical section problem with these flags we might be setting the flags a bit late and what would happen if two readers came in? the first reader to finish reading would set the reading flag back down to false it would look like no one is reading you could imagine two writers coming in both writing threads would see that reading and writing are zero or false and so we'll continue. oops! we've got a race condition so we're not doing very well here we're not checking our variables in a careful enough way and we're allowing readers to happen a the same time as writers I could imagine a reader and writer coming in at the same time and they both get past their while loops because neither of the flags are set yet because they are set later so if the two while loops happen at the same time, whoops! we've allowed both a reader and a write access to the data structure so this is no good, but don't worry, we've got a solution for you!
Let's see. I've heard the uiuc students are incredibly bright. Yes, they know how to party, but I've heard that you're really really bright so let's see if you can actually solve this problem yes you're going to need some sort of flags or counters to keep track and rather than set them to one or zero we should add and subtract as people come in and want to read and I'll give you a clue: you're going to need some mutex locks at least one lock and some condition variables we can start with one condition. let's do one condition variable you can add more if you want see if you can get something to kind of work with those alright, let's have a go at grading the solution here I'm not gonna do the complete solution today I'm just trying to do this in stages we've seen two broken ones, I'm now going to try and write something which is a little less broken towards a complete solution we're going to be touching these variables so I'm going to use locks to make sure that when we access the values, it's actually read/written by one process at a time so now in reader, what we'll do is we'll see if we've got any writers trying to do anything then I want to wait but rather than having a busy loop, I'm going to meditate here we go, condition wait and I'll go to sleep so, if I come out of that, I'll check to see if there's any writers and if there are, then I'll go back to sleep again alright, before doing anything, I'm going to increment my little counter here. the number of readers has now gone up by one and then I can actually access the data structures so I'll do my reading here then I'll declare that hey! I finished! hey, there's no more readers" and I can unlock the mutex yes, I can see that we've only going to actually allow one reader at a time, but trust me, for now this is a good stepping stone to a more complete solution what about the writers? well, they need to wait while there's any readers  (so any readers greaters than zero) or any writer greater than zero we want our writer to sleep great, I know a fantastic way to do that. let's call my cond_wait and pass in the pointer to the condition variable and a pointer to the mutex so we can only get out of this little loop once there's no other readers and no other writers before doing the writing, I'm going to increment my write count, then I'll do the writing afterwards, I'll decrement my write count and I'll unlock the mutex I've got my readers and writers sleeping. if they are unable to continue, they'll sleep. we never wake them up. we....probably want to wake them up occasionally, yes? we could try to be clever when we should bash the gong when should we wake everybody up but I'm not going to do that right now I'm just going to put the code in down here that says well look, if I finish writing, maybe there's another writer waiting" so hey, let me bash the gong here so pthread_cond_broadcast wake everybody up! alright, so, anybody that's sleeping, hey! wake up and check your condition, check your invariant, check the loop that you're inside do I need to do the same inside the read call as well? so if there's a writer that is waiting, we should call p_cond_signal. could it be that I've got new readers in here? cuz they might get the signal instead you can say okay! that's fine!" or you might say "actually that's impossible" and never happen. even if it's impossible, they still end up signaling someone, so I could either call signal or broadcast here so that's my next attempt. what do you think of it? it's better than the busy wait we saw a moment ago, but, what? thank you! right now, we've still got the problem of only one thread can actually do the reading because we lock the mutex. okay, we're going to have to fix that. other problems with it? okay, so you're worried about mutual exclusion. actually, the beautiful thing is that our while loop will be checked each time and because we've got locks here, we can reason abotu this much more simply. because we locked this, we know that only one thread at a time can ever be executing inside this critical section, inside this code that we've written hold on, I see what you're saying. but we're only incrementing the reader afterwards yeah, it's easy to see that initially, but remember we're going to wake these writers up but they don't actually check the values of r and w until we unlock the mutex okay so they're ready to go, they're about to run, but they don't get to return from this condition wait until we say so so they can only see a decremented version of the reader right so, we're heading towards a good solution but we've got more work to do one problem you might think about is, what would happen if I had a lot of readers? the poor writer is stuck! it never gets to change the data structure. readers barge in there and our read count never goes to zero so remember this magic saying called bounded wait"? which is about, don't let the small kids just run in front of you? if you've been waiting, there should be a finite number of other processes to allow to continue before you get a fair chance we haven't succeeded in that yet either but anyways, this is towards a good solution so now, I need to change topic because first of all, you have a quiz on friday! woohoo! it's about memory allocation you can expect these kinds of questions! alright, does code data heap and stacks inside your memory? you know how to use pthread, and pthread_exit, and pthread_join and what the differences between pthread_exit and pthread_join you know what free(NULL) does. answer: nothing pthread_create succeeds, what does it return, zero, you get the id by giving it a pointer instead can you use a function that's not thread safe in a multithreaded program? what the answer? yes you can, but you've got to make sure only one thread at a time accesses it gosh, when do you knew about pthread_mutex_lock so yes you can, but you have to be careful pthread join man, okay, so enough about pthread_join boundary tags, oh yes! here's a memory allocator that we did not talk about in lecture but rather than making allocations the size that the user requests, we can have chunks which are 2^n sizes so if I have a pool of a 1024 bytes, we can split that into two allocations of 512, for example or I can split this 512 into two allocations of 256 so if I keep my chunks at sizes 2^n then I can very quickly and efficiently find an allocation of the correct size so, for example, if I wanted 65 byte allocations, I would end up using allocations of 128 bytes and so, if I had 1024 bytes to play with, I could make eight of those allocations so you can see that this kind of allocator, which by the way is called the buddy allocator, suffers strongly from fragmentation I'm going to give you a block of 128 bytes, but you're only going to use 65 bytes of it so it can end up having a great bit of a unnecessary space, but the good news is that it's very very fast to find a free block of sufficient size implicit and explicit free lists? you've seen this now in the MP contest that we can have a separate list of free blocks so it's much much quicker to find a free block rather than scanning through a linked list of all free and allocated blocks, why not have a second linked list which only contains the free entries? so that's an explicit free list and if we do that, we can put it inside the unused space okay so you know about first fit and worst fit and how they work and you know what malloc() and calloc() do if they can't return the request. alright good, I have a moment left good news and bad news. I've got some sad news for you in a sense. monday and wednesday, I'm going to be in california so, robin is going to be taking this lecture slot. and she's going to be talking about some 241 content you're in safe hands. she's taught this course before I'm talking about andriod mook and representing illinois at the coursera partners conference this course, which ran in december 2013, we the largest ever course by illinois at 143,000 people signed up. we've since had 200,000 people sign up
... Good morning! If some of you don't know who  I am, I'm Robin Kravets. I'm a professor in the CS department. I have taught CS241 many times in the past although Lawrence Angrave has taken over and I don't get to torture you guys anymore. So it's not as much fun anymore. But he is out having fun in warm sunny California for the next two classes which means you are stuck with me. For better or worse Anyway, he gave me all the information to teach you guys. I didn't even have to give you the quiz that was done already. So we are going to focus today on some of the synchronization problems that he started on.  And get through hopefully deadlock on Wednesday.  So he left you talking about the reader-writer problems, producer-consumer problems, and one of the things that was assumed was that to make these entities talk to each other that there is some shared space between them. And I don't think there was any restrictions put on how he told you what this space would be. So in the best of all worlds we might just have an infinite buffer where we have somebody put some data in on one side and somebody taking it out on the other side and I could infinitely put in as much data as I want and take out as much data as was put in But in reality we know that infinity is never infinity. We can't implement infinity in a system So what we want to talk about today is understand what kind  of data structures and what kind of resources we can use to implement these shared data applications. So where one application is writing into a buffer and another application is reading from a buffer. ... So if we're dealing with entities where we have a producer and a consumer  And they are putting data into some buffer and the consumer is taking data out of there. What kind of limitations do we have if we're going to implement in this way? What's the first thing? Well at some point once I've filled up the queue I can only take things out as fast as the consumer is consuming them Vice versa I can only consume as fast as they're produced. But this is not an infinite buffer So what happens is the producer puts something in and puts a couple of things in and now the consumer is going to take them out And we put some more things in Now I want to put something else in. What do I do? I've hit the end of my buffer We can rotate around and wrap So let's let the producer now say let's go all the way back there and I can put my next thing in here
you can think of this buffer as something that we call a ring buffer where it's not you've kind of taken the two ends of the buffer that we're using and connected them on the other side so now i need to be able to put things in and take them out and i could just chase my own tail forever and never worry about running off the end so conceptually theres a number of things that i have to have to make this work so if i'm the producer what do i need to know what does the producer need to know the producer is putting things in it needs to be able to hit that so the producer what i filled up my ring ok so lets say im starting from nothing and the producer wants to put something in what's the first thing it needs to know where to put it! okay so let's have a pointer in here that says okay in im going to put it in there i just started some place random if i was smart my underlying data structure might have started right there yeah i wouldve wrapped the two ends okay so now that the producer has put something in what does the producer have to do it can't n isn't write anymore right you have to increment in to now point here that's where my next one would be so that's my producer what did my consumer need to know ill tell you it's out a pointer to what the first one that i want to take out so in this case it's here i'll make the consumer blue and as the consumer puts things in here, it's gonna slowly increment in to be there and as the consumer takes things out it will delete them out of the queue, out of the ring buffer althoguh i guess it really doens't matter and that's the next one to take out so there are two things i have to be careful about whats the first thing that you said before that i have to make sure that i dont what? i want to make sure that i don't overwrite data that hasn't been read yet my writers write, my producer is producing this is a big ring buffer i should've a smaller one okay i'm putting things in do i have to stop yet? no i can stop here but can i keep going? no i have to make sure i dont whoops that's in i have to make sure i dont overflow my buffers and now for the output for the consumer the consumer is going to start taking things out let's say it gets here it can still take that out but now it takes that last one out and now my out is here can it take anything out anymore? no if i allowed, if my program allowed the consumer to take something out at this point i would call that underflow overflow means that the producer produces too much and overwrites good data underflow means that my consumer is trying to take out something that's not there so those are two things we wnat to make sure don't happen we we're implementing a ring buffer so theres no underflow, and there's no overflow now i know you guys have done semaphores and you guys have done condition variables we're going to implement a solution for a ring buffer and of course we have a number of properties that we want to be able to have true for this solution and to start with we dont want any particular busy waiting so we want to make sure that our semaphores and condition variables are set up correctly and we dont have to have any kind of deadlock i know you guys haven't talked specifically about what deadlock means, but at a minimum it's going to mean that someone can't move forward so we want to be able to look at both of these things we want to implement a solution that can do that our first solution im going to give you my basic solution and from there i've been told you guys like to sit down and come up with your own solutions so i'm going to give you a basic first start so certainly whats the first thing that we need in our globals and initilazliation variables what are we trying to manage our buffer! right? so we need a buffer so i'm going to have a  and im gonna say im just going to have a 16 alright and then i need our two variables. what were the two variables i said we needed? in and out so since they are just pointers into my data structure they can just be integers im going to have an integer in and and integer out where should they both start they start at the same place? they start at diferent places? they start at 0? what should we do 0 we're going to initialize both in and out to be 0 so i'm going to give you a basic in queue and i want you to tell me if this works so i'm going to say for my enqueue im goign to put something in im going to put my value in whatever the in value is and increment in and my dequeue is im going to say that i have some result im going to save out my result becasue i want to use it later
uhhh and that's going to equal my data sub out i gotta increment my out too plus plus ++ and then i can return result so there's my solution very basic solution you guys take one or two minutes talk to your neighbors figure out what's wrong with this and how you would fix it are you ready? ok what's the first thing wrong with this? or what's something wrong with this? i'm not checking what? i'm not checking the equality of in and out why do in and out have to be equal? oh i don't want to be equal whats going to happen if i do that? yeah i'm going to try to remove data that's not there if they are equal what else aren't i doing? if not if  so if in equals 16 or more  it's not that i'm overflowing,  what am i doing? i'm overwriting what no what happens if in == 16? so what's going to happen if in == 16? not the answer how big is my buffer? yeah, well 16 0 to 15 if i write data[16] i am going to smash somebody's memory so not good so the solution was to what mod what else could i do? ok so i could mod, wait wait let me write that down i'm going to mod it so what if i do i'm going to change this to say uh data[(in++) % 16]  is that going to work? ok don't worry about the overwriting for a second is this going to help with my wrapping? is this a good solution to fixing my wrapping? there's one minor problem which is not so minor about this it'll work yeah it's going to work for a while and after a while what's going to happen? my integer's going to overflow actually my integer is not going to overflow it's just going to go negative and mod , if i understand correctly, can preserve the negative value so you're now going to get a data sub minus something accessing bad data  or just crashing i don't even know what the system's going to do if you put a negative value in your array so not the  it's the right idea you could actually be must simpler and just say ok that works too when i'm done so don't do this you could also if you really wanted to say n = n mod 16 that'll work too but that's not even that necesasry you only  have to change it if it is 16 and i have to do the same for what?  for out so not going to write that but i have to do the same for out so we've already hit on a bunch of problems that has to do with this. and the problem is all the overwriting and that uh we're not being careful about wha'ts going on and really the challenge here is there's no synchronization  i'm not synchrnoizing my readers and writers reader writer producer consumer enqueue dequeue all of the same idea basically what if i call enqueue twice at the same time is there any safety there?  no what if i call enqeueu and dequeue at the same time is there any safety there? no so let's assume that  we use this code for the actual functionality for the enqueue and dequeue and let's add some synchronization to it so that we can protect the data from overflow from underflow and from the synchronization problem of two nodes trying to put something in the qeueue at the same time and overwriting each other so we have to be careful we have to make sure that  only one node ony one enqueue can write into the ring buffer at the same time i'm teaching networking this semester so if i say node just ignore me
gets in your brain Ok Solution No2 Get that up there Okay!! I'm gonna tell you what we've got here. we've added semphores and locks I have two sempahores, S1 and S2 S1 represents my spaces in my ring buffer and S2 represents the number of items the i've put in my ring buffer if you think about it If i have space, i can put things in it if i have items in my queue i can take things out. so, that's good. I can go initialize them and move on. so now, you guys have done semaphores, right? what happens to a semaphore when you do sem_wait?  What does it do to the value of the sempahore oh did you guys talk about counting semphores? YEAH!!! if you noticed that we initialized one of these to 16 and one of these to 0 these are counting semphores not just mutexes counting semaphores if i initalized it to 16, what can i do i can call sem_wait  how many times? 15  and I can call sem_post  if i'm starting sem_pos 16 times. so what it's doing is it's giving me this ability to call sem_wait, m_queue 16 times or dequeue 16 items in and of itself that's not enough to make sure I don't break my system, but that's gonna be my counters to help me decide how many items i have, and how many spaces i have So my sem_wait on this one is gonna try to decrement  and sem_post, increment sem_wait increment Sorry backwards decrements sem_post increments so take a minute and look at this, and I can tell you this doesn't work maybe you can tell me why. Talk to you neighbors say that one more time Yes So i have initialized it to 0 but my max is 16 s2, i've initialized it to 0 with a max of 0 Let me double check the actual interface of Sem_wait while you're looking at this Sorry, i take that back. Ignore the first zero so, S1 is the semaphore, the zero is just whether or not it's shared across processes S1 is initalized to 16 and S2 to 0 Obviously I should not be writing code to make airplanes fly because they're going to fall out of the sky [something]. What's wrong? Yeah? so we're calling sem_wait and sem_post on the same sempahore my values are gonna change i'm gonna decrement and increment it right away and, how is that gonna implement my, how is that going to affect, write my dequeue yeah? so i'm going to call sem_wait on s1, which initialized to 16, that's good I have 16 spaces I'm gonna put something in. I'm gonno do sem_post and that's gonna increment it, and im gonna be forever be able to put things in
yeah, I've got this really wrong. alright, so my dequeue, is calling S2. what was S2 intialized to ? 0 which is Okay, there's nothing in there but i'm never changing it so I'm never going to put anything in there so i'm waiting forever my dequeue is never getting into anything and my enqueue is gonan run on forever so if we look at our requirements one of the things we asked for is that have we stopped overflow from happening is there overflow in this example? potential for overflow? what was the definition of overflow overwriting good data with something i'm trying to put in do we have overflow here? Yes, because the writer is going around writing writing and writing do you have underflow? Not really Why not? yes because dequeue can never really take out anything so you can really have underflow if you can't take anything out so this didn't work what else did I want to say about this do we have a race condition? is there any race conditions in here? no  why not? we've got our locks. So we can only have one enqueue in there at the same time and our dequeue is never going anywhere so it doesn't really matter actually it's gonna acquire the lock and it's gonna wait, and it's gonna block everybody from doing anything once anyone trying to call enqueue, the whole system is gonna come to a standstill so, we do have a deadlock. it's not a race condition but we've got deadlock and we'll talk more about deadlock on wednesday ok so, lets' move on we still have s1 and s2 still initialized to 16 and 0 so this is still spaces and this is still items what are the problems that you might noticed before from our prior one no matter what the enqueue did, it only affected S1 and no matter what the dequeue did, it only affected S2 so there was no coordination between the Enqueue and the Dequeue so i need to be able to tell the reader the dequeue that there's something to take out so for my next solution, i've mixed it up a bit so now i do a sem_wait on s2 and a sem_post on s1 and a sem_wait on S1 and a sem_post on s2 did that work Okay did i fix my problem? No oh ok, what did i do this time only dequeue could work this time why can't enqueue work S2 is always 0 so i'm starting on calling S2. I try to decrement it, and I've got a problem I did fix one of my other problems though did you notice what I switched? i switched the order of the sem_wait and the lock i' dont actually acquire the semaphore until the semaphore is released and that is very important because if I acquire the lock and I wait for the semaphore to be released but somebody is not gonna released the semaphore unless they've got the lock. i've created a bad problem called deadlock that fixed that a little bit Okay so the problem here was This one starts at zero, right? so whenever I call sem_wait on it it's just gonna block what about this guy Do i have overflow? Do I have undeflow? Why? Here what does S1 start at? it starts at 16 my first call to dequeue is gonna do a sem_wait on S1 and its' gonna say  Oh! Cool, it was 16 now, it's 15 here, so there' nothing really in there" so i've given you some steps on how you would do this, i want you guys to implement your own i can tell you that you can do it with those variables figure out what you want the variables to be initialized to  and how to implement your enqueue and dequeue so it's only a couple of lines of code don't make it too complex Yeah?
but the way you build your code will stop that from happening are you getting close? okay I'm hearing the mumbling die down you guys ready anybody have a solution for me what's the sequence for enqueue okay I'm going to do the same way on s1 why s1 cause I have sixteen spaces and i want to wait if there are no spaces available so what do I initialize s1 to sixteen then what do i do lock what happens if i switch these two the order of those two okay I'm going have I'm breaking my synchronization I'll ask that again when we're done so then I do my enqueue how do I finish up? sorry? what should I do next? sorry? post  and then what?  unlock okay? what happens if uh is that the right order for those two? so he says he thinks the lock should be first why should the lock be first? you can let somebody else come in really you want your lock critical section  lock as tight as possible and then do other things outside that to manage your synchronization because you it's not going to be that bad for this small example but if you don't unlock until you do some other things you're locking somebody else out okay so if you release the lock before the post somebody else could come in and could be waiting right here remember because I got multiple readers can come past the wait up to sixteen if it's empty and then they all wait on the lock because only one is allowed in the critical section at the same time and then they're out once I step out of this the next one can acquire the lock and change something before the post happens so for the small pieces of code it's not really and issue but, for larger things you want to be careful okay so what's my dequeue so it's not a correctness issue it's a performance issue so what do i write for my dequeue wait on s2 what's my additional value of s2 zero because I have nothing in there and then I do what lock and then i do my dequeue then what do i do? unlock same reason and post which one? s1 why does this work? I mean if you talk about this if you look at it right? the first thing is I'm coming in I'm saying are there any spaces if there's spaces I can put something in and now I'm telling the dequeue that I finished putting something in and now there's some items so same thing here I'm checking to see if there's any items and when I done I'm letting the enqueue know that there is more space if it was waiting for space so the key here is that the communication between the two is this crossover between s1 and s2 our initial answer remember had just s1 on one side and s2 on the otherside there was no communication between the two to let them know that there was things changing and then our other answer just had them backwards again if I unlock and then post alright first is somebody could be waiting on that lock the post just means somebody's waiting to know if there's more items the unlock says there's somebody waiting to get into the critical section but let's say there are five items in here right we'll say there's five items and I've called dequeue a bunch of times right so I've called dequeue the first time the first one goes through it says wait and it decrements it to four s2 is items right so it decrements it to 4 and it gets the lock and it could then post or unlock if the first thing it does is unlock the next one that was coming along here the next one came along and it blocked  it can't go anywhere it's not waiting for this post it's just waiting for the unlock so it's really just an ordering thing if there was more complexity to this system this mismatch could cause problems. it's just a performance issue it's not a correctness problem
okay so I only have about five more minutes left I don't think I'm going to be able to  any more questions left about this sorry any more questions about the ring buffer okay the back half of the page is return to the reader-writer problem okay so you guys remember what the reader-writer problem is? so there's a couple of rules when you're doing a reader-writer problem 1. how many readers can you have at the same time? as many as you want how many writers can you have at the same time one can you have readers and writers at the same time? no so our first rule is exclusion one writer multiple readers that also means that whatever solution I design I want to be able to allow multiple readers to simultaneously read but only one writer to write at the same time so was there anything else? yes and we want to make sure that whatever solution we come up with doesn't starve either the readers or the writers so you guys saw condition variables right? so just to refresh your memory inside a condition variable inside the system it's doing an unlock on a mutex it's blocking on a signal so it's waiting for something and then when it's done it locks it and then it returns so whenever you call a condition variable you call it with both that condition variable and a lock what state does that lock have to be in? locked because in the system the first thing that happens is the system unlocks it for you but all that is done atomically-ish don't worry about that word it's all done in one step so you don't have to worry about race conditions inside the condition variable okay so here's my first solution to the reader-writer problem I'm going to lock a mutex and then I'm going to say  I have some variables here I have writing  that means somebody's writing and I have reading and that tells me how many the number of readers inside what value can writing be? zero one  reading can be whatever doesn't matter ok so, first thing I'm going to do is lock my variable and call and while somebody is writing I'm going to call my condition wait if somebody if there's a writer in there I'm going to wait for the writer to signal that they're done and then I can go on once that's done I increment reading I do my reading, I decrement reading, I signal that I'm done and I lock similarly, on the writer side  they lock if there's anybody reading or writing remember writers are exclusive they can't have anybody in there I wait increment writing, decrement writing call the condition variable if anybody, this we're a little bit short for time so is anybody off the top of their head see a problem with this there's only one reader at a time what's causing that? the lock, right, so the lock goes from here to here once I try to read and I acquire the lock nobody else can come in does anybody know how I can fix that? there's an easier way to do that? any other suggestions? well I have to lock but you're closer it does have to do with the lock what if we unlock the lock unlock before the reading and then relock right? because this unlock will let the other readers pass the writers will get here and stop because I've already incremented my reading so the writers aren't going to be able to get into the critical section, but the other readers will there's another problem am I done? give me one more problem here there's two more problem, we'll finish them on wednesday say that again? if there's a stream of readers if readers keep coming and keep coming and there's never no readers we're going to starve our writers one more problem I lied look at the writers for a second there's a problem here what does that do? what does a condition signal do? it wakes up what? no it wakes up  wakes up one reader what do i need to change that to? condition broadcast okay I want you guys to think about the better solution for a reader-writer we'll go over that at the beginning of class on Wednesday and we'll talk about deadlock
Now let's get started. Your stuck with me for one more day and not only that, I have a cold, so I apologize for any sniffling or coughing I might do in your ears. I think we can get through this okay, I'll just make you guys talk more.  We didn't quite finish up talking about the reader-writer problem so I put it on you guys to come up with a better solution But just to go back a little bit, we left off with this improved solution. It wasn't quite as perfect as written on the page. We have the lock and we do while our writing and then we do some reading and then we tell them that there's a reader And then when it's done we do some reader, then when it's done we tell the reader's gone.  And then we signal that someone else can take the turn And then we unlock the lock And then pretty much the same thing on the writer side There were three problems with this Two of them were problematic and one of them was functional - completely functional. What are some simple fixes we can make? What was the first problem? Yeah so what is happening here; who's getting woken up here? Only one reader. Only one reader. So we want to make sure we wake up all the readers so we do a cond_broadcast What are the other problems? What part if it is causing that?  So the lock/unlock being here, right. Okay, I lock, so no one else can get into that critical section until I unlock. Which means we only allow one reader at a time. How do we fix this? Do I have to do the same thing for the writer? Why not? We only want one writer anyway, okay. This works, there's nothing functional wrong with this. This is good, now we get our multiple readers, multiple writers But it still has one more problem. Anyone remember what it is? Yeah? Yes, so the writer--what's stopping the writer from getting in? This right here. We only have one writer, so I don't need to worry about this Okay. And it means that unless the writer has gotten into the critical section, every reader that comes along--once one reader comes along and gets in, the writer gets blocked And now readers come in, readers leave, readers come in, readers leave. If that reader count never goes down to 0 we're going to starve the writer. In the real world this could be a really bad thing because I could be making a change, and delaying that update that the writer is trying to make. And the readers are working on old data. So this is not a good thing to starve our writers. And the goal for the last part of the class was to write a better solution I asked you guys to think about this while you were away from class. I can give you two minutes to think about it and pull it back in again then we can go over the solution Talk to your neighbors. Think about what you would do to fix this and make it work [silence while the class works]
so did anyone come up with a way to not deadlock our writers without telling me the code what would your approach be to not let the writers deadlock? so one way would be to broadcast to the writers first then the readers im not sure that would entirely fix the problem because even if i broadcast the writers wait let's go back to this code for a second even if i broadcast here to the writers the writer will wake up but there's still readers inside and it'll still block so it's a good try  so it's the right approach you have to do somehting that gives preference to the writers that's how we're gonna fix this. say that one more time so one thing you can do is put a number of make sure no one reads forever so the solution i have is not gonna break the problem of someone reading forever if somebody reads forever i'm never gonna let a writer in so ummm  that is a limitation of the solution i'm gonna show you even if you just let even if you say that your reader can be in there for 10 seconds let's do it that way instead of giving it a time limit you can still have every second a reader comes along so probably we should put a limit on the solution i'm gonna show you to make sure that the reader's not gonna stay in forever it would be really good if we could have them enter in the order in which they receive did anybody come up with a solution kinda like that? yeah, that's pretty close to what I'm gonna do so basically what i'm gonna show you is a way to say ok i have a waiting flag if a writers coming in and writer's waiting i'm gonna send a waiting flag and if there's a writer waiting i'm not gonna let anymore readers in and whatever reader are in i'm gonna drop through and those readers once they're done  the writers next and i'll show you how that works you know what i have the code here not gonna write the whole thing down we can look over it ok so here's my reader and my writer so i've added  here i now have two two counters that have to do with readers instead of just 1 this one says that i have a want to enter the critical section. so this one says writer's waiting" and this one says writers writing what value can this one have what value can the writers waiting hve okay what value can this one have the writers writing just one how about this one here no i can have lots of writers writing it just tells me that there are writers waiting okay and as long as there's waiting this one says as long as there's writers waiting instead of writers writing i'm gonna block my reader and this part right here says that as long as there's a writer writing i'm not gonna drop out of my condtion wait while loop okay so what's gonna happen is 1 writer's gonna come along it's going to  say that somebody's reading say we have 1 reader  in there let's let the reader go first reader comes in  i need my variables set here so we have writers  writing and reading and they all start off as 0 so i have a reader that comes along it's gonna come along here and check to see if there's writers it's gonna say no no writers so  uhh it's gonna fall through the condition variable i don't have to wait and then it's gonna increment writing, reading i'm sorry it's gonna stay in reading here for a second let's leave it there for a minute to make sure that the writers are gonna be able to get through so now i have a writer its gonna incrament it's gonna acquire the lock so it can change the writers value ok so now i have one writer waiting but now i need to check somebody's reading am i gonna fall out of this loop? yes or no can i pass this line? alright i'm gonna do while reading or writing am i reading or writing? yes so i do my condition wait so now my first writer is blocked here and what happens when it calls the condition variable? it releases the lock so and now i have another writer come along same thing happens i'm gonna increment my writers to 2 and my second one  is gonna block right there is that clear? yeah? nothing's happened yet right we haven't been signaled yet so now let's go back to this reader so this reader's done it gets the lock it decrements reading now to 0 and it signals everyobdy that will wake up it's doing a signal broadcast it will wake up both of the writers both of the writers will acquire the lock 1 at a time right they're not gonna do it at the same time the first one that acquires the lock will say  is reading 0? yes is writing 0? yes so that one can fall throgh and it can now set writing to 1 and there's somebody writing ok so now if you look at another reader coming along it's gonna say is there are there writers waiting? yes ok now wait what did i just trade off this is not a perfect solution either yeah? there's no better way for the readers so i now put the priority on the writers instead of on the readers there are solutons for having counters and allowing them to go in step by step i don't think lawrence was having you going through the priority solutions so this is the one he wanted me to go through with you
no there's no order right there's no ordering i this because everytime you do a condition broadcast there's no queue it just picks one it's possible that the operating system implemented as a queue and it took the frst one that asked for it but theres no guarantee of that you don't know how the operating sytem implemented a condiion signal why am i unlokcing the mutex when i do a write  there's actually a reason for it what happens when i unlock we said we didn't need it before but actually we do why do we need it? right. so we want anybody who's coming in reader or writer we want them to be sitting on the condition variables here and here the only way for them to get to the condition variable is if the lock is unlocked while theres a writer writing that doesn't mean another writers' going to get in it just means another writer will get to the condition variable that clear? can let it gel. anybody have anymore questions? because i want to move on to the topic we are suppoesd to be talking about today which is deadlock ok so i'm going to do something that i know lawrence never does but i'm going to use some slides dr seuss' birthday was on monday so i thought we would honor him with the ultimate deadlock actually if you take algorithms sometimes people talk about cat in the hat which is recursion dr seuess seemed to have an affinity for algorithms one of the things that we didn't necessarily see this specific problem of deadlock when we looked at the readers and writers problem but we did see in the circular buffer but we did see things getting stuck and the canonical example of deadlock is these are the north going and south going zacks they both walk up to each other and they go I'm not moving. I want your spot" and the other one wats my spot and neither one is willing to make any adjustments and they're stuck this is the canonical deadlock what's happening is i'm waiting for him to move and he's waiting for me to move and with that we create something that is actually very easily to notice that there is deadlock in the system so we see deadlock everyday anybody living you know who's ever lived in a city you've seen deadlock on the streets any time and it could be caused by lots of different things it could be caused by some idiot driving into the middle of the streeet and stopping there and deciding what to do and all the other traffice come along and starts going yeah um we're stuck and it doesn't even have to be you konw an indecisvie problem it could just be that there's lots of traffic and a car pulls into the intersection and can't make it all l the way across and you're going to have the same problem this is what we call gridlock gridlock is deadlock nobody can move everybody is waiting for some other spot that doesn't exist even if the cars that were blocking it in the first place are gone it still can't go anywhere what we're going to see is that the main problem here is that the first car is waiting for the left car to move the left car is waiting for the bottom car to move and the bottom car is waiting for the right car to move and so and so forth and again the same problem that we had with the north going and southgoing with the zacks is that we can't get anywhere so essentially deadlock is a situation where  we have processes if you want to get away from the cars and the dr seuss characters we have processes that are waiting for an event that will never occur and it turns out that this doesn't even have to be multiple processes typically it is multple processes and if they can't make any progress then the system is deadlocked turns out that a single source can deadlock itself it's waiting for some resource how do you think it could deadlock itself? anybody? i have one process and it's moving along it's it's waiting for something if i have a condition variable that i set to something and then in that same thread or same process i then went to go or Â unlock even you don't need to be as complex as a condition variable i set a lock to locked and then i'm moving along and then in that same control thread i say unlock i'm stuck if nobody else is going to touch that so i can deadlock myself by not using locks and unlocks correctly so there's also something called livelock can i have a volunteer come up here for a second just a simple. i'm not going to hurt anybody i promise. just stand right here for a second, come on people in the front i'm going to give you an example ok first we're going to be the zacks stand there ok we can't go anywhere ok but now he's going to be really nice and say ok i'm going to move to the side so you can move to the side ok try again one more time ok you can go back to your seat that's called livelock did we  get anywhere? no but we're standing there you ever done that in the hallway where you just go back in forth in front of somebody? that's exaclty what livelock is we were moving we were potentially making progress potentially doing something but we were not making any progress and we never got past where we wanted to be so in terms of processes we're going to see that processes can sometimes try to avoid deadlock  by essentially he was trying to avoid deadlock by saying ok i'm going to be good and say you can have the spot" so they're releasiing a resource but then i say no i want another one so whatever algorthms you design to try to avoid deadlock could create this livelock situation
there's lots of different things you can do to deal with deadlock you can try to prevent it. this is probably the most expensive thing that you can do you have to understand exactly how your system exists. you have to understand all the states in your system you have to be able to look at it, run from algorithms on it and say that nothing in the system, no program, no application can cause deadlock to be able to do that, you have to be very,very pessimistic because even if we're dealing with the zacks aren't very nice, if two of them never met, it's never gonna be a problem. so only if they actually meet that they cause deadlock a number of systems might try to do something like detection and recovery so detected that there was deadlock and now we're gonna come up some algorithms to recover from it avoidance is kinda somewhere in between. we're gonna look at our system and come up with systems that don't come up with dealdock a little bit more expensive than detection not quite as expensive as total prevention and then if you really have trouble you can have your system operator sit there and fix things that's your worst case - you don't want to do that does anybody know what unix/linux does for deadlock prevention or detection or avoidance or whatever anybody know? wanna take a guess? how does linux deal with deadlock? how many people think it does deadlock prevention? detection and recovery? avoidance? manual intervention? you wanna know what it does? nothing this is called the ostrich approach, you stick your head in the sand and ignore deadlock ever happening. that is pretty much what they decide they leave it up to the application writers to make sure they don't deadlock so, the nice thing about this is that none of the expensive components of prevention or recovery or detection need to be implemented they just say everything's faster and if it's rare is it really worth the overhead? the assumption is that it's rare and we're not going to use it or if it's really important for a particular application that that application take care of it that being said you can't ignore it because it's part of this class and i'm gonna talk to you about how to figure out what's going on with deadlock to be able to do so i wanna be able to model  i want be able to model my processes and my resource that they wanna use in a graph and this is called a resource allocation graph and my resource allocation graph has two components it has  it has processes which are these circles  and it has resources which are the squares and what i'm gonna do is i'm going to take an arrow from a resource to a process that means that p1 is using r1 and i'm going to take an arrow from a process to a resource saying that p1 requested r2 so this would be process 1 is using standard out process 1 has acquired a lock the second half, the right half would be some other process acquired a lock already and p2 is asking for it but doesn't get it until the other process has given it up so, why do we go through the bother of this? well it turns out that if we look at resource allocation graphs they have this great property that tell us how to deal with deadlock or how to detect deadlock, or how to detect deadlock let's say we have this situation now where r1 acquires, sorry, p1 acquires r1 so process 1 has acquires some resource and p2 has acquired a different resource but now p2 is gonna request that first resource that p1 has and p1 is gonna request the resource that p2 had what's gonna happen? so, if they're gonna hold on to these resources and they can't make any progress until they get the second resource, we've now created something called circular wait they're both waiting for something the zack's were each waiting for the other to move the cars at the intersection were each waiting for the other to move this is called circular wait and this type of cycle in a resource allocation graph tells us that there's dedlock so, on your handouts from today, you guys have some examples that we're going to go through so let me switch over to our examples can you guys see that okay or do you want me to put it on the center screen too? so, i'll help you through the first one the first one, here's my boxes and lawrence was calling them candyboxes and they hold candy and there's one piece of candy in the box and whoever gets it get's to take it and i guess when they're done they put it back. kinda gross so if you heard him say candyboxes he meant the resource squares and the resource allocation boses now how many processes do i have i have process 1 and process 2 so i'm gonna write p1 and p2 and the way i read this is process 1 requests resource a and resource b so process 1 requests it and there's no arrows coming out of the resource that means that no one's using it right now and p1 can acquire it so i draw an arrow to p1 because that means that p1 has acquired a and b now, process 2 comes along so this is time for each of these, down is time now p1 says i'm gonna request  oh i guess there's a 3rd one here p2 requests process c sorry process 2 requests resource c, which way does the arrow go? to p2 towards p2 and, what about b? which way does the arrow go? towards the resource or towards the process? towards the resource because a already has it is there a deadlock here? no why not? there's no cycle i don't have my circular wait, okay
Let's do the next one You guys do the next one, you've got 30 secs to do it, it's very easy I'm going to write the processes and you're going to tell me where to put the arrows I'll write all of these while you're looking at it, you can go through as many as you want I'm going to set this up Okay so for the next one P1 requests A, B and C Which way do I put my arrows? towards P1 all of them? nobody has those resources and P2 requests B and C which way do I put my arrow? to the box? For which one? for both of them? Yup cause A has both of them Is there a deadlock here? Why not? There's still no cycle Let's do the next one, A requests A and B We know those go that way because A is the first thing to request it P2 requests B and C which way does the B arrow go? To the resource or to the process? To the resource And for C? To the process How about for P3? To the resource or to the process? To the resource and for C and B for P4? Both? So they both go to the resource ok Have I created a deadlock? Is there a deadlock there? Still no deadlock, this is kind of boring, no I'm just joking Ok you wanna make a bet that there's a deadlock here? How many people know that there's a deadlock here? Then help me, so P1 requests A and B P2 requests B C and D which way does the B arrow go? Towards the resource and the other two go... towards the process We know there's something here so this has to go towards the process P4 wants D and P3 wants B But now P1 requests C which way does it go? To the resource and you're going to go back around the bottom here Is there a deadlock here? Whats happening? P1 has requested C and then P2 is using C but P2 has requested B and p1 is using B Got it? So you'll notice this is what is called a bipartite graph You only ever have arrows going from the top to bottom or from the bottom to the top they never go back and forth between each other okay last one and then we'll go back to talking about deadlock ok i'm going to start it off uhhhhhh because I don't know what I'm doing do I? there we go P2 wants B And C and D Okay this is almost the same as the last one P3 requests B ok what's new here? P1 released B P1 said ok I don't need this one anymore, it's not there and once it's been released, the next process waiting for it can get it let's say it's P2 so now P2 what happens to the arrow for P2? It switches direction so let's see if we can make it switch directions. So now when P1 comes along and requests C Is there a deadlock? No So the key here is to remember that as processes are doing things, they are releasing and using resources and the whole stepwise of understanding how they're releasing and using them needs to be looked at to be able to detect deadlock okay any questions about the resource allocation graphs? okay cool. I'm going to go back to my slides
So, it turns out that this, uh, circular wait is not sufficient for, uh, determining whether there's deadlock. It is necessary. If there's no circular wait, there's no deadlock. But if there's circular wait, it doesn't mean there's deadlock I mean, if there's a circle in the graph, it doesn't mean there's deadlock. So there are four conditions. They are Kaufmann's conditions. The first one is mutual exclusion. It means that only one process can use a resource at a time. so a process can claim exclusive control of the resource they require. So if we're only dealing with writers, writers require exclusive access to that critical section. If we're only looking at readers, there's no exclusive access. They can all look at the same time. So we have to have exclusive access. A lock implies exclusive access. only one process can have the lock at the same time There is also something called hold-and-wait. Hold-and-wait says that the prcoess that the process holding the resources allocated to them is waiting for additional resources.  If we go back to our last two examples here,  In this case, the first one, P1 is holding B And waiting for C In this case, P1 gave up B And then was waiting for C, and so in this case doesn't have any hold and wait. it's not holding something and waiting for something else So, in a sense a hold and wait a process has a resource it has an arrow coming in, and it's waiting for another resource so it has an arrow coming out The third thing is that there are no preemptive conditions this means nothing can be taken out. I can't say well I'm going to remove the fact that - instead of A releasing B2, I'm going to force A to release B2. I'm going to preempt it and say someone else can have it Once you have it, it's never given away So the north and south goings  There is no pre-emption. they weren't going to give up anything to be able to make progress And the last one is a circular chain of processes exists.  So, there is actually a law on the books that said in Kansas, when two trains approach each other at a crossing, both shall come to a full stop and neither shall start up again until the other has gone Yeah, not so good Total deadlock. They both can't make any progress. How would you fix this? This is a train, I'm not using a stack. Ok I'm not sure I understand your solution. Ok, so give the north going train the priority and the south always has to give up. The north always goes So that would break it. What does that break? so we had four conditions for deadlock, would do you think that would break? Yeah, there's no pre-emption here, and in doing so you've gotten rid of the cycles too. Any other ways of fixing it? Let's see...did I have any others? Priority, uh... You could make one back up. But all of them have to be able to break one of the conditions. So let's go with one more simple example. Two students need a pen and paper. I want to know what conditions these do or don't satisfy. I need to know if there's deadlock here. Two students share pen and paper. Is there deadlock there? It breaks mutual exclusion. Both students agree to grab pen before paper. Which one does that break? I always grab pen before paper. This is no circular wait. Because I'm always waiting for the pen and then I'm waiting for the paper. If they randomly did it, one could get that paper first and the pen first and the other could get the pen first and then the paper first. then we would have the cycle and they both get one or none Hold and wait Last one, students I have the pen and you give up the paper There's your preemption This leads us to the dining philosophers problem How many people have heard of this problem before? This is the canonical computer science problem. We have N philosophers and N forks BUT you need two forks to eat You can do this with chopsticks too But you only pick up one at a time
They must be hungry or they're dead Okay here's a solution for ya alright  The philosophers spend time thinking, and then get hungry  They pick up the left and right fork and then they eat when they're done they put down the left fork and they put down the right fork  Any guesses about what might happen here? What's wrong with this? Everybody grabs the left fork first, whats gonna happen? They'll starve  This doesn't work Because what's going to happen is oh left fork, left fork, left fork and one more left fork And now when I try to pick up the right fork, there's no right fork there and they can't do anything, they're blocked  Or deadlocked  Which properties does our solution have? Does it have mutual exclusion? It better have all of them - it's deadlocked. What's causing the mutual exclusion?  Can't share forks - which is good for winter time which is good in the winter time because otherwise we'd all get sick  What's hold and wait? I have one fork and waiting for another fork  No preemption - No stabbing the philisopher next to you to steal their fork  Circular wait is this potential of causing a cycle, each waits for the next neighbor to put down their chopstick  So lets just look at this in context of the resource allocation graph  So if the philosophers are the processes That means the forks are the resources and if we model this using our resource allocation graph we can say everyon tries to pick up their left fork  They all get cause there's nobody's using them so there's an arrow from process to the resource and they all get it, those are the request edges and everyone succeeds oh sorry those are requests, now everyone succeeds so everybody's got it from the resource to the process  Now everyone tries to pick up the right fork  There's request edges  And there's our cycle right there, cycle equals deadlock  I had a lot more examples of how to solve deadlock, how to solve the dining philosophers problem, but I think you'll be doing more of that later The only thing he told me to do is introduce the dining philosophers problem and say why it's bad to pick up chopstick 1 and eat. So  any questions about the dining philosophers problem? Any questions about deadlock? What is preemption? So that means you can't take the resource away from somebody  Once the philosopher has the fork you can't force him to give it up  Preemption means you can take it away. No preemption means you can't take it away And actually preemption is a solution to recovering from deadlock Because one way to solve this would be to say okay Aristotle you need to give up your fork and once he does Socrates can pick it up  Sorry Descartes can pick it up and now he eats, puts it down  And the cycle backs around And we've now solved our problem  So you can use these types of graphs to help us solve the problem of deadlock as well as detect Â deadlock But the thing to be careful about is it's not easy to determine, in this one it's really easy you can say oh look there's the cycle  I break it and it fixes everything, real systems have more complex cycles and more complex graphs  Ok - It's been a pleasure, thank you And as far as I know unless he gets stuck in california, Lawrence will be back on Friday
programs that we have you'd be paid 15 dollars an hour for your time and make roughly over a thousand dollars upon completion last year we did the same study but we've tweaked it and modified it a fair amount a lot of people really enjoyed this study, they found it was a really great way start exercising, they met a lot of people and being paid 15 dollars an hour to do anything is pretty great so if you're interested, you can visit our website, insight.beckman.illinois.edu chris out there has handed out fliers to a bunch of you so if you want to write down any of the information from your neighbor you can do that as well cause we happened to run out of fliers and you need to be here during the summer in order to participate in this study so I don't really have a lot of time to speak so does anybody have any questions? any? alright, thank you for your time great, so alright so back okay woo cool great here's one of the things I was talking about in orange county and by the way yes I did bring some warm weather back with me, it's coming this week actually next week, we'll have a much warmer weather but anyways this is one of the things I was talking about was how do you run a course where your introduce android programming to absolute beginners and in doing so get the word out that illinois is actually a pretty good place to study computer science and this is what we did, there were fun lectures, there were students in my lectures, some of them not even CS students but I had a singer song writer we went to spurlock and saw bardeen's first transistor and then being an engineer of course, he wanted to make not one but two transistors so that's a music box there right in the middle and that was fantastic right to actually be able to amplify sound using a small device brought the convention down when bardeen first demonstrated this and by the way he actually did a drinking song he played a music note on this and this is during the dry period so that's how he got his propaganda out that the transistor was a good thing and then here's me underneath singing the fifty words of java as a song parody right so we talked about the fact that look programming is hard and had students say things like yeah I built an app and it didn't work I built another app and it didn't work either and this idea that look programming is a lot about problem solving yes you have to have the technical knowledge but it's a lot about being like a detective and looking at a crime scene and trying to figure out why did it not work and then up there in the thinking bubble is another engineering student with his hair going everywhere because he's actually trying to decode at thirty thousand feet as the plane plumets because its simulating zero G it's simulating being out of space, it's on a gravity dice so that was a lot of fun a couple of years ago right so anyways, so that's what I was doing and as you saw from the notes, professor rutenbar and also someone from the provost office was there as well chuck tucker right so let's now head on over to CS241 content but before that has anyone got any quick questions about this? no? okay right so let's do today so I hear you talked about [something] yes? last week with Robin? yeah we're going to continue thinking about deadlock today but I'm also going to give you some hints about the next MP which is to make a fast merge sort, a multithreaded merge sort so first of all let's review a little problem here and see what we can remember about the coffman conditions I've got three gardeners walking into a garden shed to start their work they are after some resources right and so they are going to pick up their tools for the day in other words they are about to request some resources obviously we have a potential for a deadlock, we might have two gardeners try to pick up the same shovel or something okay fortunately we know about coffman conditions alright so how can we assure that we are avoid deadlock I want you to through the mists of time remember yes there are four coffman conditions now here's the challenge, can you actually write down at least one of them or better, can between you and your neighbor actually write all four without looking them up make a list, make a list of four items, see if you can remember what they are what are the conditions for deadlock? if your neighbors not sure, ask another neighbor [silence] right, the best way to learn to remember things is to try to remember things if you want to program your brain to say hey this stuff is important and I want to be able to remember this stuff, the best way to do that is to actually keep remembering it, to actually tell your brain oh yeah yeah i'm actually trying to access this information if you keep doing this, it's going to go into your long term storage yes cramming for tests gives you a short term cram, it puts stuff into your short term memory it's good enough for about 6 hours to 24 hours but it does not go into your long term memory it gets wiped pretty quickly so if you really actually want to learn this stuff then don't just cram for tests but actually exercise your brain it's really the practice, just to start with a piece of paper and say hey what do I know about subject X? write it all down throw that piece of paper away, do it again on a different day you're telling your brain this stuff is important to me I need to access stuff um so, right what have we got? okay first of all let's see give me a hands up if you managed to get at least one okay hands up if you've got two hands up if you've got three hands up if you've got four alright hands up if you haven't... ah nvm, nice let's keep going here's one we should know right? mutual exclusion exclusive access we need non sharable resources in other words, if my gardeners are all friendly and they say oh no no let's all use this shovel together then there won't be any deadlock but instead of course they're like no I'm grabbing this shovel and get your own so first of all we need exclusive access
access so you could say non sharable or exclusive access to a resource okay what else did you remember? hold and wait right so what does hold and wait mean? if I'm going to be involved in deadlock it means I've already got a whole lot of one resource and I'm not going to let go of it whilst I'm requesting an waiting for another resource so I'm part of the problem right? I've got something I've got a pencil and I'm going to wait until I've also got the paper I'm not going to let go of this thing alright so this is the toddler approach to sharing it's mine! I've got one thing now I want the other thing so in note form, I might remember it's like okay I've got at least one thing and I want more! well that sounds pretty similar to something else what's the condition? what's another similar condition to this no preemption what do we mean by no pre emption? yeah, that no one's voluntarily, that the only way that something is released is by a voluntary action so we can't have another gardener bashing the other one on the head just to get their tools right or tripping them up we let each process voluntarily release resources we can't kind of walk in and say oh I'm sorry I've made a management decision, you know that trough you have? I'm taking it away from you so there's a note form, we're only doing voluntary releases only voluntary release resources okay! and finally what's our fourth one? circular wait my friend wants to go out with B, B wants to go out with C, C is waiting to go out with D, D is waiting to go out with A we've got a cycle in the resource allocation graph or in the wait-for graph that we have a set of processes where the first process will wait for the second process, the second process will wait for the third process and so on and so on and so on until we get back to the first process again so we have circular wait okay now are they necessary? are they sufficient? yes they are necessary and sufficient you have all four of these, you have deadlock the good news is that if we can break any one of these then we can avoid deadlock and that is the standard approach to when you are worried about deadlock situations you backtrack, you write down these four things and say okay let's see we can break one of these conditions so I've got my four gardeners or three gardeners walking to a shed I've already mentioned we can break exclusive access by allowing them to share the resources how could we break circular wait? how would you break circular wait? oh really? come on give me an idea, yes okay so if we inside the shed numbered all the tools and said pick the lowest tool first that you need then maybe we can set it up so that there's no circular wait if we controlled all the gardeners actions and were very careful so that there was no possibility that they would fight over shoes, over shoes? tools! we could avoid deadlock again, we could make sure that hey you're only going to do this type of gardening today and you have to wait until this person's finished etc so we might manage the processes so that we never have a circular wait okay, no preemption like I said we could have one gardener that's the head gardener and say haha if I see deadlock, you put down that trough right now, right? we could force processes to give up resources in practice that's pretty hard to do because maybe the process is actually midway through say writing to a GPU buffer so that's pretty hard and then hold and wait maybe we can use something we know about synchronization to try to avoid hold and wait, we could say make grabbing all the resources an atomic situation alright so that's our gardeners  we'll come back to this later when we talk about dining philosophers again now I'm going to get started giving some hints about the next MP remember good ol mergesort? mergesort where you recurse twice and you say okay get the lower half sorted, get the upper half sorted and then I'm going to make a merge function which combined those two halves and then my part is done right so if I've got a big problem what do I end up doing? I end up making lots and lots of recursive calls until I'm working on smaller problems let's say these are 256 entries and I'm going to merge these two together and I'm going to merge these two together right those two merge actions could actually happen simultaneously, concurrently yes? at the same time great sounds like a job for threads so we'll have a thread doing this merge and another thread doing this merge at the same time and eventually say if these were 256 entries each, now we've got one big block of 512 when these are done I can merge those together so knowing what you know about pthread_create suppose I said to you ah okay it's a race we'll have everyone over here try to beat everyone over here to write a parallel multithreaded merge sort code how would you start? what calls would you call and when? so let's say you've got two minutes now to verbally discuss it with your neighbor and plan, sketch out how you're going to implement this you've got two minutes before I let you touch a keyboard, what would you talk about? what's your plan of how to accelerate this using threads ready? go
[silence] okay so let's sketch out some ideas, remember the basic form of when you call merge sort is we pass in some sort of like low and high we calculate a mid point and then the first thing we do is  say okay do merge sort say from low to mid and merge sort from mid to high and then finally, do the merge to take those two halves, copy all the values in order in some sort of scratch space and then copy that back into the main array so maybe what we could do is say well look let's in these two calls here  let's do these independently right? so our first idea might be that instead of calling these directly I will call pthread_create  and obviously I want to know what it's doing and I'll pass in some sort of task information so on the heap I'll make a little struct that says okay go from this value up to this value I'll create a little struct and I'll pass in a pointer to that struct and my little function that runs can take that task, read the contents, and when it's finished it will free it so I'm creating the memory, but the other thread will call it and similarly on this one, we'll call pthread_create and we'll call this task two and then I better wait before doing any merge, I've got to wait for these two threads to finish okay so then I'm going to call pthread_join on t_id one and pthread_join on t_id two so that might be my first attempt so some things to comment on this is first of all, we've got a running thread, why not use it? so what are we doing? we're saying hey create two threads and then just sit around and block until these two other threads have finished well that seems a little bit kind of inefficient we should have actually used the calling thread as well so we might for example try to speed this up a little bit by saying you know what just execute the second task myself directly but even this is going to create a lot of threads way more threads than actual CPU cores that I have and you could imagine that say I'm dealing with several megabytes of data and I'm splitting into these little two hundred and fifty six integers then that's many many threads so maybe we should be a little bit more clever in how we do this and get even better performance and that's where the idea of a thread pool comes in here's what we'll do, we'll make a preset number of threads and then we'll treat them to work, we'll actually separate them from the actual tasks that we want each one to do instead we'll put our tasks into a queue hey guess what, this is starting a bit like producer consumer our threads will go to the queue and say hey what's next what's next give me some work if there's no work for them to currently do that request will block until another thread puts some work into the queue right? so we've actually got conceptually now a whole load of threads going back to the queue saying okay I'm free give me some more work give me a little task structure and that might even have a pointer to a function and some other additional notes and integers etc and pointers to floats, whatever to actually perform the work so we think of our little thread as a little worker that just keeps going back to this and say okay I'm ready to consume the next task, okay? so our second idea then is to do thread pool that uses the ideas we've learned from the producer consumer and its consumer is consuming tasks now we have to be a little bit careful in this because suppose we've just finished creating let's say this block right? our task was to do the merge and to create this block another thing might be to say okay not I've finished this I should put in a new task into the producer I should submit a new job and that is to do this big merge but we have to be careful, we have to make sure that the other half of the data is actually ready is actually finished now, I'm not going to elaborate all of the ways you could do this because we're going to do a little competition and see who can actually write the fastest merge sort but I'll give you one idea and that's this: don't start on all of the five hundred and twelve jobs until you've finished all of the smaller jobs
and note the key word here is finished it might be there's no two hundred and fifty six jobs left inside the queue but that doesn't mean that they're finished there still could be another thread actually working on it, actually generating this data still so you need in your program a concept that no no, these jobs really have finished at this level I've finally got all of those small bits created into larger chunks and so I'm ready to start working on the larger jobs now a little bit of thought will tell you that you could probably even improve upon that idea as well but then it's starts getting a little bit more complicated as to improving the efficiency of this, but this is a good start and I encourage you to do this iteratively and to use subversion so that when you got a working version either copy it or put it aside so that when you blow it up etc, you can at least go back to a best working version alright so that's our thoughts about mergesort and in working on this you're going to learn about thread pools and thinking about producers, consumers, and you'll also think about barriers you're stopping work from happening until something is finished so just like the malloc mp, this again is a rite of passage but it's an asynchronous rite of passage where malloc was about pointers this is about concurrency and parallelism  right so you'll be learning about barriers, thread pools and producer consumers in the next MP questions? no questions are you ready for unofficial? you can see I'm wearing green myself alright so that was a context switch we flip from one subject to another subject except in systems programming a context switch means something a bit more specific than just simply switching the conversation what we're talking about is the idea that our CPU needs to be arrested, needs to stop working on one particular process and it needs to change contexts so it can start work on another process we can have of course many more processes which are active than actual CPUs in our system but a CPU could only work on one thing at a time it's got a whole load of registers and one of those of course it the program counter as to hey what instructions should it work on next? and we've got this idea of virtual memory, that for a particular process, address blah blah blah blah corresponds to this piece of RAM where we've got this particular state in so that's all about one process so when we do a context switch, we've got to stop all this, we've got to suspend the current process and somehow store the active state of the CPU so if you take an operating systems class, you'll discover that this stuff is stored inside the process control block and all this is happening deep inside the operating system, inside the kernel, the very heart of the operating system that manages processes, that manages the actual deep resources of the system for each process so obviously we have to store the program counter and obviously you have to store all the data registers so that when we want to reinvigorate this process and bring it back to life we can preset the CPU and then click the pause button again and start it off and off it goes and the little process never knew that it was put on ice and we reuse the CPU for another process so we store the active state of the CPU right when do you think this happens? every tuesday? come on give me a guess, yes! okay what if I have more processes than I have number of cores and I want to switch my shamrock to a diff yeah yes? what about virtual memory? yes if you want to store things to disk, yeah so it happens when we want to switch one process to another  and that can happen if our first process blocks so for example, let's say you call open or you call read and your waiting for some bytes to arrive from the user typing something or from the bytes that arrive over the network or the bytes to arrive from the disk your process cannot continue let's say that you call pthread_join or you call waitpid() your process cannot execute anymore statements right? it's waiting for an event where's that happening? it's when your process is deep inside an operating system call waiting for an event to arrive now operating systems are not going to return immediately there's nothing more for your process to do right now so that'll be a good time to do a context switch alright your process is no longer able to run so it happened when a process blocks it can also happen, in some operating systems, when a little timer goes off I'm sorry you've had too much time with the ice cream, the ice cream being the CPU I'm going to give it to someone else now so this brings us to scheduling but if we were to look at this further you'd say okay, when a process has exhausted its time quanta so if I'm going to let you have the CPUs for 100 milliseconds and we notice that you've had it now for 100 milliseconds I'm sorry I'm going to give the CPU to someone else so it happened when the process blocks and when the process exhausts its time quantas is two examples for when we might see a context switch when we might give the CPU to a different process so what does it actually mean to give it a different process? okay we've talked about the CPU but of course another critical part of the process is the amazing thing called virtual memory and I want to spend a little bit of time today talking about virtual memory
what we'll do we'll make a very simple piece of virtual memory and we'll let the hardware people actually make it real right? we're going to do it just today, the kind of five minute version and we'll let someone else worry about the actual hardware details here's the game we're going to play memory, real memory of course is expensive we'd love to have more of it but we're always constrained by the cost of memory the only really really great thing about memory is that it doesn't take up too much power we would like to be able to have processes that can actually use more memory than we physically brought we would like to have more than one processes believing that they've got all the memory in the world and that's where virtual memory comes in we're going to say make the addresses that the processes use only indirectly correspond to the actual ram or actual physical memory that we have on the machine so we need to do some sort of lookup anytime your process actually does a read or write we actually at the end of the day need to connect that to some RAM we actually need to connect it to a physical address so here is my physical address and what I'm going to do is divide it up into chunks and these chunks are called pages and I'm going to work with pages which are about 4000 bytes, 4096 bytes so when are we going to use this memory? ah all the time of course right? so if you've got an instruction like a CPU instruction that says okay increment register A just reading the instruction has to be in memory somewhere if you've got an instruction that says load from address 47000 not only do we need the opcodes to be in memory, we need 47000 to correspond to some memory so I'm using my virtual memory addresses all the time not just for the data but for the code as well anytime you write a line of C code, this virtual memory lookup is happening for every single one of those we need to be able to somehow translate our virtual memory address into a place in memory so here's the big trick take your virtual memory address, get a really sharp knife and cut it conceptually into two pieces preheat the oven to two hundred degrees... no forget that bit, right we've got the lowest twelve bits which we are just simply going to ignore for now because what we'll do with those is that we'll just simply use them as an offset in other words, once I've decided which piece of memory, which memory frame or physical frame which page I'm going to use here Of those 4096 bytes, I need to tell you which of those I'm going to use and that's where my 12 lowest bit comes into play because guess what 2^12 is 4096 so I can use those lowest twelve bits as just an offset into any one of these particular things the remaining bits and because I'm working in a little 32 bit system, I now need to map to memory okay so first of all, how many of these 2^20, how many bit combinations is that? how big is 2^20 okay well let's, i'll give you a clue, it's 2^10 times 2^10 how big is 2^10? 2^10 is 1024 so we're talking 1024 squared in other words a million a binary million a megabyte I've got a million entries, a million possible numbers up here we're gonna give these numbers a name we're going to call this the page number and we better give these pieces of memory a name we're gonna call them frame so, I need to convert one to the other right so page frame a miracle occurs we map it to a particular frame here's a really easy way to do it let's just have a table in memory of a million entriese right so we take our twenty bits somewhere in memory in a well defined location we need a table big enough for 2^20 entries and these just hold the frame number so if your looking say at this one then it turns out that you're going to use this particular frame of memory if you're looking at this piece of memory, it turns out that you need this one if you're looking at this piece of memory, it turns out that you need this one if you're looking at this piece of memory, haha, no it turns out that you can't look at that piece of memory if you try to look at that piece of memory, BOOM, we're gonna blow your process up do you remember things like seg faults? this is it! this is at that moment when we try to look at a particular page number and we say ah hah guess what, that's not actually mapped to any real memory ah ah ah, you can't do that! so we can now protect portions of our memory, we don't actually have to map all those addresses so when we say to our process hey pick a memory location, pick any memory location, do you feel lucky punk? alright if our programs are well written then we'll stick on the valid page numbers if their not then our operating system, our kernel will notice that it's trying to read an impossible entry inside here right okay so this is called a page table and we have one of these for each process alright let's see if you're awake  I know it's up silly question it's a friday. um, let's um let's figure out this, what would happen if we could actually write to our own page table? how machiavellian do you feel today? what could you do if you could change your own page table
okay i've got one person here if you've got an idea explain it to your neighbor [silence] okay let me give you a clue  what about some of these other frames that I didn't bother to draw arrows to guess what, somewhere else, there is another process that has its own page table that says okay I've got some memory here please I've got some memory here so if you could change your own page table this is like escaping the matrix right? you've got out now you can arbitrarily read any piece of memory in your system wahahahahahahha in fact arbitrarily change any piece of memory in your system you say, actually, okay, I'm actually going to map this area say to this one in here and that's pretty useful because this is where this other process is storing all the secret passwords etc so you can break the security model of the operating system so each page table actually, each process has its own page table last thing I want to say about this is we can do some really clever tricks now we've got this mechanism here's what I'm going to do you see this entry down here? I'll just shade it in it's essentially a valid entry but right now it doesn't point anywhere why? because I decided that the memory that was being used there actually isn't being used by this process it hasn't touched it for at least 10 seconds and I've got other processes in the system that are starved for memory they would love to have more memory so I'm going to reallocate one of these pieces of RAM and say well actually you can be used by some other process so right now, it's as if all the atoms behind you in the back of siebel are unnecessary you haven't looked at them for ages right? you haven't collapsed their wave function, they are not part of this room at all but if you were to turn your head and actually try to look at that location we'll make it reappear and that's what we can do with virtual memory if at some stage in the future, our process decides to use some addresses down here then oops we run into a problem the kernel at that point is notified and we quickly say oop I tell you what I'll connect this up to somewhere say here I'll put in the right data in here and then we'll let our process go and we'll do that as fast as we can and the process will never know wahahahaha because it tries this memory access, we stopped it at that moment and we only let it continue after we got all of the data ready to go so we can play these tricks all the time and part of a operating system is to figure out the best use of this memory and then update the page tables accordingly last thing I want you think about is that we can set attributes on these page tables like this entry is read only and if we did that, that means we can safely share it with other processes knowing that none of them can change it so for example, we only need to have the C library and other libraries your process might use in actual physical memory once and then everybody else can share the same block of memory because none of them can change it so we can can set attributes on these pages right so that's our simple page table and I hope now you can see it's a mechanism so we can escape from virtual memory into real memory how do we do it? we took a really sharp knife, we took our memory address and we cleaved it into the offset and a page number and then we use a page table  to look up where to go in memory and you might ask where do you put this page table and the answer is in memory but of course we can't actually look [something] so this has to be a physical part of memory somewhere and we can't use the same mechanism to look itself up so how big is my page table in this case? well I said it had 2^20 entries and each one needs to be about 32 bits so it's going to be four megabytes in size why? because there are 2^20 entries and each one was 4 bytes so that we had enough bits to talk about every possible piece of RAM in my system right that's enough about virtual memory today are you ready for page 2? page 2! okay first of all yes it's true there is a quiz on monday okay what can you expect on this? what should we be able to do we should be able to implement a barrier using condition variables, semaphores that kind of thing you should understand the three steps of condition wait the fact that it unlocks the mutex before waiting and then relocks before returning  mutual exclusion, we should be able to make a ring buffer using semaphores or condition variables so what you did in section yesterday would be useful and we should be able to spot basic synchronization errors in semaphores mutexes and in condition variables you now know about the reader writer problem and you can see the notes on github about what we call the writers preference solution where if a writer comes along we delay any new readers which wish to read the writer still needs to wait for existing readers but we put new readers into a pen like new sheep arriving they cannot continue until the reader gets its chance to do the writing and then finally don't forget our dear old dining philosophers and coffman conditions so, let's talk about that the dining philosophers problem is a classic computer science problem, robin introduced it already and uh, don't be surprised if it comes up in interviews what is it? what's it mean? what's it about? it's not about philosophers, it's not a drinking song it's about concurrency, it's about deadlock and it exploring different solutions to deadlock
it's kind of a fun thing to try and implement so we can discuss so called candidate solutions and we can quickly bring out our coffman conditions and say okay does it satisfy all coffman conditions? is deadlock possible? or does it break them in some way? so what if we did this? we'll pick up a left chopstick after we've done that we pick up the right after we've succeeded at that, great we can eat and release is deadlock possible? right well clearly we have exclusive access, we're not sharing the chopsticks yes we can have circular wait, what else? hold and wait yes we've got hold and wait because we are grabbing one resource and we're not letting go until after we picked up the second resource so we have hold and wait as well so what have I missed? mutual exclusion, circular wait, hold and wait and preemption, no one is telling these philosophers to put them down so yes we have deadlock the host is not saying okay put that down alright what if we try to do this the other way? we picked up the right one and picked up the left ahh we can still have deadlock as well same condition applies this time of course we would have if each one is picking up the right then we could... we can see we've got we can form a circle of all the philosophers waiting for the other chopstick, they all manage to pick up the right chopstick at the same time and they never get to pick up the left chopstick because it's being held by another philosopher so they all get stuck holding one chopstick so yes again we have deadlock what about if we had eat what I tell you could we use this to avoid deadlock? yes, if we're in control, if we have a birds eye view of the table we can ensure that there's never ever circular wait we could avoid deadlock so this is okay but now it requires some sort of absolute look at the table and a complete understanding of the state so this is potentially okay provided I understand deadlock, provided my solution above this can avoid... we can avoid deadlock okay what about this one? pick up left chopstick, try to pick up right chopstick, if that doesn't work then release both and restart deadlock? it's not deadlock it's not deadlock because there's no hold and wait, we've fixed... hold and wait but... this is a kind of classic approach to try and solve these kinds of problems that oh we didn't get both resources we'll just back out a bit and retry these kinds of implementations usually suffer from livelock usually what you'll end up with is one poor philosopher that doesn't get to eat as much as the others possibly none at all because it never gets a chance to pick up both it's continuously picking up one chopstick and putting it down, picking it up and putting it down so you're wasting a lot of CPU time attempting to get both but it's in fact very hard to get both so yes you can avoid deadlock but then you have to worry about livelock and with that have a wonderful weekend we'll let you know shortly when the next MP is out  and as always I have time now if you have any questions for me thank you very much, have a fun and safe unofficial
So good morning ladies and gentlemen and welcome to another exciting episode of CS 241 ...the Dining Philosopher's Code Edition! Alright, are you ready for some synchronization? Okay, so, here we go. What we're gonna do today is we're gonna talk about dining philosopher's, we're gonna look at what makes a good dining philosopher's solution, we're gonna look at what makes a bad dining philosopher's solution, even if you find it on the internet, it's probably wrong. We will also ...make a fat wallet, and we'll see about that in a little bit. Also, if you're looking for your exam script because you forgot to put your netid or something else on it, I've got them all in the corner over there, so you're welcome to come down anytime during lecture or after lecture to help find your exam script in that pile. Okay, and, so let's get started. Right, so. Dining philosopher's... Hello! Welcome to lecture, what's dining philosopher's about? Okay, thank you, yes! It's a resource problem! It's about we've got some philosopher's sitting at a table and sometimes they want to be inside a critical section or do something and they gotta try and grab their fork, or, if you prefer, chopstick... Doesn't really matter to the actual conceptual problem, right? We can deal with abstraction here... And our problem is that we might run into deadlock because they want to grab two at the same time, and we've talked about deadlock. What are the four necessary and sufficient conditions for deadlock? Give me one... You don't know. Okay, good answer! Alright, give me another one: Circular wait! Thank you, yes! What is circular wait? Okay, yes, it's from they're spinning around really fast here... no, no, yes, thank you! Yes, correct. It's when we have a set of processes where there's a cycle in the dependency graph, where one has to wait for the next one wait for the next... Okay, give me another one! No preemption! What do you mean by that? Thank you! Yes, correct. Okay, so what do you mean by no preemption? Yes! Correct, okay great! Correct, you can, we're not gonna interrupt a process once it's got a lock Okay, right, it's not like you've heard now. Like, yeah okay Okay Right, so we've done two. Any others? Mutual exclusion! What do you mean by that? Okay, yeah, we're both talking at the same time, yes! Right, so, mutual exclusion: that once a resource has a lock, no one else can use that lock at the same time. Okay, so obviously with our gardener tools example, if the gardeners choose to be nice and actually share tools at the same time, there's no problem! It's only when they say, no, I want exclusive access to this!" Because there we have a possibility. Right, have we forgotten anything? Hold and wait, yes! I need to be holding onto at least one resource, and wanted to get another one, in order to get a circular dependency. If I only had one resource, that's not a problem. It's only when I try to grab two. Right, so, you see dining philosopher's conceptually, this was used as basically as a academic discussion problem for many, many papers because it's simple to describe, it encapsulates a lot of the problems of asynchronous systems, systems trying to do things at the same time. And we can look at different solutions and say why they suck. And analyze what the problem with them is. And do all philosophers get to eat the same amount? Could it be, for example, the last philosopher does eat, there's no possibility for deadlock, but maybe when we actually run an experiment we discover that they're less likely to be able to get both forks. So, there's actually quite a lot of literature about dining philosopher's. And, it would be embarrassing to be a computer scientist and not know about this. And not know about dining philosopher's. Hence, we teach you at UIUC. So let's actually today look at some code, and that's what I've got in front of you right now. Because I don't know about you, but being a recovering physicist, you know, I like to experiment with stuff and play with stuff. Okay, overhead, let's start off with this... Actually build things, and kind of kick them until they don't work. You know, standard kind of experimental physics stuff, right? We like to, just, play with things and see what happens. So, I thought okay, let's build dining philosopher's and then see what happens, and you can download this stuff from the web. And so here's how we might start: Right, I need to conceptualize each philosopher and so I'm going to give them a name, there will be a thread associated with each philosopher, and whether they've failed or not to pick up their two forks, or whether they've managed to lock both mutexes. Okay, so, here's our struct. Why do we do typedef? Because I don't wanna have to write struct philosopher" all the time, so, so, here's how we read this, we say here look, this is the actual type, I'm defining inside here, and here's the alias, Philosopher." Then I have a global flag running"; so at some point, I want to stop my program. And if we spin down to the bottom of this code, here's the plan: right, we're gonna sleep for 40 seconds in our main thread, then we change running" to zero, and if everything has worked okay, then at some point, our philosophers won't have deadlocked, and they will escape their loop and we'll be able to finish. So, then we can call pthread_join" on all of them, and exit. Oops, I'm sorry, exit down here with return 0". If we couldn't join on them, for whatever reason, if they failed somehow, then we'll know about it at this loop here, so we can find out whether our solution is good or not. Okay, let's check that those mutex locks really were initialized... Okay, so, here let's go back and have a look at the top of the code... where is it... Okay, so we've got our nameList", we've got all of our forks, so, we're actually gonna define our forks as automatic variables inside our main method that means we cannot use this static initializer, we better call pthread_mutex_init" here because the mutexes are actually on the stack now. Okay, so now let's pass in the address of each fork there's no special options we need to set today, and oh look how robust this code is: it even checks the return value to see if it failed. Right, so if we get past here, we know for sure that all those mutex locks have been initialized. Now it's time to set up each philosopher. So, each philosopher just has a pointer to a left and right fork. And fortunately, we know about modular arithmetic, so that the very last philosopher, the index 4, will get the 0th fork again because we go 'round, right, so now each philosopher has a left fork and a right fork. And the last thing we can do with a philosopher is stop them! We've got a Philosophunction" called "Phil", which we're gonna run and we give it a pointer to our struct. So, when you work on the MP, you'll be reusing mutex locks as well, so hopefully this lecture is useful to you, and, oh yeah, that's something else we'll talk about in a little bit. Right, so that's our main loop; pretty simple, right? Just initialize everything, sleep 40 seconds, and then, just like any dinner party, you have to clean up at the end. That's not the interesting bit. Here's the interesting bit: page two!
Okay First interesting comment This actually claims to be a solution to the dining philosopher's. If you put dining philosopher's solution, this is one of the pages you find But, let's see if you, today are more intelligent, no more can do more system programming than the interweb Because today we're gonna find out if this code is correct or not Right so let's see how it works Remember, this is gonna be run for each philosopher so the first thing we'll do is we'll take that pointer that was passed and we'll cast it so now we've got a pointer for each thread each thread has its own pointer to that little struct that we've set up, okay? And let's see what we do then... okay, so Our philosopher has two states, right They're either sleeping or eating. Well, that's not quite true because we also have this middle state where we're trying to eat Right but most of the time philosophers get paid to sleep a.k.a. think, right? so Between 1 and 8 seconds, our philosopher's not doing much, just sleeping but occasionally, they wake themselves up with a fantastic thought I am! To be or not to be!" Or something like that. And they say oh, I'm kind of hungry now!" Right, this philosophy is kind of, uh... ha, makes me hungry. Right, so what do we do We get our two forks We announce that we're hungry and then we try to pick up, we try to lock our two mutexes now, here's some cleverness in this code here, here's a function we haven't seen before: we're gonna do something called trylock" what trylock does is it trys to grab the resource, but rather than getting stuck, rather than blocking if that mutex is already locked, it just immediately returns. it immediately comes back to you and says I'm sorry, that resource is actually currently locked". So, you can play again later if you want, but you didn't actually get to lock the resource So either two things happens: either you lock the resource and continue or it returns a non zero value and you continue right, so this code tries to avoid deadlock because you and I know something terrible could happen, right? something terrible... if every philosopher picked up their left fork first at exactly the same time, we've got a problem every philosopher will be holding onto their left fork trying to grab the right fork and they wouldn't because there's another philosopher saying get your grubby mitts off that, that's mine!" Yes, so that's what we're trying to avoid; we use this trylock" to prevent that. So what do I do if it failed? If it failed... We let go of our left fork. Brilliant, right? We got no hold and wait anymore. Alright, so, look at this: No hold and wait... We could actually annotate this code with some stuff that shows that we actually know a bit of computer science, or at least, more than the people at rosetta's Rosetta Code. Okay, so look, no hold and wait. And then we do something funky here: And we go around again. This, unfortunately, ladies and gentlemen, is where I stop talking, and your brain starts working. At this moment in time, I'm gonna ask you with either your imaginary friend or a neighbor of your choice, to figure out if this code is any good. If it is good, why? If it is not good, why? Okay, so I'm gonna give you a few minutes to look at this code and analyze it and be prepared to say something about it.
I have a story once about a  A friend that got 200 applicants for one job, so The programmers, the software developers were saying ha! how do you deal with like this big stack of resumes?" So the boss picked up exactly half the pile, put them in the trash, and said I don't like dealing with unlucky people." (laughter) Alright, so let's have a look at this code: Right, so Here's the plan, right: we know about circular wait, so What we're trying to do is, if we fail, we'll swap our ideas of left and rights and next time around the loop, we won't actually be picking up the fork on the left, we'll actually be picking up the fork on our right. And then we'll try to pick up the other one. And if that fails again, Well, we swap our ideas of left and right again And so we end up picking up on the left first, and then on the right. So, does this code work? If you're in your Google interview, and someone says okay, look at this code! Does it work?" What would you say? Excuse me, I need to run back to CS 241!" Can I make a phone a friend?" Right, what do people think? I'm sorry Okay, it tries to break circular wait By not having a... by saying, okay, I'll pick up the other side first" Alright True, this last kind of probably the thinking behind it this But... Does the code actually run? Will it deadlock ever, or are you confident this code will never deadlock? Remember, our understanding of this is not just about dining philosophers; it's about being able to write multithreaded code in general and spot problems. Yes? Yeah. So you, are you saying there is deadlock or not deadlock? So you're saying there's potential for livelock where one philosopher never gets to eat or two are constantly interchanging? Okay, I'll come back to that, I'll the point in a moment. Yes? Uh huh? Yep. So, when you say pthread_mutex_lock" line at the same time, which lock line are you talking about? This one? Okay. Right. So Let's talk about the live lock" thing, right. So Yes, and I'll come back to that. Right, so let's talk about the first question, right: could there be live-lock here? Alright, live-lock, remember, is when we don't have deadlock, our processes haven't actually just ground to a halt, waiting for an event; no, they're dancing around, trying to make progress, but they never actually make progress. They never actually are able to proceed, they're always saying, okay, can I take it now? Can I take it now?" It's, it's like trying to make a continuous kind of phone calls and you're never actually getting through You're using up your, you're running your CPU program but it doesn't actually achieve what you want it to. So you still suffer from starvation. So, the code tries to prevent live-lock That's kind of the idea behind this tries_left" thing. We don't want a philosopher to starve; if it kind of keeps trying to pick up one fork and it fails to pick up the second one, 'cuz our trylock says I'm sorry, another philosopher has already got it" Eventually, the philosopher gets angry and says I'm not standing for this live-lock business. I don't wanna keep holding onto the left, picking up the right, letting go, picking up, letting go, picking up, letting go, picking..." you know. This is not working out for me, I'm hungry. I really want to get access to my resources, I refuse to be live-locked." So, on the third try, I get a lot more aggressive and I don't do this trylock", right, when my "tries_left" has been decremented to zero, I just say "ah, just grab the right fork." And I'm refusing to play anymore games. I'm just gonna grab that right fork. So, on the third go, We say, no, I will pick up the fork on my left, and I'm gonna wait until I can pick up the fork on the right." So then yes, we could be unlucky, it could so happen that there is a precise moment in time when all five philosophers are holding onto their left fork. And they've all done these games of trying to do trylocks" etc. But on the third time, they all decide ah, I'm just gonna wait until I can grab that other mutex." And if that happens... The system deadlocks. Yes? So. So if they all end up in here If all five philosophers end up in here Then we have a problem. We're gonna have deadlock again, we're back to our original problem. So we haven't solved it; We've just written code that appears to work. Right. Let's see if we can prove this. Right, so, we can see a way that deadlock could happen. Do I have... right... okay, right, so...
Alright so let's run it let's actually see let's actually watch this deadlock here we go alright im just gonna make it a little bit faster im going to  instead of sleeping for so many seconds im gonna do microsleep because we want deadlock to happen right there in a few seconds right so here we go there you go see! it's working. deadlock! what? did I just? make a mistake? We showed that theoreticlally deadlock is possible but it doesnt seem to be happening! Our test is good! We should deploy this to our google servers and run our email system based on this code. So hang on we showed that deadlock is possible, why didn't it happen? Yeah, you have to be really unlucky. Just how unlucky? Right, and it ran for 40 seconds and we've just proved that our code is great. No, we didn't/ We can only prove that the stuff is good or bad by actually reasoning about it so let's see if we can force it to have a deadlock how could we try to force to have deadlock? well we need to make the chances of circular wait to be much greater and right now, uh we, we uh we grab one lock and we grab the other one so let's make it so that we'll grab our left fork, we'll wait for a little bit, and then we'll grab the right fork alright so im between these two locks im going to increase the percentage time that my system is doing hold and wait so im increasing the probability that we're gonna have a circular wait during this time so let me put in a number here like say 10 microseconds right we'll run this still no deadlock! [jibberish] when I played with this earlier, so that's fascinating. right this is a hard demo so then i tried, okay well let's try making it random so i'll do say rand mod 10 and that still didn't work oh okay 20, okay well that didnt work but when i did 60, now we're much more likely to have deadlock so let's, actually no, i managed to get it to work with 30, so okay so here's one possibility is that now by making it long enough there's a chance it might deadlock straight away because all five threads started and all five threads ended up doing those two tries and getting to the point where they all decided to say oh no, forget this. i'm gonna just not use try lock anymore, i'm gonna call lock" right so if we made that time period long enough, there's a chance it might deadlock straight away. but it doesn't always happen, right? so it could be that... okay there we go this managed to break eventually  Okay so, that was kind of a deadlock and what i have shown you is real code for dining philosopher's and also this idea that just simple testing is not enough to prove that your mutex locks and your other stuff is correct we gotta reason about it carefully and and then proving it does work is also kind of difficult. you actually have to show... you have to expand the time where hold and wait and circular wait actually might happen otherwise, a simple like minute test or 40 second test is not enough to prove that your code is correct questions about this? Okay, right. So, a couple of comments first of all, there is no prep for section this week because the MP is out Well, there will be some stuff in the section. um we, We'll probably give you some things to play with with dining philosopher's I'm gonna write section stuff today but there's nothing to prepare for, for section right, now i've gota  challenge for you time for the fat wallet challenge, okay so do I have my wallet with me? Haha, I don't have my wallet with me Can I borrow this? Right, say this is my wallet Alright, umm Actually, I need something here we go right right, this is my wallet, okay, it's got, I don't like it to be empty It's also there's a constraint on the number of items I can actually put in this, okay? So I've got some functions where I can add and remove things from my wallet Here it is And I can define some constants like hey I never want to be less than zero or greater than 100 I wrote about money because we like to think about money but it doesnt have to be money so I want to keep this variable always within those bounds always at least zero and always 100 or less But here's the exciting thing This is hints for the next MP! Right, for the MP that's currently out, if we can reason about this, maybe you can do well on the MP Right,  and here's a challenge then: So, I've written or sketched out how these functions should work If I didn't know about synchronization So, if you try and remove something from this wallet If you want to remove a certain amount First of all, don't do it While I shouldn't quit and if the money minus a certain amount is less than min, do nothing! spin, spin, spin so it's just a busy loop Right, busy loops are bad, they burn up CPU time And our CPU could be spent doing other things instead Well finally, okay, if we dont want to quit, so if quit is still zero, then actually subtract it Okay, add works the same way, if the money is greater than the amount, then spin spin spin spin spin and just wait And finally add it to the amount Right, being seasoned CS 241 students, you can immediately see oh we've got a potential race condition here" right, if i've got two threads calling remove or a thread calling remove and a thread calling add at the same time, then, I've got all sorts of race conditions like this negative equals and plus equals they're not actually atomic operations It could be that you read a stale value of money because another thread is updating it at the same time There's another race condition that  The value I read it in here is protected so another thread could be changing the value before I get to subtract it
self so we've got a lot of work to do we've gotta have first mutex locks in here and we're gonna have to put some condition variables in here so that if we're not yet ready to add or subtract our thread should just block, it should just go to sleep right, so a quick refresher on condition variables how should we use them? well, remember, before calling cond wait,  you must have locked a mutex right, so above it somewhere at the beginning of your code you're going to lock a mutex but the good thing about cond wait is that it will unlock the mutex for you right, so let's pass in our pointer to a condition variable and a pointer to a mutex and when we do that, it unlocks the mutex, the other threads have an opportunity to run, and then it sleeps okay, how we wake up a sleeping a thread inside cond wait? easy, kick the monk right, how do we kick the monk? call cond signal! and that wakes up the monk before that thread can continue, though, it must reacquire the lock on the mutex so, it's ready to go, it's woken up, well now it's stuck inside a lock call so remember this actually does three things: it unlocks locks or sleeps and then relocks before returning. right, so this doesn't actually tell you what happened. so, in practice, what do we need to do? we need to write a little while loop here where we put some condition while something is true, go back to sleep if we want to wake up a whole load of monks, then you use broadcast  on the condition variable right, the last thing to do is before you return, call unlock and the beautiful thing about this is that the code that we actually see in front of our eyes can only be executed by one thread at a time because of this lock that we've booked, i'm sorry, unlocked because of the mutex these mutual exclusion means that only one thread can be doing stuff, can be accessing our variables inside the code that we write alright, so I'm going to stop and then i'm gonna let you go, so we've got the pthread mutex initialized in here and, there's something similar for condition variables as well, so there's pthread cond initializer so it's just a magic constant which says please initialize my my object here, my condition variable or my mutex right and now this is where you come in. it's time to write those three methods using mutex locks and condition variables
Okay so let's convert this code into some actual code that works. Remember that there might be multiple threads actually trying to do this at the same time. There could be multiple threads calling remove, multiple threads calling add, and we only want one of them at a time to actually change the value of our money variable. And we wanna make sure that we don't end up in deadlock and if we say, add enough money into our wallet, then a waiting thread will now move, she could then potentially carry on. So let's think of how we can do this first of all, let's put in some mutual exclusion here so only one thread at a time can actually access these variables right so how do we do that?  well we're gonna need our pthread mutex lock calls and let's pass in... variable and we'll... course we'll need that inside our add method as well and at the end i'll need a pthread mutex unlock if I could spell it, there we go, all right okay And you might say oh hold on a moment, you didn't stop pthread mutex lock correctly." That's okay, with vim I can do regular expressions, where I can say things like  Substitute on all lines p_m for pthread_mutex and do it global on each line so if there is more than one match per line, don't do it so... so there we go. right um, so okay right We haven't done condition variables yet though so the next thing is rather than doing a spin loop,  we wanna go to sleep, and guess what?  Our code we've written here is very close to what we need for condition variables. Rather than just burning up CPU, let's just send our little to sleep. How do I do that? Well, I can... Let's delete this word Delete word delete word delete word, right oops, too much... alright I can say pthread_cond_wait And say okay, wait on the condition variable and here's the mutex I want you to unlock. Okay So you might start by initially  By having, okay, paste that line in again By saying oh I just need one condition variable" But actually, let's do better than that. Let's make all the threads that are trying to subtract go to sleep on one condition variable, and all threads which are trying to add... Go to sleep on another variable. And if we do that, we can make better performant code because we only need to wake up the right kinds of threads when we make a change to our system. Alright, so This one will make sleep on our second one. So if you're trying to add, then go to sleep This other condition variable Right, are we done? No, okay, so one thing we should do is wake everybody up. So if we stop, we should pthread_wait wake a thread up or two, how can I wake up all my threads? So broadcast, and I should wake up at least all the ones on cvs1 and also  do it on cvs2, right Now, how am I doing with time? okay, so So this thread, this broadcast would work in this particular case because its a one-way flag on most processes.  But actually, if we want to be really correct, what we should really do is We should always lock a mutex before doing this Okay Okay, so, just by for convention, if you're going to just as a kind of pattern thing, and for technical reason involving many barriers we're gonna actually just lock our mutex before calling broadcast.
Right, so, we're gonna wake all the monks up But have we finished our code? I'm sorry? Signal? Okay, so if we've just added money to our wallet, it could be that somebody that's trying to subtract could now proceed So let's wake up someone in the subtraction So are you going to do something like pthread_cond_signal on which one, on the other condition variable? Right, so, this will wake up one thread and that happens to be waiting to subtract. Would you do that? So hopefully your answer is no, I wouldn't do that, I wouldn't write that code" Why not? Perhaps you could explain to your neighbor  or to your imaginary friend why you don't wanna wake up one thread Okay, so, let's think about a particular example Let's suppose you've got ten dollars in your wallet Are we doing... I'll change it like this Say we've got 90 dollars in our wallet And one thread wants to add 10, another one wants to add 20 I'm going to make them larger sorry Add 20 or add 30 So they're both blocked right now And then  A moment later, another thread comes in and say, pull out, let's say, 15 bukcs I could see that the adding 20 could now proceed But our code was unlucky, it decided to wake up just one of the other threads, and so it woke up the one trying to add 30. It came out, it managed to lock the mutex, it tested its conditions and said oh i'm sorry, I would still blow the budget, I would still go above 100, and so therefore I'm going back to sleep" What we should have done is woken up all of the threads trying to add, in case any one of them could now continue Right, so the correct code in this And get rid of that... Is to wake up all of the other threads, right, so let's fix our code... let's substitute the word signal" for "broadcast" everywhere in my program There we go Right, and now I think I'm done. Now I think I've got an asynchronous wallet where all threads sleep until they are able to add money, yes! When do I unlock, when? Why do I unlock after broadcast? In this particular example, it doesn't matter... for the stop method... But for the other ones, it does matter. And it comes down to the fact that you can reason about exactly when things happen. And you don't want another thread going into...  Let's say you're an add, you don't wanna know the threads going into the remove method,  and going to sleep just as you are sending the broadcast message. Otherwise you have a very small but potential race condition. If you have the lock, then you know that it can't actually go to sleep while still sending the broadcast message. And it's a tiny, tiny, tiny race conditon but it's easy to fix by always having this mutex lock. So, with that, welcome to the world of synchronization. Thank you very much, hope you got a lot out of this lecture; for those of you that want to find your tests, please come down here and have a great section and have fun with the MP! Thank you very much.
I didn't get the memo that half the class would be in EOH i guess so for those of who are here, welcome, and congratulations for making it, also sent to myself right , so here's what we're gonna do today. we're gonna talk about virtual memory and uh, we're gonna look at how it is implemented in 32 bit systems and 64 bit systems, okay? so, we're fortunately not gonna need to design any hardware but we are gonna understand enough of how it works so that we can see some the advantages that it gives us and also see some of the considerations that you need when you scale from 32 bits to 64 bits right, so, just a, first of all, an important point is that uh let's see, if i got, if I've got 32 bit addressing if i got a 32 bit address to talk about then in 8 bit bytes then i need to oversee 4 bytes to store that pointer, yeah? and, if i got a 64 bit address, then just double that i need 8 bytes to represent a pointer or to represent an address so that's gonna come up again when we talk about storage relief because remember, for each of these entries, it depends on on whether we're talking about 32 bit system or 64 bit system okay, so, yeah, we're used to seeing this with pointers but w'ere gonna see this again in terms of our storage of addresses right, so, here's our first question so what's a page table? what's a page table!? who remembers? yes! thank you! yes, it's a way to translate a virtual address to a physical address you can imagine that if we didn't have page tables, well then we can have a HUGE associate map for EVERY possible virtual address and map it to an arbitrary physical address okay, how much space do we need for that map? well we'll need one entry for every possible physical address and each entry will take 4 or 8 bytes hold a moment, we have just invented a scheme that actually takes more memory than i actually have so we do better than that by dividing our memory up into pages  and we do this arbitrary mapping for not every possible byte but we have a map for every possible page not on memory  right so here's the basic idea, we got some virtual memory address and, we're trying to turn that into a physical address so on a 32 bit system we'll take a virtual memory address and conceptually split it into two parts these bits here are called the what? paging? paging? page number! and what about these lowest bits? yes, they're the offset so if we're writing this in C code we can probably come up with a way to extract the page number from an address okay so if i say i got some pointer and i shift it right by 12. what have i got? the page number! yes and what about the offset could you write an expression for the offset i only care about the lowest twelve bits i could AND it with something yes so i can mask it how do i get the lowest twelve bits okay, for this ill give you a couple of clues everyone knows that two to the eight is 256 and of course we also know that two to the ten is a 1024 so two the twelve is four times that also known as 40996 yes! so... i could write what 4095, is that correct? okay. in other words, the bit pathing 1 2 3 4 5 6 7 8 9 10 11 12 in binary so that means when i AND it with this number, all of my upper bits will be disappeared, masked to zero so this give me the offset i could have written an expression here, i could have said something like: take one and shift it left eleven more times, the subtract one as well so we got ourselves a page number and offset now just like any good cooking show, this is where we take what we've made and we set it aside for later okay, we'll be pouring the offset back in at the very end we don't care about the offset until the very very end what we're gonna try to do now is convert this page number which goes from zero up to 2^20. how big is 2^20? okay, how do we work that out? well, I just told you that 2^10 is about a 1000, so 2^20 is bout a million! binary million so what a bout a million possible numbers to look up so we're gonna take these page numbers and stick them into just a big table and inside this table, i need to know where to go inside my RAM and in fact I'm gonna convert from this virtual numbers to these physical numbers they're called physical frame most of the time we'll never talk bout frames because most of the time we don't actually care about real memory most of the time, our programs that we write live in this virtual address space but today because we're actually gonna figure out how to convert virtual memory to real memory, yeah we need to talk about them so these are our physical frames so we just have a big lookup table ok how might that work, easy, let's just have a big array and that can give us the frame number
Okay, so if we got the frame number how do i now combine that with the offset to find the actual piece of RAM, the actual RAM location could you write down an expression that takes the frame number and somehow combines it with the offset to give you the actual address in memory that you should use you're not simply gonna add them together alright, i'm hearing some good things down here, but... lets see what do we got up here any ideas somebody shout out something even if it's wrong, it's okay! alright what do we got... gimme an idea Adam! Okay. thanks for playing... guess again! right. Our problem is that our page number just goes up in ones. err Sorry our frame number goes up in ones zero one two three four five. we dont want that we want our addresses as you can see. they go up by 4096 bytes so we need to multiply that by 4096 bytes. Yes you got the correct answer thank you [something] right, so, I heard you talking about it earlier right so, we wanted to take this and somehow multiply by 4096 so i could write that that the physical address is gonna be then the frame number, Fnum multiplied by 4096 plus the offset but i dont want in hardware to multiply by 4096. do you realize how much silicon that would take??? NO i dont want to do multiplication. What would be a better thing that multiplication  Yes! Just a step to the right if you haven't seen the rocky horror picture show, I encourage you to do so. Right so we want to step to the left we're going to shift left...right? and we need to go up by how many? is it twelve? yeah we need to multiply by 2 to the twelve. so we'll shift it left by 12 how do you shift left by 12 in hardware? easy you just move the wires off by 1. you just move the wires up so by shifting in hardware is trivial, you just relabel what the electrical wires actually mean okay so got ourselves a physical address. fantastic! easy! that's our page table! so life back in 32 bit world is easy, we calculated how many, how big, our table was. it doesnt seem to big, we just have a million entries. so, uh okay, so now we can work out this kind of typical exam question. right, 32 bit system. in other words, on a 32 bit system, each entry is gonna be 4 bytes.  if each page table is 4 kilobytes. okay so that tells me that the offset then is gonna be, two to the, this is the size of the page table it's two to the twelth so this means that that my offset is gonna be 12 bits so that means Ive got 32-12 bits remaining so number of entries is 2 to the 20. or about a million okay, so we worked out a number of entries. how much space is it actually gonna require to store this entire page table for this process well each entry, has to store a number, the physical frame, and I'm gonna say we'll use 4 bytes for that you could squeeze it into a little bit less, but... we could squeeze it in into kind of three bytes or so, but let's not do that. lets keep things simple. each entry is 4 bytes... why did i need 4 bytes? because I'm taking back numbers which are 4 bytes long so ive got two to the twenty times four bytes is what? 4 megabytes! so the overhead of using virtual memory here is 4 megabytes! and we better store this table in some well known place in physical memory alright? we can't store this table somewhere in virtual memory address otherwise we'd have to use the table to figure out where it is stored in real memory so the cpu has another register that says: okay if you want to actually turn a virtual address into a physical address for this particularly process... there's somewhere in memory where i put aside 4 megabytes to store this table okay, so, a little challenge for you here let's say Ive got a program that's gonna read a byte at this virtual memory address how we many memory reads  are required? so if I didnt have a virtual memory, I would just need one memory read. I would just read the byte location 512 yeah, I would just read the byte hexadecimal value 200 but we now have virtual memory, so how many memory reads are required two! YES! we need to actually go back to main memory and say okay I'm tying to read this particular address" so, I need to turn this into a page number and offset and once ive got the page number, i'll go back to my table, lookup table, which is stored in real memory in order to pull out the actual physical frame and so this might be pointing anywhere. okay its actually in here so it took me two memory reads, i had to read the 32 bits in here, and then finally, the byte that i cared about what have i just done to my machine?! I've just through sheer brilliance managed to make it twice as slow! I've halved its speed!! remember, memory is really slow! compared to the CPU, you could often do ten to a hundred, if not more instructions for the time it takes to go to main memory remember? HI MEMORY MEM READ? HELLO youre gonna do that twice now. for every single time youre gonna read or write
So we have a problem, yeah? we have invented virtual memory, but we have halved the running speed of our machine this might be a difficult thing to sell in the marketplace if we half the speed so we need to do something about this okay we can have caches, etc but we still got the problem Now, we've invented virtual memory which is great, we don't have to worry have fragmentation so much but we halved the speed we halved the speed because we're doing this lookup alright, lets see what happens when we use a two level page design so why might be care about two level page design well lets do a similar calculation but for a 64 bit system lets keep our page sizes at 4096 bytes so, what is this? this is 12 bits... so if thats my offset. how many bits do i have for my page number? 64 - 12. i got 52 bits left thats gonna be used for my lookup table, alright? so how big is my lookup table gonna be? 2^52 how big is 2^52? okay so how do we work this out roughly. well 2^10 is a 1000. so okay its a little big this is the number of entries i'll need inside my page table i better go home and and buy a lot of memory just to store my page table so what worked really well in 32 bits is completely falls over in 64 bit land because, we... heh. our page table is just too large! BUT to quote black adam we have a cunning plan.. we'll have a cunning plan" We will use a multilevel page table because, our address space is huge, but guess what: most of it is unused! so, let's split this 52 bits up into multiple lookups so we'll take this and split it up into pieces. uh, we'll um lets start it with just two. so the idea is that I've got an initial lookup here lets say that its, that we use um... i dunno.. 10 bits? sometimes they only uses 4, but this is matter of example so we use the upper most 10 bits some of these can be empty, they may not refer to anything. they may not be used in that huge swath of address space we dont even need an entry in here so lets say that the lowest and highest entries are used here so this will point to another page table  with a whole lot of entries, lets say in this one, we have twelve bits and these entries may or may not be filled, but they dont refer to frame numbers yet. i can keep playing this game for as long as i want until i got up to a total of 52 bits alright so how many bits have i used up so far... twenty twentytwo....  so now ive got thirty bits, for example in my last one: and so on so ive just invented a little page table system here, a multilevel page system, where to convert the page number to a frame number, i now have to do one two THREE memory reads and each of these can point to a different table right so this one will point to a different area of memory... just say okay these are the entries in here, they may or may not be filled and so on so now i've made my 64 bit machine even slower than my 32 bit machine, right? now a single read or single write now takes 4 memory looks up the actual read itself and all these page table look upss if I was working at Intel at this point, I think i'd be fired, yeah? we've come up with a machine that is now twice as fast as last years model but dont worry its got a bigger number on the box, so people are gonna buy it right so this is the idea: so we've got a basic idea of how to split this up with the idea that we can do multiple table looks ups we have just got a little bit of a problem that most of the time, its incredibly slow so in a little bit, we'll talk about how to fix that alright so lets do this we'll work this out on a 32 bit system and for a two level page table example, we'll say we'll have 10 bits wait a moment, i wanna get up to uh yeah, 32 okay, and then um 12 bits for offset so how many memory reads are require to read a byte at this address well you wanna do a read first of all, you go to top level page table. this gives you the address of the next page table and finally this gives you the frame number for memories so in a two level page table, we are running at three memory reads for every actual read or write that you wanna do sorry. three memory accesses that your program tries to do. so we're three times as slow so this is a great system that allows us to have virtual memory, but as i keep saying: ITS SLOW so whats the fix? the fix is this... translation lookaside buffer
called TLB so our processes rarely need to access page frames in a completely chaotic, random manner most of the time, if you recently accessed a particular page in memory. guess what! in the next few nanoseconds or microseconds, youll likely want to access that again so lets cache the result lets cache the result of all the lookups that we're doing on the off chance that we'll need it again in the next few nanoseconds as thats the purpose of the TLB its an associative cache if you have a query about which physical frame you want for a particular page number then if youre lucky, we've already calculated that in the recent past and we still got the result in the TLB in fact, TLB is designed so that 99% of the time, we have a cache hit the result IS in the TLB one thing to note about the TLB, we do this in parallel this is hardware. so in trying to figure out what physical frame we want to go to, we ask the TLB at the same time as trying to start this other lookup through the multiple page tables and whoever gives this answer fastest, wins because remember, we're using this everytime we want to talk to memory so it is a critical piece of CPU performance ok, questions at this point? yes okay, so uhhhh let me give you an anology and then i'll try to do as it as the concept itself its bit a like this: suppose i wanted to go from a phone number to a student name so I use the first few digits of the phone number to go to a particular filling cabinet, so the 217's" im all gonna put in this particular filing cabinet. and the 604s in the other cabinet so i start off with  the top most digits (000 to 999) but i wouldnt have the actual entries inside that filing cabinet, this should tell me which other filing cabinet i should go to for those entries so its... and it could be that some of these are empty, we dont have anybody with a 555 filing.. uh phone number okay? so it will be a bit like this  we'll get the first result and we'll have our first table and we'll use the  the highest bits  but we've shifted them down... so this is just kind of pseudo code and this tells us, where the next table is so if you like, its a pointer to another array ok result 1 and we'll use the middle bits as a number inside that table and that gives us finally our frame and then we just need to multiply or shift it and then add the offset  so we dont know.. so theres multiple ones of these middle tables and they correspond to different entries in the whole address space so if you think about your process. OKAY the stacks at the top. The heaps near the bottom. and the very bottom is the program code" so you might find that you might actually got three entries for example, in your very first table. one of the very memory addresses and a couple for a the lowest memory addresses. nothing in the middle yes. yes it skips all of these lookups itll give us the frame number no because the TLB is part of the CPU it doesnt need to go back to main memory. its a tiny piece of associative cache its a expensive, its fast, and it tries to do it if possible within one instruction because without this, the whole CPU, it doesnt matter we're gonna add the most played numbers together. as soon as step outside trying to use registers, we have to use the TLB its essentially, its stored in these pairs a page to  ... frame number and i dont want to go too much further, because guess what, we can spend a whole semester talking bout TLB's if we were hardware people it turns out that on real hardware, we have TLBs associated with each level of cache. we have a TLB associated with table lookups and data lookups and TLBs associated with CPU instructions etc etc etc this is how intel figures out to make very very fast chips by optimizing the size and performance characteristics of these TLBS that youll find on the cache and you gotta decide as well.. how do you.. do you want to share these between different CPUs theres a lot more detail than we're gonna think about today I wanna comment on one important idea though we've talked context switch when we get our CPU do something else, when we want to take the CPU state and save it
so we need to do a context switch for example, you're gonna need your CPU to start working on a different thread or start working on a different process so a context switch as far as we're concerned, we save the CPU state my question for you is what should we do with the TLB is it still valid, are there the entries in the TLB still valid in a context switch? what.. take a moment to talk about it with your neighbor okay so the question is... what should we do with the TLB we got these lookups from a page to a particular frame of memory and what happens during a context switch well its a trick question it depends on the kind of context switch because here's one example, suppose we got our CPU to stop working on one particular thread of our process and please instead start working on this other thread of the same process all our virtual memory is still the same since inside the same process so all the cache lookups that we've done ... we can keep that ok here's a different example suppose we tell the CPU to stop working on this process and start working on another process our virtual memory is no longer the same the address is no longer mapped to the same pieces of memory, so then if we swapped another process we should clear the TLB the state of the TLB is only relevant to a particular process because virtual memory addresses are unique to each process as long as is... it depends on how much money you have to spend okay right ready? page 2! alright so our processes are working along one day and tries to do a simple read or write to an array, an ah! the TLB says 'i have no memory of this page' and a few nanoseconds hundred nano seconds later, we finished walking through the page tables and hah! NOTHING. nothing i got nothing of this particular page number. it doesn't actually point to a piece of real memory. what happens? its on the harddrive. yes! we can cheat ok heres the beautiful thing about virtual memory is that we can lie to our processes is that, they are like inception, live in inside virtual world in virtual memory and we actually need to have their data in physical RAM when our processes try to read or write it for the rest of the time, haha! we can just dispose of it and use that ram for other things for other processes that always want to access memory ok so where it can be find. it might be found on disk inside secondaray storage ok so, we can store it where might you find it? for example what's known as a swap file or in linux: a swap partition where area of your disk is not used for storing/making files but for storing this copy of memory so we can swap out a page at a time and store it on disk and we'll leave it there until  an attempt to read/write memory fails stop and think how that might work alright your processes are like okay read this piece of the array, or read this variable, or call this function" at that moment, the hardware says oh guess what" this virtual memory address doesn't correspond to a physical address i better kill the process the hardware of course doesn't actually kill the process instead what it does, it raises an interrupt on the CPU and we have to write some operating system code that says aha look at that!" our memory hardware is complaining. it couldn't find it" we got two options at this point we could say clearly this process is a bad program, and that address is just invalid; it was trying to read a bad segment of memory. segfault" Or it says hold on hold on. dont look! and pull the relevant data from the relevant disk and stick it to memory" itll be like trying to call comcat and they employed people in that time that you actually called them up hello i'd like to complain.... um so we can do something clever right here and that is where the dirty bit comes in with each frame of memory, we can store a little bit of matter information about how its being used by the process for example has this piece of memory ever been modified as long as its dirty why didnt we call it the modification bit I DONT KNOW  but anyway its the dirty bit to say that the contents of this memory has changed since it was first created either loaded in from disk or malloc'd when you expanded the heap  but the point is we got stuff in memory that we care about so if the dirty bit is set, we know that if we want to put this data on to disk, we actually got to save it
so what kind of optimization can you make if the dirty bit is not set if the page is clean thanks! yes! great! you don't need to necessarily write it back to disk. it could be we already got a perfect copy on disk.  whats the point of actually writing it again when you know that its identical so you can save yourself from time if you know the page is clean could be that the page for example is just NULL / zero. you havent touched it at all. youve allocated some memory and you havent used it yet it could be part of your process. the CPU instructions that actually make up your program when you know you got that stored on DISK, whenever you need to read that, just load that page in so it tells us whether the page has been modified thats not all we can store about each page what else can we store we could have a  happy bit we could have a Fri.. not im just kidding we dont have a friday the 13th bit or a happy bit but i invite you to take on a hardware company and add that yourself when you want it so what else can we put inside each page. thats matter information. what would be useful to us yes! a valid bit okay. we should a valid bit that says its a real valid address, perhaps its not currently loaded into memory what else?! ok... clearly clearly i need to make you a lot more evil think for a moment how we can our processes more secure how would you like protect memory in some way. yes! okay, what's that do? if you try to read from memory it gets you a segfault. okay i'll that ! yes how about we protect what you can do with this memory so two common ones are whether its read only and whether you can execute it or not  so think about your virtual memory map for a moment. weve got our instructions down here. our functions that we've written or the CPU code. we've got the heap we've got the stack up here ok i realize thats unreadable but you notice now! we've got the stack at the top and heap and functions the only error that we'd expect the CPU to execute instructions in is this bit down here, where we've written function code we dont expect to start executing instructions inside the heap and the stack and in fact if that happened, it mightve happend because someone's managed to have a buffer overflow and DELIBERATELY put malicious instructions into our memory and somehow managed to get the CPU to jump to that location so most processes, you should not be able to execute code thats store on the stack/heap and an exception might be a just in time compiler, such as java but most of the time we don't expect that so we should be able to mark our pages and say do not execute stuff inside this page, if you do raise an interrupt and tell the operating system about it" another one is read only. read only is really cool because that allows us to share pieces of RAM for example the code for malloc, for example for strlen how about all the of the code inside the C library, libc we could put that inside one piece of memory and then share it with all processes that need it. for example how about the openGL library for example, right, and i can start listing all the common libraries and we only need to put them inside physical memory once! so its a huge saving and i  can share with all these other processes, so that i can minimize the total amount of physical RAM right here's a little demo here okay, so in fact i can  look at this special file called maps and  in fact with linux i can see how thing are mapped so ive got and we'll talk about this virtual file system later on in the course but you can see ive got libc, and for this particular process libc, different parts of libc are mapped into different parts of my address space right so we talked about sharing stuff to be able to share libraries theres another reason why we might want to share some ram and that is IPC also known as inter-process communication, a way for two processes to share and  today we're just gonna talk about a few examples just so you can at least name drop this stuff inside interviews and here they are mmap allows me to setup some shared memory between two processes  so i can say fork and now actually have some shared memory that exists between the child and the parent so its a deliberate way to say nonono we actually want to share this physical piece of RAM together between the child and parent" how else can you connect two processe? how could else you could send some info
signals yes! its a very simple form of interprocess communication but you can send a little signal for example HEY TIME TO QUIT" or send it say 'siguser1 and siguser2' and you can decide what these particular signals mean how else can you comunicate well ill give you a hint about we'l talk about next lecture and that is pipes! and the nice thing about pipe is that you can push stuff down one end and another process can pull stuff out the other right so ok in the last 30 seconds lecture we'll talk about Amdahl's law ill give you hint about what this means for mpmerge im asking you to make mergesort go fast but think about the program for a moment. whats it do it reads a whole load of data, look at the source code . youll discover its using scanf and converting a line at a time into an integer. then we do the sort and then we printed it out to a file so your challenge is to make this bit go faster but in the basic week 1 version of the MP theres nothing you can do about the timings of in and out. and in fact if your interested, you can see just how much time these take and that would help inform you what kind of speedup you might expect for the process as a whole and with that. have a wonderful weekends. im here if you have any questions. ill you see monday! thank you very much monday we'll talk about pipes and seeking through files
Good morning class  How are you? Good Morning  How are you? Great, Isn't the weather wonderful? So here we are only a week back from the Spring Break  Let's kick back and relax  As you know  Uh  Come on  Okay, alright so  We are going to look at two important things  First is pipes The second is working with file descriptors and moving around in files Okay  So, the Â other important thing to note is that there is a quiz on Friday  No, just kidding  It's Wednesday  Okay, so the quiz on Wednesday we'll talk about in the second half of the lecture  So let's get started with pipes  Pipes are a form of IPC  Interprocess communication  It's an easy way to go to send data from one process to another process, especially when you want to talk about child and parent processes  And the great thing about is that the data that you sent stay in memory  So, yes we could have opened a file and write to communicate with different process  But we can use pipes very efficiently when we have processes in memory, so the kernel system can manage this as a stream  Now why do we call it a pipe  Because it behaves like a pipe  We can use one file descriptor to push data down one end and another process can say Okay, I'm ready to read data  Let me start pulling data out And it behaves exactly the same way as reading and writing to a file  So this is a fundamental concept in Linux and other operating systems is let's have something called a file descriptor which can actually be more than a simple file descriptor  We're going to see this again later in the course when we talk about socket and when we talk about networks  Guess what I'm going to set up a communication to another machine somewhere on the intweb and I want to send some data to it or pull some data from it, and it just like reading from a file Well  Kind of  Of course there is little bit more details but that is the basic idea  I have an integer that represents the communication pipe and I want to be able to send and receive data  Now, first thing to note about pipes is that actually you get two file descriptors for the price of one  We're gonna use the first one for reading and the second one for writing  Okay, so we have two file descriptors So they are specialized  So a pipe actually is a one way device  We could use it to send data to ourselves  It would be pretty silly, but we could use it  There is a danger to that though, which is that the pipes like a ring buffer have a limited capacity  If you try to send too much data on the pipe, your write call will block until somebody actually pulls data  So if you use single threaded process that's bad news, because now there is another thread available to actually do the read  So let's actually start by actually looking at some code here  Okay, right  Let's pull up the screen  Do we have a picture Okay  Ah  Step 1, plug it in  Hurray  Okay  Right  So here is our device now  other comments on this that there is more to read about pipes and you can read more in my little wiki book  Here we go  For example, files and working with pipes  And so there is more to read about this  So, how do we make a pipe  Okay, so the trick is first of all just make an integer array of size 2  Here it is  I'm going to call it my file descriptors  Here we go  And so we are going to pass a pointer to my array  How do I do that? Easy, just use the name of the array to this function called pipe"  Okay  So that makes an object inside the kernel that represents the communications  I can now use between different processes So for example let's now just have a look at those numbers so we got the two file descriptors fds 0 and fds 1 So we made ourselves a pipe  Now this being an in memory thing  Here we go, it used file descriptors three and four  That shouldn't be too much surprise because I already know that 0, 1, and 2 are being used, right? 0 for standard in, 1 for standard out, and 2 for standard error  Alright, so we got ourselves a pipe which then just died because process died  So we want to do a bit more than this  We want to set it up so that we can send the message from our parent to a child  Okay, so let's make a parent and child  How do I do that? It's time to fork  So here is our fork result, and if I get a number bigger than 0, then that mean I'm actually the what? The parent or the child? I'm parent! Alright  I have a child f so I am the parent  Okay, so we are going to send something from the parent to child  So let's send something down to the file descriptor  Right, now the first file descriptor is used for reading and the second one is used for writing  We should send something to fds 1  Right, what should we send? So how does the write work? So remember, it's just takes a pointer to some memory, and if we pass in a string like Hello, what do we get there? Well you get a pointer to where this string constant Hello's So we have the address of the H and we can send that And we can send that right  Later I send a new line as well  So how many characters  How many bytes is that to send down? That's one, two, three, four, five, six, right  So we will send six bytes to that file descriptor, Now we could have send it to the standard out, and we would have seen it appear on the output, right? But we are not doing that  We're going to push these six bytes down the pipe  And we stand a good chance of not blocking  Most operating systems allow you to send at least 4 kilobytes of data Others actually some allows you up to 128 kilobytes I've seen in the past, so we know this is not gonna block but what should we do now? let's just prove that we've done something we want to print out  Okay, so parent sent some bytes  Okay, and we'll Â just finish
Okay, so other thing to do then is to be the child  As a child, you want to write from this  Okay, so how can we do this? Well one low level way of doing without the c-library is to do directly call read, and if you call read, you need say which file descriptor and so, that would be fds 0  You need to say, Hey here I got some buffer, I got some memory you can use, and also say how many bytes I am prepared to accept  so if I were to make, for example, a little space on my stack here  I could then say read into the buffer, and here is the size of my array Now if you call read like this, of course you may not get a thousand twenty four bytes  So actually we should see how many bytes we got So here is the number of bytes and we expect that to be greater than zero  In fact, read will block until we get some bytes out of that pipe  Okay, what should we do with this bytes?  Well, let's for now print out Hurray I can't some bytes"  say the number, and we could say, read what happens  Right, and you can perhaps guess what might happen here  So we want to say we got this number of bytes and here is our buffer  Okay, and I'll do a new line, so we flush this  Right so let's try this and see what we get Alright, so parent sent some bytes, and Hurrag I cant some bytes"  Right, so my typing today is a little off But we saw six bytes, and we saw Hello  Now, one two three four five  We were lucky in this case  Why were we lucky? Yes! correct, we didn't send the null byte  We sent Hello" and then new line, which happen to be six bytes  But we never actually sent a null byte  We chose to not send a null byte  We just sent it as bytes  And the operating system doesn't care  It just says Okay we got some bytes from my parent" got some bytes from pipes that stick them down, and later it says Okay we'll read this many bytes" So, our code is actually dangerous  Our code could have printed out gibberish after the Hello Let's fill up our buffer with some garbage, right  Let's put an extra character in there  And you'll see that we manage to print out the hash as well  which is not a part of the message  So our mistake here is that we forget that the string has a null byte, and if you want to do string processing on the byte that you get back, remember to include the null byte  Either send it explicitly down your pipe or add it afterwards The operating system doesn't know that you're sending a string data  It's just bytes as the operating system concerned  It's just Hey, I'm gonna put this on the memory  Here's some bytes to send the pipe So, what could we do with this  One common thing to do is to include special character in the end of our message  Maybe a null byte, for example  Or another character to say Okay, I'm not going to send anymore data" So, if I for example, I could say I know that my normal data would never use an exclamation point  So that my reader would say, Oh look, I just saw an exclamation point I now know that was the special terminator to say that okay my parent is done with me, and it's never gonna send any more data So telling the reader that you have no more data is easy  You could just simply include a special character Okay, so telling the reader, you just send something special You send Okay, good bye", and then you write a little bit of code and say, "Oh look, I've just got the final piece of information I know there is no more data coming There is another problem, which is What if the reader closes and the writer doesn't know" And we will return to that in the second half of the lecture, so this just a quick introduction to pipes  Look they are pretty easy and now they can give you a form of inter-process communication  If you want your child and your parent to send stuff to each other, guess what? You need two pipes And, I deliberately didn't tell you one more detail, which we will review in a little bit  About closing these file descriptors  This is kind of naive version of pipes  We'll come back just in a little bit  Instead, we'll gonna talk about fseek and ftell  Unless any has any quick question No quick question  So the comment here is Whoops, we should be closing stuff" And we should be closing stuff here too  Okay  Alright, so let's do fseek and ftell Alright, so the next thing we'll talk about is our file descriptor, when it talk to a normal file when we call let's say open or fopen a file  Have a position  Right? We can say Okay give me the next line Say call read line  Or read the following next 8 bytes And every time we talk to a file descriptor then, we're changing the position in a file  So the operating system is keeping track of that  We can change it  One other cool thing we can actually do is jump to the very end of the file So, why might that be useful? Okay, we want to write some data again  Suppose you want to know how big your file was is the plan  Move the file descriptor, so it's right at the end of the file, and then say Excuse, what position am I?" And that tell's you how big the file is  So please tell me my current position
So, the things I'm talking about are fseek and ftell  Let's have a look at that Okay, great  So, ftell, tells us our current position  So if you go to file descriptor and you say, Where am I in the file?" That's useful in case you want to get back there later for example  It's also useful if you get to the end of the file and you want to know how big the file is  So a common way of finding out how big the file is is the following  We'll fseek to the end Call ftell and then fseek to the beginning of the file  To do what we're gonna do, say copy it In fact, past cs 241 exam had asked you to identify or write code that does this very thing  I wanna know, for example, how big of buffer I should need in order to read in the entire file  Great, no problem  I'll just find out how big the entire file is, and then go back, so I can read in the entire data  And it's a common gotcha or common mistake to forget this line  If you move to the end of the file, they say, Okay now we need this many bytes" your operating system will say, Ha ha ha I'm sorry, I don't have that many bytes Alright, so don't forget to move back to the beginning if you intend to actually read the data in  Now, fseek is actually pretty powerful  You can use it in three different ways  You could say Hey, I want to get to the end, I want to get to the beginning, or I want to get to the absolute position So if you'd actually earlier called Hey, ftell was my current position"  You could use that to say Now I want to return to at that point" Okay, let's have a play with this Okay  So, I want to open a file, how do I do that? Well let's do it in using C, so we have a File pointer here  Remember all these basically wrap a low level file descriptor, so we can call things like fprintf and fscanf, but underneath it all, they will be calling write and read  So, we could say open a file  Let's call it data.csv" Â and I want it to say open it for reading and writing  So, let me print some data to it, so I'll have 1, 2, 3, 4  And, let me fclose this  So, that means creating a file, writing to a file descriptor, and closing it  Okay, so we'll will run this And we made a file  Now inside here, I got my data.csv and I could look at its contents  There we go  Oh look, there it is, 1, 2, 3, 4  So, let's do this again, but this time , we will play out our tricks with it  Let's have a look at fseek  Here it is So we pass in a point to the stream  We can specify an offset that typically is gonna be 0, and then this whence constant, which is either gonna be Hey an absolute position, the very beginning, or the very end" So we can just seek to the end today  So we'll go fseek on f  No offset needed today  And we want to go to the end  And please tell me then where am I in the file If we look at the ftell, ftell gives us back a long  Let's not print anything to it this time Okay, and we'll have a look at that position Alright, what do we get? Oh zero, L How did we get zero L? Because that's not a real type Right  So we made a file with 1, 2, 3, 4  But the position is zero  Why? I'll give you a clue  Let's look at our data file Whoops  We just opened a new file for writing and we cleared its contents So the file is empty  We've truncated it back to zero Alright, so let's have a look at this data that I made earlier This time we'll open hello.c for reading Okay, I will see that this time we found that our program size  Whoops, why can't you see that? Just jump to the left Is that better? Right, yeah  We printed out 71 Okay, so what do we do? We opened hello.c for reading and we seek the end  And we said Okay, what's the current position?" So, with this, then I could now read in all those bytes from that file  For example, I might at this point say, Now I know how big this file is, let me have a buffer of exactly of right size" Alright, so malloc position and then I can call fread  Okay, so fread, I would like to read all bytes as possible please  And how many bytes do I want? Well that many So, does that manage to read in my file?  Let's see what we get  Alright, so this time, let's print out the   okay that was our position Let's print out, call it, num bytes read Okay, forget size of this  Probably it is size type or long, but we will use that for now
Okay. Let's check man 7 fread. So we need a pointer and size of nmemb, and stream, so we got the order wrong here So our pointer into the buffer. And okay. Alright, the number of bytes read was zero. Why? Yes! It's still at the end! Whoops.  Okay. So before we read in the entire file, let's seek back to the beginning. Alright, so how can I do that? I could do this two different ways. We could specify an absolute position 0. So I could call SeekSet. Okay, let's do that. Where is my..there it is. Or I could do relative to the current position. So if I know that I'm 71 bytes ahead. I could say move negative 71 bytes backwards. Alright, this time how many bytes we got? What? 1? Oh I must have messed up the constants here. Number of bytes read... Uh.. bop ba bop ba doo. Alright. Or we may have to read the... Oh no no no no no. That's correct. I did this wrong way around. Okay. Here we go. So, I specify this as Hey read 1 chunk and that chunk size is position." So now if I set my fread constants correctly, it would say the size of chunk is 1 and I want to read 71 of them. In other words 71 characters. Then the result I get is correct! I managed to read 71 characters. So great, I read the entire file into memory in one go. And we could print it out. So let's just puts. Where is the buffer? Okay. Buffer. Now is this safe code? Do you trust it? Look, it printed out the contents of that file. Printed out Hello world.  Is that safe? Correct! There is no null pointer guarantee at the end. So actually we should have made the buffer one byte larger and then actually put a zero byte in at the very end. So, safer code would just say Look, I know the file is there, so I'm gonna treat it like text later." But fread is just saying, okay read all the bytes into this memory. If I truly wanted to treat it as a single string, c-string. I better make sure that it is terminated at the end. So my code might have to be put at the buffer.. There we go.. Make sure that truly is terminated. Alright, so now we got a fast way to read in the entire file. Yes!  Here? fseek here? Okay, so this means the very end. Past the end of the file. So if you would to then open this as reading and writing, you would actually being appending to the current contents of the file. Yes? Okay. So.. does the a typical text ... does a typical text have a null characters in it? No they don't. It's only when we pull strings into memory when we append a null character to represent the c-string. But files don't have the null characters in them. Sorry, the text files don't normally have a null characters in them. No. It does not have an end of file character. So, instead there's some meta information to say, Oh actually this file is currently have this many bytes." And there is going to be an alternative ..so the meta information we will see about the file is the thing would be something like when was it modified? Who modified it? Who created the file, and how many bytes on disk does it currently use. Right. So the fseek does not actually walk along the file checking for the byte. It can quickly use the meta information of the file to tell how big the file is. So it's pretty fast. Yes? Would there be what? Yeah. There's actually is something call stat. But we will talk about it later. Yes. So the alternative way to get the file length is to use stat. But I'm using the fseek, ftell as a way to introduce fseek and ftell as Hey here is one practical way of using it. And stat is low level system call. If we use fseek and ftell, you are using a c-library and nice thing about that is that it is little bit more portable then getting straight down into the POSIX. land of using stat. Okay, for example, this would work on a windows machine. One gotcha is that you saw is that fseek gave you a long. So this would only work on medium sized files. These days we can have files that are gigantic. And much larger can be represented than just a long type. Yes? Right, so if you fseek back to the beginning, you can set it up so you can only write over specific bytes. So the trick here is the option we give to fopen. As so whether you want it to start brand new file or append to an existing file. But the way to think about this is simply that my file is basically just an array on disk. And I've got a pointer that points to where I would write some bytes. So if I wrote 3 bytes, I'm going to just overwrite 3 bytes.
Other questions? So... Interesting problem happens is. What happens if we open these file descriptors and then we fork? What happens, right? Cause I've got clearly something opened, talking to a file. So I can now modify that. I can fseek to different places And I can close it. Okay, so. First the little problem is let's suppose your parent calls fclose. What do you think will happen to the child? Can a child still use the file descriptor? Make your guess now, and you want to be sociable, tell your neighbor Okay, here is why I told to tell your neighbor, because psychology has shown that you'll actually remember things more if you're surprised when you are wrong. Okay, so make a commitment. It doesn't matter if you get wrong. Just at least be surprise. Okay. Alright, so the answer is that it doesn't affect the child. That these actually appeared to be independent, so actually if the parent closes, the child can continue to use the file descriptor and vice versa. Alright, so, in that sense they are independent. Alright, now what about this one?  What happens if you fseek before forking? What do you think the child and parent see? Do they see the same position? Make your guess now. Okay, so if you seek and then fork, both the child and parent will start from that position So for example, if you seek to the very end of the file, and then forked. Both the child and the parent start from that position. So, they will both see or use the new position. Okay, what about this one? What happens if say the parent or the child fseeks? Does it affect the other process? Make your guess now Right. Yes, it affects the other process Okay, hey, that's not fair, is it? Alright, so here's why. Let's think about this from the system's perspective. It's got a big list of file descriptors which are opened, and if you fork, then actually it increase reference counter and says Oh look, I've actual got two processes using my internal file descriptor. So it's a bit like showing a library book with somebody that if you want to turn the page of the library book, guess what everybody else using the same file descriptor has to look at that page of the book. Alright, so the analogy is like a book page. Okay, so the surprise is, Yes", in terms of closing it, it's independent, but in terms of using it, "No." It's actual one open reference.  So, think of it as the kernel holding a reference to a file at a particular position. And by forking, all you've done is double the number of, or increment it by 1 of number of processes using this same open resource. That means the parent could play bad news on a child. Here you go. Have this file descriptor. Oh ha ha. I'm going to change the position that you are looking at and you didn't know. Alright, so you can really mess with child's mind here. So it's like a book. There is one particular position, so that's a common gotcha.  And thus. Here's something that is kind of useful. If you wanted to write code to write to different parts of a file, at different positions. Then, if you had multiple threads, then there is a problem, right? all of them would be calling fseek trying to move to a different position. It would be nice if you can just say, No, no. I want to send some bytes and this is the absolute position in the file that I want to send these bytes. And so, this is why high performance code these days. If you go to the HPC. HPC lands high performance computing stuff. They often use something call pwrite, which allows you to specifically write to a certain position in the file independently of this fseek and ftell stuff. I don't think we'll use it inside cs 241. I just want it to mention it. It is just like a cute thing to talk about in an interview. It's like, Oh yeah by the way, this pwrite stuff exists" That came about because of changing the position of the file becomes the bottle neck. That all of your threads or child processes suddenly say, Okay, hands off everybody. I want to change the absolute position of the file and no one else can change it once I'm using it" So that's clearly a course of contention
Okay. Are we ready? Page 2! Let's so.. Okay here we go. What's a named pipe and unnamed pipe? So, I actually showed you in an example of an unnamed pipe. Where inside your c-code, you can say Okay, give me a pipe." And you pass it a reference to a little array and it fills that in with two file descriptors. That's an unnamed pipe. Does not exist anywhere other than inside the memory. There's actually another form of this, which isn't used very often. But it's called a named pipe. Which is something you can create apparently on the disk, and here's how you call it. You could say make fifo and give it a file name. Okay, so we'll call it a bag pipe. Anybody from Scotland here? Okay.  Right, so bag pipe is an instrument where you can set up a drone and you keep squeezing it, and you wear a kilt and you Stand on the great hills of Scotland. Alright, so that's a bag pipe. It seems to exist on the file system, and in fact the joy of using a bag pipe like this is that it's lifetime is independent of your process. The bag pipe will live for other processes And you can create it using this make fifo.  What do you think fifo stands for? First In First Out, right. So your first breadth into the bag pipe will be the first data that comes out when you try to read from this file. Except this is not a file. It's a pipe, so the order of the data. So reading from it and the writing of it doesn't behave like a file. It's like a queue. First-in First-out queue. They are not often use, but they are worth knowing about Remember signals? I'm not talking about con-sig. I'm talking about software interrupts we can do such as sigchild, sigint, sigkill. Pipes themselves have a signal Alright. You get a signal If you send data down the pipe and no one is listening See, if a tree falls in a forest, does anybody hear it? As the writer, how can you discover that your reader has died? Is no longer listening to the data And here's how. Actually, you can get a software interrupt, you can get the signal. Say, Oh by the way, there is no one listening anymore. All the file descriptors have disappeared, have been closed. Maybe deliberately, or maybe the child process itself has finished, but guess what? You can send as much data we used, because you'll like try down this pipe, but there is no one there to read it anymore. So you get a sigpipe, so you can choose to handle that. You can set up a signal handler to say, Oh look, my reader from the pipe is not getting anymore data" Now, a couple of comments on this. First of all, this means if you fork, then make sure you close the unwanted file descriptors So what do I mean by that? Remember we did this kind of thing, we said Okay, give me two of these", we call pipe.  Look how easy this is. Alright, so now I got my read and my write. Then I call fork So now, conceptually, we got four file descriptors. Yes, the child has two, the parent has two. But we're only going to use half of them. If the parent gonna do the writing, the parent does not need the read. If the child is gonna do the reading, it doesn't need the writing file descriptor. So a common pattern of this is in the child, the first thing you do is that you would close the one that you're not gonna use. So for example, we might close the second one, and in the parent, we do the same thing.  We close the first one, the read.
Why'd do that? To make sure that when our true reader really does finish or close their file descriptor then we'll get the signal. Then the system truly knows that there can be no more, that there is no one left to actually hear the message. Right? So that's the pattern. you'll see this, and you can read the wiki book to see examples of this, where you close the unwanted one. Okay, now the joke of the day and on EWS it doesn't work. The EWS linux kernel 2.6 whatever it is, has a bug such that you never see sigpipe.  But don't worry. I'll tell you a work-around on Friday.  Or maybe the end of today, we'll see Right, should we have time for this?Alright, how do we send an integer... a value of a variable? Okay. I showed you code that just use read and write to send stuff down to a pipe. If you wanna start sending more interesting data like integers, etc, we want to be able to call things like fprintf(), right? We actually want to send.. a user send a c-library. Guess what? Here's something very useful. I can call fdopen. Where it pass in one of my integers, a file descriptor So, for example, if I want to use the write end, and then the other is... I'm not trying to use this for reading or writing. And this gives me back one of the file objects. There, I can then call fprintf(). Or if I'd opened the reading one, I can then call fscanf() So this is a way to promote a low level unix file descriptor up to a c-based object that we can now... I don't mean object in C++.  I just mean a resource in a system so then we can call fprintf or fscanf and work with more structured data. So this takes us from a simple integer to the C-based version. Now I can use fscanf and fprintf. Questions? Yes? Yeah fdopen. Alright so we're going from an integer to a C-level object Alright, yes? When it happens, it happens when you try to write stuff in into the pipe no one is listening. So you want to try to write some data and then you just discovered that no one's listening. You don't what happens to the reader. That's the point. Maybe you could set up a different pipe to say Okay, I'm gonna finish it, you can use another pipe to send the data." But the idea is that the pipe itself can tell you when no one is listening. No. no, it's when you try to send the data itself. If there is no one there already, you get the signal. Okay, so.. right. Yes we have a quiz on wednesday. I'll publish some practice questions in a little bit. But here are the topics you can expect. Conditional variables, semaphore, mutex locks. You have mastery of these amazing tools. You know what producer consumer is. You know how to make a fixed size multi-threaded ring buffer. You could do it with semaphores, you can do it with conditional variables. You know how to analyze a good and bad implementations. You know the coffman conditions. You could understand the definition. You know reader-writer. You could analyze good and bad implementations. You know dining philosophers. You could talk about the different implementations and will they suffer from deadlock or livelock. And finally, resource allocation graphs and how to use them to determine which processes are deadlocked. With that have a wonderful week, and I'll see you on Wednesday. Thank you very much.
okay good morning class as you might have realized, spring break is starting and so congratulations for being here as opposed to enjoying the sunny weather outside, oh wait so first of all if your sitting in the back and want to have a more cozy experience, why don't you get up and move to the front and see what it's like at the front for a change I promise not to bite too hard either sit down and relax or come on down and see what it's like at the front and we can have a cozy class right so here's what we're going to do today we're going to talk about handling errors and how we detect them with our system calls and then we're going to talk about some fun stuff, we're going to start talking about networking and this is kind of important right? we want our machines to talk to each other so we'll get done today with some of the basics about ip4 and what's the difference between UDP and TCP but before we do all of that, let's see if your brain cells are working today in terms of pipes right so I mentioned before that you can get a SIGPIPE when something happens - when? when does your process get a SIGPIPE? I'm sorry I'm not listening yes, when you have a PIPE and you write some bytes to the pipe and there's no one there to listen and the failure [will cause your process to] get a SIGPIPE so you can write some code inside your signal handlers to say oh look the listeners died, maybe I'll just fork exec a new one for example now a common gotcha though is when your playing with pipes and fork as you might have found out in the lab, is that you forget to close all of those file handles that you don't need so if you still happen to have a reading file descriptor open, you won't get the signal because in theory you could still read form that okay, so that's our first little question right alright so when all the readers have closed and you try to write to a pipe, you should get a signal in practice we've found it doesn't actually work on EWS the old EWS machines don't support that yet but here's the good news, you may have gotten an email, did you get an email from me this morning? fantastic, right that's my new email script I can now send email as anybody to anybody inside UIUC anyway I won't make jobs about the provost so hopefully you've logged into your new virtual machines brand new feel free to destroy it, install software, etc etc and in the worst case, I'll just give you a new one so it's probably not a great idea to store your family archive on this machine but it is important because hey with this box you've got root you can do root-y things like mount file systems, like connect to named ports and run them ports we'll be talking about that in a little bit but anyways, so let's finish our pipes off so when can a listener discover that there are no more writers how about this then, because in section our listener right was wc, we were using word count to pull data from standard in how do you think wc knew that the pipe had closed, that there was no more bytes coming okay so we had to flush it but actually we had to do more than flush flush simply says to the C library hey you know those bytes you're looking after for performance sake I don't want you to look after them anymore send them down the pipe, in other words call write but we need to do more than that because flushing doesn't actually mean that the pipe itself has closed we want to close it but we haven't actually answered the question yet of how does the listener know when it's not going to get anymore bytes and the answer is if you call read, it returns zero so it's not an error yet, it's just simply that hey I'm going to give you zero bytes and the pipe is closed so let's do this let's have a little play okie dokie right so I made a pipe  I'm going to close the second file descriptor, in other words the write end and let's try reading from it okay so bytes read equals read we need to give it a file descriptor okay so what shall I say fd[0] is where we read from, how many bytes do we want? well here's a pointer to buffer and I'll take sizeof buffer minus one why minus one you say? well for safety for example I might put in at the very end a termination byte for example, just to make sure my strings don't go on forever okay so let's print out to see what value we get okay and I want to print out the result of my read call hey and look it's true, we do get zero, fantastic okay go away right so that's one way right? now that's obviously if we're doing the low level calls like read and write if your working at the C library level you can check for an end of file EOF condition on that pointer so remember how we do fdopen to get yourself a C library pointer well then there's a thing called fopen right so that's relatively easy then to discover that something is closed another way of doing it of course is that you come up with a special token or special character to say hey if I send them asterisks or a zero bytes, then I know that that signifies to me that there's no more bytes coming another way is to say at the beginning of your message, hey I'm going to send exactly 4000 bytes and here they come another way is to know exactly how many bytes you are going to send beforehand anyway and hard code it into your program so that's all we're going to say about pipes today let's mess up our program, let's try and read from a file descriptor that doesn't exist okay so let's say from one hundred and twenty three okay I don't need this right, so what's going to happen now? alright we get a result of negative one the read failed, I cannot read from file descriptor 123 well you and I know that's because there's nothing connected to that integer it's an invalid file descriptor but we want to actually know more than that, we want to know something about what went wrong and for that there's actually this global constant called, whoops come back thank you, errno right error number, so error number will have been set so let's find out what value it was  okay so we'll stick this in here and we'll print it out
actually we can do more than just print out an error number there's a function that allows us to go from that error number to a useful string so we've got strerror and we can pass in a number like twelve well I don't want just twelve, I actually want the number that the system has set for us, so let's print that out as well and see what we get okay right here we go so yeah our read returned -1 to say hey I've failed we've got an error number that's now set to a non zero value and we've got bad file descriptor, which now makes sense to us yeah we've passed in an invalid file descriptor number so before we've played around with things like printerror and it will print out something like It is a Friday let us go okay and perror takes the text we've got followed by okay here we go It's a friday let's go with a colon and guess what, the same message: bad file descriptor which is if you were a user a completely useless message bad file descriptor? sounds like the beginning of a bad movie no it's worse, so okay put this into your log file but don't display it to the user of course but now you can see how perror might actually be implemented in terms of this strerror function okay so that's our error number, it's set when a system call fails so if we go back to our little handout here so what is errno? it's just an int and when is it set? well when a system call fails you can find out what went wrong so nine is not a particularly... yes [question] a new line? you mean because printerror adds a new line as well? is that your question? okay right so we don't need to deal with these numbers like nine, we don't need to remember that nine means bad file descriptor because guess what? on the man page of read [something] we discover the return value we got a list of errors, here they all are so lots of things can go wrong and if we wanted to write a robust program we might actually choose to handle some of these you might say okay in the generic sense, just crash the program or write to the log file but there might be others where you might decide to say print a message to the user and that's how we can do it, we can check errorno to see exactly why the system call failed and then we can just compare it to these constants so in our code here, we could say if errorno equals bad file descriptor EBADF, your file descriptor, your program is a mess! okay so we are going to handle this particular problem what are we going to do about multiple threads? let's say I've got threads making system calls, they are calling mutex lock, they are calling sem wait, they are calling read, they are calling write if they fail, don't we have a problem? how would you know which one actually failed? suppose you're trying to read error just as another thread also fails houston we have a problem we don't know which thread set errorno muahahah yes, okay, errorno is not just an int each thread gets its own errorno integer how does that happen you ask? easy magic actually it uses something called thread local storage but never mind about that so that means if you want to know what happened inside your thread, easy, write errno if you want to know what error happened inside another thread, you can't you'd have to write the mechanics to share that information right, so it's actually local to each thread which is particularly clever yes, you can which brings us to the next question thank you very much for playing, right when is errno set to zero? when your process starts and that's it so here's a gotcha, that if we did something like if errorno is equal to something like we have the EBADF then we just assume that that happened because of the previous call we just made that may not be true, perhaps this happened, perhaps errno was set many many many microseconds earlier in our program so errno is never reset back to zero if you want to set it back to zero, do it yourself and in fact that's quite a good kind of programming practice that if you intend to check its value then remember to set it to zero beforehand
right so there's one other thing to be aware of with errorno is remember signal handlers? where we could write some code to cope with a signal like hey hey we've got a closed pipe condition so in your signal handler if we're going to be calling things which might set error number say we want to remove a file or we want to make a system call that we're allowed to call from a signal handler then it would be really really impolite to change error number for the other part of the code remember how does a signal handler work? we steal the current thread of execution we don't make a new thread. we just actually say to the CPU hey stop executing the current piece of code I want you to run this other little piece of code over here please and when you finish yeah you go back to what you were doing I'm not going to give you a new stack, I'm not going to... right we literally just steal it to run it so that means our signal handler might do bad things to error number so a good handler, a polite signal handler will remember the old value and just before returning we set it so it might go, if you want to write robust code... be careful with your signal handlers and two, if you're going to check the value of errno, it's probably a good idea to reset it to zero beforehand so that you know that if you're discovering an error, that it actually came from the code that you were looking at I've got a cute example here the other thing to be careful about is in your error handlings be careful that you're not looking at errorno values from your actual error handling so for example here it is where we're trying to discover why does semwait fail and so we printed out the problem with this code is that the very first fprintf itself may set errno and that could then lead us down a rabbit hole right? we could say okay why am I getting a bad file descriptor? well it turns out standard error was closed or something like that we had out of memory and it was actually coming out of the fprintf call so it's better to if you're going to make more system calls, more function calls, grab it and stick it inside your own variable so you know that the value you're looking at actually arose from the original call okay right so do you remember how do we print out a particular string message? yeah, easy, just call strerror and that gives you back a pointer to a string so typically you'd pass in errno here and you'd get the string that string might mean something to you and another system programmer but not much to anybody else I've got some bad news for you though it's not thread safe brought to you by homer simpson, yes that's correct your code in trying to handle errors might run into difficulties because in calling strerror in calling two different threads at the same time can contend with each other and overwrite each other's value so we've got two ways to fix this one is that you call mutex lock and unlock between getting back the pointer and using it so you would get the pointer perhaps copy it into your own memory that is being used solely by your own thread and if you do this everywhere in your code that's going to call strerror then you can be confident that only one thread at a time will be calling strerror you've made it into a critical section just remember to do that everywhere inside your code including all of the library calls that wait you control? you don't control. you don't have the source code of all the library functions that might call strerror so this is actually pretty hard to do well and consistently but I have seen people do it the other way is that actually there is an alternative called strerror with an underscore r strerror_r which is thread saf and the reason why it's thread safe is because you pass in a pointer to some memory that you would like to use okay so the next thing we're going to talk about is this EINTR hey this is the hey I got interrupted, do you want to retry? so there's quite a lot to say about this interrupt idea and we're not going to talk about all of it inside 241 suppose you make a system call that's going to go on for a long time for example, you want to write some bytes down to a pipe that's going to connect to the internet you want to call semwait which is going to wait until someone calls sempost these calls can sometimes be interrupted and immediately returned so basically, they fail they fail to actually do what you ask them to do now in the simple kind of lecture code and in the MPs we just say hey don't bother about this, it's fine but in robust code, we actually have to check for this when you are writing robust code, you have to say ok what was the return value of this system call, did you really do what I asked you it's a bit like talking to a toddler, did you really flush? [gibberish] I'm pretty sure so that's what we have to do, we actually have to say oh look, it returned negative one to say it didn't work and now we have to say but why was it something bad like I gave it a bad file descriptor? or was is it just being annoying and if it's being annoying I say hey I've been interrupted, I'm sorry do you want to play again? just call it again
now we're only going to see this for slow running potentially blocking calls so things like semwait reading and writing to the network but it's important to handle this stuff well, otherwise your code will get to what we tested but in real situations it will then fail and imagine playing kind of russian roulette with your code I tell you what, just for fun we'll make sure one of the calls you make today is not going to work do you still feel lucky punk? so that's the purpose of this EINTR, it's to say oh look these thing were interrupted, we better call them again so let's see what the kind of code would look like in this case we'll make a call like semwait and we need to check to see if it failed okay how do I do that? you could say was its return value equal to negative one? right so if that's true, we know there was an error so let's find out if the error was hey I've got interrupted if that's true, hey we'll go again right so here's our plan while this is true... go again! alright so perhaps you and your neighbor can tell me what's wrong with that code [silence] so I'll give you a clue, what's an equals sign between friends? the worse thing about this error is that you get to see this kind of pattern right? you see this kind of code and you immediately say oh that's just calling sem_wait inside a while loop it's trying to be robust code, and you don't bother of course to actually read it so what are we doing here? well errno is settable, it behaves just like an integer and so we're just setting it so what's the result of this expression? a non-zero value so therefore it's true so what our code does then is say rather than check to see if it's equal to EINTR we just set the value to EINTR and so we go around again right so what effect would this have on the code? would you spot this error? when would it do bad things for you? thank you yes, if sem_wait failed for other reasons so for example, suppose you forgot to initialize the semaphore or you're running this on a system that doesn't support semaphores sem_wait might return a different message so what do you do? you call it again! it behaves exactly like a semaphore, it doesn't proceed, it just keeps on going around this loop forever and then you say ahhhhh why is this not working? right so be careful about that, watch out for your equal vs that so that is kind of a typical pattern sometimes you see a little bit more to this as well sometimes you see that actually we want to know say the number of bytes read so we might write something like this while negative one equals okay let's store the value of our return call so let's say we want to know the result of calling read blah blah blah blah blah alright and errno equals EINTR so now I'm assigning the value of read to my result so I can use that later inside the code perhaps I want to know for example if this is zero or the number of bytes that read managed to perform so if you were to drill down into the C library you would discover this kind of implementation that every time we make a system call, we potentially have to check to see whether it was interrupted or not for CS241 exams, unless I specifically ask you to write code that does this checking, I'm not going to expect anybody to have to write this full length out but put this in the back of your mind for the day that you're actually writing real system code outside a class questions? yes? aha, right so this normally happens when a signal comes in and your process has to process the signal but that could be anything, that could be a child finishing for example you might have noticed in some of the earlier programs we wrote that if you had a sleep and a SIGCHILD happened, the sleep itself could be interrupted so why is this? the short answer is that it makes operating system programming easier remember how I said that when we have to process a signal interrupt, we steal the CPU and we actually run some code for a moment and then we give the CPU back as if nothing happened well as you can see, it's not quite true actually as part of giving the CPU back, we just give up we say hey you know that system call I was trying to do, ha, I just gave up it's a nice day, I don't have a problem with that. do you? it's kind of like the californian hello, hello yes let's do lunch and not really so in making the design of the operating system easier, we've actually put the onus on systems programmers on our user code to actually deal with handling these interrupts, with failing system calls so fantastic, you actually now know a lot about how to actually write much more robust code by checking errno  by knowing that you have to potentially check this EINTR thing there's a bit more to say I'll let you read it on the wiki book as you usual but I'm not going to be writing this code all the time in future examples are you ready? page 2!
great, we get to talk about networking so here's another cool bit of CS241 we're going to write code to make servers we're going to make code to make Yik Yak type stuff where we can send text and other data between different machines you could start with your virtual machine right now and with a friend on their virtual machine you could start setting up servers and clients and start transmitting information and this stuff is kind of near and dear to UIUC we were involved in some of the earliest network designs we are still today designing the network protocols deal with the internet 2 and the internet of things but we're going to go right back, all the way back to talk about a very important protocol which is called ip4 so ip4 or ipv4 is a way to send data from one machine to another and for that every machine will have a number, an address so if we're going to send these little packets of information from me to you or from my machine to your machine I have to know, what your address is and this is what ip version 4 is about so this is not a full exposition of the whole description of ip4, just that every machine here or every connected device can have  an ip4 address okay sounds pretty good to me, that was the plan that was the vision so when we are sending some bytes down a wire what we'll do is we'll say here's a sender, here's my ip address and here's the ip address of where it needs to get to and so these ip addresses we'l make them huge we'll say two hundred and fifty six, we'll have 256^4 in other words four bytes or if you want to be precise, four octets so octets is a fancy word for byte in other words eight bits, in other words, we've got thirty two bits to play with in other words,  four billion possible addresses I need a red pen, anybody got a red pen? throw me a red pen ah alright great, this is a great plan when it was designed we can't do every device anymore why? sorry! the pen that wouldn't fly thank you, yes, we've run out of address space but this is the dominant way, today 95% of the internet traffic is still ip version 4 so we have some tricks, we can hide a whole load of machines behind just a few ip addresses for example we can have multiple websites hosted on the same machine and so they all share the same ip address but we've got a problem, this initial specification of saying every device just had a ipv4 address is no longer sufficient so we'll be going over to ip6 slowly the protocol is already out but today ip version 6 accounts for less than 5% of the internet traffic we'll talk more about the actual details of ip version 4 after spring break so let's instead talk about a very special place, anybody going home for spring break? yes! great this is where you're going okay, so 127.0.0.1 is a very special place in our hearts it is the ip address of your local host your home machine, so if you try and send a packet here, it doesn't have very far to go next time you find a script kiddie on the internet, tell them to hack this ip address right so it's very very common, every system programmer knows this address if you set up a server for example and you want to test it you might to try and open this address in your web browser to say okay connect to the server on this very machine alright so rooting this address is this trivial, it doesn't even need to go to the network port the kernel will notice that hey I'm trying to talk to myself and not bother to actually craft any electrical pulses on the wire, it doesn't actually leave your machine and you can use this on a virtual machine or a real machine etc etc etc so this is your local host you can even buy door mats that say there is no place like 127.0.0.1 okay so that's your first ip address, fantastic! most people don't remember many ip addresses but they know that one and they might know an ip address for the dns server but more about that after break instead let's talk about a port so we're going to send some electrical pulses, some bits, down the wire and hopefully it will arrive at the other end at the machine of our choice so once it gets there we have to say well what are we going to do with these bits who are they for? so the idea is to think of a port, like a C port where things arrive we won't give them character names though we'll just give them numbers so on the outside of our packet, we'll say hey this data is going to go to machine whatever one hundred and twenty three point one blah blah blah and I want to go to a particular port so our packets then have thirty two bits or four octets hey look, here's an octet octet octet so in other words we can choose numbers between zero and two hundred and fifty five I just made this ip address up so this is our ip address four times eight bits or four octets but we also need a port number and port numbers use sixteen bits why? it seemed like enough at the time and eight bits didn't seem to be enough these are fairly arbitrary decisions back in the nineteen seventies and earlier to say well we know that we think that this internet thing is going to get big and if we have this many bits, then hopefully we can have different processes listening to different port numbers and that's the basic idea
so perhaps you know a few standard ports like port 80, what's port 80 used for? yes, the web! if you make an HTTP connection to get a webpage, there's a process listening on port 80 so today you could write a process that listens on port 80 and sends arbitrary bytes back to people and you've got a basic web server what about port 443? this is secure HTTPs so secure HTTP does it have to have https content? no, it's just a convention and your client then, your web client, if you connect to say the BBC if you put this into your web browser it's going to turn this into an IP4 address this is the simplified version for friday okay? and also it's going to say look I'll try and connect on port 80 and I'll connect to port 80 and I'll say something like hey give me the home page and hopefully the process at the other end will send back some bytes okay do we know any others? 22, what's 22? yes ssh so your ssh client knows by default to connect to port 22 it doesn't have to connect to port 22 by the way, you can tell it to connect to a different port now if you write a program and try to try to listen to these ports, you'll fail here's why port numbers up to 1023 are known as well known ports and only root can connect to them or sorry, only root can listen to them, only root can serve on these ports the thinking here was hey we've got some trust issues, if people are going to connect to my box, then we don't want any old user process being able to serve content from these ports we'll restrict it to people who have, to all the processes that have root access, that are admins  questions? so the last thing we'll talk about today is two different ways to talk to a server this is not a complete set there are other ways to send bytes to a server there are different protocols but these two are good ways to get started because they are very common and they have different characteristics here's the first version UDP UDP is packet based meaning, can I borrow this? thank you, that I can write where my packet wants to go so I write down your IP address and then I send it out in the wire and who knows? maybe we'll get there it did! in fact today, if you were to do a test between two different data centers between two different continents, 97% of UDP packets would get there so it's packed based, and if you like, it's kind of fire and forget you don't get any tracking number with these things you simply say here's my bytes, I want to send them to this IP address, away you go, good luck out there, hope you make it, if you don't, too bad and like I said, typically 97% will make it the other 3% who knows? they just died half way, they gave up, they found a cafe so there's no guarantee, there is no real reliability guarantee that UDP packets will get there however, it's pretty fast because there's no accountability it's just hey let's get it through as many routes as possible to get to its destination there is no ordering guarantee either so if you send two packets one after the other, they may arrive in different orders here's the other thing that can happen there could be duplicates right, so you send one packet the other end gets 0 gets 2 gets 4 of them so this is the wild west of sending data what do you get for all of these issues? answer: speed you're not trying to track anything, you're not making any constraints on the network, you just say hey get as many of these things to the other end as possible so when might that be useful? yes? video games? for what kind of traffic? why? okay so if you want to stream some data out where you don't care about the old data and you just want to, say, update the current position of all the players or perhaps send some audio where if you drop a few frames, it doesn't matter then UDP is a pretty good choice but you do have to work harder under these kind of constraints your code that you write has to say I might not get the data, I may not get the data in the right order, I might skip some data yeah so it's often used in where let's say audio or games where old information or data is unimportant
alright so the other one TCP we'll talk about what TCP stands for after break TCP is the opposite TCP is like a pipe unlike the pipes that we saw before however, you already have one file descriptor TCP allows us to say okay here's all the bytes that are going to make my home page off you go here are all the bytes in my file push it down that pipe and out the other end, at the other machine that we've connected to, those bytes will come out in order without duplicates without missing bits so some magic must have happened between our two endpoints the packets that were sent maybe some got missing, maybe got duplicated, but we are unaware of that complexity with TCP, it becomes just a pipe and if the network between our two endpoints improves TCP will speed up the rate at which packets are sent if it degrades, it can automatically reduce the speed so TCP gives us a way to hide a lot of the actual network complexity of how those packets get from one machine to another and we'll talk about those guarantees after spring break have a wonderful but safe spring break, I hope you have a lot of fun playing with the new virtual machine the TAs will be in touch with you when it comes to grading MPs thank you very much! come down and see me if you have any questions
okay good morning and welcome back from spring break you might recognize that music as part of the Star Wars music, we'll find out why in a little bit well what we're going to do today, of course, is talk about networking here we are towards the end of the semester and the major topics we're going to look at is networking that is, how we can connect one computer to the rest of the internet and also how can we deal with scheduling and files and a few of the, kind of, loose ends towards the end of the semester so this is it, right? this is the part of the systems programming that allows us to watch Star Wars on a computer from another machine, or anything else who you'll find on Youtube, which of course, was invented here by a student and we'll see how you might've even seen Star Wars prior to Youtube so let's, kind of, take a look at that, right so let's get started first of all, kind of a little bit of sure case for, perhaps you're interested in networking, we're not going to all networking, or course in 241 but, there are courses here that take it a lot further so this is really just some highlights of first of all, if you wanted to know about networking and you wanted to able to talk like you know what you sound lick you're very to quick to start talking about the OSI model and this is really just a set of abstraction layers, so when you talk about vulnerabilities, or you want to design a protocol, you're actually going to be doing it inside one of these levels so let's have a look at some of these okay so, for example, our friends over at the ECE building they worry about the physical level, like what voltages do I want and how am I going to represent my 1's and 0's etc. 241, we're going to be playing mostly with in this level in terms of looking at packets and different mechanisms of transport in particular, we're going to be playing with TCP and UDP that's not the whole story though because of course, we don't want to simply send a packet of arbitrary data we like to make applications applications themselves have protocol so, if TCP and UDP are methods, are well-defined ways to communicate at lower level, at the higher level, you're going to find things like HTTP when do you see HTTP? websites! yes sir, if you wanted to talk to a web server, you need to know how to talk HTTP, and there's a document about that about how what it means to talk HTTP, what bytes you should send, what responses you should get if you want to send mail, there's a prototype called SMTP alright, so how about all of these different kind of levels of protocol inside CS 241 what are we going to see? well, we're going to see, like I said TCP, UDP most of the internet today, as you know, uses IPv4, or often shortened to just IP4, or even sometimes IP and this is an addressing protocol that allows me to talk to machines, but we only use 32 bits to describe the endpoints, the starting point and the endpoint so we're limited because we have more devices than that so don't panic, we came up with a new protocol called IPv6 which now has 128 bit addressing except even though it was designed many years ago, it still represents less than 5% of today's traffic and it still has problems that you'll find routers, which are misconfigured throughout the internet and IPv6 is not yet as reliable as it should be right but there are, okay so that's the kind of as far as we go in terms of these lower level protocols i'll show you what the actual bytes look like for IPv4 and IPv6 in another lecture but for now, we're just going to say, hey this stuff exists, and this is the way I can send data from one machine to another machine so let's have a look at this TCP and UDP alright, first of all, we better understand what they stand for so UDP is user datagram protocol" so, by the way, the word datagram comes from data and telegram it's like this, I want to send this telegram to you and I'm not quite sure when it's going to arrive and in fact, if I send two telegrams to you, maybe they'll arrive out of order maybe we'll get lost along the way, the carrier pigeon will be eaten by a hawk who knows, right? we don't know whether the information I send will truly get to the endpoint maybe a scribe will actually send you two of these things so, we talk about datagrams when we have this unreliable delivery mechanism so that's its main characteristic, it's unreliable and that pen doesn't work too well, so let's a different one unreliable so we can get our datagrams out of order if your general says, hey! retreat!", and another telegrams says, "hey! advance!" without actually putting your own timestamp information inside that, you don't know which one is sent first so UDP gives you no guarantees about when things are going to arrive, the order of things going to arrive, and whether you have missing data, or even duplicate data so, essentially it's making no guarantees about the lower levels of the internet it's saying, if there's any problems, if someone decides to disconnect the cable, or the router between you and me is misbehaving, you're open to those problems you have to deal with it but it's fast there's no handshaking as soon as I send a packet, and arrives at your end, you see it okay, so one of the main characteristics is it's unreliable, what does that mean? we may see dups we may see missing datagrams it may be out of order so there's no guarantee about sequencing essentially, it's saying, yeah, I've got a post office and I've got telegram service, but I make not guarantees about how good it is". it might change from second to second it might change from second to second"
alright, so why would anybody use UDP's? and the answer is: most of the time, we don't because it doesn't give us many guarantees however if we were writing an application where we prefer to handle these missing packets, so all of these unreliabilities stuff over late packets, over late information arriving, then maybe UDP will be a good choice alright, so let's flip to the other protocol, that is quite common, and that is TCP or transmission control protocol so if UDP was giving direct access to those telegram service TCP inserts some control now between you and actually what happens, actually what goes out on the wire actually, it will abstractly no, it will hide all of the problems we might see when packets are actually sent from one machine to another machine so what are we talking about? well, you're going to see the following great things first of all, it tries to add some reliability I feel like I'm a used car salesman at this point Hey! Don't worry about your car! If it breaks down, we'll send you a new one. No questions asked." if your packets get lost in transit, don't worry, I will handle it for you I guarantee that your data will get from A to B and in the right order! just give me the data you want to send, and you'll be fine and in fact, I'll give you some error collection as well so, we might write this as error detection, or guaranteed that your message is error-free which is whiter than any other cereal, no what? okay actually error-free is a bit of a marketing hype, actually the checksum is only 16 bits so actually, you got one in the 2^16 chance of this error detection not discovering some random bit flips so that's a little bit of a hyperbole but, it does do error detection okay, what else we got? flow control and similar to that, congestion control so our protocols are, at an abstract level and we don't know whether we're trying to send data over a fiber optic link or piece of telephone wire or even just some old barbed wire that we happened to have that stretches from my farm to your farm TCP can cope with all of these of course, the number of bits we can send per second in these two examples are very, very different so we want a mechanism to ramp up the speed at which we try to send bytes and we need mechanisms that can cope with partial failures so, suddenly, our route from China to here changes drastically and we can no longer send as many bytes as we'd like per second TCP will notice that and actually to reduce the number of bytes it sends per second, so we can optimize the use of available bandwidth in real time and finally congestion control hey, we don't share these links, so we actually want to be careful that we don't step on each other's toes and so, we attempt to make sure we play fair with other users of the link how do we do these things? magic! no we, of course, TCP actually includes additional information, in addition to the bytes that you want to send, includes additional information inside each packet as to how many bytes should be sent and the status of each end we might talk a little about it inside CS 241, but if you want to know more, take a networking class at the 400 level one of the most amazing things about TCP is that it, it has to work even with adversarial people, or attacks on the internet that will try to steal those bytes, copy those bytes, masquerade as you, and TCP is evolved of the time to try to cope with some of those threats and we might talk a little bit about that right then, so let's answer some of these questions okay, which one of these you think uses handshaking? yes! TCP! before TCP, can send any of your bytes it actually has to set up  it has to send a packet from one direction to the other direction so there's a latency, there's a startup cost to creating a TCP connection which one do you think requires more system resources? TCP, yes! so, TCP behaves a bit like a pipe except that we can use the same file descriptor for receiving and sending so remember how we're seeing read and write, and you've seen in terms of being able to talk to stdin, stdout you've seen it in terms of being able to read or write from a particular file, you've seen it in terms being able to read and write from an unnamed pipe guess what, we can use these with TCP as well! so once you've set up a connection with TCP, sending stuff is easy! and I'm going to put it in quotes easy for system programmers like yourself there's a few gotchas and we'll talk about some of those today and in future lectures okay, which one of these do you think encrypts your data? make your guess now neither the bytes you send on the internet using these are completely visible to anybody else that is sniffing on the wire so, do you trust every telegraph operator between you and your mom? because they could be copying the bits that you are sending Hi mom, having a great time. Send more money. Thanks" being able to see those characters so of course, there is an art to making sure that those characters don't mean anything that's we can encrypt them in some way but that is not part of these lower level protocols
so a long, long time ago, we didn't care about  sending things in just clear text on the internet because there were no bad guys no one was listening to those bytes that we were sending and in fact, there used to be a service, a telnet service, where you could log on to a remote machine, type in your password and you'd have a remote terminal these days, of course, we use SSH on port 23 but it didn't always be like that there used to be a service on port 22, which was completely unencrypted good luck today finding an unencrypted port 22 a terminal service on port 22 well, guess what? i've found one let me show it to you of course we're talking about an application here, a virtual terminal, where we can connect to a remote machine and start sending it some bytes so here it is right let me okay, right [gibberish] okay, so there happens to be a server on this particular address let's connect to it yes, you couldn't actually log into this particular server, but it will play Star Wars movie four in ascii and so it slowly sends bytes to you, and your terminal interprets those bytes as characters, and displays them on the screen and the servers careful not to sent too many bytes too fast right, so do you think this particular server, this terminal connection is run with UDP or TCP? TCP! because normally where we want to connect to telenet, we want to make sure that [gibberish] the screen size is a little messed up, but you kind of see the idea this is what happens to good protocols they end up serving Star Wars movies fortunately, a UIUC student came up with Youtube, and we no longer have to watch this kind of stuff, right? okay this is way too much fun so it's easy to find, just type in telnet" and "Star Wars", and you too can watch Star Wars and enough of that so these days of course, we have this major use of the internet, which is web traffic so when you want to talk to a web server you need to understand this high level protocol from the seventh layer HTTP, hypertext transfer transport protocol this of course runs over TCP and HTTP is actually an offspring of an FTP protocol and it's pretty old now, version 1.1 is about 15 years old and it was a  text protocol just recently, we now have http version 2 of this protocol which is now a binary so if you go to a model server and you say hey, i'd like to talk to you using version 2 please", then you'd need to be able to speak it in binary but the original protocol was text and so we can just play with that today, we can actually connect to a web server and get it to send us a page get it to send us some information and that brings us to page 2 alright, so let's do a little demo first we'll try this right, so let's try connecting to a machine i love the music right, here we go we'll do illinois.edu and I'm going to connect port 80, which is where web servers listen on great, we've connected right, so we've connected this machine and now, I can send something, so I'm going to type in get / HTTP/1.0 and we'll hit return twice okay, great! look at that, it actually understood what I said, and it sent back a whole load of stuff it said, oh look! this machine, this web server is serving using apache version 2.2.15 so if I was a hacker, I'd immediately type in apache 2.2.15 vulnerabilities" and tell us which version of SSL and OpenSSL great, I'll use those as a hack as well to discover if they've got any vulnerabilities it tells me when this page was last modified, so if I have to have a cache of this page on my local machine, I know that if my version is more recent than Friday that date, then 2012? my goodness then I can use my own version, right? and finally it tells me a little bit about what's there, so basically there's nothing there and it's in this particular memtype, this text/html so my web browser can use that to understand this content, and we know that we expect seventy-three bytes of content let me try a different machine let's try
so we'll get that and HTTP/1.0 okay, right! and I get a big chunk of text, including stuff that says Hey, maybe you want to use Javascript as well" alright, so I'm getting a little bit of text, of a script on that page and finally we see these tags down here, </body>, </html> is that part of the HTTP protocol? No! what is it? it's HTML! HTML is independent of our network protocol HTML is just a way to describe a webpage and of course you can save that on a file you can save it on a USB stick HTML is completely independent of HTTP, so HTTP is about talking to web servers HTML is about how to mark up web pages they are two different protocols so we've shown that I can use this little tele-command to talk to webservers and this number 80 here is a port number if you want to run things on port 80, you can't unless, you run it as root so, the lower port numbers port numbers 0, 1, up to 1023, require you to be an administrator on the machine which is great because you will have a virtual machine now, that you can root into you can do sudo, or you can log in as root, and you can then set up a web server on that machine on port 80  let's see what we're going to do today we're going to write some code that basically does this from C so we're going to connect to another machine so this is kind of what was enough for you to write half of Yik-Yak, if you'd like at least the client end here's some code I wrote earlier perfect timing and this is the beginnings then, of what network coding looks like now what we're actually going to create is something called a socket so a socket is a system object  not a C++ object, of course but just an object that represents the connection endpoint that we can send bytes into and get bytes back from so it's like a, think of it like a socket you can plug into it's going to be a way for us to communicate with remote servers and also weigh a socket's you can set options on a socket we're not going to do anything fancy today but how to identify sockets? easy just with a file descriptor so this will just be a small number and once we've done all this magic, we can just call read and write on this socket descriptor, and use it just like an open file so let's what we've got here i'm going discuss this amazing beast this didn't used to be inside CS 241 or any networking class, this is relatively a new addition: get address info, and it makes writing network code much, much easier it does so much for us, it sets a whole lot of C structures for us and it can be used in a variety of ways, we're going to look at one way today, which is to go from a host name that we understand a fully qualified name here, like www.illinois.edu" and turn that into an IP address a binary number so to use it we actually have to create a little struct notice the struct name is the same as the function getaddrinfo but in fact, there's going to be two structs we set one up as a kind of hints" structure, to say this is the kind of stuff that I'd like to know about and we get back a pointer to a different struct of the same type so that's why I have one called hints" and one called "Okay, yeah. I'm also going to need a pointer to one" so I'm not going to set up result, that was going to be set up for me and if you look down here, you'll see that we pass in not the pointer, but a pointer to that pointer because this function is going to mess with that pointer it's going to set that pointer to the completed information right so, what do we care about today?  well, I would like to have information for connecting with an IP version 4, so I want to make a connection yeah, yeah, just like 95% of the rest of the internet traffic using using version 4 and I want to use TCP and as we know, TCP is a stream, it's like a pipe and these constants are kind of hard to remember, don't panic in an exam I give you a crib sheet but also, just as a hint, notice that they always come in this variety where the AF corresponds to a hint for you about what things should this be connected with? so sock, for example, the kind of socket type is a prefix as to what this constant should be now these constants are just integers they're just there to make our code look more readable as opposed to hard-coding constants unfortunately, it can mean then that you can accidentally put the wrong constant into the wrong field, and the compiler won't complain your code simply won't work now, writing network code is hard because it's like going to McDonald's, where everybody inside working there hates you unless you specify everything exactly correctly nothing comes out the window at the ned like doing a drive-thru and trying to do it with an English accent I have a really hard time at McDonald's You want fries with that?", and I'll say something, it doesn't really matter what I say, and I never get fries so when new is desperately working trying to figure how to say  another fun thing with an English accent is the phone things, you know like say one" to "one" I never get anywhere so this is the fun of networking code is that you've got to specify things exactly and you've got to be on your tip-toes to make sure you haven't accidentally put the wrong constant in the wrong field because no one will tell you've made a mistake right, that's the first gotcha is give the right constants for the right fields the next gotcha at least for this code, is for the unused fields, we better set them to 0 and that's the purpose of this memset there's a whole load of things in this struct that I don't want to set and if I don't do this memset and this is just on the stack then as you know, the stack memory is arbitrary so make sure that you've set unused fields to 0
so this getaddrinfo() is  sort of a powerhouse of a call it does an awful lot of work behind the scenes including making a network connection, say hey! hey, anybody! anybody know who this is? www.illinois.edu? anybody got an ip address to this?" so what am i talking about? i'm talking about dns, and we'll talk more about dns a different time well that itself, but that call itself could be making network requests to say hey i need the ip address that's connected to this name" so the whole lot of stuff that happens behind the scenes just to discover the ip address right, so what does the ip address go into? it goes into one of these structs and where does the ip address actually appear? it actually appears inside here, this little [gibberish] here, this address, and this other thing called addrlen is set so why can address be different lengths? well, socket is an abstract idea, and it might have different kinds of sockets we might have an ip4 type socket, or we might have an ip6 kind of socket, or we might have an apple talk socket so these c structures are actually designed to be potentially different lengths, so when we call connect, we actually have to say and this is actually the size of my data structure" right, so so what have we got? we've got getaddrinfo() to fill out that socket information for me if we didn't have this, we'd be writing lots more code, and it's really ugly, it's got lots of casts in it the beautiful thing about this is we set up a hints thing, we say do we want ip4 or ip6, or we don't care, and we say say the socket stream, or we want UDP, and then we create a socket and we can connect to it and we're done! we're ready for action! right let's write some code then so connect will do the handshaking, so now we're going to actually use this thing  right, so i need to send it something, okay right, so what i'm going to send? here can be my request it'll say GET" homepage make that larger, here we go right get the home page, i'm going to speak http/1.0 to you, and i need to send it these newline characters to say that's the end of my request /r/n", if i wrote it twice okay, we could  for debugging let's just print this out okay and i'm going to write the minimum code that will kind of work, this is not robust quality code by any means that we'd used a real web server, or any other client but it's good enough for lecture demo today right, so how do we use write()? well, remember that you need to give it a file descriptor okay, that's what i got from the socket you need to give it a pointer to some bytes that we want to send okay, that was my request and i need the number of bytes, yes if right, even number of bytes so, could i say request? how many, what is the size of request? that's 4 bytes or 8 bytes? because it's a pointer, it's not - we didn't specify it as an array remember arrays, kind of like pointers, but they're not pointers if you ask for the size of a pointer, you get a size of a pointer, which is 4 bytes on a 32-bit machine, 8 bytes on a 64 we didn't want that we could've either made request a different type, we could've made it a character array, or we could just calculate it during runtime so let's do it during runtime so strlen(), give me the number of characters inside request i do not need to send the 0 byte the protocol is not about c-strings, it's the end of the line, the end of the request is to find in terms of these double newline characters, right so we send that  i could get the return value to see how many bytes were sent, but nah, it's a lecture right, so let's get back to response, okay, we need some space for that, so as this is just a quick demo, we'll just have some space on the stack here it gives to my response and  let's read from that socket right, sock_fd i need to give it a pointer to some space, some memory how many bytes do i want to read up to? we'll say 999 why 999? well, because if length is, get at least one thing we will print it out as a c-string, so i'm going to terminate it and finally, we'll print it out okay questions at this point? aha, it's easy! right? the file descriptor wasn't set once i called connect() i've connected! i am network man! anyway, so we've now got the power of the internet at our fingertips well at least all of the internet we can connect to using TCP right, so let me [gibberish] okay, we'll do illinois to begin with right, so we'll run this  what'll i call the code? [gibberish] alright, awesome [gibberish] ah! great, happy days right, so let's run awesome hey! look at that! we wrote some c code, we connected to another machine! this is what it's all about, this is what makes 241 so powerful, right? now we can actually talk to any Â machine, and now i can run my machine, i can run this a hundred thousand times, and run a ddos attack on the internet don't do that because every server, of course, can log the ip address and log the content of what's being sent to it
now I actually have done attacks the difference was, was I had a nice, big legal agreement not from the janitor of the company well, from a C level executive i.e a CEO, a CTO, that kind of thing and I did this as part of a company, so I had liability protection, etc, etc, etc and I kind of knew what I was doing right so with great power comes great responsibility, and unfortunately, now, you are now treated as people that are no longer normal the justice systems hates you and they would love to see you put away for many, many years even for simple hacking, as defined by the newspapers right guess what? there's a log somewhere that says your peer address was used for x, okay that's good enough me!" send him to jail and he can work a dollar, or she can work for a dollar a year" splitting rocks, whatever probably not the ending to your university career that you're hoping for also yes, the server has logs, but there's routers in between that have logs as well, so it's relatively easy to discover where packets are coming from so if you must hack a system, here's a system i suggest you hack get in there and delete as many files as you want that of course is the ip address for your own machine, right? the packets never leave the machine, the kernel actually recognizes that as an ip address and we'll not even send that to the network hardware alright, so let's have a quick look at this response we saw that this http request includes the number 200 and little strings that says hey! okay!" how do you think we can generate a different number? you probably know one of these number already with a four right? 404, not found? that is part of the http protocol let's change our address oh, sorry, let's change this so we request a resource that doesn't exist we'll go aprilfoolsjokes.html see if there's anything about that, right? okay alright, so we'll let's compile this okay let's run our awesome client okay, what do we get this time? we got a different number, 404 so this is how your browser knows that this particular page does not exist, and it would render some blank content you could put some other stuff in there as well there are other definitions to say hey, this page has moved. please redirect to this other url, etc." so the http protocol species all of that right, let's take a break for a moment, and talk about the course couple of comments i hear that quite a few of your classes have given you, like lots of homework to finish and even exams this week, so no exam this week mondays in future weeks not too good yes, please expect, unless otherwise stated, that the in-lecture exams will be on mondays for cs 241, okay i will try to get out practice questions before that what else do i want to say? oh, yes, oh yes, right so the last thing i want to talk about today is some alternative ways to program first of all, yeah, you've probably now know about, kind of, vi and vim vi has a historical background to say, suppose you have a really slow connection" the beautiful thing about vi is that it tries to actually work even if you've got a pretty slow connection, and it has some cute tricks in it as well, so i think i've shown you this one, where we can say, change our current lines, so we can substitute, and if you know regular expressions, you can write regular expressions in here so, for example, we can change include" to "exclude"  right, that's a kind of simple one, right? i'm just changing it to exclude" let's undo that we can change a whole load of things, so for example, let's on all lines, substitute 'if' for 'while', and the 'g' just means, if there's one matchy thing on a line, then substitute it, so now i've got bad code, right? let's quit this without saving but i want to mention that that's not the only way to write code another way is to use the cat" command so you've seen cat" in terms of reading from a file, right? well, cat", if you don't specify anything, we'll just echo back what you've typed
right, so now we can do cat>hello.c so now we're going to pipe the output of cat into a file hello.c" so this all you need to program right? so now do #include <stdio.h> int main() { printf(hello\n"); return 0; } right, how do i finish? i have to tell my terminal that i don't have any more input, so i'm actually going to close now stdin how do i do that? by doing ctrl+d here we go and now i can compile my program hopefully, and if that gives me return value 0, then i also want to run it so there we go right so if you ever find yourself without any editor, don't worry, just use cat okay, right questions? no questions still no questions, okay right, have i shown you that the includes actually exist oh, here's a useful command, which" right so which" is, you'll probably use it next time you have java installed you say, okay, where's that?" alright? or where is my gcc installed?" and so which" looks along the path to discover where these commands actually are, so how's it do that? well it looks inside every directory including inside $PATH so next you install something you might want to edit this $PATH variable and you'll notice that the directories simply have a :" here on a linux machine simply have a :" between them and where can you edit that? well on a linux and mac, you can edit your  okay let's go to my home directory, which is like this little [gibberish] you can edit your bash oh, come on oh, that's why bash_profile, and you can define things and add additional things to your path, right? great! so, the next lecture, we'll start talking about TCP servers and UDP client-servers and i will get the interview questions out for thursday by the end of this evening! Have a great week, good luck with the MPs thank you very much! have a great week, good luck with the mp's
alright good morning class how are you  alright let's try again, good morning class how are you ok great so here's what we are gonna do for the last lecture we look to making a TCP client   we made a socket and we ask the socket to connect to a remote server we connected it to Illinois.edu and we connected it to BBC.com, this time this lecture what we are gonna now is to go to the other end of the equation and we are gonna make a TCP server, and I'm gonna walk you through the steps and some of the gotchas for that so we'll talk about some of the nitty bitty of the code and although we'll put it all together and ask you about the server ok sounds like a plan, ok let's get started before we do that, let's see how much you remember from last lecture alright so what do we need to do to set up a client TCP socket ok so here we go um so back in the mists of time get address info didn't really exist and we have to carefully setup a struct um but fortunately for us today, getaddressinfo does exist so the first thing we might do is um we'll use get address info, so how do we do that well we setup um a hint set up... the um.... addressinfo struct  and we'll setup the hints we'll copy this struct. another intended use for this getaddressinfo we are just gonna pass it into getaddressinfo and so here's the thing that we care about like we really want a stream based protocol hey we wanna use IP 4 or we wanna use IP 6 or we um or we don't care we'll use either but anyways we said about our struct like we are doing down here we said about we are configuring it um we could get address info to setup the real struct for us and then we can use it so now here's the um here's the main part write a socket call connect so in a sense making a client actually requires two calls get a socket and ask that socket to connect to something that's not quite true because we are using this getaddressinfo to help us make the connect call but this is the actual part, if we actually know exactly what we wanted to put set it to connect, we won't need to be calling getaddressinfo that's just a helper method for us actually it's just these two calls: hey i want a socket, and hey please connect to somewhere. please connect to BBC and here's the IP address. right alright so um last semester no, last lecture i lied to you just a little bit i said getaddressinfo returns a struct of these addressinfo objects. well that's kind of true actually, it returns a linkedlist of them so here's what happens, you say, look, in my hints i would like a certain kind of connection, like, i would like, say, IP 4, for example and i would like, say, a stream based port for, say, TCP getaddressinfo says, okay you wanna get this remote host, i will find all of the possible ways to set up a socket and connect to the remote host and return it to you and that's what we get, we get a whole lot of these addrinfoes now and for our little code inside CS 241, don't worry about that, just use the very first one that it gives back to you assuming of course that getaddressinfo gives us a success result code but if you are writing a more verbose server, you might say i wanna connect to the BBC and i don't care if you can find a good IP 4 connection or good IP 6 connection i know what i'll just try both alright so, in fact you get this linkedlist alright so what have we got inside this addrinfo  alright we've seen these um, this half up here which is kind of a description of what we want this is the stuff that we are probably gonna be using in our code later on and that is this structure here, sockaddr and also the number of bytes in that address so you'll be seeing us passing those addresss. so you'll be seeing us passing those two fields into our connect call and our bind calls in a little bit ok so watch out for these, so this is the stuff that is setting up for us so we don't need to set up ok alright so we got our addrinfos alright so how many addrinfoes does it return? 0, 1 or more? i promise you that we'll never return you a negative number OK um.  one little thing that you might notice on the code before which is that if getaddressinfo fails you can't use perror() or structerror no, it doesn't set error number like that it's got its own error error code that you could use to return an error and we'll look that up in a bit instead i wanna charge through this because I actually want to get to the demo today the demo is the most fun but so what is AF_INET6? what kind of address family is this it is, yes, IP 6 IP version 6. well we can talk about nodes we can talk about hosts, we can talk about machines using 128 bits of addressing in other words our address base is much larger alright so it's gonna take us a while to exhaust 2^128 possible addresses so IP version 6 was created because people foresaw the problem that hey we are starting to run out of addresses with IP version 4 so what do you think this might be I'll give you a clue there's no place like home this is how we talk about our localhost  using IP version 6. so if you want to hack yourself using IP version 6, this is the address you need to connect to there is actually a shorthand for this where we can collapse the longest ones and zeros and so there the shortest version of this is just ::1 i'm not gonna talk about all the rules about collapsing IP version 6 addresses you're welcome to look them up but i guarantee you that they won't be on the exams. the wikipedia references is perfectly good enough if you ever need to actually need to talk about IP version 6 addresses but that's the shortest IP address IP v 6 address. and yes this might be on the exam or this should become acknowledged that hey, this is yourself and this is localhost
okay so lets see if we can set this up then I'm going to start writing some code then to make a TCP conneciton so yes we need to setup one of these int objects and we'll have a pointer as well to get the result so what should i set for the family? well if i want to connect with version 4 I would be connecting with IF_INET6 if i want to do ip version 6 i would put a 6 in here and what about the socket Well we want a stream based protocol in other words TCP so for our socket type we specify socket stream if i had left these entries as zero we're basically saying hey we don't care and then we get back that linkedlist what are you connect to the BBC using the UDP using um datagrams you could connect using tcp and these would just be different entries in that linkedlist and then your code could try them all hey lets see if we can get a webpage over udp and the answer is actually quite a few webservers will do that they'll look at you strangely and go what do you want? but they will actually say okay I'll give you back some data as a single packet right so right we're going to fill this in ok so what do we put in here our function call of course is get address info and what do we pass over here well we need to pass in the hints and we need to pass in our reult okay, so lets see if your neighbor can first of all the mistakes i've just deliberately made in that code and also what are the two missing things that I need to fill in here what are the first two parameters so what mistakes did I make and what's missing in that code okay right so  couple a mistakes we made first of all actually we want the address of our hint struct so we'll put an ampersand there and also we want the address of this pointer it's going to change that pointer for us ok so what do we pass in here? well we pass in sometimes it's called the node but you can think of it as just basically the machine we want to connect to so we could write www.illinois.edu we could write www.bbc we could write we could say for example do ::1 if we wanted to connect to ourselves using IP6 we could write 127.0.0.1 if we wanted to connect to ourselves and we were using ip4 for here, i'm going to now specify the port and you can do this with two ways you can literally just write a string like 1234 but for well known ports like HTTP, HTTPs you can actually write the protocol name like HTTPS  if you happen to know the port number, yeah you could use that so get address info is surprisingly useful if you give it a ASCII name it will try to convert that to a port number for you so if it returns zero we've succeeded if it fails now we can actually find out why and that's where that function comes in  we could call gai_strerror and pass in that result code and that would give us back string okay now I'm not going to expect you to remember that, the string error but what you might do as a system programmer with this networking code and in fact any time you want to write good code is check the manpages so if we were to go to manpages is this going to work here we go alright we see that um okay i can take the return  if i now read the description and the return value of this it would tell me that hey this integer can be plugged into this call to give me a basic message about what went wrong and let's have a quick look down here to see the kind of things that can go wrong we have a bad family bad flags no data no name this call can fail in all sorts of ways we might fail at turning a name like bbc.com into an ip address okay but lets say it worked what do we do next well the first thing we might do is okay let's make a new socket now you seen in some of my earlier examples that i've made the socket at the very beginning of the code and i hardcoded in exactly what family and type of socket type I wanted but you could also just use the return values
there we go we've also go the information we need inside here to actually create the socket so if you expect you'll get address info to return maybe an IP6  maybe multiple kinds of different sockets then you'd be pulling that information out of that linkedlist each time so we've called socket and then we would try to connect to that remote host and let's say we've successfully got a connection hey great we're now talking to that machine right so this connect call is heavy it's big it's slow  it actually goes out there and connects it doesn't just like oh, connect please" it's "no make contact" send some packets to and from that machine so connect might take a second or more to complete might take a minute if you're remote server you're trying to connect to is a long way away so this is potentially very very slow how quickly you can talk to the remote machine if you're trying to talk to yourself that should be pretty fast so you could talk to yourself very quickly and discover if you can connect to a particular port there's one thing we didn't talk about yet and that is  this magic call called bind so usually we don't like to be bound up but today we're going to be calling bind on our socket we're going to take our socket and we're going to bind it to a particular local port we're gonna say hey! use this local port" now most of the time when you want to connect to a remote server you don't care where your packets leave from you don't care which port is used locally just let the operating system let the kernel choose the outgoing port but when we want to make a server typically we do care if I'm going to make a webserver I want it to be on port 80 so we can use bind if we want to set the  local port you could also use it if you've got say two network cards and you want to specifically use a particular network card but it controls the local side of the connection  which is exactly what we're going to need when we make a server  so if i tried to connect to your cellphone right now on a particular port i'd probably discover that it's not listening on that particular port that I was connect to connect would return back and say haha I'm sorry I've failed I've managed to send a packet and it said nothing  i didn't get anything back for your cellphone so connect fails what we ought to do in the server is the opposite we want to sit here and wait for people to come to us wait for packets to come to us wait for packets to come to our port what we want then is a passive connection not something that goes out and tries to connect but just sits there and says huh no let us the packets come to us we can do this and it's very very easy alright so a passive socket level one understanding is just hey it waits for connections to connect to it it's sitting on the key side of the particular port saying okay I'm on port 80 send your packets to me I'm ready and when they do I'm going to do something special right so what's a passive socket  first of all it's a socket that is listening  it's also known sometimes as a server socket because we use it for serving we just it for waiting for connections so it's passive in the sense that it's waiting for connections and it has a cute little trick  lets say I'm the client, you're the server can you catch? let's say you're the server right there you go that ladies and gentlemen is a dropped packet alright here that server wasn't listening okay fantastic right so I've sent my-k-I've just connected to the server on the passive socket now here's what the passive socket does when it returns the connection, when it does the handshake back to me thank you it sends an additional piece of information which is don't talk to me, don't talk to that port anymore I've got a new port set up just there that is the special connection that is just between you and me so we'll see that in a moment on the C side as well  we'll see that on the seaside, I like that so we'll see that in terms an additional file descriptor that's part of that handshaking once we make the connection on the server side, no no we have a completely different port just for that one connection why do we do that? well guess what we're making a server we're trying to take over the world or whatever and other people might be connecting to port 80 as soon as they do that they're going to be talking to you again so in order to keep all these connections separated we push them onto different ports alright so the time you actually spend talking to this particular port is minimal okay so why do we create one so we can have a server I want to make a server right so how do i do all this have I put this in yet no so here's what we should do  in our hints struct we're going to specify one more thing let's go back to here something we haven't used yet is this flags and there's a flag to say hey make a passive socket for me please trying to think if it's yeah must be uppercase right so before making your get address info call, just say oh, by the way, I would like a passive socket by the way i would like a passive socket
now if we were to run our code by the way I didn't talk about this little guy in here what did you think he's there for? right? this little tiny question mark is the ultimate april fools in the sense that this will get you every day of the year this is C going oh you mean you didn't set all of the parameters in a field? don't worry, I'll make your code work today but, if we don't set all the fields inside a struct, then who's to know what the values are of the ones that we didn't set now maybe you made it in global memory and you know that there's going to be zero but if we didn't if we just made it on the stack then who knows what those global fields are going to be and we're just giving them to the operating system so who knows how getaddressinfo is going to interpret those unset fields so I'm talking about these in terms of setting up network code but this is actually a common common gotcha with C is you hey I've got a struct, I'll set a few things and I forget to set the other fields so right how can I fix that? well I showed you before one way is to call memset okay so how about we do this? memset on the hints sizeof(hints) zero and I can relax that I've now got job security my code will work! haha april fools so what have I just done? I've just managed to set zero number of bytes to a small integer value in other words the memset call I just made had no effect whatsoever because I accidentally swapped these two values around I suggest that you ideally just don't make this mistake or don't make this mistake in production code because the worst thing about it is that you probably won't realize it, you probably won't notice it right? the memory half the time is zero and it's only when say you are reusing old stack memory that you might not get nonzero values so watch out, watch out anytime you work directly with memory that's the most likely time that you'll get some very subtle bugs right so we've got our thing set up getaddressinfo is returning zero, it's working, right so... here's what we can do now remember how I said... in a client we make a socket and then we call connect and we connect to a remote end in a server, we go socket and bind we're not trying to connect to a remote end at all we're just saying ha I just want to set up a local socket here that doesn't connect to anything, it's just going to sit there and listen and all the parameters that we pass to connect to the same ones as bind so we're going to be passing in... these two again, this address and that length of that struct we'll see the real code in a moment but basically we've swapped our connect for a bind because we want to talk about not a remote endpoint but a local endpoint right... so at this point we'll just take a little bit of a break to mention these guys and also to kind of show you what the code might look like if you didn't have getaddressinfo so when setting up a socket one of the things we want to talk about then is the port address and the IP address and you'll notice if you do a lot of google searching on code, you'll quickly come across these functions here this htonl and htons here's what they do, they swap bytes around sometimes they swap bytes if you run this on an x86 intel machine why? why do you think we might want to swap the ordering of bytes? security? good idea but not the answer I was looking for endianness yes! so endianness why do we care about endianness well the point is we're sending information over the wire right? we're sending stuff out to the network, we don't want it to depend on the order with which we represent integers so if we're talking about a particular port number that's sixteen bits we better agree when we send the packet out on the network as to whether we want to put the low byte first or the upper byte first so network order is big endian and that should be independent of our machine so if the kernel says by the way, this remote host is connected to you on this particular port or here's this ip addresses we better be careful, these integers may not actually be the integers that we normally understand we may actually have to deliberately read that value with the bytes swapped so that's where these functions come in if you happen to compiling this code on a little endian machine big endian machine, they don't do anything, they are a no op they don't need to swap any bytes if you call them on an intel machine however, they give you the result with the bytes correctly swapped from big endian order to little endian order
vice versa so what do they stand for? they stand for host to network short and network to host short [silence] so here's an example where we want to specify the port as port 1100 notice how I chose a port greater than 1024  and I want to set it directly into this structure here socket address and so I have to remember to actually set this up to be the network the network port number so this port number is actually going to be passed directly into the network card we're going to assemble the packet and that packet will have these bytes in now the correct order to say okay [something] on this particular port you can use these inside your own code let's say you wanted to have a high performance server and you're not going to send ascii information, you actually want to send binary information and you want to send say the position of your players to all of the other, you want to cast it out to all of the order players on your game server you would have to decide on your protocol to say am I going to send this out in little endian or big endian format and you could use these kinds of calls to make sure that it doesn't matter whether your C code is compiling on an ARM platform an Intel platform that we always on the network are sending bytes out in the same order same endianness  alright so that's just a little aside, you'll see these codes and now you know what they do and here's the other one where you use it for a long so you can use it for 32 bits right so okay right so it's quite often said that setting up a server takes four cores we better say what they are and it's a common exam question or interview question to say what's the order of these? and what does each one do? right so the first one is easy, hey we need a socket you're not going to get very far without a socket we need a way to configure our network and a socket gives us back a file descriptor that we can then start to use once we've got that file descriptor we want to bind it to a local port let's bind it so we are now going to be on a particular local part and we set it up, we pass it now actually we're ready to go here's the nice thing that we can do with server sockets we can ask the kernel to do that little handoff trick and to start queuing up any connections so now we can start listening at that moment... we're live! our kernel is starting to actually accept connections for us and we'll generate a small queue of incoming connections that we can now start to process so with listen, we actually specify the queue size so as part of that little handoff process when we say oh actually go and reconnect to me next time on this other port number now the kernel has taken that and said okay by the way expect connections on this other port number, so internally its got a little queue when we want it from our user's side, we call... yes I'm prepared to accept this reverse call accept! so on the server side, when you call accept, you get... a new file descriptor okay so here's a big gotcha is that you've now actually got two file descriptors to play with if you want to be talking to your clients that are connecting this is one you get a new file descriptor each time accept returns also, this blocks until we have a client if your code is a bit slow in calling accept don't panic, that's why we called listen listen says look uhh my user code may not be able to call it except immediately so have a little backlog of connections that the kernel will maintain and hopefully I'll be able to call accept in the future so its very simple code, very simple server we can just call accept once, and that's it and that's what we'll do in a demo in a moment later can call accept in the loop to process one client at a time probably not going to be the best webserver in the world but hey it works and we can run that on some tiny embedded hardware later we might do things like hey let's for every accept call start a new thread and then everybody can talk to my server in parallel well that works until a thousand people try to connect and then you have a thousand threads that start on a machine with 8 CPUs that's probably going to work out so great so then we need to start figuring out even better ways to have a high performance server but anyways that's our four calls, socket, bind, listen and accept alright let's see this in action ooh look code!
Here we go! I'm going just hard code my, my constants. Like I said, we could have got this back from the address info. Today, I want to play with IP4, I want a TTP connection. There's my flags, those other flags you can set them here by bit-wise or-ing them. But we want a uh... a server, or passive connection. Yes, I remembered to set all my other unused fields to zero. Right. Yes, I'm going to call getaddrinfo. Check the result code; if it fails, I'll turn that into a useful error message. It's really really useful if your code doesn't work to actually check error messages by the way. Okay, so. We got a socket call, we got a bind let's connect to a local port. And look at this! I'm using the stuff I got from my getaddrinfo. I'm passing in that point of that struct and the size of that struct. okay, that's my set up: socket bind. Now, we start to say, Ooh!" Um, please start listening and have a little backlog of ten connections. Okay. So, just for fun, I want to show you that I can say, I'm just doing a particular port. If I reach into one of these low-level C structures, I better remember to reverse the right order to turn it into from network to host (ntohs) and use the result of that call. And now we're going to have our little server. This server code didn't actually send anything back to the client. It just listens to hear what the client has got to say. How do we do that? We call accept. Later on if we wanted to have to fill in the structure, like where the client was connecting from. We wanted their own IP address we can fill out these structures here. And remember how I said accept returns a new client? Here it is! Here is a new file descriptor (fd), and I'm going to use that on my read call and then turn it into a C string and print out what they said. Okay So, let's uh, let's run this. Hmm. *bzzzzzzzzzzzz* Okie dokie, alright, so there's no error checking in this last part, um, alright. So I can... clear this right gcc ./server1 (./server1.c). Okay! Alright Oh, look at that! That's my OSX is saying do you want to accept it? Wait! And it chose file descriptor 3, is this your port 1234? Shall we connect to it? Okay, alright. So, let's do this um, now I could write some C code, but instead I want to show you a pretty useful tool. It's called netcat. Here is netcat. Blah blah blah, blah blah, blah blah blah, blah blah blah. Look it's like cat, except you can connect to an arbitrary machine, using an arbitrary protocol. And anything we sent this, it will use standard in and standard out. So today, I want to connect to 127.0.0.1, my local host, and I want to connect to port 1234. So our code is working! The accept call has returned.  And it has given back our new file descriptor. Right, should we send something to it! Yes, okay here we go. HELLO GET / HTTP/1928349q87eyfaiu7tbeiqvwfa SAfuigae And here we go. So, it got that from the socket and printed that and stopped. This is the most useless web server in the world because it accepts one request then quits. Very easy to make a denial of service (DOS) on this particular web server. So what we'll do is make it so it cannot accept multiple clients. We're not going to do any threading code in this (we could though!). Right as soon as accept returns, why don't we make a new thread and pass it on. Instead, we'll just put this little part inside a loop. Alright so a while there. Okay, so we put this accept call inside a loop Make another connection, and so on and so on. So we got the basics now of a little web server. What we have to do now is figure out how we are going to pause this. what do we want to do with this information, and what do we want to send back to the client? Alright, so in fact what we've made is something a bit like a honey pot. For example, here's why it's called a honey pot.Take a jar of honey, open it, and see what insects are there after a minute or an hour. We can do this with our server. We can get it to simply listen on a particular port and see who connects and say capture the IP address. Or we can pretend to masquarade to build a real machine. Oh look! people are trying to log into this let's see what kind of pass let's see what password they typed in. We can see what kind of attacks they do to our machines. So, on many modern networks now we have these machines which appear to be real machines, but which are infact are simple honey pots. This is the simplest kind, right? Where we can simply log the connection attempts, who they're from, and what information is sent to us.
Alright, another thing we're going to finish today is epoll. So I suggest for a simple server, hey, just uh, just little while loop. The next simple server is: hey make a thread so at least we can do this with uh multiple threads so that I can be servicing two clients at the same time.threads so Well, these kinds of ideas work until now you have hundreds or thousands of clients connected to it at the same time. And um, a bit of history is that we used to have a core called select" you'll find in everywhere (works in a mac), but these days, epoll is a common solution to a hyperbolic server; in fact, you'll get to play with that this section. And what epoll will ask you to do is with sockets or pipes, and you'll get to play with pipes. You can say, Actually, there's a whole load of file descriptors that I'm interested in." And so, the basic outline of epoll is: you make, we make a set you'll create, and then, using a control function we add a whole load of file descriptors, a whole load of file descriptors. You say you'd want to read or write to these. What's your intent? And then you can wait--wait for an event. That's the basic idea. So actually now, I can have a single thread waiting on a thousand clients. If my clients don't talk to me very much, when one of them does, I can immediately find out which one. ...because epoll call will tell me, Hey! By the way, now you have to talk to this particular file descriptor, now you need to be talking to this particular file descriptor." The old way of using select: will select allow me to go to sleep once something is happening; but once select returns, I'd have to kind of go through every single file descriptor. I'd have to do a linear search to find out which file descriptor was the one that I need to process. So, that would be in session this week with epoll, and the other section thing we hope to do with sections tomorrow is to connect some class 7 code on the tablets as well. With that, have a wonderful week! Good luck with the MPs! I'll see you on Friday <3
alright good afternoon class now so today we have quite a few pretentives in the orders if you traveled here because you ... cs 241 but ur just visiting the class today please just wave your hand i know theres quite a few of you right these people I invited just been accpeted to cs major program or they are visiting campus so be sure to be nice to them and tell them what a great place wisconsin is so here's what we are going to do today we are going to finish our discussion about sockets uhh in terms of .. what we can do is we use imports, and  what happens if is my mic on yet what happens if we dont set various socket options when we are developing our programs and we discover that the port is in use and that kind of stuff and then we talk about how can we make the server actually discover who is connected to us so we can find out for example its ip address so yesterday you made yik yak, or at least use a very simple version of yik yak, where we connect to our virtual machines on the android tablet and now that we want to make it so that our server can actually find out who connected it a little story for you that is the very first time i visited urbana champaign was I was visiting wolfram research they're just down the road, you may have heard of them they made methametica i did some 3d visualization software which connected to wolfram using sockets they connected to mathematica using sockets and this is back in the day when we actually made a plugin  an external piece of software to display 3 dimensional shapes so i was talking to them and back in the older days of the web, before blogs and they said, you know, one trick what we do, about our web server, is we got various competitors right now and we dont want them to know immediately when we release our product so when they come to our website, we check their ip address of the connection and we serve them the old content so our competitors see our content at least two days old so they'll be a bit slow in discovering when we actually release new software so that's something you can play with with the yik yak implementation  that give bad inforamtion if you don't like the client connecting to your server hey, give them something, give them some alternative information ok so how can you do that? easy! look at, say, the ip address, the bytes they sending to you you could invent a new protocal all messages to you should have a hash value which should start with a colon etc. etc. etc and why not share your protocol with your friends at cs 241 so that you can connect to each others' virtual machines and why not tell some bad information to the people you dont like in cs 241 and then you can tell them when the exam's on when they re not alright  so lets go out for our handout for today uhh we need i can ... some content today alright what's the honey pot easy! a place for honey! remember this? we can make servers that masquarade as real machines  and then uhh see how they've been used on internet for example, what you see in todays lecture is how can we discover what client is connecting to our server so we can label those ip addresses you could for example on your virtual machine have a port 80 open up  and see if anybody tries to connect to your machine okay so what are the purpose of these calls, htons and ntohs? Â what do they do? yes host to network and network to host why do we need this? well because if we gonna be transfer bytes to each other we should agree on what order we should send the bytes for example if we are talking about an integer of two bytes long, we are sending the low byte or the high byte first and our cpu may not respect that perticular ordering and in fact if you on a intel machine it is actually the wrong order ok so we can use these to make sure that any integer values we send as binary are correctly ordered, that we put them in the right order for either working in our cpu or sending out on the wire we send it to the network card ok so its time for host to network short, network to host, short so we'd use this, for example, when working with port numbers umm port numbers are 16 bits ok so what are the four calls with the network server we've done this already remember our basic idea is we want to make a socket we'll say what kind of socket right then well call bind because we want to bind to a particular local port we may also use it to bind to a particular network card so weve made actual socket now so how do we get started we call listen all of these things will happen very quickly the next one will block, and that is when we call accept accept now will block if there is no one trying to connect to our server.  so it only returns when a client has actually connected.  why do we call listen? because we may want to set up a small queue so that if multiple clients connects together, the operating system is prepared to look after those immediate connections until we get them from accept and each time you accept, you get a new file descriptor and each time the client connects, it gets a new port to talk to alright so we've seen that now one thing i didnt talk about before was freeaddrinfo yes we've been playing with getaddrinfo to fill in a pointer to that struct  and remember that struct actually could be a linked list so when we finished using it rather than having to walk through the linked list ourselves there happens to be something called freeaddrinfo that does this for us and of course that is going to pull out the next pointer before calling free on each struct so what do you think might be wrong with this little piece of code here? you can assume that inside the dot dot dot i've called memset on hints and i set up the hints struct correctly  umm but what do you think mistake i might have made in writing this little bit of code make a pointer, called getaddrinfo, and then I called this function called free to say  ok, free that linkedlist that getaddrinfo set up for me what could possibly go wrong? yes? oh should i pass the address actually no freeaddrinfo takes a pointer to the first struct and go through destructively and frees up each member of the list  okay time to put your, yes thank you yes right so, remember we need to ask ourselves what could possibly go wrong ok here's one possibility  suppose getaddrinfo failed for example, you haven't actually connected to the wifi so it cant do the domain name lookup and find ip address so suppose getaddrinfo fails that means it never changed this pointer 
so what is result pointing to? could be anything right? we just made this little thing on the stack its just whatever happened to be at the stack memory at that moment so we just called free on a arbitrary block of memory whoops our program is probably gonna crash at this point but its certainly probably vulnerable to other attacks at this point ok so how should we fix this? well here's what i would do i will probably set this to null to begin with and let me check, I'll only called this if the result has been changed so if its not equal to null then call freeaddrinfo that's a more robust program right port hijacking so i love this i want to dress up as a highway man as a pirate yes! there's a potential for port hijacking when we write our server programs imagine this, imagine you write a fantastic web server or another program that uses sockets to communicate and then your program finishes, perhaps it crashes at that precise moment, another process starts listening to the same port mua hahaha... and it gets some bytes that were intended for yoyu well this is a security risk we should prevent this, right we should prevent another process from immediately starting up and so that actually led to a socket rule where if you claimed a particular port, another process can't immediately reuse it if that process belongs to another user, we have a longer time out let's actually see this as a little demo and then we'll say what we can do uhh ... where is it... alright... so ok, right, good i have a program here. so now let's run my little server here ok so gcc server1.c alright, so here's a little program we service for where we waiting on accept waiting for connection right, so let me connect to this. i'll start a new window,  and is today i'll use nightcat , so nc localhost 1234  okay, we've connected. Yes! it's good! so I can send something over here let me at this point quit my program, i'll make a few changes, and i'll run it again.  oops. bind failed address already in use.  I couldn't reuse that port so that port for little while is still being bound to that old process even though the old process is quit, we couldn't immediately reuse it.  okay, so what can we do as developers? uh we like to be able to reuse our programs so i'll test it quickly [gibberish] it's okay I can reuse my port 1234 again so what options is to use hey, dont develop too fast but no we can do a bit better than that we can actually disable this security feature by setting an option on the sockets so lets see how we can do that hello ... just trying to connect to my machine right, my machine. so let's see what we can do here and there's a little option called setsocketopt where, make this larger, where ... on my server socket, i can say i wanna be able to reuse the port in the future so if you set this option on the port, that this when your process dies, or quits, another process can immediately reuse the same port okay. some odd syntax. we are gonna see this in a bit more examples.  of this.  is that youll see that we have to , in this case, pass in the address of the integer value, and then the size of an int so we are gonna see this passing a couple time today when we pass in the addresses of something and size of the thing that we are trying to pass in but thats just a bit kind of useful line of code that youll be using in one of the later mps one of the mps that we've got lined up for you is called wearable's mp, where we are going to simulate having a whole load of devices talking to, say, a server, so you might have to watch, you might have a pace maker, you might have a, i dont know, hair, that talks to your server  and this is the single ... connecting and constantly talking to your server which collects your data, maybe collecting your blood pressure, and a whole load of your vital signs so  we want a server when we developing these stuff we wanna be able to quickly reuse ports, so here's the option to do that okay, so let's make a note of this how do i do this? if we start our programs and we use the same port, easy, we gonna use setsockopt and the magic ... is this SO_REUSEPORT thing which should be in the wikibook. If not, I would add it and notice we do this before we call bind so we do this early on just after creating this socket set this option on on the socket right so we've played with very very simple kind of server, now you wanna do more.  right? this is uiuc, this is illinois of, university of illinois, we wanna go up to eleven. we don't wanna have just a single connection to a single client we actually want to write servers that can talk to thousands of clients at a time how can we do that? well, a long time ago, we realized that i dont want to always block on my read call waiting for my client to send me something, it would be nice to find out which client is coming talking to me has sent me some bytes so, the idea of select was born okay, right, so the very first implementation to attempt to making performance servers is to use the system call, is called select probably about 5 minutes after someone designed select, we discovered it wasn't any good. 
it was good enough at the beginning for the first four minutes but here's the problem with select you have to do an order N scan after it returns to find out which file descriptor you should be talking to you should be calling well that means an order N like up to say 1000 system calls and that in itself takes time, it's going to take milliseconds of time to say or should i be talking to this one, should i check... so select was a first pass, the great thing about select is that you'll find it everywhere if you want to write code on say simple embedded devices on windows, on mac, hey! just use select and don't worry about performance, it's good enough and it's easy to write code which times out so you can say okay I'd like to wait for say a second to see if the client sends me anything so select is a reasonable choice at that point so what happened next... is a system call called poll is defined that solved some problems, but today what we played with and what you've seen in lab is epoll the only downside of epoll or the main downside of epoll is that it's on linux but not mac not BSD so now you're stuck right? what should I use? select? poll? eopll? etc so epoll is performant, it's great for if you have a thousand long lived connections so it's ideal if you've got thousands of long lived connections so this is your yik yak server now a single machine can support thousands if not more connections, epoll would be a very good choice and as you saw, the way we used epoll is we set up a set and we just add file descriptors to that set and then we say okay now I'm prepared to wait, I'm prepared to block until I'm able to read from at least one of these and then when it returns it tells me which file descriptor I should use so for CS241, yeah we can play with epoll in the MPs and should you ever find yourself in a startup or fortune 500 company that wants to write a server, let's see that's probably every single fortune 500 company these days or just about most startups have some sort of client server architecture you might come down to which one of these should I use? just remember that there's actually three different versions here's some other thoughts on your server though which is.. sorry of you startup... is that why don't you do what chromium does, the browser that you found inside your android phone or chrome if you've downloaded as an app it uses the library called libevent and libevent basically wraps these three things so it provides an abstraction on top of the system calls now we're not going to use libevent in any exams, this is just an FYI it's that next time you want to do your startup, check out libevent because then you can write code that runs anywhere and it just provides implementation underneath that talks to select, poll or epoll to get the best possible performance on each platform so I've been throwing a lot of information at you very quickly today, any questions at this point? okay I've got a bit of news for you I understand its passover this weekend so I'm going to ask the TAs to push the deadline for the MP back to Monday night 11:59 pm okay so one minute before midnight on Monday is there not an MP that's due.. somebody sent me an email saying hey I need an extension so I'm going to ask the TAs to make sure there's no deadlines on this weekend okay if there are two deadlines this weekend ok well I push the one on Sunday onto Monday if you do not observe passover, you may still take advantage of this if you feel it's unfair to have two deadlines the same evening feel free to submit the first one just on Sunday night and then pretend that the extension hasn't been given I'm also asking the TAs to try to provide more verbose information about the MP merge by the way, the MP merge tester runs on a VM just like yours so it's probably a good idea to check your VM code on you personal virtual machine okay right so any quick questions? okay right let's jump into some other kind of little bits of know how then so we've been making servers that listen on a particular port if you're just doing development, you may not care which port your server listens on you'll just say hey give me any port that's currently unused here's how we can do this first of all when you call getaddressinfo if we're setting up a server, obviously we want to talk about localhost, that's NULL and just say I want port zero which is another way to say hey I'll be happy with any port well now we've got a problem though, we need to find out which port number we're actually listening on here's how we do this, there's something called getsockname sock of course stands for socket as opposed to things you wear on your feat this code kind of looks a little bit like the code you might have been writing before getaddressinfo existed we have these different structs for example... there's this sockaddr in which you can think of as a version or as a subclass of this other struct but because C doesn't support [something] we can't say hey this extends this other struct we have to forcibly typecast it and so there's all sorts of interesting gotchas, any days that you forcibly type stuff you might forget for example to put in the ampersand here so there's all sorts of gotchas I'm not going to ask this on an exam, I'm just pointing out, if you want to develop code that listens on any port, this is the way to do it you call getsockname on your socket and now we from that struct we can figure out which port there's just one little gotcha here if we try to use this value directly.. hahaha oooooooh we're going to be in a world of pain why?
one important thing we have to do to this particular value if we want to know the port number okay let's go back to the beginning of the lecture dodododo hello everybody welcome to Friday and don't forget what do you think htons means? network to host means? remember those little functions? yeah these C structures are the C structures to do with hey the bytes that we're trying to send to the network card the port number that is represented inside this struct is not really an integer like we like to think of it like an integer that's on our CPU so if we actually want the value of this entry, we've got to convert it so don't forget to call... network to host short ntohs and that will give us back an integer value that is actually the integer of the port so next time you hate your lab partner, just walk over and delete that code and watch them try to connect to the wrong port for the rest of the discussion section right so that's a little gotcha there, no one will tell you that you've forgotten to convert your integer to the right value other than the fact that you'll be trying to connect to the incorrect port the other thing you might want to do is find out who is connecting to your server here's how we can do that, remember this accept call, the thing that blocks waiting for a client to connect remember how it gives us back a new file descriptor? well we can now pass in a pointer to a struct very similar code here hey I've got this C structure, please fill it in and if you do that, it will tell you information about the remote client it won't tell you their login name but we can find out things like their IP address and their port number so for example, if you didn't like the remote client, why don't you send a thousand packets back to them and try and shut down their machine and send them a denial of service no don't do that for real unless you happen to be the US government okay so we've got that information and we now want to print something out here's how we can do it you can say okay turn this number to an ASCII value and that will turn it into an IP4 address like 127.0.0.1 we can see that and also with the port number, oh look here we go again, don't forget to convert that struct entry into a real number and then we'll print it out okay so let's see that as a demo okie dokie so I'll go to server2 let's see if this works okay right right so I've got my code now, it just picks an arbitrary port number that is available and let me try connecting to that well actually why don't you see if you can connect to that if anyone's got their laptop open you can telnet to 172.17.248.187 and see if someone connects to that port number okay fantastic right and I got your address so now I can telnet back to you for example right let's see if you're running anything on port 22 no you're not, okay so I can't try and hack into your machine today alright so that's in what you need for the next MP and to make your next multibillion dollar startup company of course this stuff underpins webservers, it underpins a little company called youtube, you might have heard of it, it started by an undergraduate here it started, well, what are we in siebel center networking, this is what it's all about, being able to connect multiple machines together and we've seen the basic socket calls that do all of this so for the remaining part of the lecture, let's say goodbye to networking and talk about a different systems programming topic are you ready? right, page 2! okay so today a couple of quick comments yes we have a quiz on monday it's going to be topics that we haven't talked about for a while remember virtual memory? do you remember page tables? translation look aside buffer? no? okay well don't worry now will be a good time to learn I will send a practice quiz in the near future remember pipes? do you remember how to use fseek, ftell, fpause? and finally we got the dining philosophers concurrent problem and also the reader writer concurrency problem so they'll be in it too okay so expect that quiz on Monday in lecture any questions? alright then so let's talk about a new topic scheduling! you already know as a student a lot about scheduling probably the scheduling algorithm that you're most familiar with is called earliest deadline first yes? right? my chemistry home is due and its due in 10 minutes oh no! okay so this is a problem of just how efficient can we be? can we use our CPU resources and other system resources to get as much work done as possible? well it turns out of course that earliest deadline first isn't actually the most efficient algorithm because we might spend a lot of time flipping from one piece of work to another piece of work and so we actually have addition latency involved with these context switches and with scheduling all of this work so for example, if you find yourself constantly updating your calendar to say oh I'm going to do this work here and this work here you've chosen an inefficient scheduling algorithm
so this is a non-trivial problem. we got things we wanna run inside our machine which are very urgent we got say mouse movements to update, things on screen to change we've got things are not so urgent but requires a lot of cpu a lot of disk so this will like batch jobs where we dont necessarily need them to be quite so responsive, but we want to schedule them so that they finish within a certain amount of time so these basic questions lead to a very large amount of mathematical analysis and experimental analysis as we try different scheduling algorithms and we try to find ways to make our system have a highest performance as possible and this is non-trivial, and if you get it wrong, people dont like you programs, say, hey, this java thing sucks or hey this machine is no good for processing audio. i keep getting dropouts because my process isnt given enough cpu time when i need it or hey my scheduler just crashed my car because it didnt give enough cpu time to the neural network that decides whether to turn left or right so scheduling turns out to be a critical part of the system i'm going to look at it in terms of three different scheduling algorithms,  and also, just to give you an introduction to some of the terms of how we might actually compare different schedulers alright so lets define a few terms first of all, turn around time what is 5+11? 16 see, those about 2 second delay, when I ask the question, when i demanded the response, the completion of the work, and you actually give me the complete response thats turnaround time the time between when someone says hey, heres your chemistry homework, and you actually finish it.  ok, thats turnaround time, theres pretty obvious meaning, theres nothing special about it waiting time, so well define this as the total time that a job is able to run but is not schuduled in other words, if you got your chemistry homework, hey give me another subject.  anybody have other, what homework do you have right now? stats ok, heres this stats homework, right, its on your desk, its ready to go, but you dont get to it because you are inside a cs 241 lecture ok, theres part of waiting time of this job, of this homework later you do some of it, but then you decide to go out with lunch with you dog or something. so again, this is more waiting time for this job. so if we want to compare between different scheduling algorithms, like the lunch first scheduling algorithm, as apposed to chemis right, we can talk about the total amount of waiting time this homework is done we can exclude tho, the time you actually writing on this so honestly the waiting time we'd like to be as small as possible  right, what about the response time? okay so heres a little difference between response time and turnaround time remember, the turnaround was basically the difference between the end and when you actually first submited it when you first knew about that homework the responsible time, is the time to the very first response so if it was your chemistry homework, it might be ok, you dont submit the whole thing yet, just submit the answer to the question 1a.  so you dont need to finish it, you just need to start producing or showing some output from your job. so if you going to run a very long job, we dont care when you actually finish it, we care about  when you actually starts it, able to give its first response.  first result so thats just a little gocha response time is not the whole time, its the time required to generate the first output then we might care about throughput throughput is the number of homeworks that you can do each week, no you dont care about that, okay fair enough throughput we care about the number of jobs that we can complete. if your system was always swapping between bit of this hw, bit of that homework, your brain get so fried by thursday you say huh, if we get this I'm going to choose an easier major, right umm so your throughput will go down you haven't chose a good scheduling algorithm so throughput we care about the number of jobs we complete in some unit of time latency we can define as the overhead of our scheduler that leads to delays or additional overhead of this scheduler that slows down our ability to actually do useful work and then starvation right, starvation on your chemistry homework will probably get you an F on your chemistry homework  how could we get starvation? how could a scheduler generate a starvation you forget about the job ok yes thats not a very good scheduler  i dont do homework, ok what else? thank you! ya! so you always do your cs241 homework and you never do your chemistry homework or your stats homework so if you have a priority system when you  always do high priority stuff or you only do the homework you like, or you always do the easiest hoemwork the shortest homework that very project that is due for the woodworking 101 is never gonna get done
so yes you can see starvation with this systems so we gonna look at these terms and we are going to umm analyze different schedulers right, so here's a few common schedulers and next week on wednesday we are going to look at these in detail and run some examples through them fcfs, right, when i call it fcfs because in literature we see these things so commonly shortened because its a bit of mouthful first come first served so this is the mcdonalds scheduler you arrive first, i serve you first. its a queue, right its a simple queue. you put your homeworks in the order that they arrive.  is that a good thing? uhh it depends, we gonna have to think about whether these schedulers good for batched jobs or for our responsive needs because we actually have our user that wants to see progress on their work so we have first come first served in other words , its just a queue right, the next scheduling algorithm, its fantastic, here it is shortest job first now, we can use this, we can analyze our scheduler mathematically in practice you might run into a bit of problem if you try to actually implement shortest job first. whats the problem? yeah, how do you know? so what you need to do is go out and buy a crystal ball and become clairvoyant and steals some tacheons from physics lab, and simply know in the future, how long your job is going to run now ok some specialized circumstances, you might be able to do that. for example, if you ran exactly the same program yesterday, and you are running the same code, with the same kind of data today, you can be pretty confident that your job is gonna take two hours to run but in a general system that is not true. we dont know how long our jobs gonna run but we can still at least analyze this. if we have some fake data, say, job1 takes 10 minutes to complete, or 2 hours to complete, we can still do some analysis. so shortest job first in practice ... [cant hear] difficult to implement because you dont know how long it is right ahh haa, this is the pirate one, its the round robin now this might sound like a kind of quaint english thing and we dance around and jib with some medieval music  that would be an incorrect answer round robin, heres the idea, is that all of you are important, so im gonna spend a bit of time with each of you alright i set my clock, i talk to you a minute, and bye i talk to you a minute, and bye, i talk to you a minute, and bye, now of course i'm the cpu, right, we are talking about the cpu giving resource to each of these jobs, so imagine like if i got all of these homework, all of these stuff that my cpu can be doing, i'm going through all of these processes, and they got the cpu for a minute, and lets say, you're the last job, yes well we gonna go around again ok so you can see if this say for fun all of these jobs has three minutes worth of cpu to complete,  ok none of them complete within three mintues, ok i'm gonna keep going through. these got a little slot of time, so thats why we call it round robin. now it turns out that this homework, half way through, has some problem on it that cant be completed, without additional information from the professor so the cpu say, you're blocked, you're waiting on a semaphore, you're waiting on a callback function that, so i'll skip you. you are not actually runnable at this point so our scheduler only needs to run jobs which are not blocked.  so for example, if you just wrote you server code and your calling accept, we dont need to spend any cpu time on that process. its blocked, theres nothing for it to compute.  anyway, thats round robin so the idea is that we have a little piece of time and you get it and you get the cpu for certain amount of time of course it might be that if i give you thirty seconds, hey you're done already nothing more for you to do. you've finished copying data to the disk, you just called accept, you just called mutex lock and you're waiting for it to finish.  so your process might give up the cpu before you minute is up before you time quantum expires, but if you dont, ha, too bad for you, i'm taking the cpu away from you, and i'm assigning it to a different process so your little process is now stuck in time that homework is half finished because the cpu is now working on a different job.  right, preemptive scheduling. ok, this is easy, if our jobs, if our task have different priorities, hey, system programs is really important to me, and i'm going to get this done before anything else, then we can use that as a scheduling decision so lets go back to round robin for a moment, and say how long should our time quantum to be? all that tradeoffs ok, lets turn that into a homework problem again. suppose that we work on this problem for ten seconds, and then this homework for 10 seconds, and then this homework with 10 seconds, and then this homework has 10 seconds  what's the disadvantage? yes?  thank you! i'm doing a lot of context switch. I'm going to spend a lot of time, actual woke up time, real time, just switching one problem to the next problem so much so and now i've introduced some latency into the system, so much so that um my throughput is no longer good, its because actual cpu time is burned is spent doing all these context switches okay, so lets go to the other extreme than. I'm going to work on this homework for a day and then i'm going to work on another homework for another day and the next day, so i've made my time quantum very very large now
what's wrong with that? ok, if a process runs forever, or one homework is really hard, you taking cs 473, you think 241 is hard, ha! wait till you take 473 right, or take 373. anyway, the three hundred class, now, the i may not get to some short jobs quickly, right? if this job over here is just Hey, send all those email, they reply, you can have to wait a long time, even though it's gonna take a minute for you to complete this job, i've got a very slow quantum so those are two extremes, I got one way where i got to introduce a lot of overhead, because of the context switch, another, where short jobs are now waiting for a very very long time, to be accessed so what do we do? on a real system. on, say a laptop, or on your linux. where for starters i'm gonna talk about linux just a sec because linux has actually got something better we gotta choose an appropriate quantum and you will see times, typical times of ten to hendred milliseconds in other words, a little hardware clock goes of says, hey, your time's up and interrupts the cpu, and kernel gets involved and say hey, time to move onto a different job" why do you think we chose ten to a hundred milliseconds its empirical. yes, so in what factors, what factors influence that decision ok we got a lot of things running in parallel, we've got interactive jobs, you typing on a terminal, for example, and as you type, you want the letters to appear. if we context switch, if we go off to a different problem, many times a second, you won't know. people won't know that they are sharing the cpu with multiple jobs right? you could be logging into a server, or you could be typing in a terminal, and it looks like hey, the system is mine" the cpu is all mine to play with, and if we keep swapping it around fast enough, no one except for the people taking cs241 will know no one will know that actually we keep swapping the cpu  so that's the first idea to why we choose to this kind of time which is its not so short that we have a lot of overhead, but its short enough so that our system appears to be responsive when we interact with it these days you might see even faster times as well right, and finally, what does linux do today, it uses something called ... oops ... a completely fair scheduler ok some comments about this, one is, huh, there is no such things as someone could be completely fair.  you ask any two-year-old alternatively, it's completely fair for some definition of completely fair  final thing is, this scheduler was actually stolen from network theory.  the ideas behind it were generated by understanding how to schedule packets on the network  and that's what we talked about it today with that, thank you very much. have a wonderful weekend, i will see you on monday for the next mini exam! thank you very much. Come down to see me if you have any questions
Ok, class welcome class to CS 241 First announcement Yes, CS 241 is a lot of work but you may have noticed there are seniors still walking around in this building They survived CS 241 and you can too Why not get a T shirt Yes I appreciate its a lot of work But this is what kind of sets you apart from other students in other universities By the end of this course you really are going to know your stuff  And you really are going to change the world Ok so here's what we're going to do today We're going to talk about scheduling We're going to look at some simple different ideas about how to do different schedules And similar effects it has on things like the waiting time And exactly when each schedule is is uh uh exactly when each process is scheduled Right so let's have a look at this and in a moment I'm going to ask you to calculate this So as this is a model of - we're going to uhm be clairvoyant - we we we know when as a design we know when our processes are going to be ready to run And uh we've got four processes, we've labelled them one two three four We can say hey process four doesn't exist at the beginning or it's not ready to run Perhaps it's waiting on a condition variable, the process is waiting for some data to revive But anyway we don't need to consider it in the very beginning of our model here Uhm and then these different processes have different amounts of execution time they need in order to complete So for example in process one takes thirty milliseconds So we're going to look at our little simulation in ten millisecond blocks and see which process is using the CPU for each block of time Now here's our different scheduling approaches we've got Okay We've got something called round robin So with round robin what we do is we try to be fair and say Well you can have the CPU for a certain block of time In this little example, 10 milliseconds And after 10 milliseconds the alarm goes off Ding! A little hardware clock goes off And that causes an interrupt the interrupt then causes the CPU to execute some code inside the kernel The code inside the kernel says AHA you're out of time And now I'm going to give the CPU to a different process So the idea is we're going to do this every 10 milliseconds Uh we'll try to be fair So this means that if there's a long running job It shouldn't matter too much since after two milliseconds we're going to give the CPU to someone else And they get a chance to execute Okay so that's round robin We'll work that out in a moment And you'll notice in this little example I've actually got three processes All ready to go at the very beginning So what we'll say is the order in which they ask if you're ready Is just dependent on how we've written them done So process 1 we're going to run before process 2 et cetera et cetera et cetera  And then the next we're going to calculate is shortest job first Meaning we actually know in advance these timings And we give this to the operating system To the scheduler So it can decide when to run them A I gotcha here" is remember you can't actually run process 4 at the beginning of time because it doesn't exist yet It only comes into play, it only enters the stage after 10 milliseconds Alright so that's not a choice at the very beginning And then we have first come first serve This is just a simple queue Whoever arrives first gets to eat first And they continue to eat, to use the CPU until they are finished So it doesn't matter how long they take So that's first come first serve, FCFS That sounds pretty fair to me but we'll see if there's a problem with it later Now we can make these a little more complicated We can talk about how to preemptive shortest job first And the idea here is if a new job arrives In other words appears on stage ready to go Then if it's shorter we'll run that instead Now, one thing to look out for shortest job does not mean remaining time It means the actual original specified time So if you've only got ten milliseconds to run on a thirty milliseconds job  It still compares thirty milliseconds Not the remaining time, it's the actual total time When we talk about shortest job first And then the other variant is preemptive priority where instead of thinking about the execution time  We have some sort of priority assigned to each process So for example if this was controlling a lunar lander Controlling the rockets is probably more important than say running the -inaudible- activity right now We need to make sure that we make immediate course corrections So uh, in this, we've got higher value equals a higher priority And if a higher priority job arrives on the scene Ready to go Then we will give the CPU immediately to that job So that's the process we're going to run in a moment Let's go back to these questions So when might a process be in the ready queue Let's think about processes you've programming, you've written Why might it be in a ready state? Not running on the CPU But in a ready state What could have happened? Yes! Okay so there's more than one process who wants to run And someone else has currently got the CPU Give me something that might have happened to your process That makes the mediates become ready Ok, thank you. It's waiting for say disk IO, or say network IO Perhaps you've called read Perhaps you've called accept And now you're waiting for a client to connect to your web server To your chat server To your database server That thread of execution cannot run yet until the operating system says Okay, yes! I've got your data, off you go Okay What else? No ideas? Yes! Let's say you call sleep and your process sleeps for five seconds After five seconds your operating system says Oh, okay, right, fine Time to wake this process up I'll let this process continue, I'll let that thread continue Similarly if you had a call with a timeout Alright, there's going to be time when your processor stops A zombie is not ready to run A zombie can't run, it's finished It's still taking up space in memory Inside the processor control block because we have things like it's exit status
Yep Okay so a thread has called condition wait Is not yet ready to run but if someone then broadcasts it It goes into the ready state So if we wanted we could draw a state diagram that says Look our processes can be in these different state It could have been just started, it be running on the CPU, it could be in this ready state And once it's in the ready state it's up to the kernel who gets to play and when And that's what this scheduling is all about Alright so we can define something called wait time And uh I can write a little formula for it Where's my notes Oh yeah So the wait time is the total amount of time spent in the ready state Waiting to run So uh if we know the completion time and the start time That gives us the beginning and end Some of that time was spent actually doing useful stuff Actually executing So if we subtract that stuff we can actually discover how much time our process was unable to continue, it was in the wait state So I can say that the total wait is the uhm completion time so Time, the actual wall clock time when we finished Minus when the process first arrived Minus - so that gives us the time interval And the other time we can subtract is the time we spent executing So the duration that we spent executing So if we subtract off those two We get a certain amount of wait time That might be useful in calculating the wait time in these examples So it's not the first uh time that we have to wait because a process might go back into the waiting state For example If a process with a higher priority and you are running a priority based scheduler Your process might be pulled away from the CPU and the CPU is assigned to someone else To a different process Okay, so we've done that So it's not the first waiting time It's the total waiting time Okay so just occasionally, maybe in these examples I haven't calculated them today You have a tie break For example your process might be ready to run again after round robin And a new process arrives on the scene ready to go Which one should you use Well we need some sort of tie break decision And in which case we might to choose the job that arrived the earliest on the scene So now we want the earliest job to complete So let's see if any of these examples require that tie break situation Okay soooooooo Here's five little examples I'll get started and then you get the next one So let's look at this round robin So round robin remember It's like a little song, each person gets to sing a little bit So process 1 gets to use the CPU for the first 10 milliseconds But then our hardware interrupt goes off and the kernel says HAHA not for you anymore And then process 2 has been waiting Also process 4 arrives on the scene But we're going to schedule process 2 because it was there first Alright 10 milliseconds later we switch our process 2 and process 3 gets to use the CPU Another 10 milliseconds later our hardware clock goes off And finally process 4 gets to play And guess what happens next? We go around again! So process 1 and then process 2 Now at this point process 2 is finished It's used its 20 milliseconds up It's finished calculating whatever it needed to calculated Then it's 3 Process 4 you're already done  So we're back to process 1 So now we could calculate the wait time and if we wish the average wait time So for process 1 how long was it waiting? I could count that 1 2 3 4 5 It was waiting 50 milliseconds And process 2, it had to wait uhm, 1 2 3 4 - another 40 milliseconds Process 3, from my notes, looks like fifty And process 4 will be uh thirty milliseconds So I can add that up to get the total wait time and then divide by the number of processes to get an average Okay So that was me working through another example Now it's your time to play 20 milliseconds? Oh quote possibly yesI'm sorry, oh quite possibly,  Because yeah it arrived at 10 milliseconds So it had uhm to wait in additional 20 milliseconds before being scheduled I think Right so Perhaps its not obvious but these are the end times of each block So this one goes from 10 to 20 and then 20 to 30, et cetera et cetera et cetera  Okay Right Sooooo Now is your chance to get cozy with these different scheduling algorithms And to run through these little examples It shouldn't take you very long Any questions? Okay, have a go.
Okay so with the shortest job first We're not interrupting the existing jobs So even though process 4 arrives and is ready to go And is 10 milliseconds We let jobs run to completion Alright so 4 before here has to wait an extra 10 milliseconds before it can run There is no preemption Okay that's what we're going to do down here When we do preemptive shortest job first When we actually take the CPU away from a process In the preemptive version yes we start with P2 But then P4 arrives on the scene, the new kid on the block Alright and so P4, off you go P4 runs to completion and now P2 can be scheduled back It beats P3, it arrived earlier And then P3 runs And then finally P1 has been waiting all of this time and it gets to run Alright K First come first served Couldn't be easier, right It just simply write down the order in which we wrote them down here No brain power required whatsoever And then the last version we are going to look down here is preemptive priority Yep It's not about the remaining time  It's about the total time of the job It's not remaining shortest job It's about the total So don't do any subtraction stuff It's a common gotcha Alright so and the priority in this example saying a higher priority number is more important So process 4 is the highest priority but it's not around at the beginning of time Instead process 3 gets to run And then it gets interrupted Process 4 comes along and says I need the CPU and I need it more than you So process 4 finishes so we go back to process 3  Process 3 finishes And then we go back to process 2 Process 2 finishes And finally process 1 So we could calculate some wait times This one is 160 over 40 That gives us an average wait time of 40 milliseconds Shortest job first: the average wait time turns out to be 20 milliseconds First come first served: average wait time 37.5 ms Preemptive shortest job is 22.5 ms The last one is also 22.5 ms Alright so we don't care that much about the figures But what we do care about the following Firstly there is a difference in ordering And yes this was just a paper and pencil exercise But it kind of shows you depending on how much you care about a particular job You might be in the ready queue for a long time, you might be waiting for a long time Secondly we have a clear winner here The shortest job first minimizes the wait time in this example And uh in general as well And if you think about that, that kind of makes sense The long running job and I put that first, all of my other processes are going to have to wait for that length of time Therefore I should put the very longest job at the very end of my queue  And I can just prove that recursively therefore that my average wait time must be minimal if I put my shortest jobs at the beginning of the queue And I order them by total execution time So if my idea of fairness, if my idea of an optimal system, was just in terms of how long my processes have to wait Then I would choose shortest job first There's a problem with that of course First of all we'd actually have to know how long our processes really do run for And that might call for a crystal ball Or at least an assumption about how my processes work today are exactly the same as how they worked yesterday And that's kind of stretching it about with real systems Our preemptive schedulers worked pretty well Of course they're more complicated We're going to have to write a kernel who is prepared to switch out a process and save it someway so that we can preempt and pull it out And replace it And our round robin actually has the worst wait time even though it was going to be pretty fair though we thought it was going to be*
So what about this? We've heard about starvation before where a process never gets to complete it's uh, it never gets to make any significant progress. Which scheduler could lead to starvation and how? Maybe there's more than one correct answer. Don't tell me know; tell your neighbors and see if you agree. Okay, so uh, a student has let me know that my calculations are suspect so I probably am off by a quarter millisecond or so. So I apologize for that. Silly  numerical error. Okay so which ones can suffer from starvation? The second fourth and fifth. Shortest job first, yeah, so if you're getting text messages continuously you might never get to your chemistry homework. So next time you don't fill out your chemistry homework, or CS 241 HW, keep sending yourself text messages. They're nice and short, you'll do them straight away. So shortest job first; we can set up a starvation by keep making short jobs and we'd never get to the long job. The other possibility is pre-emptive shortest job first. So again uhm I would never get to my long job if I keep submitting short jobs. And preemptive priority. Same idea If I keep having an urgent thing to do I might never get to schedule my low priority items Is there a problem? Yeah. We have to choose a tradeoff. We have to decide what we mean by fair. So which schedulers are appropriate for batch jobs? Of course the answer is It depends! By batch jobs we mean aren't interactive which are typically run for long periods of time without user interaction. They have all the data they want to process Maybe stuff out of files or network Do some analysis on that data So we might care about say earliest job finishing first or shortest job finishing first in which case we might choose a shortest job first scheduler We might care about seeing the results of all of our jobs And we are prepared to wait so we might choose round robin Uhm The other possibility is to, in a real system Suppose your job crashes or runs forever, has an infinite loop If there is no preemption if we don't forcibly remove that job from the CPU everything gets backed up So we have to careful if we're not going to preemptive running jobs Right So there isn't a simple answer for this batch jobs It depends on what your criteria are So what scheduler does Linux use? I mentioned it last lecture Yes! The completely fair scheduler. Which is a little bit of an oversell Alright so it's not completely fair But it is similar to round robin where we are prepared to interrupt a process Every 10 milliseconds or so But we're prepared to give an extended period of time to jobs which don't use all of their time quantum So for interactive programs, desktop programs, UI programs These tend to have very bursty needs of the CPU  Like OH QUICK the user touched something OH QUICK I need to read data on disk And they won't use it for 10 milliseconds They will only require a tiny bit of CPU Processing before we end up say sending it an event to the system Update the screen And we're done And we wait for the next user event So the completely fair scheduler says we'll remember that these processes didn't require a lot of CPU in the past So we'll prepare to give it a little bit of extended CPU in the immediate future So we'll try to make the system as responsible as possible K here's a classic problem in scheduling It's known as the convoy effect And we see this with the first come first served Scheduler And you can imagine a real system where I've got jobs which are very strongly CPU bound And other jobs other processes which are IO bound And if you branch in the queue going this way by first come first serve I might have a big job which comes I illustrate by drawing it a large size It's going to take a lot of CPU time to run And behind it I've got loads of little jobs which They don't take much CPU but they take some IO to do And then the classic description of the convoy effect Is we imagine this process uses the CPU for a long time Then just a little bit of IO And then repeats And here's the problem. These are the processes that start after this CPU heavy process They can't use the disk Or the IO They only need a tiny amount of CPU It's like going to McDonalds to grab some little ketchup packets or something And someone there is taking all the space I just need a little ketchup packet" I'M SORRY WAIT YOUR TURN" And so we have poor use of uh IO CPU usage is great. it uses the CPU 100% of the time Very efficient But these other jobs are stuck and uh So our disk utilization is pretty poor We could have had a better choice if we used something like round robin Where we let these little jobs jump in and let them use the CPU for small amounts of time And then they can actually get on with their disk IO Right The questions about threads I mean uh scheduling
Okay so we talk about this classically in terms of processes What a thread really is just a thread of execution Uh everything we've talked about processes applies to threads And uh you can actually set the uh scheduling if you wish uh in the pthread library And so for example there's a pthread call that allows you to say hey I want to use round robin scheduler Or hey I want to use first come first served So it's possible to set that as you create each thread Bear in mind If you set them first come first served Be careful because if a thread never finishes All the other threads wait forever wait an infinite amount of time Because we did first come first serve and you are at the front of the queue And you're saying Hah I'm going to take up this server forever MUAHAHAHAAH So that's just a little gotcha if you truly try to set the scheduling policy Uh so another quick tidbit there's this little command called nice People would like their commands to be nice So what you can do is Linux changed the priority of your process by nice-ing it And uh mere mortals, non root people, can increase their priority number which decreases their priority Which makes it less important And so you can say Okay I have a long running job Its going to take a lot of CPU But only run if there's nothing else to do In which case you might call nice As part of that If you are root you can nice the other way You can actually make things more important and higher priority But you probably won't need nice unless you're trying to run uh background computational jobs And try to make it so they don't interfere with your UI So that's enough about scheduling Let's have a look at page tables So we've been playing a lot with TCP packets And uhm most of the internet uses TCP However uh we did mention there's another thing called UDP Which is packet based It's not a stream We simply send our telegraph or datagram off and hope it gets to the other side Let's have a quick look how we could make a UDP server And see how it's different from a TCP server Okay so uhm if we want to fill up a UDP server Listen on a particular port We'll set up our hints as usual Oh good we've set it to zero And today we want to use IPv6 128 bit addressing So how do we specify that Well for our family we don't want address family INET We want INET6 for our socket  We don't want sockstream We're not trying to make a streaming interface here We just want to send these little datagrams So we have SOCK_DGRAM And we want to listen on a port We don't want to actually send something anywhere We're trying to make a passive socket So for our flags here I need AI_PASSIVE Okay so we set this up We can call get address info as usual I don't need to connect anywhere I want to connect to port 300 And we'll get our result Let's assume that works So well check the return value of this Here's how we can set things up It just takes two calls Yes we need to make a socket as usual Remember that represents our kernel object The thing that is going to talk about our ability to the outside world And we pass in everything we get from our result object Note the hints Yes we want to continue to a particular port So we need to call bind on that socket But then that's it There's no queue to make There's no exec to do We just wait for packets to appear How do I do that? I call recvfrom And when you do this Not only can you get the data that someone set you So let's pass in a buffer and how big our buffer is You can also find out who sent it So that's the purpose of this structure here And we pass in the size of this structure as the last argument
So what are these UDP packets look like? So here's the specification of UDP It's this little diagram here And there's really not much to it It's the UDP format I got a source port, destination port So each of those is 16 bits I've got the length here, also 16 bits a checksum which is optional for IPv4 And the data that someone wants to send me So that was the original spec So it looks like we could have packet sizes up to 2^16 Because that's the number of bits that our length is In practice that may not be true The spec actually says the minimum supported is 500 bytes And in practice most routers will happily send packets up to 1500bytes Which by the time you add the overhead of the UDP and IP fragment  It means that UDP packets are limited to about 1472 bytes So try sending a packet greater than that on a classic network Good luck How do you know it didn't work? This is the sound of silence You get NOTHING You send stuff out It goes nowhere There's a router in the middle that says I SEE YOUR PACKET I SPIT ON IT I EAT YOUR PACKET FOR LUNCH Right So There's two little problems right It's great for sending small amounts of information An amusing anecdote here is IPv6 has since designed jumbo packets Which can be up to 4GB in size I mention this because I find this amusing because right now  Most of the infrastructure spits on anything bigger than 1472 bytes And we've got spec that allows up to 4G Good luck getting that packet to go anywhere Maybe by the time you graduate we'll see jumbo packets floating around on the internet But the spec is there It's probably going to take a generation of electrical failures before we upgrade enough of the infrastructure before jumbo packets truly work You might be able to get it to work on your local subnet On your local router If you buy some very modern hardware But these days currently  UDP in practice Yes that's about the maximum size you send a packet So where is UDP actually used? You will see UDP packets for DNS domain name service So when you type in something like HEY I want to go to the host which say its bbc.com Somebody somewhere needs to know how to translate this address to an IPv4 or IPv6 address And the person The service Who knows how to do this is DNS Which cached this information So there's a whole hierarchical structure of servers that can convert hostnames and addresses to their relevant IP numbers To do this your machine sends out UDP packets And it may send out to 2 or 3 different DNS servers They might say Hey Im in a rush here And quick I need to know Who has the answer? So that's why we use DNS A single packet, if it gets lost, it doesn't matter I'm going to ask someone else as well If it times out I'll just send it again It's a simple kind of QUICK I NEED THIS and hopefully I'll get the response back as fast as possible Much faster than opening up a TCP connection So DNS traffic uses UDP Let's compare this with TCP So the TCP packets are much more uh complicated Here they are There's some similarities You'll notice that we've got a port number From the source and the destination Why do you think we need the source port? I'm sending you a packet to your server Why should I send you my source port? So you can respond So look there's multiple packets going out of different ports on my server all of the time When the other socket at the other end wants to send back some information it needs to know which port to send it to So  the source port is important because we'll need that for the destination We've also got a sequence number. Remember What does TCP try to do ? It tries to hide the fact that we're sending packets across We've kind of turned this into a stream But packets might get lost It might get duplicated So our trick is to keep track of the total number of bytes that we've successively sent in each direction So we'll mark each packet with where we are in the stream So we have a sequence number It represents the actual number of bytes that have been transferred in this direction so far So this means if we lose some packets The other end can say HEY I lost you. I lost you at this point  Can you resend starting from here? And that's part of the acknowledgement number The other end of our connection can say I hear you I've got your message so far up to this point in the stream Right
In the beginning Uh TCP could just uh back in the early days of ARPANET our sequence numbers could just start from zero Today however They don't Initially when we start the connection we actually start it with a random number So we have a 32bit random number which is our initial sequence number Why do you think that might be? Security Otherwise somebody could send some data to whoever we're talking to And if they chose the sequence number correctly They could insert some data into our stream By making it harder to guess what sequence number we're on we can make our approach a little bit more robust So it uh it's random Now with each packet we send There's various flags we can set This is not a networking class So we're not going to go into detail with what these mean But we will mention this That packets can be labelled with these little flags And the first packet you send has this little label that says the SYN-ful packet  And the receiver, the server, says THANK you! I acknowledge your SYN-ful ness. Yes Right so imagine you had a jigsaw puzzle A 1 dimensional jigsaw puzzle Much easier than a 2 dimensional jigsaw puzzle And each piece arrives with a sequence number This makes it really easy to put together That's the purpose of the sequence number if they arrive out of order, if you have any missing pieces You actually know where to put it inside your data stream You might get - a quick question It'll lap around Oh yes You couldn't send more than 4gb in a packet Yes the sequence number actually represents the data It's not just a count of the packets It represents the contents, it represents the data stream And what the bytes that you've put inside the packet where they should be fitted into inside the stream Right so you might have a packet that says OKAY I'm sequence 10 here's my data blah blah blah And there's another packet that might before or after that says I'm sequence number 20 and here's my data blah blah blah And the operating system says thank you very much I can see that the data stream that I should give back to my process should have the blue data first and the black data after  it So I might be able to reassemble the data back into a stream of data to send to the program No there's no limit Talk to me afterwards These numbers can lap around This is just a long stream And uh data was arriving from here in packets And the user is calling read so we're giving the data as the user process wants it But these numbers can just wrap around modulo 4gb Alright so So this is the connection handshake That we see between the server and the client So the client says HEY I want to connect to you And here's my SYN-ful number My sequence number The server says okay I've ignored your sequence number Here's mine So this is the client saying hello This is the server saying hello back And this is the client says I acknowledge your sequence number as well With that third packet we can also include some data So we'll see that again in the future And you see these diagrams in network classes where the client tells the server The server responds And the client responds again So we have this three way handshake But this takes time  They're governed by the speed of light*? They're governed by the hardware They're governed by the routers in the way YES Quick question Okay so The server and client nomenclature, those words, are really only important for the initiation of the connection After that both sides can play Both sides have sequence numbers Both sides send acknowledgement packets Both sides control congestion Etc etc etc There is no longer a kind of master slave relation Both have equal footing So we'll finish with this that So one thing we'll try to prevent again is something called a SYN flood Which is an attack on TCP Where we try to send a server a whole load of packets with these synchronization messages Initiation messages We walk up and say HEY I'm SYN-ful here's my number And the server replies back and is now waiting for the response So it's very cheap to send these You can just fire a packet Whereas the server now has to set up a connection And it's like okay I'm waiting for the handshake So it's an attempt to do a denial of service on a server And with that we're out of time So thank you very much And I'll see you friday
alright good afternoon everybody and welcome to friday yay so here we go heres what were going to do today is were going to talk about file systems and how files are represented but I also wanted to let you know about a cool new project that we're getting started and I'd like you to be part of it so I apologize for the spam but here's why I think its really cool wouldn't it be nice if you could go back to a lecture and say uh yeah uhh what was he saying when he talked about this term or that term which lecture was it in when the instructor or lecturer mentioned x y z so thats the idea is so can we transcribe lectures recorded lectures and then make subtitles? for people with strong english accents like myself? and for searching as well so for example remember those 241 videos that I made for the beginning of the course? supposed you wanted to find all the lectures where I mentioned printf() so we can kind of google search it and in real time find it oh yeah thats the one I wanted and you click on this and  my machine seems to be a bit slow today probably because its friday and off it goes and uh we can review the concepts so we've done that now for those mini videos and now I want to do that for 241 content and then we're going to take over the world the plan is to make it successful in this course and then say to the college why don't we do this for other courses as well inside the collge I'm already trying to make ways to prepare the lectures to say hey you know your course is recorded hey you could do so much more. lets make it successful inside 241 first so heres the plan we take a one hour video and we divide it into chunks short say 7 minute chunks and then you just take a short amount of time to type it in there is a second pass where you take those phrases someone else has done and you make sure they're lined up to the right part of the video its very easy work and we think it might might actually improve your grade because you're spending time on tasks because you're actually reviewing the content so thats the idea thats the promise lets see if it happens so please consider signing up and to help uh feel good about doing this um myself and another professor from Beckman we're going to throw in 50 dollars of our own cash each time so we have 100 dollars each time and we'll have a little lottery for each person for the people who are actually helping to do this so there's a small chance reward maybe you should use the 100 dollars to buy more lottery tickets and upscale it onto a million we'll see right so anyway thats that and i'm afraid those rewards are only available to cs 241 students at this time okay so thats class transcribe lets make this big lets make it big enough that we can crowdsource this and make it so that it actually even works for other universities as well okay right so back to today's content oops I had an overhead right class here's what were going to do I'm going to ask you now with a neighbor or imaginary friend of your choice to come up with some design goals for what you would like to see in a file system so you won't be the first person to invent their own file system. its been done done by times before but what are your criteria? what would you like to put inside your file system? supposed we said oh your senior project is to make new filesystem how should we measure it? what are the high level designs don't give me implementation details like oh I want to hash everything. I want to cache it. No. Give me some high level things What are your kind of selling points What are your requirements for what makes a good file system so take 5 to 10 minutes with a neighbor or imaginary friend and write down some of those criteria [people writing down the criteria] okay [someone talking in background] ok so lets make a list! what ideas it says pick  no lets not pick lets have some volunteers what ideas what are our design goals then shoot give me one yes you want it hiearchical  you just want me try to spell that word. ok alright so we want it hierarchical, what else? [someone talking] ok. we efficiently use our storage space so we might need to keep a map of which areas we're using and which areas we're not using ok what else
ok what about security  you want it so that uh not everyone that has access to the storage system can just leisurely access all files  we want to have some kind of access control  ok  what else you want metadata okay  what do you mean by meta data  ok so metadata like when was it uhh when was it last modified or its size  okay  what else ok what are we allowed to do with the file  are we allowed to read it  write it  execute it? eat it? the new edible file system  what else? yes okay you want to be able to do efficient searches  so that if i have a certain text file or video file umm it'd be nice if it just did my transcriptions automatically right? so find all the video files where printf() is mentioned  what else? yes  support things llike symbolic links  you said  symbolically  what you mean by that?  so you want files pointing to other files  the file you wanted is not found but don't worry  just keep following go over there have a look other there  it says haha you look over there  right  yes we want to be able to somehow symbolically say this file exists exists  perhaps in two place sat the same time  okay  right  lets uh have a look at uh some of the other things that we've got down here  right so  there are some other things that we didn't talk about like umm  you might also want versioning i want to get back in time  you know my users just accidentally deleted everything  oops  what do we say  well we get out and say you get a new job or we could say dont worry my file system supports uhh some sort of history and i can actually get back old files  maybe i want to kind of support some kind of backup  i want to be able to keep my filesystem actually running actually continue to use it as i continue to take a copy of it offsite umm and i want to be able to do that efficiently  encryption  so this is similar to uhh access control but you can imagine what would happen if someone got hold of your flash drive right now or your usb key right now  could they read the files off it? yeah  okay you can say to that little flash drive  okay give me all the bytes in disk block 0  disk block 1 disk block 2  ha  and you probably could read most of the data  even if we had set up the data to have access control  if we can actually directly access the bytes  if its not encrypted, we can read the actual data  so we might want encryption as a native part of this  what about compression? maybe our filesystem should automatically try to compress data  so that it can efficiently use our space  you can imagine for example with text that you uhh could do a great better job of compressing test so that it occupies a smaller amount of storage space  because we want great performance so that might affect how we organize our disk our contents on the disk  we probably want our disk blocks of the same file to be pretty close to each other  we want to be able to read and write and create new files as fast as possible  and some areas you might see is deduplication  so if you and i are storing the same files why should we be using multiple disk blocks? multiple storage space? perhaps we should do something clever behind the scenes and say oh actually uhh these files look exactly the same  at least for these parts of it  so we reuse this disk block but don't tell the user  we'll do this kind of behind the scenes  we'll make it a native part of the file system  alright so the things I've mentioned here are some of the advanced features that most filesystems don't support  for example deduplication sounds great, but very few file systems support it  heres something we didn't talk about  why? because probably you're cs majors you're not uhh ece people  we just assume that the hardware kind of works 99 point 99% of the time right  ha ha ha ha ha   not good enough right  we need to be able to assume things go wrong and we don't want to suddenly our entire filesystem  hey you know that thesis you worked on  no even better hey you know everyone's thesis that uhh ok  so theres a story about a another department  im not going to say which university it is in  that didn't keep backups running  they thought they were running  they weren't running  and uhh  when they want to use the backup  they discovered all the files were 5 years old so we want to make sure our file systems are as robust as possible and can cope with failures and tell us hopefully in advance when the hardware is failing  ok  so these are big design goals and actually creating a file system is difficult  and uhh we are not going to make file systems in 241 however we're going to look at uhh simple linux file system called ex2 which is the predecessor for  ex3 and more recently ex4   oh thats exciting isnt it  so we're going to look at some of the early features of ex2 to see how it represents files on a disk  before we do that  let's step outside of our high level features and actually look at how we can actually talk about files  well here's uh one idea im sure you probably already know is I give a filename like hello.txt thats relative to the current directory of my process  i can uhh specify an absolute path by starting my path with a forward slash here  so for example i could do /home/angrave/hello.txt and now i've fully qualified it  so it doesn't matter what the current directory is
i can write relative paths using the following uh uh special directory names  what does single dot mean? means the current directory  so what does two dots mean? the parent directory  go up one  go up to the previous directory  what about three dots  nah that doesn't mean anything  I just put that in there as a joke  alright don't do 3 dots  you could probably actually make a file with those 3 dots if you wanted and really confuse people  ok so yes  we can talk about relative directories  so for example if you wanted to go up three directories you could write  .... / .. / and then we could keep going and so we could do  ./ that doesnt do anything that just says ok stay inside the same directory and then go up to another into current directory x then go into directory y then go back out so now were back inside directory x etc etc so you could come up with these convoluted paths and its up to the operating system to follow the money if you like  to follow these to identify which directory you actually wanted to end up in  ok  so we've talked about relative paths  we've got an example of a relative path  perhaps you could simplify this one ok so what does this say? you start from the current directory  go into a  go into b  go up one  ok so we've left b we're back into a  now go into c  now go into the same directory  so the directory that we are currently in is just a c  and you could put an ending slash on the back if you wanted to or not questions? yes! haha okay so why is it that we do  ./a.out? and the answer is because of your path environment variable  so you've been writing code  we've written code with exec() and theres a version of exec thats got a p on it that says look for the filename on the following path so if you were to write hey run a file called a.out  it would look in all the directories specified in the path for something for a.out and guess what your current directory is not on that list  probably for security reasons  it is unusual to just run some artitrary file on the current directory  you could change your path so the current directory is on there  you could say okay my path is now $path and heres another directory the $path is just a string right  and so if i did that i wouldn't need to the dot forward to run something out of my current directory  questions?  okay  so heres what we're going to do  we're going to take our secondary storage  our disk  whether its a flash disk  and we're going to conceptually think of it in terms of blocks  and so the lowest level i can say to my my hardware  hey get me block #7 get me block #8 and a little white later, the contents of that will appear in some memory that I've requested it in so why do you think we make these the same size as our memory pages?  why is not not an arbitrary values like 1300 bytes or something? yes okay lets go back to thinking about virtual memory for a moment  what did we want to do with virtual memory when our memory is uhh when our memory is being used by alot of processes and we need more space  what do we do? we take a page of memory and copy it out to the disk  when we want to load our programs in  we're loading them in at a page at a time into memory  so most of our operations to disk are page based and we and so our disk blocks are are they are the amount that we move to and from disk is always going to be some multiple of our memory pages  so yeah we'll look at it today in terms of making them exactly the same size  right  so some of the calculations we've done for virtual memory are very similar to what we will see when we look at the file system  right so we talked about some of our high level ideas for a file system  what about then our files  what would we want to store for each file  we had some meta information such as uh the length of the file  uhh when it was last modified what else would you like to see  what other information should we store for each file? ok  take a couple of minutes to write down a list so we got one of modified we have some other timings as well  I had a few things like  when it was created  ok  what else? ok a file type
okay what else? ok so read, write, execute in other words what kind of access you can do  can you read it write it execute it  eat it smell it sniff it? yeah  who owns it  ok  what else? yes  ok who modified it last  what else? last opened? ok  when last opened  might be useful say for backing up things  or optimizing where things are on the disk  what else? hm? path ok ok  yes  hahah yes name  yeah would you like file #7 or file #8  i don't know which one is which  ok anything else  yes  ok whether its kind of binary or text  alright anything else  ok version  alright i'll add one more which is um where  how to get the actual contents  we probably want the contents of the time  we didn't actually talk about it  we talked about all this great meta information  we didn't talk about the fact that yeah all that has some contents as well  so we probably need to store exactly how to go do the disk  which disk blocks being used to actually hold the contents of the file  it'd be a pretty silly file system if we couldn't actually store any content with it right so actually what we've described here is this basic idea of an information node or an inode that we'll find again and again in various kinds of file systems  so we've described alot of meta information uhh for real inodes, let me mention some things that don't exist  there isn't a path  we just have um fact we don't have name either  uhh the other thing we don't have is um lets see  who modified it  the other thing we don't have is file type but we do have things like the left when was it last modified  there's an owner  and we can find all these things inside a basic inode  so im going to today talk about one of the simplest permission models and it's this  each file has an owner or user, a group, and then we can then just talk about the general public  everybody else  whether they're allowed to touch this file or use this file in some way and for each of these three different kinds of people that might want to use our file  there are just three permissions  read write execute  read write execute read write execute unfortunately there is no edible bit perhaps for next years april fools you'd like to write your own filesystem that is edible  so we can basically say if you're the owner of the file  if you're the user owns the file  you can read it you can write it you can execute it  if you happen to be inside this if the user trying to access this file is the member of the group that owns this file then again we can specify some permissions everybody else gets these permissions  so here is a surprising potential gotcha  in C guess what happens if you start your number literals  your integer literals with the number 0  you're speaking octal  so if you were to write int a = 0123 congratulations you just managed to confuse a java programmer  this is not 123  each one of these digits represents three bits so this is exactly what we need if we want to talk about our user group and other permissions  because we can encode three bits into this number and easily read it off as well  so this is 001  this is 010  and this one is 011  so I can easily read off what is going to be the user group and everyone else in terms of their permissions  we'll talk more about that on monday  no wednesday my apologies ok  right i'll mention though  some useful calls here  we're going to run into chmod to change the uh permission bits on a file  and there is a call you can make inside c and theres a call you can make inside the shell there's chown  if you want to change the owner  you already know mkdir for making a directory  perhaps you didn't know mkdir -p which is useful which makes all of the parent subdirectories if they don't exist  so for example I can say a/b/c and rather that complaining that a and b don't exist  it will make a and b if they don't exist  here's some other little tricks that you don't know  if you just write cd to change directory it goes back to your home directory  this is in the shell  also in the shell   tilde i uh once had a book that referred to this symbol as a corgi as in a small little dog excrement
and im now forever cursed by looking at that and thinking that way so i'm happy today to share this curse  so this tilde means also home directory  it won't inside of c programs  its just a function of the shell program  such as bash  so if you are somewhere else and you quickly want to refer to a file inside the home directory you can do ~/hello and my favorite little trick is cd - which means go back to the previous directory that I was in  so if i wanted to swap quickly between two directories I could do cd -  and finally theres push directory and pop directory  which allows me to say remember the current directory im in and later go back to it  so theres just some little kind of unix helpful things to do  with that lets have a look at page 2  so here is how we can lay out the information we want to store inside our secondary storage  we'll have our meta information stored inside these inodes and we'll just put all of the inodes together  we'll talk more about that term next week  and then we've got some remaining space  so when we first format this disk  we're actually going to say we assume I have never need any more that I have a maximum number of inodes so we just have a fixed size table here  and then I've got the bulk of the remaining space  and I'm going to split this up into the disk blocks  and then later when I want to get my data  I will actually say ok give me disk block 0 give me disk block 1 etc and so on so today. what we're going to do is look at how we can actually store the contents of a file using this classic inode structure. here's the game we want to be able to store very small files efficiently and be able to access them very quickly disk access is slow on a spinning disk you have to wait a long time for the disk head to move to the right head and for the disk to spin around before you can get um the data its actually an easy calculation if you know the disk rotation speed like 5500 rpm or 7000 rpm you can figure out how many miliseconds before it's done one revolution and moved to the right spot but its the order of 10s of miliseconds so we want to do minimizing of disk accesses for small files. so what we want to do for very small files is inside the inode we'll just store the disk block numbers for some direct blocks right so the beginning of our file will be inside block 7 or block 8  uh block 9 is actually already being used so we want to go to block 22 and so on and so on and so on so if i want to read a file  I'm going to have to read the inode which I might already have inside memory and we're going directly to these block and request the trouble is our inodes are of fixed size we just put them all together in this little array here so our scheme is only going to work for a small number of direct blocks. and typically this number is about 10 so we have 10 of these the advantage of course  is that for small files it's very very quick to know which disk blocks I need here's what happens next we'll take one of our standard regular blocks and we'll use it not to store any data in but just to store  some numbers the numbers of where to go next so go to block # 4 go to block #199 go to block # 233 etc etc etc so we better figure out how many entries we can put inside one of these disk blocks so also two pieces of information we need here size of our disk block and size of each pointer ok so lets write one out lets suppose our disk is using 64bit addressing so we can have alot of disk blocks how many bytes is this? 8 also known as 2^3 and let's say that each block is  4kb what's that in 2^n notation? uhh ok well everyone knows that 2^8 is 256 2^10 is 1024 so 4k is 4 times that so its 2^12 so if you have got 2^12 bytes and each entry takes 2^3 bytes my back of the envelope calculation tells me  that 2^12/ 2^3 = 2^9 oops there we go I can store 2^9 entries ok whats what. what number is 2^9 512! so I can have 512 of these blocks  so if that was the end of our addressing scheme. we can actually work out whats the largest file that we could store right so forget this stuff for a moment how big of a file could we have well we have got 512 data blocks here plus another 10 here so if that was everything I could have 522 times each block was 4kb and that would tell me then how much space my largest file could be so what do we do when our file is bigger than that? ok so the famous quote by wheeler every problem in computer science can be solved by another level of indirection so if you've got a problem dont worry just wrap it around we'll fix it by encasing the problem with  with another solution this was done on the DCL building have you ever walked through the dcl and notice there are outside windows on the inside that's because we have glued the building and rather than building a new building we just put the building inside a bigger building so next time you walk through dcl you'll notice ahh thats why there are window panes there so  here's our plan then is that for even bigger files well have a lookup table of lookup tables wait a moment this was just like like virtual memory yes? where we had a multi level table and the key thing here is that for medium files more of these need to exist we can grow this as needed
right so  now it's time for you to play i've got a few little questions here I've changed it so that um now we only need uh we're going to have this many number of blocks so 4 billion disk blocks okay so how many bytes is that? for each pointer? 4 bytes! also known as 2^2 alright the reason i'm using exponential notation is because division just becomes subtraction. right so i'm going to need 4 bytes for each entry. and so for  these disk blocks you can now calculate how many entries I can actually hide inside each disk block it's just going to be 2^12 / 2^2 also known as 2^10 so I have 2^10 entries inside each disk block right so that in mind have a go at answering these questions for the last question you can leave your answer in an equation form or an expression don't need to actually do the math a question about one quick line of reasoning here which is if i've got that many disk blocks 4 billion disk blocks then I need 32 bits to be able to talk about any particular disk blocks to be able to represent 2^32 possible entries and so If I've got 32 bits then that means I've got 4 bytes per pointer okay for question 2. if the  index is half full that means I don't have 1024  I've just got 512 entries inside here or 2^9 and I've got 512 valid entries then that uh reference actual disk blocks so how big is my file? you might want to want 512 and that would be the wrong answer why? thank you yes! theres another 10 here so i've got not 512 but 512+10 I've got 522 disk blocks and If i multiply that by 4kb I could tell you how big a file was what about actual total number of blocks used? it is not 522 it's why? we're using 1 extra disk block here for the index ah ok now the trickier one here is what about a triple? so we've seen it for indirect double indirect theres one more level of indirection where we can go for triple indirection which is an index of index of indices wow before we actually get to the actual datablock so how big does our file need to be before we need to go to triple indirection? well that means that we've got everything filled out we've got all of our indirect blocks we've got all of these double indirect blocks so we've got to figure out how many blocks we have in this table well we've only calculated each of these little indices can have 1024 pointers so this has got 1024 this has 1024 etc right and how many of these do we have? well we have 1024 entries  in here questions? obvious? so now I can figure out how big my file is i've got  10 direct blocks. i've got  1024 indirect blocks and 1024 double indirect blocks and if i was to add all of those together it would tell me the largest possible file I could have before i needed an indirect block right so some comments on this filesystem is that as your file gets larger it takes longer to actually get to the disk blocks that you want yes? so as  for very short files we can read these directly for longer files we need to start actually reading our tables into ram as well so we can actually follow them so there is a cost of having large files using this system
alright i will mention one other thing today yesterday for fun I wrote a scheduler at least a house computer mumbles here we go and I put this in subversion and it actually tries to solve those little scheduling problems that we have so um you can download it  you can play with it um and you can see we've got like the logic for say  um round robin which just goes round and finds the first process that is runnable and stops if there is none shortest job first that looks for the job with the shortest execution time and priority jobs where they have the highest priority for example it just prints out a little schedule for that so feel free to download my code and have a play with it with that have a wonderful weekend and I'll see you monday for the next lecture quiz thank you very much come down to see me if you have any questions
Alright. Good afternoon class. Where are you? There we go. Alright. Hi So uh last night I had some fun uh making this uh camera preview. Uh. Normally when you set up a camera preview in android uh  For speed, you don't get to see the bytes. You don't see the actual pixels. Here's why. Memory is really really slow and when you start looking images typically you're talking about uh a million bytes or more Uh and uh uhhhhhh working with that in in Java and copying it from buffer to buffer  is going to make any kind of preview mode very very slow Um just as an example, uh a typically CPU these days can execute about 215 instructions per Sorry 250 per instructions per main memory access Versus say level 1 where it can do about 4 instructions per main uh per level 1 cache access Right so um I didn't want that thought I actually to get the bytes from the preview  and uh finally I finally got it working last night. So we'll be playing with this in uh section uh tomorrow. Uh Theeeeeeee plan, We'll see if I get it working and then if I can't then it's your turn Is to uh make a webserver that's part of this app So that the webserver actually is uhhh got a back end interface into an application This isn't quite as crazy as it sounds. In fact, many of programs now uh have an in built webserver so that you can interrogate  uhhh the current state of the program so for example if you're developing a game, You might consider a webserver as an alternative way in into the kinda back end of your your game engine so you could look at stats that the program is running you could change things as so as the program is running you could even build a complete a small interpreter so you could say quickly set where the uhhh where the players are or load a particular state file so that kind of thing I've seen it done with uh gas chromachaffs as well where there's a main screen and then there's a behind the scenes webserver which you can connect to  if you know the port and maybe a password Uh so again you can check the status of the engine or the program as it's running So as planned is can we make a webserver that is part of this camera preview and then we'll use it to actually share The image Alright so. We'll make our bit of kind of spyware so that anyone that knows the port number can actually look at the uh the current preview that's going on. right So that's what we're going to make. Ummm Now today, we're gonna talk about uhh files andd uhhh this kinda one really really really big idea and it's gonna this kind of misconception I want to clear up today that a file name is NOT a file and it's an easy trap that we get called into because we think like that all day long we think, open this file and here's the name Right If you could walk out of this lecture Not believing that anymore, then, you made significant progress Instead what I want you to think of isss that a file is an i node That, a file is just the bytes, just the content Forget for a moment that it has a name Forget that it lives inside a directory Forget that it lives inside a hierarchy That's all icing the cake, which we're gonna do seperately from the actual file Right. So how do we think of files? Think of them as just a particular inode and remember this is how we're going to organize our space on the disk Where we initially format it, uhh we'll have a super block SUPER BLOCK But the super block is just a managed information about how we've actually organized this data And in fact on real disks, disk information is so critical to be able to get anything done It's actually replicated several times throughout the disk  Just in case uh we get um a cosmic ray or some other effect which obliterates this particular copy But anyways super block tells us, how many say inodes we've got and and where the very first data block block starts Right. So. If we're using an inode. That means we've stored a file on our disk And remember we looked at last time that each inode might have some Direct entries HEY here's the content and we'll have say about ten of those But if we want to store larger files, Then the game we play is we store a reference a data block that is not actually used for data It's used just to hold pointers to actually data blocks And if we have a larger file, we play this game twice we have now, a reference to a data block That it to itself contains pointers to yet more tables of pointers And then finally huge file,  Then we play this game three times, thriple indirection block and that's it, we don't play after that. Right? We don't try to. We don't have quad indirection blocks Right so that's our contents of our inodes and you remember that inodes have more than just these pointers,  they have a little bit of information as well, a little meta information like the file size ummm, ahhh who owns the file. And as we'll see in a little bit Guess what? you could basically, from C, Discover what's in the inode. And uh. Including the inode number, And remember we talked about some of these things like, Who saw it, when was it last accessed, when was it last modified? When it last changed? And Total number of bytes
Ok so, let's get back up here We said that uh, we don't care about file names The inode is the file Is the big idea. Okay Okay right That's the big idea, great!  So what we're going to do to all going to talk about it after the rest of the lecture Okay so we've got a problem then, if that's the big idea, how are we going organize things into directories How are we actually going to give things names if we're saying their names is not actually part of the file Well, all we're going to say then is the name is actually part of a directory listing. So, a directory then will have A listing, and the listing will be A name And An inode number A name, and an inode number. etc etc etc etc In fact, we can think of a directory as just a file We'll bless it, we'll set a particular binding flag to say this isn't actually a user file, it's actually part of the file system And uh we'll need to read the contents and expect the bytes to mean the following The name followed by an inode number. The name followed by an inode number So that's all the a directory listing is Name followed by inode number And these, inodes then might correspond to one of our files but it might correspond to another subdirectory. Right so here's the big ideas we've had so far right Files don't have names. Directories have, a little map from a name to an inode number. And directories themselves are just files. They have data. What is it a data? This little mapping. So they'll have a data block with this kind of mapping. The good news is that we don't actually need to read these bytes. We've got some posix calls which we'll see in a moment Which actually interprets these bytes for us But what we'll be doing is opening these these directories just using a regular file descriptor And then we could call this posix call to actually weed out um the  the data as if its uh a certain ballistics Right Questions so far? Yesssss Yes so, every directory is gonna have two  special entries which um doesn't uhh the first one dot dot which is the um what parent directory, yes, how do you get out of here. I wanna go back up. right Anddd also, we don't need to store this one directly but we'll come across it in a little bit Ummm In current directory dot So we don't necessarily need to keep that inside the uh inside the the data but mainly the posix core will always see it. It's like uh Yes I can talk about myself So, each directory knows about itself and it knows about  uh it's it's parent. A directory can only have one parent so we're talking about a tree Other questions? Okie dokie. Then let's Okay Alright so let's um Let's uhhh put some contents into a file Okay, my text Hellooooo I am a cat Alright And ctrl D to save. finished Great so normally we do kind of ls to see what's in here um Ok Umm But I can do more than that, I can say give me the inode numbers Here we go Uhh in fact, one of the options for ls is just to say give me it on one per line So now, yeah, I can, you can believe hopefully that every file Really is just an inode number, so if you're talking about a directory name or file name you're not, you're actually that's just gonna be converted into an inode number If i wanted to make another directory so hey I'm a subdir That subdirectory has what? a unique inode number So one way to tell whether you're truly are talking about the same file. you and me is to see if we are uh talking about the same inode number on a particular file system Alright so I lost my I seem to lost the projector, okay alright
So how can we find that the inode if you're the command line, you could just uh pass in uh on the side, ls or from code  uh we've got the following calls, we can ask for a stat, give the status of this file and uh there's two useful variations one is you supply a path,  so for example, I could say  stat on my file demo.c and pass in a pointer to my struct another is I pass in a file descriptor Now if you're going to start reading things from uh the buffer that's set make sure that you check the return value right? so you want to check the uh the result is 0 otherwise its succesful if it's non-zero then that's  that uh C structure uh was never touched and you'll just read garbage or old values so it's a common programming gotcha. just assume that stat just worked  and then try to pull out um uh values and information from that stat where its in fact, stat says huh I don't know file or you don't have permission for that file or hey, it's nice day outside I don't I'll bother to do any work today Um that's not actually a posix error The uh Right so so check the return value of stat Now I mentioned before you can do fdopen and uh fdopen allows you to go from a file descriptor at the posix level up to uh uh a C file pointer complete with buffering and using printf and all that good stuff You can actually go the other way There's uh function called fileno which allows you to extract theeee file descriptor out of C as well Right so we can fill this in And there's one other call call here lstat So there's one thing we haven't talked about yet which is symbolic links we're gonna play with these in bit. we're just gonna mentioned them today was gonna say okay this exists and as a symbolic link is a file that pretends it doesn't exist instead it says HAH I don't exist, what you're actually looking for is over here somewhere and it gives you a redirection so just like you might move house and could set up your mail forwarding that's what a symbolic link can do so, uh you can say, Oh actually the contents that you really want uh read or write are not  here, they're stored in some other directory if you want to be evil you could set the symbolic link to point to another symbolic link which  can point back to the first symbolic link Muahahhahaah at which point your machine catches fire No you won't have been the first person to think of this and your program wont have been the first program to do this so instead the operating says  hold on a moment, I've been following these these symbolic links too many times i'm gonna quit trying to follow them and will give up after a preset number of times But anyway, uh the lstat exists if you actually want information about the symbolic link itself, rather than trying to follow it If you call lstat on a regular file that's fine it'll just be the just be that equilvalent of calling um stat so lstat is useful if you are really interested in the symbolic link itself like who created the symbolic linke, who do I need to blame for this mess right? or when was it created? That's pretty unusual, most of the time we actually want to follow those links right? what most of the time we we just want to imagine that uh these aliases are automatic Right any questions so far? Okay so let's get a have a share of a look to see all the stuff we can kinda discover about the file First files themselves lives on a device yeah we know they have an id number and they have this  security access as simple protection where we can talk about who can do what so we're going to see more of this in the moment but this is the idea about who can read it, who can write it, and who can execute it they also have an owner and this we've got a user and a group I'm not gonna talk about groups much in CS241, just know that they exist Um if you get into linux administration, maybe it's it's useful if you have a lot of kind of team members working inside the same directory um but we're not going to play with them let's just let's just uh umm restrain our attention to users today okay And then the um total number of  locks, in actually uh these happen to be in in multiples of 512 just for historical reasons uhh and so that tells us, for example, whether the uh the 8th direct block entry is valid or not, or we should be using the indirect block as well etc etc so we from the number of blocks for example if that uhhh if that was a sufficiently small enough figure,  you'd know that there wouldn't be any triply indirect blocks or double indirect blocks etc etc etc Right so now I can write code to say, find me all the files which uhhhhhh have been created today or have been created by a certain user Most uh users are actually integers And so the file system doesn't keep a record of user names if you want, you can turn an integer back into a known user name you're gonna have to ask the operating system to do that so at the file system level, we just distinguish different users by different integer numbers
So I said that, hey we'd like to look at different files and maybe call stat on them Um, here's some starting code that maybe we can actually start to find different Look at, look at actually entries within a uh Entries inside the directory So here's the format of reading directories, we say okay I wanna open a particular directory And we're giving it dots. So what does dot mean? Current directory. Yes! So it depends on my process Where whatever the current directories of my my process. I could put it in an absolute directory here for example This opens a file descriptor So one way this could fail would be if you already got too many file descriptors open But it wraps it inside this DIR because we don't care about the actually bytes stored inside this magic file called a directory, we wanna pass it in terms of um uh uh uh the the names for example stored inside and the inode numbers possibly So that's what this uh readdir call does It updates an internal state inside this structure  and uh we can keep calling it and it will iterate all of those entries returning one at a time And then we could extract the name, maybe we care about trying to find a particular name So if strcmp returns 0, great we've got an exact match uh we could say yes we've found it Eventually readdir says okay I give up.  I um the the there's no more entries in which case it returns null So this is fairly kinda idiomatic C code  Where you not only  assign the result of a call to a variable you also uhh check it for something Like whether it's non-zero or not So eventually our while loop finishes we close the file descriptor and free any other internal resources perhaps we've malloced some memory inside there to hold the names and we return 0 saying we didn't find it okay so what's wrong with that code? Don't tell me. Explain it to your neighbor Or take a good guess Okay so here's the code no errors found I'm gonna use it to try to find some file uh each time my little while loop, i'm going to print out the name i found Just run it okay Yay great! It actually all of the entries and remember how we said that we actually dot and dot dot yes, there they are, they're the first two entries  that we actually will see when we  iterate through the contents of my directory so i could start making this into a more useful program, I could start finding things uh for example, uh instead of just dot, i could actually make use of uhh the uhhm main. alright this could be for example uh argv(1) For now i've got a program that's a bit like DIR it's starting to look for things inside a certain directory okay right, so what's the error in this code? Yessss. Thank you, if you find what you're looking for you don't close the file descriptor Aight, the reason why this  I've bring this up because cause it's a really common error and it's really evil one to debug because when is it gonna you that it's gone wrong? somewhere else right? somewhere other time where you actually try to open a file descriptor when you try to open some you know simple file that exists and it's absolutely no reason why it can't open this file and yet your program fails in some bizzare way and its midnight and you've been staring at this for two hours and you wondered, why why did you learn to read?  you know life would've been so much simpler if you could kinda stayed in the yeah stayed outside and ran around and played or something right, so yeah watch out for this. and it's a very common error to forget about frame resources why blame only yourself but blame C C doesn't give us any support to actually uh remember to close resources hardware resources that we've opened and in fact your often find that's true for other languages as well even  with C++, uh we've actually got  to somehow remember to explicitly free those external resources and in this case it's remembering to call closedir So how can we closedir? Well one way is to make sure all possible code paths actually free the resource another thing that  we should probably do with our code if this is actually if we are being paid to write robust code is check the return value and being prepared to print out the actual error so if we actually written good code then our failure might have logged the fact that there were no more free file decriptors for us to use and that would've a strong hint that we were leaking resources
Um by the way A um Some people in the world of C actually use goto right? In this kind of uh Uh this kind of scenario so  we can have a kind of goto cleanup and we have a kinda cleanup right Uh and then yeah we fixed return values as well so Instead of this return here we set a flag or something Okay um whether you do this or not is a fantastic way to get into arguments with everybody Uh there's a lot to be read about how goto is bad but in practice you will find a system level code that does this as a way to to support kind of basic Um exception, exception handling And uh failure cleanup code. Uh where you want to leave early It's not the only other way to do it, the other way is to to actually set create your resources inside a wrapper method and uh uh then, uh you can return early inside your inner method Okay so let's let's let's pretend we didn't talk about goto There we go And fix our code Right, so close uh our directory pointer Right uh Next lecture we'll talk about how to extend this so that we can do uh Directory searching into subdirectories as well Right any questions about this? Alright there are mentioned one gotcha which is remember that you have the parent and your current directory so attempting to do subdirectory searching is like OH I know breadth first search or I know know recursive search! Be careful you don't keep searching yourself forever. Aight Oh be careful you don't keep searching down and up the tree forever your searches are going to take a long time if you go down the tree and back up the tree at the same Uh all is part of your recursive code so you have to remember those special cases remember you're going to see dot and remember you're going to see dot dot Right okay time for side 2 Okay I love this word canonical right it's What's a canonical definition of canonical Can you give me? Two directory paths that refer to the same file? Other words could you write down a string that actually reends referring to the same file but actually when you look at them they're different You're nodding your head how would you do that? Okay Okay, that's a good idea. Okay so, for example, slash home slash angrave slash um Uh one dot text might be the same as just Hey current directory" slash one dot text Okay give me another way that I could refer to these files? Yeah Well some kind of weird double echo race condition thing going on. kay Okay so go up one directory then go back into angrave And then go into one dot text again Okay any other way? Yup? Okay, tilda actually is is a cheat that's actually part of the shell So that so tilda is expanded already. Um how about? dot slash dot slash dot slash dot dot slash angrave slash some subdirectory then go back up turn left right etc right? we could invent these crazy paths which after we've followed them we finally get to the file, I also mentioned these things called symbolic links.  Maybe we follow a symbolic link so we go to the file yeah awesome dot text which actually resolves to our original file So how do I know that these files are actually referred to the same thing? The answer is we need to reduce them down to the canonical form and the beautiful thing about a canonical form is that if you have a canonical path and I have a canonical path and they are identical then they must refer to the same file Why? cause that's the definition of a canonical path So is uhh it's not necessary an absolute path. Not all absolute paths are canonical but you can be sure that if two canonical paths are identical, they are talking about the same file right how do I get the canonical path? Well you give me any path you want I'll call realpath on it it will follow that follow any sym links that you happen to refer to follow any dot dots etc etc etc and then finally it'll give me an actual path. I can use that and later I'll just free it You can pass in a buffer but in practice don't bother just let malloc make sure it gives you enough path enough space Now I mentioned this because actually we can use this for security suppose you were to make a web server you probably don't want a web server to be able to serve all possible files on your hard disk drive Cause if it can, you bet your dollar I'm going to be looking for slash etc slash password Aight. Or your ssh uh private key we'll try to download that And in fact, these kinds of tricks are used to escape the current directory or the root of the webserver and uh we want to try to prevent that so one way when you're checking directories is to convert it into a canonical path and then check that it actually truly starts with the based directory that you care about so for example the user is trying to get an image from your image directory  not trying to download your password file as an image I've encountered numerous server programs that don't do this check so for example, uh I can get a printer to include using uh postscript and other commands to include a local file from the printer and therefore print out the printer's own password and other information you want about the printer whoops So anyways so thats so real path next time we want to write a robust server, remember this it's useful security tool
Okay right Question for your neighbor and yourself Does the inode contain the filename? Choose now Hundred internet points if you get the correct answer Okay Right If you think the answer is  No, it's not part of the inode give yourself a pat on the back or or or or or shake hands with your neighbor alright? if you thought the answer was yes exits are this way and this way there are still majors look there are still majors looking for other people no it does not, remember okay? it does not the inode, the file does not know about it's own file name okay? that's the most important thing the most important point today we've got today okay and it allows us then to do  the following, i can have same file appear twice in my file system this seems impossible if you still think the file name is the file how can i get a file to appear twice? in two different places what do i need to do? yes I could yep hard link it. what's actually to my directory entries? Yes! thank you! remember my directory entries are just name inode number Somewhere over the mountain I've got two entries With a name1 that goes to a node1 and another one in another directory I've got a name to and it happens to point to the same inode number I've better singing otherwise anyway alright so thank you I just made that up okay Yeah so look here's one directory remember all the directory is just some data it all that data is just a name and an inode number inside another directory we've got  a different name somewhere but it happens to point to the same inode number My goodness! So if I go into these two directories try to actually open the file, I open up this file and you can talk about this file when you talk about inodes and I start reading the bytes I'm talking about the same file That means if I change the content of this file then that file in that other directory changes as well why? because it's the same beep file okay? This looks impossible if you're sitting at the command line and you know you got two shells open and you're actually changing the contents of one file  and you've got another one other here and you cd-ed to a different directory  Oh my goodness! this is crazy, no it's not just remember this, it's just an inode we've just got two different places that happen to refer to the same inode number okay how do I do that? I can use a hard link How do I do that? There's a command called ln So link allows me to make another entry to an existing file let's see if I can pull up the manpage a moment So you type this into a terminal and congratulations you've now got two files, two entries which point to the same inode so you could type say for example link hey here's my file slash home blah blah blah blah blah uh file1 this better exists so it can pull out the inode number of that file and then go somewhere else uh blhblahblahhblah file different name alright so for this magic to occur, we want to be able to know when those disk blocks become available  for resuse, that means an inode has to do this has to some reference counting in other words, how many directory entries  actually refer to this inode if i reduce that down to 0 I know nobody cares about me alright and we can resuse that inode and we reuse the disk blocks associated with the file so everytime you link, we're gonna increment the reference count,  everytime we link you add a hard link we implement the reference count now you might wonder, can i do this with directories as well right? could could my filenames here be directories and the answer is yes kind of no right so why yeah kind of no, here's why the operating system the repair tools all assume that directories are tree based structure if you are allowed to start messing with this hard links for directories you could violate that assumption you could set up a directory which has two paths you could set up a uh file system hierarchy which never ends right? you keep going into subdirectories and you come back round to the top somewhere and so all of the tools for following inodes wouldn't be to complete so in practice, filesystems typically prevent you from doing this right? even root cannot do this on most file systems the file systems C code says Hahaha no right nice try but no right so you can only do this with with regular files you can't do it with directories Right Questions? So what have we said? we just said that hard link is easy we just make a another entry inside a directory with a different name for the same inode and you can do it using this link tool, this link command
Right uh we got time to talk about provisions or the mode bits Here's some example ways of changing who can do what to a file you're going to see these numbers uh quite typically 644, 755 and they're written in octal and reading octal is really easy we just decode each digit into three binary bits right? four two and one and so instead reading four turn and one think read write execute so what's this? this is change the mode bits of this particular file sandwich into read and write for me or the owner of sandwhich, read for the group, read for everybody else so if you're not in the group you're not me, you get the read, so you get to see the contents of sandwhich but you cant modify and you can't execute it what's uh 755? what permissions do I get or what permissions does the owner of the file get? read write execute, four two and one. everybody else gets what? read and execute So that's a very common way of setting permissions, there are other ways to do it uh you can do it symbollically so this means hey subtract the write permission from all three uh types of users uh this means subtract read and exewcute permission from the uh owner or other I forget I'll look it up personally I prefer the octal numbers what's wrong with the file that has the following permission? let's suppose on the file system you found a file that was owned by root and had those permissions? what if you find what could you do to this? right what does 7 mean? read write and execute, so first of all here's a file that  anybody can execute anybody can run anybody can read it but also anybody can write it muahahhahaha so now you don't delete the file you changed the contents of the file and next time someone runs it they run the code that you put inside it so if you find a file like this, this is a security risk right so uh you could play with chmod um from the shell you can also use chown to change the owner so for example uh I could change the owner to user angrave on a file but of course I just can't change any old that will be a security risk so only um the  super user can just modify any arbitrary file so only root can can override a particular ownership like this and you could do this from code as well, so you can set the permission bits or the mode bits on on a particular path Alright there's two other bits inside of the mode integer that are useful, set group which I won't talk about. instead let's just finish the lecture with set user ID And uh   There's an example, have you heard of sudo? Right what does sudo do? Okay right, so supposed you have a command called, makemeasandwhich Which only root can execute sudo says okay change into the root user for a moment and run this command right so maybe you wanna format a disk which as a as a mere mortal in the system  you don't permissions to run this command because the command itself has say the following permissions  right makemeasandwhich might be owned by root and might be uh let's see we want it to be um executable by root and everybody can't even can't even read it right so if we could put sudo in front, sudo takes its arguments and runs it as root so on your virtual machines this is quite a useful command if you briefly want to become a root so how does sudo work? sudo has to have root permission to be able to do the things it wants to do like run things as root so the sudo command itself has this set user id bit set so that when it is executed it doesn't run as you as the calling uh user of the process uh it actually runs as a different user it actually runs as root so that's the purpose of this set-user-ID-on-execution bit it's you can change the effective user of the process once the process starts and the example of using that is sudo and uh if you wanna see sudo makemeasandwhich it's a popular xkcd comic right with that, have a wonderful week. I'll see you on friday and uh have fun in discussion section
alright, let's try that alright, good morning ladies and gentlemen minor technical difficulties this morning my laptop decided to freeze one second out of four never seen that before, guess it must be because we're trying to have a demo today right, so here's what we're going to do today I'm going to introduce you to one of the coolest things you can do in system programming and that is memory-mapped files so cast your mind back to when we said that we had virtual memory and our addresses are mapped to different parts of physical memory and this happens magically without our programs having to do anything well now we need to actually take control of that mechanism and we can ask for a file on disk to be mapped directly into our memory that's pretty cool if you think about it if you actually had, say, some structured data on memory, you could immediately jump to a certain area of the file and read it, without having to write read calls, fread calls, fc calls, that kind of stuff you can just say: Hey! I know where is is in memory I can just read that memory and the operating system will say Hah! I don't have those particular bytes actually on RAM yet, let me do it for you! Hold on a second we'll pause your process, and we'll pull in those bytes and we'll release you again so you can immediately see the contents of the file. The other cool thing we can do with this is if we mapped some memory using mmap and we then fork() we can now communicate between two processes directly, using some memory addresses so we'll play with that today if I can get my laptop to restart and play play correctly, okay alright so whilst that is  warming up. I've set it to gas mark 350div class=caption-track-final-caption ui-resizable" draggable="true" contenteditable="true" style="width:8832px">alright, let's try that<div class="ui-resizable-handle ui-resizable-e" style="z-index: 90;"></div></div>fwwar let me tell you about a couple of useful commands here one is dd so if you ever want to just copy some bytes from one place to another and you want to take control of exactly how many bytes to copy rather than, say, copying the whole file, dd is useful it will open one path and open a right path and you can say how many bytes to copy so, for example, the following copies some bytes from /dev/urandom to ~ (tilde) okay you and I know that ~ (tilde) means... the dog was here yes, that it means my home directory so I'm going to make a file called secret.txt" hopefully the NSA doesn't try to decrypt this file because, in fact, it's just random bytes (evil laughter) and how big should it be? well, I want each block size to be 1k and count of 1024 in other words my total file size will be a megabyte I could, if I wanted to overwrite my secret file start reading bytes from /dev/zero and again the file's going to be the samedfan and again, I'm going to make a file that is the same size equivalently, I could have set my block size to be 1 byte, and put in a million here or whatever  [gibberish] so we'll pretend I know that calculation there we go and that would've caused the same number of bytes but it wouldn't have been quite so efficient we would have made very small calls so it would have been a little bit slower I can also use the following file as a place to send my output /dev/null here's some wonderful things about storing things inside /dev/null : you can store as much as you want inside /dev/null but it ain't coming back so this is perfect place to store your your love letters from past girlfriends, dogs, cats, goldfish, whatever because no one will ever find them that you've got this perfect storage of course, it's infinitely compressable as well you can send as many bytes as you want to /dev/null, and it won't use any disk space why? it's not a real place in your disk it's not part of your disk's filesystem there's something special about this /dev you won't find it actually listed in your disk anywhere, oh good my machine has booted up, now we can actually play instead, it's a virtual filesystem hooray! okay good okay, right, so let's go into, what have I got so I want to find anything that talks about CS and ends in a '1' so that star is an example of globbing the filesystem doesn't do that; the shell does the shell says Okay, I'll try to find all matching things that match that pattern you could have done that for parshell for example anyway, so let's go into our demo two today
why did we not find it? oh because I want to go into... oh cd cs241 okay good, right, we're in the right place okay, so we talked about file globbing and uh, oh yes here's another little useful command let's have a look at, say the timestamp for mmap and you'll see I made it this morning at 10:46 yeah, I was busy just before lecture I can change that timestamp just by calling touch, so if I say touch, and here's the file oh I cannot touch it, why? who owns the file? root, right, and only root has read and write permissions okay, so, let's become root, alright, so I can do sudo, and that will give me root permissions I'm going to do sudo -s because I want to stay as root alright, then, let's touch that file and if we do that wait we've just updated the timestamp so why would that be useful with make? what does make use? the makefile, yes, and inside of the makefile you write rules and those rules depend upon the timestamps it compares the modified time of the executable, or the output of each rule and all of the sources so, if we've touched our input file, then we can force make to remake any executables or libraries that depend upon this file so useful, for example, if you've just changed your compiler options say if you wanted to add a debug flag, and rather than, say doing make clean or manually removing stuff just simply updating the timestamp is sufficient by the way, with make, you're not limited to just setting the timestamp at the current time you could even set it tomorrow, so you could say Hey, look, my homework wasn't done until tomorrow" or something so, you could actually modify the other timestamps but we won't play with that today but there's just a cute little useful tool sometimes to be able to modify the meta information about the file let me make a new file, okay, so here's a new empty file and this file only has the permissions of read and write for root let me check my umask that's actually a poor demo, because root is special I'm going to get out of being root let's make another one, touch empty okay so here's a better demo, root is a special case so when I make a file normally, I have read and write permissions and so does my group and everybody else does not have those permissions why is that? in part it's to do with my umask where the umask is one of the options that controls what permissions are taken away from a file so if I change my umask to be 777, I can subtract everything from those files let me make another file now, and look at that now we haven't got any permission to read this file at all or write it, or execute umask is a subtractive operation, it masks out some of the default bits that we would have otherwise set on the permissions of each file it's not the only thing that controls the default permissions of new files but it is part of your process so I'm playing with this inside of the shell but we could also do this inside of a C program aswell and so if you want to securely create a set of files where you don't want anyone to be able to, say, read them or you're going to create a lot of files then setting umask first is a good security operation you're subtracting the bits that you don't want set so in this case I said hey, take everything off, we don't want read or write or anything" if I had said umask, let's do 600 what have I done now? I've taken my own bits off 6, my read and write aren't there, m but I've let through the group and the world access rights so what's a typical umask? a typical umask is 022 that's a typical default value. What does that do? What does that subtract? remember we're thinking in octal, so each one of these values remember, is read write execute combined into an octal number so for ourselves we're subtracting nothing, but what about the group and others? we're subtracting write we don't want anyone to write our files by, anyone else to write our files if you actually read the manpage of write and other things you'll actually find references to umask so here's one other piece that controls the creation of files it does not effect existing files, it's only during the creation of new files and new directories it also creates, effects directories so let's play with this I will make a new directory So let's turn everything off (evil laughter) and I'll make a subdirectory and I will try to make inside subdir1 another file, so mydata.txt oh, I get permission denied, I cannot write into the contents of this directory why not? because we took the execute bit off the directory, so here's something a little strange the execute bit for a directory means, can I actually see the contents of the directory not the name of the directory, because that's not part of the actual directory but the name of the directory is back inside of the closing directory, in the parent directory it's can I actually open the directory and look inside and see what files are stored there so I couldn't go into subdir1 and in fact if I tried to list the contents of subdir1 I get No! you can't open that directory!" because it's not executable
so let's change our permissions so change mod, and I will change it to now what's a reasonable permission for directories? well maybe we want to be able to read write it and execute it, of course and we want other people to be able to read and execute it, so if I do that then now I can make my file and now if I do a d so I can actually see the subdirectory itself you'll see that yes, we're a directory and yes, I've got the read write execute for myself and execute and read for everybody else that was a very quick introduction to umasks and touching things and file globbing. Any quick questions about this? Alright, conceptually not hard, as I said the only surprise is that for directories, two bits is the execute bit that controls whether you can see inside the directory so no the directory's name, but whether you can actually go in and see the contents of a directory what files and other directories did I put inside of it and for the umask, remember it's a mask you're subtracting things that otherwise would have been set and it's only for new files and directories so nothing conceptually very hard now, here's the fun part, let's let's have a look at some of these other filesystems I've already mentioned /dev as  this completely different filesystem that's not actually a part of my disk and so that's the big idea, that I've got one set of paths in POSIX that I start with slash and go from there, everything's underneath this single slash all of my other things that I want to add all of my USB keys I put in all of my virtual directories and virtual filesystems are going to be underneath this root Windows used to have a different idea, it would say I'll put one disk inside of C:\, I'll put one disk inside of D:\ and we better not have more than 26 disks or we'll run out of letters that was the old kind of DOS way of doing things, thank goodness we've gone past that now but anyways back in POSIX we all start here, and we can add the virtual filesystems underneath specific directories of our filesystem so we've got /dev, there's a couple of others here they are: /proc and /sys right, so how can we find out about these? glad you asked! Let's have a look at a little demo here I want you to cast your mind back to before you were born and filesystems were heavy not something you would carry around in your pocket but literally something you had to lift with both hands because it was a huge tape, a huge disk and you'd lift it and you'd mount it onto a spindle and spin it up the command for looking at and thinking about filesystems is mount tell me what's mounted, tell me what's been put into my machine and by default we get a big list and we can see it and we discover, oh look, I've got a whole load of different filesystems mounted on different points inside of my filesystem so I've got one called /srv some of these are going out onto the network, etc I've got something called tmp oh, here are the one's I've just been talking about, /proc and /sys and there'd be /dev somewhere aswell so there are different types a lot of the ones we're looking at here, as you can see, are ext4 which is the modern-day equivalent of ext2 which we've already studied and we could add more to this so if we plug in a USB key, for example you would see it appear here if I mounted a DVD or CD it would appear here our filesystems don't need to be on external devices they can even be inside of a file so here's a file I downloaded earlier it's a .iso image meaning that I could copy these bytes using, which command? dd, yes, onto a say USB key or onto a DVD-ROM, but I actually want to have a look to see what's inside this file it's just a sequence of bytes, it's just a filet' but allegedly this is actually a filesystem inside this file so how can we do that? first of all we need to make a directory where we're going to mount this filesystem so let me call it stuff and you know right now if I look inside stuff there's nothing there! oops, cannot open directory? why is that? probably because my umask, oh alright, okay, thank you umask fix my umask, okay make directory stuff2 so there's nothing inside of that directory what I'm going to do now is that that iso file and say to the kernal, Treat this file that I just downloaded using wget and pretend that it's a real disk somewhere and start being able to read from it now you know that when you write disk commands you actually read in chunks, not at a byte at a time we're not doing fseek() and fread(), we want to read 4K blocks so we need one additional magic command with mount to say, okay, loop it back and wrap it wrap this this file and turn it and treat it as if it's a full as if it is a block-based device so let's do this, let's switch into root mode here okay, where's my little file? let me play with globbing, so there we go match any files that start with that, and I know it's just one of them today okay, and I want to mount it on a particular directory so, we had stuff2 oh, it didn't work because I didn't add the loop option yes the .iso file I want to treat as a block-based device so I need that one last option. Great, it works, and now we can, if I look at my mount listings, see that we've got that file mounted inside of my directory as this iso9660 which is a standard for CD-based filesystems and it's using particular loop-based device to turn it into a block-based device great, let's go and have a look
wrong directory there it is! right, I can now explore this filesystem. In fact I can say hey find me all of the files there we go, find me all of the files that match, say something beginning with efi and I can actually see what's inside of this filesystem let me try and change it say, Angrave was here" and this will fail because our filesystem is read-only so not only do we have umask control what we can do our entire file systems have different capabilities and so our iso9660 our CD-ROM based filesystem is only good for reading from  We cannot today change the contents  and if I actually mounted a different kind of file system, I could I could have actually written into this set of files and that would have changed the outer file, would have changed the .iso and that's the beginnings of how we can make virtual machines we can set up a complete file system for a virtual machine to boot from as just a single file Ok, right, so now I want to unmount it, I think I've shown you everything I want to show you here okay, so how do I unmount things? umount. I don't know what happened to the 'n' right, but it's umount okay, so we better find the thing to umount alright, so here's my mount, I just want to find things to do with that .iso, so let's take the output of mount pipe it into the input of grep and grep will only print me lines that match my pattern so I'm going to look for things that match .iso here it is, that one line, that saves me a bit of eye search trying to find it okay, so now I can umount on angrave/demo2/stuff2 did I miss something? oh cs241 thank you It's busy?!?! Why is it busy? I'll give you a hint: we're currently in there, that's currently our directory so the kernal says, I'm sorry someone's using this device right now, I can't let you unmount that because I've got another process trying to read its contents So let me go up one directory okay, so now I've unmounted it there we go and now there's nothing let inside stuff, we're back to an empty directory again okay so we're seeing the lifestyle, sorry, the lifecycle of mounting and unmounting we've played with grep now let's play with some virtual filesystems alright so if you ever want to just clear the screen clear is useful, if you've messed up your terminal reset tries to do some things reasonable let's have a look at a couple of these files let's have a look at, say, hex dump of zero if I start reading from /dev/zero I can just get a whole load of zeros If I read from /dev/null there's nothing, it's completely empty but they're not the most exciting ones, let's have a look at so next time you want to write a secure program, and you need some secure random numbers, numbers which are actually difficult to guess /dev/random is your choice you could open this, and read from this directory, and it will give you back random bytes random bytes that are difficult for an adversory to guess in advance how does the operating system generate these numbers? by collecting entropy okay what is entropy? well, things like external things can happen to my system so for example, let me press the Shift key and of course, I can't , because I'm not on that machine uh, so what I can do on that machine is look for arriving network packets let me try to generate from random entropy and slowly, when it's got enough entropy, there we go it can give you some more random data so not only does it need to generate random data, it needs to actually keep the meta information about just how much randomness has it collected at this point well look at that, lots of stuff must be happening maybe the disk drive is going, maybe there's some additional network packets happening but it's run out of entropy, so it blocks so it cannot give me anymore bytes at this point without um it cannot reliably give me more bytes at this point which are random so /dev/random is useful if you really want to wait until you've got cryptographically secure bytes if you don't need cryptographically secure bytes if you're prepared to just accept some limitations, then use urandom and that will just happily stream random bytes to you all day long so off we go by the way, with hexdump, you can even ask to see the characters aswell here we go, and perhaps if we waited long enough, we'd see Shakespere so that's one way to generate a lot of random numbers very very quickly we can find some things out about my machine here, lets go into /proc now and first of all, if we do an ls, we can see there's a whole lot of numbers here and some other interesting files that are generated by the kernal these do not exist on the disk drive this listing of files is generated by the kernal because we asked for a particular directory and if we were go to a particular one of these files again, it's generated on the fly as we request bytes from these files so let's have a look at, say, the memory for this file
what have I got here? I've got useful things about how my memory is organized let's have a look at Swap information you see that my Swap file here is about a Gigabyte in size and let's get a look at my CPU okay so I can get a whole lot of data but my CPU I can discover, say what features my CPU has but my favorite thing about CPU is I can discover how many bogomips it has in fact this little particular box has 4 CPU cores and each CPU has 6,000 bogomips a bogomip is one of the most well-known fake measurements of how good a processor is and it's this: when Linux starts up it runs a timing loop to see how quickly a CPU runs before the hardware timer interrupts so we can get an idea of roughly how many instructions we can run per second and that's what this is telling us roughly, our little CPU can run six thounsand million instructions per second that's a pretty fast CPU and of course it's a completely fake measurement we don't ever start to get close to that but it's a cute way of being able to compare one CPU to another and have an idea of how fast the timing loop is if we're just writing a very simple - in Assembler - kind of a litle for loop to wait for, say, a hundred instructions or so so that tells me something about my CPU speed and as you can see I can see how many CPUs I've actually got in my system so I can look at these these system-wides prompters, but I can also discover things about specific processes remember these numbers over here? They're just process numbers how about we find out something about our own process well I've got two ways to do that actually, the shell in a variable, tells me the process number of itself haha! I'm now inside the Matrix here I am inside of the process number of my shell let's see what we can find out about it all sorts of things so we can we can discover something about its memory make that a little bit more readable there's a lot of stuff inside of maps the first thing is, this tells me how the memory of my process is mapped so I remember how I said Hey, some memory's not mapped to anything" well here's the proof the very lowest part of memory is not mapped to anything the first we've got, actually, is memory starting at this virtual address going up to that virtual address and... come back! and it's at this address that memory is actually executable, and it's mapped from a file called /bin/bash then later I've got heap memory, here it is then I've got all of these librarys like ld libc, you could probably guess what's inside of libc all of the C calls that we call and eventually we should find the stack down here aswell oh there it is and there's our current stack I've got schedule information, I've got other status information and I've even got the file descriptors and I can look at even the the command line that was used to start this so if these are readable then that suggests an important security concern which is anything you put on the command line other people can read so it's probably not a good idea, on a shared system to put your passwords, or any other secret information, on the command line because this interface allows people to actually discover what's on the command line of all running processes let's start something in the background so let's start sleep 10 echo so let's go into okay that was the wrong process with a little bit of searching we could have found that command line for echo and discover the secret alright so that's enough of these virtual file systems I think it's time to talk about virtual memory, so page 2 so using virtual memory is and using memory-mapped memory is relatively easy I'm going to show you one version today which is where we have our memory-mapped file and we actually have a real file behind the memory that we're going to use next lecture we'll play with forking and show you how we can use this with IPC aswell
okay so here's our plan we're going to use something called mmap and when you say Hey, I want to map some virtual memory" we need to say what kind of memory do we want? do we want memory that is readable? writable? or executable? some combination of the above? so typically we will want at least read and write access so here's our protection so this is how, if you if your process tried to, say, change a byte of libc the virtual memory hardware would say Hold on a moment!  you don't have write access to that file. I'm going to let you proceed any further and it would raise a signal but we want to do more than that we actually want to be able to modify the file and we're going to actually change the contents of our file just by writing into memory which I think is pretty cool the other thing we're going to see is this map shared which means that changes we make are shared with the file sudo change owner to be angrave run vim, great now, there's a gotcha with using mmap which is that it's not going to automatically extend the file for us so if want to be able to, say, store a few integers in our memory-mapped space then we better make sure that our file is big enough before-hand so let's do that first let me look at a file descriptor and I'll open the file called data I want read and write if it doesn't exist, I want to be able to create it if it does exist, I'm going to truncate it and here's my permission bits, 0600 what does 0600 mean? the 0 and the beginning means I'm going to speak octal and the 6 means I want read and write permission and everyone else, ha! nothing for you we're making this a private file we need a way to be able to extend this file how can I do that? any ideas? how about using seek there's two ways to do this: we could have actually written enough bytes so we could have written size time size number of bytes into my file but another way do it is just to deliberately seek to a new end-point, and we'll write something in there so let's seek on my file descriptor who remembers how to use seek? I want to go this far into the file and remember we can like seek end seek beginning, we can say seek set and I'm going to write just one byte in here so let me write into my file descriptor here's a pointer to some data I want to send I'll just send, say, abc and I'll send those three bytes and in doing that, I've made sure that my file is more than this size so that's just the easiest way of extending the size of a file now we do our map and if it works, we get back a valid address for now I can treat that address as some memory that I can now use so I'm going to write into my memory 12345678 and this other hexidecimal constant called dead code to make sure that the changes in memory are written back to the file after I should unmap it, so how do I do that? I call munmap and we're done so let's compile this undefined reference to seek what did we do wrong there? sudo chmod angrave everything
oops, too much speed okay thank you right so oh yeah, sorry I was doing lseek alright so we got a reasonable address we wrote those bytes into it now actually let's have a look at our file okay here's a letter 'a' that we wrote here's those numbers we wrote 12345678 and deadc0de but that's not what we see inside of the file why? endianess, yes what can you conclude about this particular processor? that 78 56 34 12 we put the largest values of our integer, the 12 and the very end our integers are written in reverse we put the the smallest byte of our integer first in our file and that's a property of the CPU so be careful when working with binary data we have to know how our CPU represents integers and other data formats if we're simply going to just write them into the file likewise, if you're going to read from a particular binary file you need to know whether that structure on the binary file actually can be easily mapped into the CPU that you're trying to work with okay, so that's our file, and look how easy it was to actually change the contents of the file we just wrote into the file as if it was regular memory and if we had a very very large file we could simply write in offsets here and immediately use that data so if this was genetic data we wouldn't need to parse it, we could simply write it and read it directly from our processing loops so it can make working with binary data very very efficient one last comment on this is that memory-mapped files isn't always a free lunch you won't necessarily speed up all operations the kernal, the operating system, the disk drive are designed for fast streaming of data so if your process is simply streaming data in doing some simply processing or filtering of that data as it comes in and streaming it out, memory-mapped files will not give you any significant advantage what it will do for you is when you want to make use of the virtual memory framework to automatically map parts of files directly into address space and with that, my demo's finished. Any questions? you might find this useful in the very last MP if you're trying to your keyserver run fast, but I'll say no more for now. thank you very much, I'll see you in two days.
alright! do we have sound, testing testing yes great!  good morning and welcome to cs 241 here's what we're going to do today i'm going to cast your minds back to 1991 when a little while ago yes tim berners-lee posted the following the world wide web an executive summary the WWW project merges the techniques of information retrieval and hypertext to make an easy but powerful global information system.  little did he know that he would be so right. i'll skip on to the other fun bits like to follow a link are really clicks with a mouse! these are the only operations necessary to access the entire world of data!"  he also says inside the same posting that  making a web is as simple as writing a  few sgml files" so html actually has a history before that which was a larger markup language called sgml eventually as you know we decided to use a slightly simplified markup language called html the www model gets over frustrating incompatibilities of data format between and suppliers and readers by allowing negotiation of format between a smart browser and a smart server so here was tim berners lee's insight, is that what we need to figure out is not the coding and the making it work on all kinds of platforms, yes we need to do that, but it's actually the protocol that is important the protocol between the client and the server the summary does not describe the many exciting opened up by the WWW project  remember at this point he's just talking to a few friends at CERN, a physics lab in Europe such as efficient document caching, a reduction of redundant out of date copies and use of knowledge daemons  there is more information in the online project blah blah blah here, here's a very simple prototype 128.14 and it gives you an IP address  i found an early version of his code version 0.2 it has some bugs in it, it's not even secure but i thought it'd fun to show you the code because here's what your'e going to do in lab tomorow you're going to write a web server i'm going to give you half the code you fill in the rest and you're actually going to use mmap to be able to serve the files back onto a web page and here's the thing about searching at the other end of the scale, large information providers may provide an http server with full text or keyword indexing was tim berners-lee actually thinking about google at this point?  i think maybe not, i think maybe at the time he was thinking about servers that would actually index documents on that machine not about machines that were powerful enough to index the whole WWW project but anyways, next time i meet him i'll ask him what he meant by that comment so yeah, i'll include this text in tomorrow's section, you can read it yourself so let's turn to today's handout  alright, so just as a warmup exercise, how do we mount a disk image? so let's say i've given you a file and that file actually represents a complete file system what do i need to say?  well you're going to use the mount command because it's a file, a stream of bytes, we actually need to use a loopback so we're going to need the -t option because we need to turn it into a block based device  we give it a reference to a file and we give it a point on our existing file system where we would like that file system to appear but the big big idea is 'hey i'm mounting it' i'm adding to my existing file system then i can cd into it and potentially change the files of that file system okay, what is the setuid bit? what's the purpose of that? so on a file i can set the uid bit and if I do what happens when people execute a file with that bit set?  yes! that's right, it's the process that has started is not started as you as the caller it's started under the user of the owner of the file  so for example, if we have a program called sudo, which we do and the owner of that is root then if i've set the UID bit  then when you execute sudo, it doesn't execute as you it actually gets all the privileges of root. so that's a kind of typical use of suid. my goodness, that's not your eyes, that is this projector. there we go, that's a bit better, right. so if for example you wanted to have a program that made some symbolic links and mounted a directory  and you wanted to do all this stuff that requires root and it requires admin access you might make a program and then by using suid  you could then allow other non admin people to run your script and for this script to do administrative things for them  so let's turn our attention to mmap  the purpose of mmap is to give us virtual memory that is backed by a file and when we try to read or write those virtual memory addresses  the kernel will automatically read or write to the file  that's on the file system we don't need to bother with reading it into our data structure our data structure can simply just be at that address okay well let me ask you now um, mention that we've actually got a couple of options  first of all  you have to choose one you have to say  when i'm going to call mmap, i either want a private copy or a shared copy so here's what happens if it's private you say any changes i make to my data structure i don't want them to be pushed back onto the disk i just want my own private copy so now  it's like saying  okay, load this stuff in, i'm going to scribble all over it and i don't want anybody else to know about it it's my own private copy, right? and in fact for efficiency, we don't make an immediate copy of these pages, we do it only when a process attempts to write to those pieces of memory in other words, if i started four copies of your program, i don't need four times as much ram  i will only actually make a copy of a frame when you attempt to write into it
so map private uses copy on write for each uh frame of memory, so for each four kilobyte block behind the scenes it will copy it only when you attempt to write it and that copy is then just like any regular memory that you might have made on the heap once your program is gone, it's gone, there's no store of it it's also private toward a particular process map shared on the other hand is useful when we're going to want to fork a process and then our child and the parent will see the same physical piece of memory so any changes that the child does, the parent will see, to that frame of memory also, it will copy the contents back to the file that we opened so, it's doubly shared, right it says um that i'm going to use this for interprocess communication between my child and my parent and also i'm going to copy  back to the file right so this is two useful ways of using mmap  so most of the time you're probably going to want to say  ok, i want to see it shared so early versions of mmap did just that but we realized that actually maybe sometimes we want to be able to share things with a child and the parent process and not actually have any file on the disk at all we just want to set up some physical ram that it could be seen inside two processes and uh if you want to do that you can, you just need to pass in  map anonymous  by the way if you actually want to work on os x, you need to use map they are synonymous but so this means 'hey i don't actually have a file i just want to mess with virtual memory so that i've got a page of memory or more that i can share between a child and a parent process' what can i do with that, well i might want to simple write values in you can also share a semaphore  remember semaphores? these counting things where i can increment the count if i attempt to decrement the count, it might block if my count attempts to go beneath 0?  so now i can actually use this to synchronize between two different processes we're not gonna go into the details of how to set up a semaphore inside shared memory but a google search  thanks to the world wide web will let you do that right, we can find easy example source code to do that, so that's beyond cs 241. just hey, back of your mind, know that this exists should you ever need to do this  okay so let's have a look at some example code how can we use mmap well we opened a file descriptor  okay so let's open a particular file called alice"  i'm going to open it as read only and then i call mmap  so i'm going to map today one page 4096 bytes and then we can talk about how we want to use these bytes and uh we've got three little bitwise flags that we or together  so there's proc read, proc write, and caught exec yes! i want to execute my files! my bytes1 off with the head said the queen what's the purpose of these bits? do they affect the file on disk?  no, remember with virtual memory we actually declare how our process can use different pieces of addresses yes we can have some addresses that don't map to any piece of physical ram  other addresses might map to some physical ram that we're sharing with hundreds of other processes for example, lib.c, the c library lots and lots of processes want to use the code inside that so rather than having multiple copies inside our physical ram, we just have one copy and have lots of mappings to that for that physical memory to be secure then  we better make sure that all of our different processes can only read it also, we can have another layer of security to say 'actually we're not going to let the cpu execute opcodes from arbitrary pieces of memory'  so we can actually say that our memory is executable or not  so we're not going to put any executable code in today, we're not trying to build say a virtual machine that's going to compile source code into executable bytes today we just want to have some memory that's read or write okay  so i've got two examples here  one where i've got the text of alice with the looking glass  another one where i've got the text of justin bieber's best lyrics  it's a very short file and you can tell me which one of these will work and which one of them won't and why so there's a clue  one of these will work one of these won't yes! yes! right! so we've put some options to say that we want to write to it   and in fact here we are trying later to write to it look i'm just using a pointer into memory and i'm trying to write the first two lines of the jabberwockee poem but i said that my mapping should be shared  in other words changes i make to my virtual memory  should eventually be pushed back into the file  and if i try to do this here's what will happen mmap will fial and in fact i'll get back the address negative one so you'll often see code that compares the pointer to -1  if it is, then we know that mmap failed 
now my code didn't attempt to do any error checking, so i'm just trying to strcat straight into this address which would be -1 and so i will probably get a segfault  in my code  um, i didn't talk about map file and in fact map file is the default and in fact you can it's not necessary to specify but you'll notice that all these things are bitwise OR-ed  so we build up a single integer that represents all of these flags right so, we've got this one we've shared this one which is map private and here's the great thing is that when we specify map private it means to this particular process so we can read justin's lyrics if we want but fortunately we think they're a bit of a cow, so we can do copy on write so we can actually overwrite to our heart's content all of his lyrics if we wish to unfortunately, we can't change what comes what comes out of his mouth he gets to keep his own copy of his lyrics file we're only going to change what's inside ram what's inisde our memory so this is allowed, this is okay even though we said that the file itself is read only and we want to write into it  we're doing that because memory is private and so we get to store our own copy in memory okay um  if you do want to write, once you finished changing things then it's important to call munmap  to release these resources right to say 'okay i've finished with this particular mapping' at which point the system may get around to writing it out to disk if you set it up that way but it doesn't have to immediately and in fact for performance there's no reason  why it might do it between now and some point in the distant distant future  so there's one other useful thing i'm not gonna test this but hey if you ever use this mechanism  if you want to force your changes to be sent back to the file system  call msync it's like nsync, but more musical i'm sorry terrible joke,  right, is that how you spell msync? who knows. okay, they're a boy band, they were allegedly popular  i probably misspelled it  anyways, so! yes, do this but realize if you call msync to many times then you're going to have slow performance because then you're waiting for your pages of memory to be written back to disk  okay, so  we know enough now to start playing with mmap  remember if it doesn't work actually find out what the error message was and think about your options what kind of memory mapping do i want to use so let's use this  and this hints now for how we're going to create our first tim berners-lee kind of web server let's say we want to serve a file back to a client  we actually want to send some bytes we've already made our socket code and we've already set up a file descriptor so somewhere previously i've done something like  okay let's do fd-open on something i've got back from my accept call something like that  so now i can start receiving and sending bytes using the c library to the client and now i want to send the file  okay, so the http protocol says you should write a few lines of text at the beginning like the MIME type, like the content length so yeah pretend i've written those lines now i just want to send the bytes, okay here's how we can do it first of all remember stat? let's use stat to find out the actual size of our file  then i'm actually going to open it so i just need my read-only flag here  that's easy enough we've got that up there and then i want to map that into memory okay this is where you come in what would you write have a look up here to see if you can figure out the options  what options do you need? because once you've got that pointer, we'll check if it's not equal to -1 we can just call fwrite to send those bytes in memory! we'll say look here's the bytes i want to send, send me 1*this number of bytes, and send it to this file descriptor bam we're done! we have the WWW thank you very much i am tim berners-lee anyways, so, right, or you've got missing just this line, so this is the one line that's missing between us and finishing our WWW web server alright, now it's up to you. what are you going to write in this line? take 2 minutes to see if you can write this line  you can write it down here if you want if you're out of space what options do you need for mmap?  okay, so what do we need? right i'm not going to spend any special options today, we need to pass in how many bytes we actually want to map from the file we only want to read through it 
and  actually we could write map  shared map, private, it doesn't matter in this case because we're just going to be reading or writing, I'm sorry, just reading from it and we pass in our file descriptor, here we go, and we don't need any offsets so something like that should work and we'll check to see if that gives us back a reasonable address pointer and if it does great i have immediate access to the bytes in that file don't forget at the end to use unmap and munmap or else very quickly you're going to run out of virtual memory when your WWW project becomes popular okay, right so let's have a demo now of actually using this to talk to two different processes great, so here's my program if we wanted to quit, we could print say the line number of where we failed  so i'm going to in here see if my mmap failed and if it did i'm going to simply quit and my macro quit will include the file and the line numbers so in debugging this, i can see where the problem is alright so let's have a go at this  i'm using map_anon because i'm using this on os x (on a mac) and i don't have a file descriptor to pass in because i'm just trying to communicate between a child and a process  okay, so once i've got the address, here's my plan  i'm going to treat it as pointing to some integers  then i call fork and now i have two processes  in the, in one process let's see what have we got so that's the parent process, so in the parent process i'm going to write these two values 10 and 20 and in the other process okay, here's my attempt at synchronization, we're just going to sleep for a second to make sure the other process has finished  and then we're going to read the values of shared so i've got two processes remember but they're sharing one frame okay, so we'll add those together and see what we get  okay, do you think this will work? let's have a plan, see what happens alright, so we run gcc invalid argument and of course we've got a crazy address why, what did we do wrong?  okay, here's what we did wrong, you've got to choose one, you've got to choose either shared or private so in our options here we we definitely need anon or anonymous because we don't have a file descriptor but we have to say  an options, so suppose we did private, what do you think the result would be ah, we got 0 in the other process! why? because we made it private! okay, what we wanted was... we shared the memory, okay so let's fix this and a second later, yay! great!  right, so there we go, we've managed to toggle information using memory mapped operations between one process and another process  pretty cool huh? well i think it's pretty cool and i think memory mapped files are fantastic when you have a lot of binary data or text data  and you want to be able to write simple code to read it and manipulate it  you'll often find it's very very easy to okay just map the whole file" then call strcomp or call a regular expression on the whole file and we'll let the virtual memory automatically load those pages into memory for us okay any questions about mmap? okay, right, time for part two! this is one of the few times i'm going to use powerpoint, so sit back, relax, turn your brain off you know how i feel about powerpoint, but i've got a few things to say and i've got a few slides which are actually useful we're going to talk today about file systems from a very different perspective  i'm going to talk about file systems by what can we do when think beyond just a single disk and how can we make our file systems robust? okay, this is not a new question, and one answer to this is RAID so we'll talk about RAID and then at the very end of this i'm going to talk about well suppose your problems are bigger than just a single disk array  suppose you want to start a company like Google how can you make a file system that works even beyond a single data center? so what do some of those challenges look like? and i'm just going to cherry pick a few items out of that and give you a reference if you have intentions of building a file system or building a company as big as google right so let's talk about RAID you've probably heard of RAID, it's relevant today even if you're using RAID, but i'm going to talk a little about the history about where it came from  it comes from redundant array of inexpensive disks  so here's where what we got there, first of all due to moore's law where we can pack more transistors on our silicon, and so we saw CPU speeds doubling very quickly however, disks themselves were not increasing in speed yes we learned how to pack more information on them, but the time to access any one piece of information was still dominated by the speed it took for the disk to rotate around so you've probably heard about say 7200RPM or 10000RPM  this sounds like it's spinning very fast, but if you work that out in terms of milliseconds, it's still a long time before it can rotate back to the right spot so we have a rotation time and seek time of actually physically moving the head to the right track on the disk, it takes time even if you can move it very quickly you still have to allow for it to settle so disks are slow  so why don't we spread our disks over multiple disks?  secondly the cost of our disks started to fall dramatically so it became apparent that rather than having one massive really reliable disk, let's actually use cheaper more commodity hardware and instead think algorithmically of how we can improve the rather vile reliability of our data stored on disk so that's just a little bit of historical backdrop
okay, so what are we going to do we're going to take our data and push the bits somehow across multiple disks multiple physical disks and in that way we should be able to improve performance because now our i/o channels are talking to multiple disks simultaneously however, our disks are unreliable and if was to buy a disk today, the promised 30000 hours of performance before it failed, then if i had 100 disks that means that i expect my data on average to exists for two weeks before probability before it goes bad the thirty thousand hours is not a big figure as soon as you have large disk arrays okay if you're wondering how big is thirty thousand hours, if you work forty hours you get to about 2000 hours per year  if you work 24 hours a day you get some small multiple of that so we're talking about a disk that supposedly lasts a few years and as you can see we've shortened it down to just two weeks  so we're going to have to think about how it'll solve this problem of making sure that our disks, our data is reliable if we have a disk failing on average every two weeks okay, so one thing we could do is simply copy the data to two disks! this is called mirroring and you today can go and buy little enclosures that support RAID 1 and all they have is two identical disks and they send it to both and if one disk fails then it doesn't matter you've still got the data on your other disk hopefully the disk array tells you when one disk has died, and hopefully it tells you which disk has died because you're going to be replacing one of them right? so the good news is that if i do this, then my reads are suddenly typically twice as fast! because now i've got potentially two different disks from read from  so i can actually execute two reads concurrently at the same time and using the disk however in terms of writing i've got to bring both disks into sync and then so i have a lowest common denominator and so my writes are no faster plus i've doubled the cost of the storage and that's a hard pill to swallow, maybe we can do better than that well anyways there's RAID 1 alright, today i'm just going to talk about RAID 1, raid 3, raid 5 I don't want to confuse you with too many different levels, so we can at least see how these things were solved right so RAID 3 let's use parity codes and for this example we're going to choose odd even, we'll chose even parity  which means we're always going to write an even number of 1s so if you give me a value that has an odd number of ones in binary data, then my parity bit will also include a 1 why don't i do that, well that means that i can recover my bits if any one of those bits are lost does that make sense? alright, didn't we play this game inside CS 125 right?  here, let me write down a number, here it is, and i'm going to make sure that i've written an even number of ones okay, there we go so here's the number you gave me, here's my parity bit if somebody came along and said haha! you can't have that bit anymore i'm not gonna tell you what it is then i can look across all of the bits i wrote and reverse engineer it, right? I can say oh look i've got an odd number of bits and therefore this missing bit must have been a 1 great, so here's our plan, is that we'll buy another disk to store our parity bit in  and we'll have a say disk for every other bit so in my little example, if i'm writing bytes, octets, then i just need to buy 9 disks so i've already increased the cost of my system by one extra disk yes, the disk has gone  there is no disk, right? it's died we're not trying to deal with bad data, we're trying to deal with missing data literally the disk stops spinning it gets hot, whataever, right. it just makes awful clunking noises and refuses to talk yes, yes, right so this system's only good for being able to recover one bit  right, so i would need all of these in other disks alright so i have my disk 1, disk 3, disk 4, disk 5, disk 6 okay any disadvantages to this? it's pretty cheap, yeah, but now my write performance is limited because i have to always be updating parity information as well okay so here's a little attempt with this. suppose i have a 4 bit computer and 4 bit data  then i've got my four disks, my data, and a check disk as well for storing the parity bit so if i'm storing this 1001 great, that is already even, so i can just write zero, and in these other examples there is say for the light blue one i wrote an odd valued value, so my parity bit, my check disk, includes a 1 right, let's kill a disk there we go. right so you now believe me that if one of my disks dies, oops, there we go. suffered from a small nuclear explosion then i can recover all of the data that was actually originally on that disk by reading all of my other disks  i can now write a little process and reverse engineers what should have been written on that disk 2 and i do that for my entire data set okay there any problems with this? let's think about the chances of another disk dying whilest we're trying to recover the data so we've got this mean time to failure  and mean time to repair  and yeah we can recover the data but it assumes that bad things don't happen whilst we are doing the recovery process  so with raid 1, we'd copy all of the data off one good version back onto a new disk with raid 3, we need to go through all the data on all the disks using the parity to recover it
so um what is this probability  well this is a worked example of the probability of a second failure is determined by the time to repair  divided by the mean time to failure divided by the number of disks and so if we plug in some typical values then we discover we've got a .009 chance of losing all of our data of that one of our disks dying whilst we're trying to recover our data it turns out that this mathematic figure is completely wrong it's not true in real life have you heard of murphy's law? murphy's law turns out to be extremely true for RAID disks  if something goes wrong, and there's other versions that say look if bad things happened once they're going to happen a second time or similar chinese proverbs as well why do you think the second disk dying whilst you're trying to recover is much more likely? there's actually two reasons, yes! yeah, thanks! look if disks had been bought from the same supplier, from the same batch, they're probably going to expire about the same time you know that little bit of grit inside the bearing that caused it to heat up and eventually warp? well that's caused because part of the manufacturing process is sprinkling grit on that spot and if one disk fails after 2000 hours, then probably another one as well the second thing to realize is that this repair process is really hard on the disks  you're going to reading out all of the data and probably trying to use the disk array for whatever production requirement you have at the same time so not only are you trying to sweep through the entire data set, your production process is saying yeah i need this data i need this data i need to write this I need to write this so you're stressing your disk drive much more than normal operation so another department inside this campus experienced this very same problem and it turned out that even though they had RAID, their two mistakes were a) to assume that RAID was perfect and b) not to have any monitoring to tell them when their RAID had failed and so they experienced this very problem that during the repair, a second disk failed, and that was it it was gone and their backup was several months old, whoops alright, so um back to our RAID 3 our performance is only so so because we need to update the check disk for every write right so lastly let's look at raid 5 and raid 5 mixes it up a little bit  or actually literally here's the trick: for different data blocks we'll put the parity bit inside a different disk  we're interleaving the parity across multiple disks  so now we've reduced the bottleneck of storing all the parity information on the same disk and in fact we can now allow multiple reads and writes in parallel right so that's the short intro to raid 1 3 and 5 that's all i expect you to know for cs 241 let's stand back even further and actually talk about a bigger problem which is  okay how do i make something which is even bigger than a data center if i want to have a file system that spans planetary sized data so for example, you're google and you're storing everybody's gmail and you thought running out of storage space on EWS was bad this is from a google engineer you know you have a large storage system when you get notified at a petabyte of storage left I wish I had that problem on my laptop, right? I'm sorry, I've only got a petabyte of storage left. so how could we build a file system that is at this scale?  okay, well what kind of issues do we have? yeah we know that disks fail  and in fact google takes the approach of buying very low commodity hardware and expecting failure and instead putting software and algorithmic refinements on top of commodity hardware  the stories of when google was scaling up other companies couldn't believe the trash that google was bringing into data centers why are you bringing in that old dell box? don't you expect it to fail? the google guys were like yes! we expect it to fail! but that's okay"
they were more interested in keeping their costs down so they have hundreds of thousands of disks and so we expect a large number to fail but it's not just single disks failing, we could have a whole rack go out, power could go out the network cable could be severed. the network port could go bad. etc etc etc all of these things could take down parts of our file system and we need it to be resilient to these kinds of problems at different levels so how do we do it okay, back in 2001  the google file system was pretty simple hey let's just keep 3 copies of every file and we'll put them in distributed places so we'll have one in the east coast, one in the west, and one i can't remember and google at the time was pretty america centric these days google has much broader reach of course and much more of its data is stored outside of the US so what do we do we use something called reed-solomon codes, where rather than storing at actual data that you wish to store, we store an encrypted or transformed version of that data and that transformation uses our s codes now you've actually already played with reed-solomon codes if you have a) played a cd  the data on a cd uses reed-solomon codes because CDs get stretched in fact reed-solomon codes can cope with a scratch up to about a millimeter or so or b) you have communicated with a space probe so, if you've talked to voyager, or mars path finder, you're using reed-solomon codes i imagine a is more likely than b, but you never know! this is uiuc, right? these codes then are very good with bursty and unreliable and missing pieces of data and what's amazing about these little mathematical objects is that their expense is pretty lightweight that space trade-off of reed-solomon codes is pretty small so we use reed-solomon codes and we only need 1.5 times redundancy  so that's how google solves it i've put a link in these slides for those who are interested in this stuff there's lots of great sort of war stories and tidbits about this but here's what you need to know for cs 241 is that we need to think about file systems beyond a mere data center and  one of the approaches to cope with missing data is to use coding theory and to represent our data on the disk okay, right, so that's all i've got for today have a wonderful week and have fun tomorrow in section finishing a streaming webcam and also writing the WWW project and finishing the web server
[introduction] alright good morning and welcome to the signal version of CS241 here's what we're going to do today we briefly talked about signals way back at the beginning of the course cast your mind back to when we were creating processes and we said that hey when a process dies the parent gets notified we get a SIGCHILD right? and we talked about SIGINT for when you press control C as a way to stop a process or if you want to stop a process and you don't want it to prevent you you would call SIGKILL yes? and SIGKILL you cannot catch it you will terminate that process there's actually quite a bit more to signals and that's what we're going to talk about today and we're going to show you how to prevent signals from arriving at your process we're going to talk about some of the terminology about this and finally how to do it correctly with threads as well right so I've got two signals here they are, oh I need a volunteer thank you for volunteering you look like your busy, in fact, thank you for volunteering as well okay right a signal remember is an interrupt so we can interrupt a process from doing something by throwing a signal at it okay so here's an I not for illinois but for SIGINT right there we go okay so come over here you're the kernal thank you, here's my process okay and of course if I type control C we can deliver the signal to the process throw it at them ok look he caught it, right it appears that this process has installed a signal handler and has caught the signal so we delivered it, the process caught it, but the process carries on right? it didn't stop there are some signals however called like SIGKILL that cannot be caught if we were to send this then of course we know that the process dies now where can these signals come from? they can come of course from the process itself the process itself could say hey I'd like to send myself a signal right? you'd like to raise that crazy idea yes? and in fact the system call to do this is called raise so if you call raise, what you're doing is you're sending a signal to yourself alright so if you were to kill yourself you call raise SIGKILL if you want to send yourself SIGINT you say raise SIGINT now here's the exciting part, is that actually you can block signals you can block specific signals here's your signal mask if you'd like to hold that in front of you the amazing thing about this signal mask is that it actually stops  well we can set it to stop a lot of signals but we'll set it up to say block SIGINT because guess what if we want to send SIGKILL I don't care what you do with your mask this is getting delivered SIGKILL you cannot block but you can stop SIGINT now if you set up that mask okay? what do you think is going to happen to the signal you're going to block it right? so it's going to rebound off that piece of paper good guess but not correct, here's what happens to the signal if you're going to hold this and look as if you're going to throw it at the process no just hold it like your like practically in a sporting magazine or something here's what happens, the operating system says okay you've set up your mask, here's what I'll do this signal is pending I'm ready to deliver it to the process anytime you drop your guard down so anytime this mask goes down, we're going to send a signal how are your arms doing? yeah okay right so I'm interested to see some of the terminology right? we've got a pending signal so the word pending is the idea between when we created the signal and when we wish to deliver it so what happens if you think at this moment in time we start pressing control C control C control C control C or we start raise SIGINT raise SIGINT raise SIGINT we keep trying to raise more signals do we get a backlog of all of these signals ready to be thrown at the process? hundreds of balls about to arrive at you any moment you change your SIGMASK and let through SIGINT actually no, there's not a queue of the if you have raised SIGINT, if you've generate a signal, there's only one SIGINT to be delivered whilst we stay in this kind of captured moment in time, think back to par shell and when we talked about preventing zombies yes and we installed a signal handler to catch sigchild right? there's actually a race condition, oh you know what a race condition means now there's a race condition, suppose two children finish at exactly the same time or close to the same time it could be that we've generated SIGCHILD here and we're not going to generate another SIGCHILD for all of the other children that finish at the same time so actually the code that we wrote a while ago is not sufficient because there can't be a queue of the same kind of signal I can still have other signals for example my SIGKILL and I can deliver that but there's never a queue of multiple ones okay why is this? well imagine in an implementation where these signals are really just little bits we've got a little bit ready to fly just like a hardware interrupt where I've got a particular interrupt coming from the particular device I've got a particular signal I want to deliver to a particular process now the other thing we should talk about is what happens if this process calls fork and this process calls exec what might happen to my pending signals? what might happen to my SIGMASK the other thing we have to think about is what happens if this is no longer just a single threaded process but now uses say pthreads what should we do there? so suppose you are a pthread process okay? so in other words you've been compiled with pthreads and now you call pthread_create here's what happens if you call pthread_create you've now got two threads running yes? here's the great news, the second thread inherits your mask alright? so now they're both blocked from SIGINT
what do you think happens if I change my mask? here's what happen: the signal will be delivered to the process and caught by me [something] okay right so the signal in this case was delivered to me right but it couldn't happen until one of us dropped our guard here you go catch raise that so right what do you think happens if we both get rid of our masks it's arbitrary, who's going to throw it? okay who gets the signal? it's random, whichever thread the operating system decides to interrupt with a signal okay? so that's the basics of signal, give our volunteers a round of applause thank you very much why the virtual demo? because sometimes there's more interesting than simply going okay here's the technical details  yes there's a lot of just little annoying technical details but that's okay because you're illinois students you're used to being annoyed oh wait, that's not right so I'm going to run through some of these details they are on the notes, they are on the man pages etc and there will be a multiple choice quiz on this and I'll generate the practice exam shortly alright so what have we got? let's talk about some of this terminology right so we've talked about generating signals what do we are doing? well somewhere deep inside the kernel we've got a little bit set that says okay we want to deliver this particular signal to... to a particular process what's it mean if a signal is pending? it's that time interval between when we've generated it and when we've delivered it to the process okay so it's the period of time... between when we generated it and delivered it we know what it means for a signal to be blocked now it means the process has a signal mask that is preventing that signal from being delivered it's like putting a stop on your mail right? we don't just discard the signal, it just waits until we can actually deliver it what does caught mean? it means you've installed some sort of signal handler and you've decided to take care of that, process that signal in your own fashion in your own special way and then finally disposition right how do you feel about lady gaga's music okay pretty bad at the front here, that's your disposition to that particular signal what' your disposition to this lecture good so far, okay, phew that's another disposition so our disposition is what are we going to do? how do we feel about a particular signal? you know that we can install signal handlers and we can have different actions that occur for different kinds of signals you know that some signals can't be caught but for all of the other ones we can set up a particular disposition so thinking in terms of an implementation you could just think of a disposition as a table of function pointers so one function for each signal in other words, if I get a SIGINT go in here and execute this code so when I install a signal handler, I am changing a particular disposition to that particular signal right so basically it's wutchu gonna do when you get a particular signal? wutchu gonna do when you get SIGINT, wutchu you gonna do if you get SIGTERM, wutchu gonna do if you get SIGCHILD, etc that's your disposition, the sum of all of those actions is your disposition to signals right okay let's have some guesses then do you think your signal disposition is on a per thread or per process basis? make your guess now and I'll tell you the correct answer in five four three and the answer is process! it's on a per process so signals are delivered to processes what do you think the signal disposition is of your child? is it reset to the default? or is it a clone of the parent? make your guess now and I'll tell you in five four three two.. it's a clone! or the same as the parent in other words if you set up your parent to say ignore SIGINTs when you call fork so will your child so this is a bit you know the apple doesn't fall far from the tree if you like rythm and bass, maybe your offspring will as well but if you call exec it's reset right, so now we can start talking a little bit about the code so where would I call SIGPROCMASK? when I don't want yellow balls thrown at me if you say that during an interview they'll think you're crazy right so what's a better answer for SIGPROCMASK? using the correct terminology of signals what am I doing with my mask? blocking, yes! we set up a mask to temporarily block signals
if you are working with a single threaded process and use sigprocmask guess what, if you're compiling with pthreads, then use pthread_sigmask this allows you to have different masks for different threads so now we can talk about whether a signal will be delivered for a multithreaded process and we saw that it will be delivered to one thread and it can be any thread that is not blocking the signal so what does this mean in practice? in practice this means typically in our initialization code before we called pthread_create let's just try and block everything, let's just serve a big mask and say hey we don't want to know about signals right now and then later in one particular thread, we'll say we'll deliver signals to this particular thread and we'll lower our guard, we'll lower the mask for that particular thread so what's it mean when a thread actually gets a signal it means that thread is going to be stopped from executing the code that it's currently working on and they are going to steal it we're going to use its stack to execute the code that we write inside the signal handler so anything it was in the middle of doing, let's say it was in the middle of malloc, let's say it was in the middle of updating a data structure that is put on hold whilst we do whatever is inside our signal handler this is why things can be signal unsafe suppose your halfway through updating your data structure or suppose malloc is updating its data structure and then you try to go in and do something to that datastructure whoops now you're reading and writing from the wrong bytes we can't use mutex locks for this to prevent this because we are actually stealing the thread in order to run our signal handler code so I'll talk about a way around this in a moment where we can take a lot more careful control about when and how we handle particular signals okay so how do I learn more about this? on linux, not on your mac, but on linux, in section 7, there's a whole long article all about signals so we use -s7 to say go to section 7 and we can read all about that so let's talk about appending signals remember appending signals is our signals we're about to throw and pending signals work in the opposite way to our signal disposition that when we call fork the new child has nothing on the other hand if you call exec some sort of exec call pending signals are preserved so that means you could do something like that following let's fork and then in the child... we know there's nothing appending yet because we've just forked right? so let's deliberately raise something here okay so I'm going to raise SIGINT now if I hadn't done a signal mask at this point that could be delivered straight away whoops I've just managed to control C myself but instead in this little example, we're going to suppose... we've already set our mask suppose our mask already includes SIGINT, in other words, I'm not... going to accept your SIGINTs right now, talk to the hand right? I'm blocking this but the next thing we do is we exec something wahahaha what happens now? pending signals preserved the mask gets reset because that's what happens when you... oh, wait wait I'm certain that if in my exec code, if that now changes the mask, it can get my control C, I could actually interrupt a process before it has even started up by generating a pending signal so my other process will get the signal later when the mask is changed and we won't say generated, we'll say delivered! so reasoning about signals and working with them is tricky because we have to think about the timing of when things happen and we have to be careful about what our masks are right so I've talked about pending signals if I want to send a signal, if I'm inside a multithreaded program I want to send a particular thread I can use pthread_kill if I want to just send a signal to my whole process I can send raise, if I want to send it to another process, I can use kill so signals are at the process level however, in a multithreaded process which thread actually catches them and performs a signal handler that you've installed is dependent on the signal mask of all your processes
right so we talked about creating signals and sending them let's actually work with them now I mentioned signals at the beginning of this class, I mean at the very beginning of the semester here's the bad news signal should not be used for multithreaded programs and in fact if you read the linux documentation it would typically say signal should not be used don't use signal! why not? well a) it's not really supported in multithreaded processes but also b) it's definition was inprecise so the way that signals are delivered on different operating systems is ambiguous so fine you managed to get something working on linux and that's all you care about use signal, but the better option is to use sigaction where we have a lot more control over what happens when we generate signals now in addition to installing a signal handler with sigaction instead of signal there's two other ways of dealing with signals, one is to create a file descriptor like a file, that we can read from a stream and what we read from is bytes that tell us about what signals have happened I'm not going to talk about it inside 241 just other than the fact that hey you should know about this and it's a pretty good way of working with signals so you could open one of these inside your own specialized thread and start pulling signals from that file descriptor and interpreting those bytes another way is to use sigwait where sigwait blocks until a signal happens and then it gives you details about which signal occurred and we'll have a look at that today in fact, let's take a break from a moment because I realize this is a lot of factual stuff and let you know about this so I've got fifty questions for you and this is going to be worth four percent of your grade and it's purpose it to help prepare you for the final exam so here's the idea is it's a little homework feel free to work in pairs, what i'd like you to do is actually try and research and try to understand the answers because we're not going to grade this purely on correctness we more care about the fact that you took the time into learning these answers because many of these questions come up in real interviews as well so I've got fifty questions for you, actually the fifty first question is optional it's this, it's draw an imaginary picture of you battling your most evil or tricky CS241 CS programming bug so looking forward to seeing dinosaurs or whatever however else you imagine working on that so can you give me a hand handing these out? here we go if you could hand some of these out for me that would be fantastic you will find that some of these are merely code writing exercises I encourage you actually writing out the code by hand because that's what you're going to do in the final exam some of these are based on information inside the wikibook and some of these will require a quick google search to find the answer maybe we haven't talked about it directly inside lecture yet feel free to write your answers in note form, like i said... this is about doing exam prep and getting points for it as well okay? so the purpose is to help you review the CS241 material yes I'll make additional copy right let's go to aux pc [silence] okay so now I've got the code version of the demo that we did at the beginning of lecture we're going to set up our proc mask, our process mask so that a particular signal can't be sent to our process, can't be delivered to our process right so what's the plan here? well, a long long long time ago, signal sets just used to be an integer however, there was a concern that the number of signals might exceed the number of bits inside the integer on any one platform so to make a more cross platformed solution we have this type called a sigset_t and then there are functions either set all bits, clear all bits, set one bit, etc etc etc we're looking at an example then when we are going to set all the bits inside this little bit mask and then we're going to use that and as you can see this sigprocmac actually allows us to discover the old signal proc, the old mask again so that later on in my code, I can restore the original signal mask so it's typical in well engineered programs then to at the very beginning of the process raise all the guards, raise the whole mask up so that... so that no signals get delivered early on, not until we're ready for them until we're ready to open shop right so we're calling sigprocmask we're saying okay I want to set the mask to my new mask so that's hey stop everything.... and then we raise SIGINT in other words we're pressing control C on ourselves we're trying to interrupt this process now as you and I know, because we set the procmask, that means that that signal is... generated but it's not delivered, it's in a pending state
so now we can carry on, let's change our signal proc mask to whatever it used to be we'll print exiting and we'll return zero right so let's see what happens, how far will we get in this program before it finishes? alright so we've sent out SIGINT nothing happened but then we changed the procmask again and that turned out to be our doom, our downfall by resetting signalprocmask to what it used to be, the signal could be delivered and of course what's the default behavior for SIGINT? kill the process. yes? there can be a delay so the system does not make any guarantees about when the signal will be delivered typically it will be as soon as you make an operating system call and that brings me on to my friday demo, I want to show you something really cool which is not directly related to signals but go on quick question yes, we're going to do that in a moment, we're going to make a thread to handle signals which is a nice engineering solution to working with signals but no I want to show you something called strace strace allows us to look inside the matrix, it allows us to see the operating system calls, it gives us a system trace of what a function is doing alright? so let me show you the code once more of... my little demo here, here it is okay we are going to set the um... called sigfillset, sigprocmask, we're going to write sending sig out, we're going to raise, etc so that's the code, now let's run this again with strace wahhhh lots of output okay, let's... scroll up here and make it a little bit smaller okay we can see every single system call that ran as part of this process you probably recognize quite a few of them right now first of all, what do we do? well after forking we had to call exec to actually load the process then we called break to discover where the beginning of the heap was we called mmap and we said we want to be able to read and write into this space we want it to be private, anonymous, etc  and just give me some space 4096 bytes negative one at the end tells me it's not associated with any file descriptor and then we call open on this LD thing and then we call fstat on that we call oh yeah it returns three sorry file descriptor three and then we call mmap to get that into memory give me a private copy with this file descriptor and here's the address that it goes in then we load the C library also file descriptor three because we closed it and we're going to mmap that so we're pulling the C library into our file system sorry into our virtual memory okay so we set up a few more memory mapped regions okay and here's the beginning of our code we are setting the signal masks see that puts being turned into a low level write call so a tgkill thing which is a low level version of our raise and then we set the signal process mask again and that's when our process gets interrupted by SIGINT so this is pretty cool right? you can actually see what a process does at the operating system level you can get between any process and all of the kernel calls that means that we can set our process up into lala neverland and make arbitrary return values to anything that asks for the system to do so strace is very powerful you can shim into every operating system call and see what it's being called with and see the return values right so that's our sigprocmask little demo let's go back to the handout right so I mentioned this hey instead of using signal, use sigaction here's how we use sigaction we need to give it a signal number and we also set up one of these structs struct sigaction with everything we need to do or we want to say what to do when a signal is delivered okay how do we set it up? inside my struct, I could have a regular handler just like we did with signal here's the function that should be called when the signal is delivered there's actually another function which allows me to get a lot more information about the signal but we're not going to talk about it in 241 but if you wanted to write a more complicated signal handler you might use this other function prototype instead okay what's different tough is that there's a mask a set of signals and these flags and it's important to remember to set up these other two items so here we go, here's some example code, right we're going to have our little struct we'll set up our handlers so that's our callback function let's do something with that mask I'll tell you what that mask does at the moment, typically you either empty it or fill it and then with our flags, typically you either set this to zero or sa_restart and then finally okay let's register for SIGINT this information so this set of signals does not affect delivery of the signal, this set of signals says what should be my mask when I'm actually inside the signal handler so for example, if I'm handling a SIGINT do I want to block all other signals do I want to prevent a SIGTERM from coming in now for our typical easy little programs naw we don't need to worry about them, we don't need to care about these race conditions but if you're writing something complicated when you might have to say prevent SIG control C but also make sure that realtime information, realtime signals are always processed then you might actually use this to work out which signals can temporarily block another signal of a lesser priority to you from being executed of a lesser priority to you from being executed
right so we'll just say hey we don't care we'll let all of the signals interrupt us right so that's a quick outline of this let's have a look at page two cause we're going to use it alright let's fix the code we wrote at the very beginning of the semester then when we talked about eating zombies how do we eat zombies? we call waitpid on them on the parent so our problem is that this signal handler isn't going to be called every time a child exits because if I have two children exiting at the same time, I might only get one signal remember? if a signal is pending, it has been generated I don't start queuing them up so if I had two children finishing at about the same time or if I have temporarily blocked all of my signals then.. then I want to be able to eat multiple zombies so here's how we can do that, the better code to do this then is to keep calling waitpid until there's no more zombies left to reap, until there's no more zombies left to find right so here's the typical way of doing this  there's a Â flag we can put in here to say actually... don't wait just return immediately if there is no more children to.. no more zombies to find then let me know about it [silence] and so we better put this inside a loop so here's our plan we'll say while the exit value is a valid child address so while this is greater than zero then I know I've got a valid pid and go around again and eventually I'll run out of child processes to reap okay how we doing for time? good so now it's your turn can you remember what to put inside this? so we've set up our signal hander how do we correctly install it? [silence] okay right so  we've set up the handler we better set up this mask if clearing zombies is the most important thing and we don't want to be interrupted by anything, not even say control C then let's say that we'll set the mask... on a... let's say mask.. what's that? it's going to be sa.sa_mask [writing] and then finally flags we could just say zero but there's something that's useful for real programs which is sa_restart so if you install signal handlers with sa_restart you're making your life a little bit easier in the rest of your program if you were to read say about write or read other function calls at the system levle sorry, other system calls you discover that some of them will simply return immediately without doing anything and give you an error which is E_interrupted or E_retry and E_interrupted means hey I was interrupted by a signal so I chose not to do anything ah thanks operating system, that's really helpful why don't you try again? do you want to play again? and so we have to write code that checks for the specific error condition that says I was interrupted and I want to restart well specifying this restart parameter in here... makes our programming a little bit easier because the number of times that happens is reduced it's I'm afraid not 100% but, it does do the restart for you automatically on some function calls again it's not worth knowing the big list, it's just worth actually going to say man -s7 signals and reading more about it if you are interested
great okay so we've got time for a final little demo and what we're going to do is instead of the system stealing one of our threads to handle a signal we are going to explicitly create a thread that pulls signals one at a time and handles them so its more code to write but it's less likely to.. it own't suffer from asynchronous signal problems if we're careful about how we... process our signals so let's.. I'll show you what I mean so what we're looking at today is... using SIGWAIT and I'm going to put that inside a thread who's only job is to say okay tell me the next signal that's delivered we can tell it in this case the mask is which signals do I care about [silence] so if I get a SIGINT, do some code, if I get SIGTERM do some code so for example, Java, if you sent it a SIGHUP will print out a whole load of debugging information about the garbage collector and other internals of the... stack traces and other internals of the JVM the apache webserver if you send it a SIGHUP signal will reread its configuration files so that you can make updates to the webserver without having to restart the process and deny people that are currently connected to it so this might be a way to do this, you could say oh look if I've got um... SIGHUP if I get this signal... then print something out or reread my configuration data today I'm just going to show you a demo with just a couple of these and we've got a little default case for our own purposes that calls fprintf which we wouldn't call normally inside the signal handler because it could be that the thread that we've stolen it from is already inside fprintf or inside malloc etc but by using our own explicit thread, we can do this, we can do it in a safe way right so let's have a look at a demo... yay okay great right so here's our plan we will set because we're a multithreaded process we will set our sigmask before creating other threads so that when we create a new thread, it inherits the same mask and our default mask today rather than just saying okay ignore everything what I'm going to do is addset and just put in two bits the bit for SIGINT and the bit for SIGTERM that means that if someone sends me a SIGINT of course there's no thread that is prepared to catch it both threads are blocking these signals and here's my application code sleep one, print dot and because I want to see the dots immediately I'm turning to my C library to immediately flush anything inside the C buffers so we can see the dots appear one a second and inside my thread, here we go, today I've got my... my important code that's going to present some debugging information what is that? oh it's just the name of the signal that was delivered okay so let's compile this right if I was going to compile it... like this, what will we see? it will complain right? undefined reference no one defined pthread_sigmask what we forgot to do is to tell gcc that we're trying to compile a multithreaded program so... here we go let's give it a pthread option good and now we've got ourselves a little demo and every second it's printing out dot and then flushing the buffer so if we now send it a signal... our single thread wakes up, returns from SIGWAIT and runs the code inside that case statement which just prints out SIGINT where did the control C come from? oh that's just the shell telling us that it sent a control C and so I can say ok stop stop stop stop stop and of course it never stops alright and but I can still call SIGQUIT and that will terminate the program and with that have a wonderful weekend and I'll publish a online version of these questions in subversion. thank you very much! thank you very much!
[silence] alright good morning class, how are you? hello myself how are you? right I am great thank you let's try again, good morning class how are you? okay great so here's our plan for today, we're going to run through and talk about these final exam questions if you're sitting by yourself please move until you're sitting next to somebody if you worked on these questions with your neighbors why not find a different neighbor that can maybe give you insight into the things you thought you knew and the things that you didn't think you know so please find some interesting neighbors at this moment secondly, I'll give you some tips on doing the streaming merge sort I'll talk about MP deadlines, we'll do an ask me anything and if we have time we'll do some tips on learning and prep for the final exam right so at this moment please find a neighbor and we'll take a few moments for you to compare answers and find out ask your neighbor stuff that you were unsure about [silence]
[silence] here we go so I did a quick poll to see which questions people would like me to go over in lecture I'll get through some of them today, others we'll get through before the end of the semester here's the game is that this is all stuff that CS241 UIUC students should know, it'd be embarrassing if you graduated and you didn't know this stuff, if you weren't able to explain it to other people say... in an interview or if you're on a team and you're getting more mature right? and so the idea is to say look this is less about okay learning in the classroom and you should start to be independent learners and also kind of use each other as resources and of course we have the wonderful WWW project with all sorts of factual information out there so I'm going to encourage you to actually be able to be independent researchers when it comes to CS knowledge okay so let's go through some of these but first let's take a little break and talk about what's coming up next week right the big one is the key value competition the very last MP is due at the end of the semester so Wednesday one minute before midnight all entries before then will be graded realize that if a hundred people were to submit at that moment, it would take say three minutes times one hundred, it'll take over 300 minutes before you see your result so if you want to leave it to the very last minute, be my guest, but realize that you're playing with fire you may not have a second chance of course to fix anything so early submissions you should see results early late submissions it'll take hundreds of minutes before you see a response before all of that, here's some other good news hey guess what there's going to be a last chance perhaps you got a zero on the MP because you were busy doing something else right or just made a silly mistake or don't panic you can still reclaim 75% of your points if you've already got at least 75% on a particular MP, you can ignore that MP and of course take the maximum of these grading runs and all prior runs so for everything except key value this applies on Monday, if you didn't finish MP merge part 2, here's your chance and by the way, we have made MP merge part 2 a little bit easier to earn for points if you can pass part two you get 95%, if you beat the TA's solution, you get the remaining 5% in the very first run of MP merge streaming, only 25% of the class were able to succeed at this task which it was a new MP and actually to be honest, it surprised me that it was hard so today I'm going to...  today, however, one is I'm going to give you a couple of hints and secondly you're different people than before right? you're brighter, smarter, better looking, ah that doesn't matter but you're brighter and smarter and so you should now be able to finish MP merge part 2 and do much better than you could than at the beginning of the semester right so we'll come back to that at the end of this class if you already did well, we're going to give you some bonus points instead yes at the back? uhh I believe there was a context page and I heard this anecdotally from the grading TAs, that only 25% of students... but I tell you what, I will ensure that an email is sent out in the near future certainly before the weekend okay right so yes I realize it's a busy time at the end of the semester, that's kind of always how it works isn't it? so see my FAQ, help I'm working too hard, yeah I'm sorry learning is hard right? also don't confuse recognition like oh I know this I have seen this before with actual ability to do something... yes? yes there will be something on piazza very shortly or the home page to say the URL for that similarly a URL for the key value as well alright so as you know, there's a big difference between being able to say oh I recognize this to hey I can actually recall this vs hey I can actually use this information vs I can actually debug a version of this vs hey I can create something based on this which satisfies additional constraints right? we're talking about different levels of  bloom's taxonomy of understanding and learning
right so yeah learning is hard I'm sorry if I knew a way to do the matrix for instance I know how to do systems programming, that would be fantastic but we can't do that just yet right so let's have a look at one of these problems today and this will actually help with the rest of the homework which is perhaps you can do this, I'll give you the answer in a moment, perhaps you should be able to do this, this is actually based on a final exam question remember the bitwise operators? these are not the logical operators, these are bitwise operators so we can use ampersand & for masking for example this is or | left << and right shift >> or right shift and left shift and so we want to use these to write some pseudocode as to how the hardware works right? can we actually write some C like code that would convert a pointer here it is here's my little pointer to one byte and determine the page number and the offset right so this shouldn't be too hard if you know your bitwise operators I'll give you just 30 seconds for you and your neighbor to have a go [silence] okay so here's the plan, we think of our virtual memory address in terms of two halves the lower bits will be our offset and we're just going to ignore those for a moment they'll come back to play at the very end when we add them back in and we've got a page number as well so the upper bits are our page number right so we can use our bitwise operators to extract this from our single pointer for the offset we want to write a mask so that we only see the lowest bits so we're going to say pointer & and now I want something that represents the twelve lowest bits, in other words if I was writing in binary it'd be 1 2 3 4 1 2 3 4 1 2 3 4 so that would be my binary representations and all the upper bits would be zero right can I convert that into hexadecimal remember hexadecimal each hexdigit corresponds to four bits right? so we should and it with 0xfff and the upper bits of this number are all zeroes right what about the page number? I want to take these bits and shift them to the right twelve times well I could divide by four thousand ninety six but instead why don't we just shift there we go so now I've got my page number if my hardware implemented a single level page table I could then use this to look up an entry inside that single level page table that would give me what? what's it called? what do we get when we look inside the page table? the frame! yes the physical frame so if I still use this, look it up inside the page table, I get a physical frame if I take that frame, I can now combine it with the offset to give me the actual address so the final address.. would be... take the frame shift it... left by twelve, put it into the right place and or it or add in the offset and that would give me the actual RAM address, the actual piece of RAM that I want to read or write to of course we're writing C code, my assumption is that our hardware engineers are not writing C code, they are probably writing verilog or vhdl or some other lower level hardware language alright so let's see if you can play with page tables then for this little example here's a virtual address this time I've got eight bit pages, they're tiny, and the following page table so using this, what is the physical address associated with this virtual address? so we're going to have to take this address and cleave it into a page number and a offset [silence] and the answer is... it's a trick question, you can't answer it yes? because... where's the offset going to be? the offset is going to be the lowest eight bits so the upper hexadecimal digits are your page numbers and I didn't give you... enough entries of this table, its somewhere off here so I didn't actually give you this particular entry right so let me stencil it in, so somewhere deep, much lower in the page table, there happens to be entry number 010203 and if we were to look up there and we found an address like... BAAD now you can tell me the actual physical address, I've got to take this and combine it with the original offset so in other words, the final address will be BAAD04 would be our physical address
questions about that? so you see when you use a page table things are slow because our page table itself is stored in memory so anytime your process wants to do anything read or write a piece of memory it first of all has to read this memory of the page table in order to calculate where to go in memory you've slowed everything down so to speed everything back up, we need a cache, what is that cache called? yes the TLB, the translation lookaside buffer because most of the time when we use an address, we use it again in the near future and so hopefully we have a cache hit, hopefully we have a high likelihood that we don't need to actually go back to our table to discover the answer so the TLB is part of the memory management unit, its job is to short circuit this lookup so that we can actually have good performance alright what does peterson's solution solve? do you know? does your neighbor know? if your neighbor said the critical section problem, congratulations you should sit next to that neighbor in a future class yes the critical section problem how dare I ask questions which are from weeks and weeks and weeks ago here's why, if you want long term memory of CS241 content the best way to actually learn something for the long term is to use your long term memory and so I'll be talking about that in terms of revision for the final and beyond right so it solves the critical section problem right malloc is thread safe but not signal safe the malloc you wrote was not actually thread safe but now you know about mutex locks you could have written a little lock and unlock around your code and made your malloc thread safe but it's not signal safe why? what's special about signal handling that's different from threads not quite yeah you're interrupting the process okay right yes you might interrupt malloc whilst it's executing malloc code reenter malloc and the data structure could be in a inconsistent state so it's a bit like... an analogy here might be you have a whole load of chefs coming in so you say I tell you what I'll have mutex locks so that only one chef at at time is allowed to use my kitchen so that's thread safe with signals, what you do to the chef is you say actually hold on chef I'm going to get you to come back to the room and cook this different recipe they walk in, there's the same thread, but now the kitchen is in disarray, the oven is already got something inside it, already set to a particular temperature and now your chef attempts to use these resources whoops, we can now get our memory data structures into an inconsistent state or we might try to lock a mutex that we've just locked resulting in deadlock because we were the thread that actually locked the mutex right and... here's one little challenge for you, okay think back in time to sempahores how do semaphores work? remember they don't let their count go below zero if you call sem_wait, it might block until someone else calls sem_post so I'm going to finish this code to make a barrier or rather you're going to finish this code to make a barrier what I want is so that the first four threads when they call this code are blocked but when the fifth thread arrives they all may continue but not before alright so how are you going to finish this code and what are the initial values for sempahore a and semaphore b alright this is a timed challenge you've got until I've done two laps of this and finished singing ackey breakey heart fortunately I sing very quietly  [silence]
 alright so we've got five threads walked into a barrie ow! what do we have going on here? well each time they walk into a barrier, they try to wait on A and then they increment a count if the count is something, hey let's post to the other semaphore and then let's always post to something else so this first semaphore sA looks like it's being used to define a critical section why should this be inside the critical section? we only want one thread at at time to be incrementing count or checking its value so if we make this post back to A then we can ensure that one thread at a time is incrementing the count so we can't have a race condition so that suggests the first value of sA is what? one, yes! so we allow one thread through but if another thread comes at the same time, it's forced to wait until the first thread has posted right so we're doing one at a time right now we said five threads so this is going to be if our count has gone up to five cause we're doing it after we've incremented the count what do we do? we post to sB this suggests if I want my early threads to wait... maybe I should set this to zero because why don't i wait down here and I'll wait until that count is incremented to one okay does this code work? does it let through any threads before the fifth thread arrives? can any threads get through? if I send it four threads can any of them get through? where do they get stuck? yeah the sem_wait waiting for sB so the first four threads get stuck at that line all waiting for the count to go up by one but on the fifth thread we call sem_post great we're done right? our code is complete. actually what happens instead? yeah one thread is lucky the other four not so much, one thread is going to say great I was able to continue the other four of course are going to wait forever but there's something we can do to that one lucky thread that is going to give us a domino effect right? and that is what? let's sem_post so as that thread walks out the door, it bumps up the count again freeing the next prisoner that prisoner, that thread walks out, bumps up the count, freeing the next prisoner and so on and so on until we have all five threads have left our barrier so that's correct code, what would have happened if we had switched these two around? perhaps you can explain it to your neighbor and decide if your neighbor's explanation is any good so what would happen there's not a barrier anymore, yes, before we called sem_wait we've added one to the count so now every thread will simply get through the moment it arrives so it'd be a useless barrier alright thanks for playing today's review questions right so let's talk about some other stuff first of all Monday I'm leaning towards having no quiz on Monday, no more quizzes but I'd like to just take a quick survey, if you would like one more quiz this semester on Monday do this, this way, if you'd like no more quizzes for the rest of the semester... do that Yes I'll still be dropping three the last quiz will be a quiz of all possible questions okay is that sufficient information for you to be able to make up your minds are you ready? go [something] has it, there were more people pointing in that direction so there will not be a quiz next week, no more quizzes right the next thing we'll talk about yes you can generate your own quiz simply by concatenating all possible PDFs okay so let's see we've got... we've done MP deadlines, streaming sort, oh yes right section tomorrow, section there is no prep for section, in section you will get your webserver finished we may add one small little thing to it as well and then the rest of the section time will be spent on MP development and MP finishing and MP questions plus there's an opportunity for you to give feedback on section experiences back to your course assistants etc so please come to section, also please bring your answers to section for points right? to get the four percent, bring your printed copies to section thank you very much right okay [silence] right once upon a time I had some data and my data arrived in chunks here it is there was a little callback that said hey I've got 256 numbers for you before returning, you have to copy those numbers out into your own area because by the time you return, that little buffer is going to be overwritten with the next set of numbers so that's the callback, to be given all of these, unfortunately you didn't know how many times you're going to be called back other than the fact that to make the MP simpler there was going to be 2^n number down here so it might be 4 6 8 16 32 etc etc etc
so our task then was to turn this into a merge sort problem in other words.. that two neighboring chunks of data should be combined each individual chunk was sorted using queuesort and we had say eight threads available to start doing all this merging now the naive TAs solution was actually not that hard to beat here's all it did it simply copied all of these into a large array and we made a fair guess about how big a size it should be but we did use realloc just in case the data was going to be larger than expected but we didn't start off with something small like hey 16 or 32 we gave it a big number because if realloc does need to realloc for space then it used to call malloc, it needs to then do a memcpy to move all of that data and talking to memory is slow so we made a good guesstimate about how big a buffer we would need it simply waited until we got all the pieces and then it used the part one code and then it printed out the whole result right how can we do better? in this regrade of this we're actually going to put in a small delay between each one to assure that there's actually some significant computational time to work on these items so some things that we can do which are better, obviously we've got 8 threads we could get started sorting this data before we see the very last piece of data the other thing we can do is at the very end we could actually start printing the results before we finished the final merge so in the very final merge, as we're pulling these two yellow pieces together if I got to here, I don't even need to write this data back I could be printing it out to a file as I merge these results together, so there's actually two optimization ideas right so what's the simplest way of doing some of these early merges well one is to say hey doing this stuff thinking about all these different levels is really really complicated for my tired brain and so get something simple working, here's a really simple idea is look at these in pairs look a lot of merging actually just takes down here at the smallest level so we could get some speed up just by thinking about these small blocks right so every time I see an odd numbered block, I'm going to start off the merge process to make myself a bigger block and so I could probably write that code just to deal with these smaller blocks the accounting, keeping track of all the statuses of these little blocks is not too hard and then when I finish making all of my lighter blue, my cyan blocks, then I'll just... give the rest of the problem to my original part1 code and just let it run through that right I should probably stop here because unfortunately... you are all two bright, you want to do better than this here's the danger, A writing C code is hard I'll give you an example of that on Friday when I talk about Toyota's C code and their embedded code inside their memory management unit various swear words have been defined to describe just what a mess this C code was so that's the first thing, look writing C code is hard, writing any code is hard second is that thinking about this algorithm is hard and sometimes it's good just to come up with something which you have high confidence in working, get that working and then have a go at something more complicated so I'll give you some hints about something that's a bit more complicated without going into a full algorithm and it's this let's label our blocks 0 1 2 3 4 you get the idea and also, we'll keep track of the blocks as to how much data they contain which is sorted so initially after we've done the queuesort I've got one block size of data and later up here I've got two block sizes of data so if I keep these labels then my labels correspond to where my blocks start in memory so let me call this block 0, this block 2, this block 4, this block 6 if I do this, then I can make the following observation my block size gives me a strong hint to which pairs I should be merging together so for example, on my cyan here, if I gave you block 4, you could say oh you should be merging that with block 6 if I gave you block 6, you could say oh you should be merging that with block 4 once they are of sufficient size so if I gave you a block 4 of size 2, you'd say okay great that needs to be merged with block 6 of size 2 if block 6 of size 2 is not yet ready, then do nothing and we can go the other way, hey here's block 6 of size 2, you should merge with block 4 of size 2 if block 4 of size 2 is not yet ready, do nothing, don't panic, don't worry about it because at some point block 4 will be ready in the future and it will merge with me
so how can I determine which blocks to put together okay let's have a look at this one, this is still zero and block four but this time the size is size 4 so if I gave you block 4 of size 4, you would say oh you should be merging with block 0 if I gave you block 0 with size 4, you'd say oh that should be merged with block 4 okay have I given you enough examples yet to see how we can determine which two blocks should be merged together I'm using exclusive or I'm xoring with the block number, the size so for example, here's block 8 of size 4 8 xored with 4 is 12 I'm flipping the lowest bit in the block number and eventually in my little example here I merge 8 with size 8, with 0 with size 8 one of these will come in last and I'll do the final merge and say oh look here's all the data I needed to merge, I'm done, I can start writing out the data if that is too complicated to turn into code I have two advices that's okay! take CS 373 473 then your brain will explode  learn about things like topological sort which I can't spell this morning and that's okay you'll remember this lecture with fondness, oh that was so easy compared to this topological sort is when you start to think about dependencies between actions and it has some relevance to this task in hand but you don't need, the other piece of advice is don't panic, you don't need to go this far to beat the naive TA's solution okay so let's turn ourselves back to some of these questions right some of these I will not address today, I'll talk about them on Friday, remember you are getting points for learning and not simply printing out the right answer let's do which scheduling algorithm describes the smallest average wait time? results in the smallest average wait time, the answer here is going to be preemptive shortest job first why? well you can construct examples where we might have a very long job and a whole sequence of small jobs and if you did that, the long job you want to put at the very end otherwise it holds up everybody else, it holds up all of the other processes waiting to run so how do we assure that the longest job is put at the very end? answer: shortest job first, yes! preemptive priority you would have to make sure the priorities are based on the length of the job which is not necessarily true the longest average response time, what's response time? well think about a webserver, a webserver might start giving you some packets, some results pretty early on but it might take several more milliseconds before you get the full response, we care about how early can we get the beginning, how long do we have to wait before we start to see some output? just the early output right so what's the longest average response time? first come first serve could give us a long average response time because the very last job submitted is not going to give us a response until finally all of the other processes have completed if we wanted a fast response time, what we should do is give each process access to the CPU as early as possible so what's an example of doing that? round robin yes! so round robin with a nice short preemptive, nice short quanta so that each gets to do some meaningful amount of work and start generating output okay minimizes response time round robin, waiting time shortest job first, total response time so this is response time of course all processes again round robin would be useful here how am i doing for time? right the other questions I will address on Friday I will mention I'll just finish with one important idea right psychological research has shown that if you want to learn stuff, if you want to remember stuff, the most important thing you can do is remember stuff what do we mean by that? is use your long term memory? how do i do that? easy start with a blank piece of paper, write down everything you know about every topic inside CS241 tomorrow, come back to the same piece of paper and write down more, do not use your notes, just write down more if you vaguely remember something put some question marks and some helpful hints the third day, do the same again the fourth day give up and yeah use your notes but you will discover that in trying to remember things, in actually exercising your brain stuff we start to come out of it in drips and drabs at first but it will actually ensure that you have a long term understanding of this material and with that have a wonderful week I'll see you on Friday!
at any frequency alright so we want to allow information at any frequency not just at multiples of the fundamental frequency but that really means that k times omega not is no longer really the right unit to use we don't really want to want to say let's get an integer multiple of some fundamental frequency what we really want to say is that let's let k go to infinity then we have an infinite number of units on the frequency axis that's a little tricky we had an infinite number of frequencies before we had an infinite number of harmonics of the fundamental but now we're going to  this was infinite in the way that the integers are infinite and now we're going to go infinite in the way that the real numbers are infinite so here's the maybe the most interesting trick today is that we're going to let omega naught the fundamental go to zero because we allow information at any frequency and we're going to take k  and turn it from an integer into a real number and specifically we're going to take k times omega naught and call that omega and call that a real number so is that a continuous spectrum of frequencies that's a continuous spectrum of frequencies so omega will be any real number any real-valued frequency pi is a valid frequency so we're going to take this formula and take its limit as capital T goes to infinity with k omega naught  being equal to omega and now that's actually a simple limit to take well we do care the problem is that the limit is zero so we have to get rid of it so we'll have to come back to worry about that here  because now we've taken this formula and multiplied it by T we'll have to remember that that vanished because we do have to remember it but there was no way to keep it we had to get rid of it in fact we'll define  X(omega) as the integral from  minus infinity to infinity of x(t) e to the minus j omega t dt and so looking at this formula right we're getting something like capital X of omega the fourier transform I need to write the title on here X of omega  is something like the limit as  capital T goes to infinity while k times omega naught  is equal to some number omega of capital T  times capital X sub k
There isn't a pair This is kinda cool actually that they're almost perfectly symmetric. In fact in physics they do it with half the frequency in hertz rather than with omega: the frequency in radians per second. And if you go through and do a variable substitution.. let see.. f is equal to omega over two pi. So d omega is equal to two pi f. You plug in a df over here you would get rid of this two pi, you would discover that they are even more symmetric. In electrical engineering we always for some reason do it in terms of omega Maybe because we like writing.. we don't like writing cosine of two pi f t, we like to write cosine of omega t And therefore we have have one (inaudiable) as the scaling factor. There has to be a one over two pi To go from X of omega back to x(t) is one over two pi That's the only scaling factor that occurs The other is the phase And remember where that came from. that came from orthogonality. That came from if you take this X of omega and plug it in here, you will get e to the j t times this omega time e to the j t times this omega subtracted so we get something that looks like this The integral from minus infinity to infinity of e to the j omega 1 minus omega 2 t  integrated dt So that's the integral from minus infinity to infinity of the cosine of omega one minus omega two t plus j times the sine of omega one minus omega two t And this is the principle of orthogonality. That integral is equal to zero if omega one is not omega two Orthagnality says that we can find these x of omegas in this way by just multiplying by e to the minus j omega t and integrating because the integral of cosine and omega 1 times cosine and omega 2 those two things multiplied together to get some other sinusoide  And any sinusoide has a zero average If I integrate over all time I get a zero for my average This infinity causes some problems, if omega one is equal to omega two, what is that integral equal to? The integrand is equal to one What is the integral? Plus infinity! That's a problem that we'll have to come back to in a few minutes. We don't have the tools yet to talk about what it means if omega one is equal to omega two at plus infinity But I want you to be able to recognize already that you have a j omega t in order to get x of t back again. That means that to get x of omega you need e to the minus j omega t because of orthogonality. Because that's the way you ... if you reconstruct this x of t using the sum of cosines and sines you have to invert the phase inorder to find x of omega from that That's because you want this integral to to come out to zero every time omega one is not omega two
[Students Talking] (Lecture starts at 3:05) Alright, welcome back. So, we have an exam tomorrow night in Animal Sciences Lab 150 from 7:00 to 8:15.  The exam covers homeworks 5 through 8, so essentially phasor response, sinusoidal steady state, and Fourier Series. Today, we are actually finishing chapter 7.2. 7.3 we'll still do next Monday. The Fourier Transform property number 16 from the table in the book is Parseval's Theorem. So, I want to talk about that. Actually, that table, remarkably covers quite a lot. It covers everything from chapter 7 through 9 are in that table. I'll introduce a few more properties as I go through today because I want to introduce them for the purpose of giving you more examples of Fourier Transform pairs. In particular, what we're really talking about today is energy. Energy in the Time Domain and the Frequency Domain. And, in particular, when we talk about how energy is distributed across different frequencies, that's this thing called the energy spectrum. And that's exactly the same for the Fourier Transform as the Power Spectrum was for the Fourier Series, where we had a distribution of power across different frequencies. So, first, let's talk aboutÂ Power signals and Energy Signals  I told you on Monday that signals that have finite total energy are the signals for which you can easily take a Fourier Transform. And that's almost, but not quite true.. We have these two things called Power Signals and Energy Signals, and in chapter 7, all that we're dealing with are the Energy Signals. But in chapter 9, we'll come back and talk about the Power Signals. So, Energy Signals are things that have a finite Total EnergyÂ where the Total Energy is defined.  Again, this is the Signal Energy. We don't know if it's a voltage or a current, so we can't whether we're going to multiply by r or divide by r or whatever. So, we just talk about this Signal Energy, which means we integrate total of the signal squared. You square the signal and then you integrate it's total over all time.
So, the examples that we worked with yesterday are the rectangle function and the triangle function and let me write those write those out again for the purpose of defining the triangle function the way it's defined in the textbook. The rectangle function is this thing. And what's the total energy of that signal? The output of W is equal to the integral of minus infinity to infinity of f of t quantity squared integrated dt. And, 1 squared is 1, 0 squared is 0, so this is the integral of 1 from minus 1/2 to 1/2, so that's 1. So that has a finite total energy, so it has finite Fourier Transform, and, in fact, we know that F of omega is equal to the sinc of omega over 2. Then, the other thing that we got to by the end of yesterday was something that was kind of triangle shaped in time. And it had a Fourier Transform that looked like a sinc squared. Let me put limits on those in order to define them using the definitions that are in the book. The book calls this one, let's call it g of t is equal to triangle of t, and if it's equal to triangle of t, that means it's the triangle that hits the x axis at plus and minus one half. And, that has a finite energy. I wrote in my notes that that the total energy of that is a half, but that's not true. Let's take a look at the total energy, W, with integral from minus infinity to infinity of g of t quantity squared dt, which I calculated incorrectly when I was preparing for the class, so I'm not sure off the top of my head what that is. It's not just the area under this curve, it's the area under the square of this curve, right? So, the square that and find this total area. Anybody know what the integral of 1 minus t squared [inaudible] is off the top of their head? Everybody knows how to integrate t squared, right? So, we could do that but I wont because I'll probably make a mistake on the blackboard and then it will look silly. So, instead, let me just write out the Fourier Transform, which I do have in my notes. G of omega is one half of 6 squared of omega over 4. Which means it has a total peak of one half, and it hits 0 every time omega over 4 is a multiple of pi. So, it hits 0 at 4 pi and again at 8 pi and so on. That's the standardized version of that triangle I showed you yesterday. Those are both obviously finite energy signals. In fact, there's something else that we can see: We can look at these and say that (alright, on down to something else that we can cover today) both of those are pretty much low-pass signals in the sense that in the frequency domain, most of the energy here is down at low frequencies. By energy I mean, sort of the square of the Fourier Transform. I haven't really defined that very well yet because I have to actually give you Parseval's Theorem. Rather than giving you Parseval's Theorem with these signals, let me swap those backwards by introducing a new Fourier Transform property. This one is number 6 in the book.
So those are sigmas for talking about things like common thing, our simplest theorem  as you reviewed for the Parsaval's theorem says in the Fourier series, talking about whether it is Fourier transform So in the Fourier Series, we have some symbol that duty, which is equal to the sum of k from negative infinity to infinity of capital s of k times e to the j k omega 0 t, it is periodic with some period of capital T  is 2pi over omega 0. All right? We say this has power spectrum magnitude capital S of k squared  so if you plot power spectrum as a function of k, we will be applying k on horizontal axis and magnitude of s of kth squared on the vertical  axis. And what we mean by that reallly is  that tells you how the power of f of t is distributed across different sine waves that are composed. It says that the total power, capital T, which is average square of the signal, integrating  over 8 complete period. And the magnitude f of t quantity squared, right? Here is the average power signal we take one complete period and integrating total energy of that period, and then divided by time   Parsaval's theorem says that that total power is actually distributed across different frequencies components And make it up, and actually the sum from k equals negative infinity to infinity of magnitude of s of k quantity squared so we can talk about part of power corresponds to DC component. That is f of 0 squared. part of it corresponds to the fundamental frequency, that is capital S of 1 squares the S of -1 squared part of it corresponds to the second harmonic, that is capital S of 2 and capital S of minus 2 and so on we can talk about how power is distributed across frequencies.  Well, for LTI system, the output is equal to  a triple omega times input, right? So we have this formula for phasors. We said that the power is equal to one half of  real part of v times i star, which equal to one half times the real part of magnitude of v squared  over Z. If it is just R, then it is magnitude of V squared over R, right? Where R is real part of Z, which is magnitude of one half times R times magnitude I squared.
That should look kind of familiar to you. What I've shifted in the frequency domain, what would happen if I flipped these two things around? Put this in the time domain and this in the frequency domain? I get the time-shift property, right? So this is yet another example of this duality of the Fourier transform, that the forward transform is almost identical to the inverse transform, and that allows us to say things like -- if I take f(t) and subtract t-naught from it, then it's Fourier transform is e to the minus j omega t-naught, times half of omega. And the only difference between the time-shift property and the flipped-around modulation property is the sign of the sign of the exponential. Normally, in some of the others... In the derivative property for example, the phase is flipped, and there's this extra scalar... But the extra scalar vanishes in this case because... Anyway, because it turns out that way. Because you do the intergrals and the extra scalar goes away.  There's one more thing that we need to know, though, and that is what happens if I multiply by cosine instead of just e to the j omega-sub-c t. But the Fourier transform is linear. If this is true for e to the j omega-sub-c t, then e to the minus j-omega-sub-c t, times f(t), that will have as its transform, well it's a modulation with the negative frequency. What on earth does that mean?  Well it just means a phase shift in a sense.  This is f of omega plus omega-sub-c.  So here's a shift to the right, and there's a shift to the left.  Positive frequency means we shift to the right, negative frequency means we shift to the left. If I take this, and add it together with that, I get the real value modulation property.  Cosine of omega-sub-c t, multiplied by f(t), gives me 1/2 F(omega - omega-sub-c) + 1/2 F(omega + omega-sub-c).  The Fourier transform is linear. If I add together something multiplied by this, with something multiplied by this, then I get the Fourier transform of one of those things plus the Fourier transform we have here. So let me draw some pictures.  Let me suppose in the time domain, s(t) looks something like this.  And let me suppose in the frequency domain, it looks something like this.  So let me suppose that it's relatively low frequency. Speech audio tends to drop off, well you CDs are sampled at 44 kilohertz, so the speech audio has to be limited below 22 kilohertz, in fact there's not much information at all above that [unintelligible]. Which is why you can transmit a pretty good telephone signal using only 8k samples per second. So if this is band-limiting to maybe 3000 hertz or maybe as high as 10000 or 20000 hertz, but much much less than 580000 hertz, then when I modulate it by multiplying it by cosine, x(t) is equal to s(t) times the cosine of some carrier frequency. Like this. What I get in the spectrum is s shifted to the lift plus s shifted to the right.  So I get that s of omega shifted out here to the left and shifted out here to the right.
Hello and welcome to Chem 233. This recorded webcast is the first recorded webcast for the course. This webcast will provide an overview of the course. First, my name is Dr. Shawn Miller and I will be your instructor for Chem 233. Before we begin, I would like to remind you that this recorded webcast is merely a summary of course structure and policy as outlined in the course syllabus. You are expected to read the course syllabus in its entirety and be familiar with its contents. This webcast is not a substitute for reading the course syllabus. For course announcements, please regularly check the Compass 2g course website and Piazza. We will talk about what Piazza is in a little bit. I do not send mass emails on a regular basis. I prefer announcements because they are a permanent location where you can always view the information I would like you to see. Please make sure you read the syllabus and check announcements on a regular basis. If you miss something important and it is located in either of those two locations, that is unfortunate. It is your responsibility to ensure that you are up to date on course information via announcements and the course syllabus. I suggest that you check for new announcements every day. If there is an emergency and I need you to know something immediately, I will send an email then. Chem 233 has two main components. The first component consists of webcasts, like the one you are watching now, and the lecture periods. This component of the course is focused on theory and problem solving. Via the webcasts and lecture we will discuss experiment background information, tips for performing an experiment, and work through practice problems. The second component of this course is the laboratory component. The laboratory component is focused on practical application of what you have learned and critical thinking. In this component of the course, you will perform experiments, collect data, and then draw conclusions and support those conclusions using the data that you have collected. After you finish this course, what should you have gotten out of this? Well, by the end of this course you will be able to explain the theory behind standard organic chemistry techniques and instruments. You will be able to solve problems utilizing fundamental organic chemistry laboratory concepts. You will be able to predict the outcome of an experiment using knowledge of the theory behind an experiment. You will be able to execute basic organic chemistry laboratory procedures efficiently and safely. You will be able to record relevant scientific data and observations and finally, you will be able to draw conclusions supported by provided spectroscopic data or your own recorded laboratory data. Thats a lot of goals. How will you practice achieving these goals? You will practice achieving these goals by first, watching the recorded webcasts and actively participating in the discussion formatted lectures. Let's talk about these webcasts and these lectures. Every experiment will have one or more webcasts associated with it. You are responsible for watching those webcasts prior to coming to that lecture period associated with that webcast. These webcasts, like the one you are watching now, are viewable on the Compass 2g website and you can view them as many times as you wish. A typical webcast will present both the theoretical background information for a topic, as well as practical and safety considerations for the associated laboratory experiment. When watching these webcasts, it is highly recommended that you take notes like you would for any other lecture. You will find these notes useful when it comes time to say prepare for a post lab quiz or for an exam. If these webcasts are the primary method for communicating information to you, what are we going to use the lecture periods for? Attendance at lecture periods is optional. What we will be doing in these lecture periods, if you decide to attend, is we are going to treat them like we would treat a discussion section where we will work through worksheets that you will find on the Compass 2g website. These worksheets will be a combination of multiple choice questions, free response questions and other practice problems and calculations. If you decide to come to lecture, please remember to bring your clickers and to print out and bring the worksheet associated with that lecture ahead of time. Prior to coming to lecture, you will also have the option of completing a survey on the Compass 2g course website. This survey is designed to solicit feedback from you on what topics you feel you are most uncomfortable with. your response will help guide me on what to focus on in the lecture periods. For the laboratory portion of this course, you will practice by preparing for lab at home via reading the lab manual, completing the pre-lab quiz for that experiment, and completing your pre-lab notebook. You will arrive on time for every lab in proper attire, and then you will preform laboratory experiments. When preparing for and performing these laboratory experiments, you will do this in the mindset of 'What am I doing and why?' instead of 'I'm just going to go and do what the procedure tells me to do'. Everything you do in an experiment has a purpose and if you can rationalize what each step is supposed to do, that means you have a solid understanding of the theory behind that experiment. How will you prepare for these labs? First, we must talk about what types of labs you will perform in this course.
The first type of lab is what we call a dry lab. As you can see in the schedule in the course syllabus the first three experiments in the course are dry labs. Dry labs are labs that will be on spectroscopy. These dry labs will not be performed in your assigned laboratory room, instead these will be done in assigned classrooms working in small groups to solve spectroscopy problems. That will be located in provided worksheets. The other type of lab is a wet lab. A wet lab is what you might think of a traditional organic chemistry lab, where you will enter a laboratory and perform some chemistry. The procedures for these experiments are located in your lab manual. Now that we know the two types of labs that you will be performing, how do you prepare for each of them? For dry lab, you will watch the webcast or webcasts associated with that experiment and take notes. For a dry lab, there is no pre-lab notebook. There is however a pre-lab quiz which you can find online on the compass2g course website. It is important that you complete the pre-lab quiz. If you do not complete the pre-lab quiz you will not be allowed to perform the experiment. As mentioned previously, these dry labs will not be performed in your normal laboratory room. Before going to your dry lab you'll need to identify the time and classroom you'll be performing the dry lab in by looking at schedule posted on the compass 2g course website. You can do this via using you lab section number and/or your TA's name. Preparing for a wet lab is similar. As with the dry labs, you will watch the associated webcast or webcasts for an experiment and take notes. You will then read the lab manual pages for the experiment while thinking about how the procedure lines up with the webcast. If you can explain how each step fits with the theory discussed in the webcast, then you have a good handle on what the experiment is trying to do. You will also watch any assigned technical videos located on compass. These technical videos will show you how to perform each technique ahead of time. For example, in the TLC experiment, there is a technical video that will show you how to set up a TLC plate. That way you will have some ideas what to do when you actually get to lab. For a wet lab, there is a pre-lab notebook and you must complete that pre-lab notebook according to the instructions in your lab manual. You must complete the pre-lab quiz associated with that experiment on compass. If you do not complete either your pre-lab notebook or your pre-lab quiz you will not be able to perform the experiment. Because this is a technical course, or a significant portion of your grade comes from performing experiments, attendance at each lab is required. Make-up labs are difficult to arrange. Do not assume you will be given the opportunity. If you know ahead of time that there will be a conflict due to religious or other accepted reasons, it may be possible to arrange for a make-up experiment if you provide enough notice, at least one week in advance. It is important to arrive to lab early. At the beginning of every lab period, your TA will give a short lecture just to go over the highlights of what the lab you will be performing is, some tips to perform it efficiently and safely, some things like that. You must be there for that lecture. If you arrive during the lecture, you will receive a 10-point deduction from your lab notebook score. If you arrive after the lecture is completed, you will be prevented from performing the experiment at all, even if you completed the pre-lab quiz and the pre-lab notebook. That's a lot of things to practice, and mostly on your own. What kind of support will you be given? The final part of practicing for any course is getting help and discussing the material with other people and you will do that with your peers, with myself and your TA, online using Piazza or in person at office hours or via email. In this course you have the option of using Piazza. You can find enrollment instructions for Piazza in the course syllabus. Piazza is a free service which you can think of as a course forum or a course wiki. How it works is you have a question and you can post a question that is viewable to everyone. It is also answerable by everyone that means that me, the TAs, and your peers can answer your question, meaning you're more likely to get a rapid response. It also means that because these questions are public, that if someone has already asked the question you were going to ask and received an answer, you can simply look at their question and their answer to solve your problem. When posting on Piazza, if you wish, you can post anonymously to your peers, but be aware that instructors including myself and TAs know who you are when you post so make sure that you are polite and follow the rules for posting on Piazza. Do not be afraid to ask questions. Now this is a two-way street. if you are asking questions you should also be trying to answer questions. Be active and help each other out. If you're a little nervous about trusting the answers from you peers, don't worry both me and the TAs will be checking every answer that gets posted and make sure the information you are receiving is good information. Let's say you really want some face-to-face time with either me or your TA. You can always go to office hours. My office hours are located on the course syllabus and your TA's office hours will be posted online within the first week of the course. If you can't come to office hours, but would still like some face-to-face time, email me or your TA and we will do our best to make ensure we can schedule a private meeting. And finally, of course there's always the old standby of email. You can always email either myself or the TA if you have a question. If there are personal concerns you need to discuss with me, use email and not Piazza. Contact me directly.
So far we have discussed what you should be getting out of the course when you're done how you will practice achieving those goals. Now we're gonna talk how you will be assessed how your grade will be assigned. You'll be assessed using a number of different tools the first of which is a 'Getting Started' Quiz. This Getting Started Quiz is designed to assess how well you understand course policy and laboratory safety. To prepare for this quiz you should be familiar with the course syllabus, the lab manual, and the introductory webcasts being this webcast, the lab safety webcast, and the fundamentals webcast. Some of the questions in this quiz will have answers that are not located in any of these sources. Part of working in the lab is having some common sense, and you should expect questions that will test your common sense. This quiz is graded at the time of submission, in other words right after you submit it so you can take it as many times as you wish to maximize your score prior to the deadline. There will also be a pre and post lab quiz for every experiment in this course. For every lab experiment there will be one short electronic prelab quiz that you will find on Compass. This prelab quiz is primarily designed to be a safety check to assure that you have a fundamental understanding of the experiment. That means knowing what the procedure is going to be and knowing the safety considerations for the experiment. If you have prepared for the experiment properly by watching the webcasts and completing the prelab notebook these quizzes should take you no longer than 5 minutes. These quizzes are very short and are designed to be easy to complete if you've done your homework. You may use your notes for these quizzes, but you must work alone. For each quiz, you will be allowed 2 attempts. The 2nd attempt is designed to accommodate any difficulties you may encounter. For example locking out accidentally or submitting early. Be aware that the final attempt will always be the attempt that is accepted. If you successfully complete the quiz once then take the quiz again but get a lower score, that's the one that's going to count. The second attempt will always be the one accepted even if that score is lower than the first one. Each lab experiment will also have one electronic post lab quiz that you will find on Compass. The post lab quiz is designed to test something different. The post lab quiz is designed to assess your knowledge and understanding of the theory and practical aspects of the experiment. You should treat these post lab quizzes as practice for the exam. This means that you should be comfortable with the materials in the webcasts, and if you have taken notes, you may use those on this quiz. As with the pre lab quizzes, you'll be allowed 2 attempts to complete this quiz again to accommodate any technical difficulties you may encounter, and once again the second attempt will always be the one that is accepted even if that second attempt score is lower than your first attempt score. As this is a lab course, you will also be assessed based on your lab experiments and your submitted lab notebooks. What you submit will depend on the type of lab. For dry labs, it's pretty simple. You will be given a packet to work on, and once you complete your packet you will submit that packet to your TA for grading before the end of the period. For wet labs, you will be submitting your lab notebook pages. This will include the prelab work that you put into your notebook as well as the notes you take during the lab and the conclusions you write after the lab. Taken as a whole, the notes in your lab notebook should be complete enough that any other student could repeat your procedure exactly as you did and get the same results. This means recording things like actual amounts of materials used, writing down any deviations from the procedure that you made, and specific data and observations that are requested. Instructions on what to record can be found in your lab manual. You will also find in your lab manual an example pre lab and post lab notebook. Look at those and use them to guide you on what you should be including and how your notebook should look like. Once you've completed an experiment, you will then take the perforated pages which for most of you will the white pages of your lab notebook and submit them to your TA. Your TA will grade these notebook pages based on completeness, the recording of relevant data in the correct format, correct calculations, and reporting your results based on that data, quality data analysis, and so on. A description of what we're looking for can be found in your lab manual. The rubric that will be used to grade your first wet experiment will be publicly posted on the Compass 2g course website. This will be the only rubric that will publicly posted. However, the format for the rubric for all subsequent wet experiments will be roughly the same. Feel free to use this rubric as a reference as you proceed through the course. Finally, there will be two exams and a laboratory practical.
Exams will be held as shown in the schedule in the course syllabus. These will be traditional exams. You should expect multiple choice questions, free response questions, and other types of questions that are specific to organic chemistry. Laboratory practicals are different. Laboratory practicals will be designed to test your practical skills, your ability to perform organic chemistry laboratory techniques. These will be held as shown in the course syllabus during your normal lab period. We have just finished discussing all the many bits and pieces that will combine to make up your grade. The Getting Started quiz, your pre-lab quizzes, your post-lab quizzes, your lab notebooks, the two exams, and your lab practical. Your letter grades for this course will be assigned as described in the course syllabus. The lowest pre-lab quiz, the lowest post-lab quiz, and the lowest experimental scores will be dropped at the end of the course. These don't all have to be from the same experiment. For this course, there will not be what you might call a curve for most components. For the experimental scores, and experimental scores only, there may be a standardization if and only if there's a significant difference in grading between TAs. So far in this webcast we have discussed many different aspects to this course: webcasts, lectures periods, lab periods, quizzes, notebooks. How does it all fit together? Here is a diagram which hopefully will help you see how everything in this course fits together. For the lecture portion of this course, you will watch webcasts and read the lab manual. Having done that, you will have the option of attending lecture sessions where we will work through problems. For the last portion of this course, you will watch webcast and read the manual, and then having done that you will complete your pre-lab quiz and your pre-lab notebook, which will allow you to perform the associated experiment. Once the experiment is done, you then need to complete a post-lab quiz. The material in your post-lab quiz will be a combination of material from the webcast and material from the experiment itself. Notice how in this diagram the arrow leading from the lecture portion of the course is larger than the arrow leading from the experimental portion of the course. That is by design. The post-lab quizzes will be comprised primarily of material from webcast because your post-lab quiz is designed to test your understanding of the theory and fundamentals behind each experiment. The optional lecture sessions will solve problems that will help you prepare for these post-lab quizzes in the same way the optional lecture sessions prepare you for the post-lab quizzes, the post-lab quizzes are designed to prepare you for the exams. One feeds into the other. The lab portion of the course is similar: complete the pre-lab quiz and pre-lab notebook to prepare you for performing the experiment, which in turn will prepare you for performing the lab practical. Congratulations, you've made it to the end of the first webcast for this course. However, there are a few other webcasts that you need to watch. Remember to watch the 'Intro to Spectroscopy' webcast before coming to the first lecture session. You should also watch the fundamentals webcast if you are concurrently taking CHEM 232 or need a refresher on organic chemistry fundamentals. You also have a lab safety webcast to watch. You should watch that before the due date for the Getting Started quiz. You will find some of the material in the webcast in the Getting Started quiz.
Hello there, this introductory webcast will be about laboratory safety. This recorded webcast will summarize laboratory safety details that you will find in the course syllabus and in your lab manual. you are expected to read the course syllabus and the laboratory manual and be familiar with everything in them. this webcast is not a substitute for reading the course syllabus or the lab manual. One of the biggest parts of lab safety is being prepared for lab before you make it to lab. Knowing what you will be doing is the first step for performing an experiment safely. If you walk into lab with no idea as to what you will be doing, that makes you a danger not only to yourself but to your partner and to everyone around you. This is why before coming to lab, you must complete your pre-lab notebook and your pre-lab quiz. If you fail to complete either of those things, you will not be allowed to perform the experiment. When you come to lab, you should bring a certain set of materials. This includes your lab notebook, your safety goggles, your lab coat, a calculator, and a pen using blue or black ink. Anything else, including copies of the lab manual and your cell phones should be stored outside of the lab in the provided lockers. There is just not enough space in the labs themselves to hold all of the materials you normally bring to a course. Once you are in the lab, you must remember this rule: you must listen to your TA. They are there foremost for your safety. One of the things your TA's will be doing is ensuring you are wearing proper attire. TA's can and will ask you to leave if you have not worn the proper clothing and/or brought the proper safety equipment. This is more than simply having it with you, you must also wear the material correctly. For example, goggles must be worn over your eyes at all times. They do not do you any good if they are resting on your forehead. Similarly, lab coats must be on and buttoned at all times. Your feet and legs must be completely covered. That means full sized pants or skirts and shoes that cover the entirety of your feet. If you have long hair, it should be tied back, so as to avoid being dipped in or tipping over materials in the lab. Similarly, you should have no dangly clothing. Scarves, oversized lab coats, neckties, bulky sleeves, things like that. These types of things tend to knock a lot of equipment over, potentially causing a safety hazard. Lets talk about goggles first: here are a number of different types of safety goggles. Not all of these goggles are acceptable for you to wear in the laboratory. For example, if you look in the upper left hand corner, we have what are more correctly called safety glasses. These glasses are designed to protect your eyes from impact. They will not protect your eyes from spills and so safety glasses are not acceptable attire. Similarly, in the bottom left corner, we have a set of typical eyeglass with what we call sideshields. Again, these are designed to protect your eyes from impact, but not from spills, so these are also unacceptable. You must wear lab goggles of the type that you see in the upper right and the bottom right. These lab goggles create a seal around your eyes so that even if you spill something on your face, the liquid cannot drip down into your eyes. As mentioned, these must be worn properly at all times. Your TA can and will deduct points from your lab score for continuous improper use of your goggles. The proper type of lab coat must also be worn. Lets look at the lab coat on the left: it's buttoned up correctly, but what's wrong with it? The problem with this lab coat is it is too short. your lab coat must reach down to about your knees. That provides the maximum amount of protection for most of your body. Knowing that, you can probably tell what's wrong with the lab coat in the middle. The lab coat in the middle has short sleeves. Your lab coat must have full sleeves. Having full sleeves provides the maximum amount of protection for your body. The lab coat you should be wearing should look like the one on the right. This lab coat has full sized sleeves, it reaches all the way down to almost the knees, and fits properly. Do not wear a lab coat that is too small or too large. As with lab goggles, TA's can and will deduct points from your experiment score for improper use of lab coats. Your lab goggles and lab coats are only one layer of safety. The clothing you wear underneath them is just as important. As mentioned previously, a proper lab coat provides maximum protection for your body. The clothing you wear underneath must also provide the maximum amount of protection for your body as possible. So for example, things like shorts, and capris are unacceptable. They do not provide enough coverage for the lower portion of your body. Similarly, sandals and slippers are also unacceptable. They leave exposed skin and thus do not provide enough protection for your body. This list here is not an exhaustive list, TA's have the authority to decide whether the attire is appropriate or not. Ensure you read your lab manual so that you know what we are looking for when deciding whether attire is appropriate or not. And if you have questions, you can ask ahead of time. At the end of an experiment, you will always have waste, you will always have leftover stuff that you have to get rid of.
This waste must be disposed of properly. Different types of waste go into different containers. You can read about what types of waste go into each waste container in your lab manual. Inappropriate mixing of waste streams, or in other words, different types of waste, is a safety hazard. If you don't know where your waste should go, don't be afraid to simply ask your TA. Remember they are there primarily for your safety and they will be happy to tell you into which waste bucket to place your waste. If TAs see you disposing of waste in an improper container, they will deduct points from your experimental score. It is better to ask than it is to lose points. At the end of your experiment, you and everyone else in your section must ensure that your lab is clean. There are portions of the lab such as the weighing balances, the sinks, and the waste disposal areas and so on that don't belong to any one person. As a result, they tend to get messy fairly quickly. These community areas do belong to all of you, and so all of you are responsible for ensuring that these areas are clean and organized. To reflect this, your TA will grade the cleanliness of your lab after every experiment. These lab cleanliness points will be the same for everyone in the section. Before you leave, ensure that all community areas have been cleaned appropriately. The rubric that will be used to assign your lab cleanliness grades can be found on the course website. As mentioned throughout this webcast, there are many penalties that can be given if you do not abide by the safety rules. In addition to the situations we have discussed in this webcast so far, your lab notebook experimental score can be reduced as a result of other safety infractions. Examples can be found in the course syllabus. Each infraction will reduce your lab score by 10 points, up to a maximum of 20 points per lab. If you continue to commit infractions even after losing 20 points, you may be dismissed from the lab and forfeit all lab points associated with that experiment. To get you up to speed at the start of the course, there will be a lab check-in. Lab check-in is mandatory. Any student failing to attend the lab check-in and a safety orientation will receive a failing grade for the course. Lab check in is where you'll meet your TA, be assigned a lab drawer, and locate important safety equipment inside the laboratories. If you know that you will be unable to attend check-in, you must give prior notice to the instructor with proper documentation for an excused absence to avoid that automatic failing grade. Check-in procedure can be found in your lab manual. During lab check-in, you will locate important safety equipment in the lab so you know where they are and how to use them. That brings us to the end of this webcast. Remember, above all else in this course, safety is a priority. Ensure you listen to your TA< keep an eye on each other, and exercise good common sense.
Hello there. In this fundamental webcast, we will be discussing line structures. Line structures are the most common way organic molecules are drawn in organic chemistry courses. Being able to interpret and draw line structures is critical to your success in organic chemistry. Before talking about line structures, let us first discuss organic molecules in general. For some basic facts about organic chemistry and organic molecules in particular, organic molecules are comprised primarily of carbon and hydrogen atoms. However they are not comprised exclusively of carbon and hydrogen. Remember that heteroatoms are non-metallic, non-carbon, non-hydrogen atoms. Common heteroatoms that appear in organic molecules include nitrogen, oxygen, and the halogens. Other heteroatoms such as sulfur and phosphorous do appear in organic molecules, but will not appear in this course. One of the most important skills you will acquire in organic chemistry is how to draw and interpret organic molecule structures. Molecular structures are how we show what atoms are connected to what other atoms. If you are concurrently taking CHEM 232, you will be discussing this topic there as well. So think of this as studying the same material for two different courses. To begin, let me draw you a molecule called 3-butene-1-ol. You don't need to know anything about this molecule, you don't need to why why it's called that, or memorize its structure. I'm simply using it as an example. When drawing the structure, you have to show what atoms are present. In this case I'm going to start with this carbon. And you also have to show what is connected to those atoms. These lines you see me drawing between that C, which stands for carbon, and that H, which stands for hydrogen, is a bond. And now I'm going to draw another bond from this carbon to an adjacent carbon, but this time I wanna add a second line. That second line is also a bond. This is a double bond, which hopefully you remember from general chemistry. The carbon-hydrogen bonds are single bonds, and the carbon-carbon bond I have drawn here is a double bond. I'm going to continue drawing this molecule. And there we go. That is 3-butene-1-ol. You can see that I have four carbons present in this molecule, right down the middle. Remember the octet rule from general chemistry. In organic chemistry, the most common atoms you will find are carbon, nitrogen, oxygen, and hydrogen. Carbon, nitrogen, and oxygen are all second row elements, which must follow the octet rule. Notice how every carbon in this molecule follows the octet rule. Now let us look briefly at the oxygen. If you look at the oxygen, what I have drawn, that oxygen only has two bonds, therefore it is not following the octet rule, right? Well, not quite. Also remember that atoms can have lone pairs, and that's what this oxygen possesses. Now we can see that this oxygen is also following the octet rule. What I have drawn here is a structure that corresponds to 3-butene-1-ol. However this is not how most organic chemists would draw the structure. How most organic chemists will draw the structure is what I will draw on the right. And I'm done. Now, compare how long it took me to draw the structure on the right to how long it took me to draw the structure on the left. The structure on the right is what we call a line structure. And as you can see, the line structure is comprised mostly of lines. Now, how does the line structure on the right correlate to the structure I originally drew on the left? When drawing or interpreting a line structure, there are a few rules you need to be aware of. Located at the intersection, corners, or vertices, whatever word you prefer, of a line structure, you will find carbon atoms. That means this atom on the left which I am circling in red is a carbon atom, this corner next door is a carbon atom, and I'm going to continue down the line structure, putting a red dot over all of the carbon atoms. Do you see how these carbon atoms correlate to the structure I drew on the left? Where this carbon on the farthest left is that carbon atom? Notice how this has a C double bond. This also has a carbon double bond. And as we go from left to right, you see how these carbon atoms correlate.
To the structure on the left. so rule number one of line structures: every intersections, every corner, every vertex corresponds to a carbon atom. now let's move on to the second rule, maybe you have already recognized that these lines that connects the carbon atoms corresponds to the bonds. For this line, which i'm overlaying in blue, is a bond. this other line is a bond, and this line is a bond, and so on. and you can see how that carbon-carbon double bond have two lines[ where i have a second line denoting that double bond. so in a line structure, every line corresponds to a bond. if you have two lines, you have a double bond. if there are three lines, you would have triple bond. you may have notice how the line structure is significantly less cluttered than the original structure i drew on the left. this is because we have not drawn in the hydrogens. in a line structure, the hydrogens are implicit. they are not drawn, but we know they are present. let's go ahead and draw in the implicit hydrogens in this line structure. hopefully you can see how these hydrogens in the line structure map on to the hydrogens in the original structure on the left. you can see this carbon here on the left had 2 hydrogens attach to it, and this carbon here on the left also has 2 hydrogens attach to it. in a line structure, the hydrogens attach to carbons are generally not drawn, this is to reduce clutter to make it easier for us to see the rest of the molecule. as you might imagine, as we get to larger and larger molecules, we're going to have larger and larger numbers of hydrogen atoms present. and draw all those hydrogen atoms is both time consuming and makes it more difficult for us to see the rest of the molecule. note how in this line structure it was only the hydrogens on the carbons that were implicit. the hydrogen attach to the oxygen atom was drawn, as you can see. hydrogens attach to heteroatoms, that means hydrogens attach to oxygen and nitrogen, both commonly are always drawn in line structures. the reason that hydrogen atoms attach to heteroatoms are different than hydrogen atoms attach to carbons is because hydrogen atoms attached to heteroatoms are often used in chemical reactions. they're often very important in reaction mechanisms. in contrast, hydrogen atoms attached to carbons are not used often, so it is usually ok to simply leave those implicit. also notes how i have not drawn the lone pairs on the oxygen atom. i can do that. i think i would've had drawn in those lone pairs if i wish, but it is not required. you can draw them in, there's nothing wrong with draw in the lone pairs, and in fact, it may be better for you at the start to draw in those lone pairs so you remember they are present. however, when given a line structure, always remember that heteroatoms have lone pairs, even if they are not already drawn in for you. to recap the basics of line structures; in a line structure, every intersection, every vertex, every corner, whatever description works best for you, corresponds to a carbon atom. you can see that via the red dots on this line structure. every line connecting one atom to another atom is a bond; more lines means more bonds. so one line is a single bond, two lines is a double bond, and three lines is a triple bond. in a line structure, the hydrogen atoms attach to carbon atoms, are implicit. they are not drawn, that doesn't mean they are not there. the hydrogen atoms are always there because remember, carbon must always obey the octet rule. that means if you see a line structure, such as you see here on the right, you must remember that if this carbon has only 2 bonds shown, there must be 2 implicit hydrogens atoms present in order to obey the octet rule. hydrogen atoms attached to heteroatoms such as oxygen and nitrogen are always drawn. finally, the lone pairs on heteroatoms can be drawn but don't have to be. so if they are not drawn for you, do not forget that they are there. we use line structures so that drawing the structures like i did on the left because line structures are faster to draw, they have significantly less clutter, and they are more representative of the actual shape of a molecule. on the left i have drawn all these bonds at 90 degree angles. however, you know from vsper theory, which you learned about in general chemistry, that most bonds aren't at 90 degree angles. you may remember that this carbon is sp3 hybridized, therefore it is tetrahedral. and that this carbon here is sp2 hybridized therefore it is trigonal planar. and you can see how the line structure better reflects that reality. for this carbon if i draw in that implicit hydrogen, remember this carbon is sp2 hybridized, therefore it's molecular geometry is trigonal planar, therefore the bond angle should be 120 degrees. and this line structure indeed shows 120 degree angle.
Look at the carbon on the right. We know that there are two hydrogens attached. It is sp3 hybridized, therefore it is tetrahedral in geometry. And while these bond angles are not 109.5 degrees, they are closer to that than what we saw here on the left. Now let's get some practice interpreting line structures. On this slide, I have four line structures. Let us go ahead and identify the carbon atoms in the line structure in the upper left. Remember that every corner and every intersection in a line structure is a carbon atom, so let's go ahead and find those. One here at the end, one here, and we continue down the line structure. Every one of those dots is a carbon atom. Therefore, there are six carbon atoms present in this molecule. What about hydrogen atoms? How many hydrogen atoms are present? Because we are just starting, let's go ahead and draw in the implicit hydrogen atoms to make that counting easier. Look at this carbon farthest left. This carbon has two bonds drawn connecting to it. Therefore, to fulfill the octet rule, there must be two hydrogens attached. Let's also look at the carbon next door. This carbon has three bonds connected to it. One, two, and three. To fulfill the octet rule, this carbon must have one hydrogen attached to it. Now, let's go over one more. This carbon has one, two bonds already attached to it. Therefore, this must have two hydrogens attached to fulfill the octet rule. And as you continue down, we simply follow that same rule, until all carbons have fulfilled the octet rule using hydrogen atoms. Notice how this carbon here has no hydrogen atoms attached. That is because it already has four bonds. One, two, three, and four. Therefore, there are no hydrogens attached to his particular carbon. Let's count the number of hydrogens present. One, two, three, four, five, six, seven, eight, nine, ten. There are ten hydrogens present in this line structure. How about double bonds. Are there double bonds present in this molecule? Yes, we see that this carbon-carbon connection here is a double bond. And we see that this carbon-oxygen connection is also a double bond. Remember that every line corresponds to a bond. If there is one line, it is a single bond. If there are two lines, it is a double bond. Now, what I would like for you to do is to pause the video and do the same analysis for the remaining three structures. Identify how many carbon atoms are present in each line structure, and how many hydrogen atoms are present in each line structure. What I suggest you try to do first is to identify the number of hydrogen atoms without drawing them in like we did here. An important part of organic chemistry is being able to interpret a line structure without drawing in all of the implicit hydrogens. So go ahead, pause the video for a few minutes and tell me how many carbons are present in each of the remaining line structures and how many hydrogens are present in each of the remaining line structures. Welcome back. Let's see how you did. Let's look at the structure in the upper right. How many carbon atoms do I have? I have one, two, three, four, five, six, seven, eight, nine, ten carbon atoms. How about hydrogen atoms? Let's go ahead and draw those in just for this one. I have one hydrogen attached to this carbon. Why only one hydrogen? Well let's look at that carbon. We have one bond, two bonds, three bonds. Therefore, this carbon needs only one hydrogen to fulfill the octet rule. And that is the same for all these other carbons on this side of the molecule. What about these carbons in the middle? How many bonds do those have? One, two, three, and four. These carbons in the middle already have four bonds. Therefore, they have no hydrogens attached to them. And if we go around the ring, we see that each of the remaining carbons have two hydrogens attached to them.
And if we count them, we can see that we have one, two, three.....eleven, and twelve hydrogens on this molecule. Now, let's look at the structure on the bottom left. I see four carbons and I see eight hydrogens. If you only counted six hydrogens, don't forget to include the hydrogen atoms attached to the heteroatoms. Those are also present. They are important to count. If we go to the structure in the bottom right, I see six carbon atoms, and fifteen hydrogen atoms. If your numbers don't match mine, then go ahead and draw in the implicit hydrogens and count again. Hopefully, this section has been good practice for you in learning how to interpret line structures. That brings us to the end of this webcast. To recap: Line structures are an efficient way to draw organic molecules. As most atoms in organic molecules are second row elements, most atoms obey the octet rule. In a line structure, each vertex or corner corresponds to a carbon atom. Each line corresponds to a bond. Because carbon follows the octet rule, each carbon atom with fewer than four explicitly drawn bonds must be connected to implicit hydrogen atoms. The number of hydrogen atoms connected to each carbon is the number needed to get that carbon atom up to a full octet. Or, in other words, four bonds total.
Hello there, in this webcast we will be talking about functional groups. Understanding functional groups is critical to understanding organic chemistry, but even before that, to simply talking about organic chemistry. This webcast will discuss what functional groups are, why they are important, and how to identify and name them. There are many ways to take atoms and connect them and put them together. Fortunately for us there are many combinations of atoms that are common in organic molecules that we hear all the time. We take these particular combinations of atoms and we give them names. These named combinations are what we call functional groups. We call them functional groups because these combinations of atoms give the molecule its unique chemical properties. They give the molecule its function. Being able to identify functional groups in a molecule is incredibly important in organic chemistry because it is those functional groups that you will use to perform chemical reactions. To begin with we are going to talk about carbon functional groups. Organic molecules that are comprised entirely of carbon and hydrogen are what we call hydrocarbons. An example of a hydrocarbon would be gasoline. There are two main types of hydrocarbon functional groups. The first are what we call saturated carbons. Saturated carbons are carbons that contain only single bonds, carbons are sp3 hybridized. Here in the upper left we see a carbon that is attached to three hydrogens. You also see that there is this line, this bond, going over to the left. All this is showing is that this carbon is attached to something here on the left. We call that a methyl. If we take that same carbon, but replace one of the hydrogens with a bond, again to some atom, now we have a carbon that is still sp3 hybridized but is attached only to two hydrogen atoms. We call this a methylene. We continue the pattern and replace another hydrogen with another bond to some atom, now we have only one hydrogen attached to our sp3 hybridized carbon so we call it a methyne. For these first three entries it didn't matter what was connected to the carbon. For a quaternary carbon it must be bonded to four other carbons, whereas for the others, for the methyl, the methylene, and the methyne they can be bonded to carbon or a heteroatom such as oxygen or nitrogen. Keep that distinction in mind. Now that we have discussed saturated carbons, let us discuss unsaturated carbons. Unsaturated carbons are sp2 or sp hybridized. Here in the upper right we have what is called an alkene. You might also hear alkenes referred to as olefins, they mean the same thing. We have two carbons that have a double bond connecting them. This carbon carbon double bond is what we are talking about when we say alkene. An alkene has hydrogens or carbons attached to it. If we take three alkenes and attach them in a particular way, we get what is called a benzene ring which you can see down here. A benzene ring is not an alkene. A benzene ring is comprised of alkenes but they are not the same, they undergo different chemical reactions. If we take a benzene ring and connect it to something, you bond it to something, its called a phenyl ring. In organic chemistry when you are talking about this kind of structure as a functional group, you will always refer to it as a phenyl ring. A phenyl ring is a type of aromatic ring. You do not need to know what an aromatic ring means right this moment. it will become much more important when we discuss NMR spectroscopy.
Finally here at the bottom, we have an sp hybridized carbon and an sp hybridized carbon connected via a triple bond like we do here, we have what is called an alkyne. In case it is difficult to see, there are in fact carbon atoms here at the intersection. So if you see an alkyne, remember that. These are the names of the most important carbon functional groups you will find in organic molecules. Over time, these names will become second nature to you. If you are taking CHEM 232 concurrently, you'll be doing this in CHEM 232 as well. You can think of this as studying one thing for two different courses. Now lets move on to non carbon-based functional groups. Let us start with molecules that contain halogen atoms. Here, I am showing a chlorine atom. I can use a fluorine atom or a bromine atom or an iodine atom here and it wouldn't change. Whenever you have a halogen attached to a carbon, that is called a alkyl halide. Now let's talk about oxygen-containing functional groups. If i have an oxygen that is connected to a hydrogen atom and a carbon atom of some kind, this is called an alcohol. If I take that same oxygen atom and connected to two carbon atoms, it is now called an ether. Now let us discuss nitrogen-containing functional groups. On the right, we see three types of nitrogen containing functional groups. If I have a nitrogen connected to two hydrogens and a carbon, this is called an amine. In this particular case, it is called a primary amine. If I take this same amine and now i connect it to a carbon atom instead of a hydrogen, it becomes a secondary amine. If I take that same amine and now connect it to three carbon atoms, it becomes a tertiary amine. Hopefully you can see the pattern: one carbon atom, primary amine; two carbon atoms, secondary amine; three carbon atoms, tertiary amine. All these functional groups are amines, and so if i ask you what type of functional groups contain a nitrogen atom, if you respond 'an amine,' that is a correct answer. If I ask you to be more specific, then you can say primary, or secondary, or tertiary amine. One note before we continue: for alkyl halides and alcohols, there are primary alkyl halides, secondary alkyl halides, and tertiary alkyl halides. Similarly, there are primary alcohols, secondary alcohols, and tertiary alcohols. That naming system is completely different for the naming system for amines. If you are concurrently taking CHEM 232, you will learn about that nomenclature as you start discussing elimination and substitution reactions. The final type of functional group you are going to discuss is the carbonyl. A carbonyl is a carbon double-bonded to an oxygen. It doesn't matter what that carbon is attached to. Whenever you have a carbon double-bonded to an oxygen, that is a carbonyl. Carbonyls are incredibly important functional groups in organic chemistry. As a result, it is important to be able to recognize and name all types of carbonyls. As you might imagine, there are many different things that we can attach to this carbonyl. Every combination has a particular name. this is because every combination performs different chemistry. For this course, here are the five types of carbonyls you need to be familiar with. Here on the left, we have what is called a ketone. A ketone is when you have a carbonyl that is connected to two carbon atoms. If you look down below, we have what is called an aldehyde. An aldehyde is a carbonyl connected to a carbon atom of some type and a hydrogen atom. This is a very small change, isn't it? We've simply exchanged a carbon atom for a hydrogen atom, but this has incredible consequences for chemical reactivity. It is important that you are able to distinguish them. In the upper right, we have what is called a carboxylic acid. We have an -OH group, but this is not an alcohol. Previously I told you that an alcohol was an oxygen connected to a carbon atom and a hydrogen atom, and in most cases this is true. In this case, however, we treat the entire package as a functional group. Note how I have circled the carbonyl and the -OH. They cannot be treated as separate components. They are one whole. Similarly, down below, we have what is called an amide. This -NH2 is not an amide. We treat this combination of atom as a single entity. So when you have a carbonyl attached to an N of some kind and a carbon, you have what is called an amide. This particular amide is a primary amide because its nitrogen is connected to one carbon and two hydrogen atoms. A secondary amide would replace one of these hydrogen atoms for a carbon atom of some kind. It is the same naming scheme you saw with the amines.
Finally, down below, we have carbonyl that is attached to an oxygen like we saw with the carboxylic acid. However, it is an oxygen that is bonded to a carbon, not a hydrogen atom. This type of functional group is called an ester. To recap: A carbonyl is a carbon double bonded to an oxygen, connected to some other atom. There are many different types of carbonyls, and you will learn about these types in CHEM 232. For this course, these five carbonyls are the most important carbonyls to be able to recognize and name. For some practice, let's look at these lines structures, and let's identify what functional groups are present in these line structures. I will walk you through the one in the upper left. Here, what do we see? I see a carbon carbon double bond here, which I know is called an alkene. I see several CH2s, which I know are called methylenes. I see this CO, which is an carbonyl. What kind of carbonyl is it? Well, this carbonyl is bonded to a carbon on the left, and a carbon on the right. Therefore, this particular carbonyl is a ketone. And finally here at the end, I see that I have a methyl. And there we go. I have identified all of the functional groups present in this line structure. Now, what I would like you to do is pause this video, and spend some time identifying the functional groups present in the remaining three line structures. When you are ready to check your work, unpause the video. Welcome back! Let's see how you did. Let us look at the structure in the upper right. You may have noticed that there are carbon carbon double bonds here in this ring, like there was in the structure on the left. You may have named each of these as alkenes. It is true that these are carbon carbon double bonds; however, recall that when you take three carbon carbon double bonds- when you take three alkenes- and you connect them in a particular way, they form a different functional group. These would not be called alkenes by an organic chemist. Instead, an organic chemist would recognize that this as a whole is called a phenyl ring. And this distinction is important. Alkenes undergo different chemical reactions than phenyl rings do. Alkenes have different properties, including spectroscopic properties than phenyl rings do. And you will see this when we start talking about spectroscopy. That is most of this molecule. The remaining pieces of it are simply a series of methylenes. So that wasn't so bad. Hopefully you now recognize the differences between a simply alkene and a phenyl ring. Now, let's look at the structure in the bottom left. What are the functional groups present here. We have here on the left a methyl. We have here an -OH, which we know is called an alcohol. There are two hydrogen attached to this carbon; therefore, this is a methylene. And finally, we know that this -OH is not considered to be on its own because it is attached to a carbonyl. So, we recognize that this entire thing is what we call a carboxylic acid.
Hopefully you were able to distinguish the alcohol from the carboxylic acid. These two -OH's are not the same. Now let's look at the final structure. We have a methyl here farthest left, we have a large number of methylenes. Now let's look at these heteroatoms. The one on the right we know is an amine. That is a correct answer. If you wanted to be more specific, you could say that this is a primary amine, but it is not required unless it is relevant and by relevant I mean that I ask for it or the distinction is important when we talk about spectroscopy and we will see an instance of that later in the course. Now let's look at this oxygen. We have this oxygen that is attached to the carbon on the left and a carbon on the right. Therefore, this oxygen is part of what we would call an ether. And there we go. We have identified all of the functional groups that are present in these line structures. Hopefully this was helpful to you. Being able to interpret line structures, and that includes identifying the functional groups that are present, is crucial to your success in organic chemistry. That brings us to the end of this webcast. To recap, functional groups are common combinations of atoms in organic molecules. Different functional groups will do different chemistry. Sometimes functional groups can be similar in both structure and in name but they are all different. It is incredibly important to be able to distinguish between each type of functional group even if there is only a small difference between them because that small difference in terms of structure can have massive implications for their chemistry. For example, in this webcast, you saw many different types of carbonyl functional groups. Ketones, aldehydes, esters and so on. While they all have a similar motif, they all have a carbonyl, a C double bond to O, they are all different and you should treat them differently. For similarities in name simply look at ether and ester. Confusing those two functional groups is common when learning about organic chemistry for the first time. While the names are similar, the functional groups are quite different and so when memorizing these functional groups do ensure you are not confusing one for the other.
Hello there. In this Fundamentals webcast, you will be discussing molecular polarity. This is a topic you have heard previously in general chemistry. We're going to use the same ideas that you learned in general chemistry, only now we're going to apply them to organic molecules. To start that conversation, let us discuss electronegativity. Recall from general chemistry how electronegativity is a measure of how strongly an atom attracts the electrons in a covalent bond towards itself. How do we know which atom the electrons will prefer? How do we know which atom the electrons will be pulled towards? We have to look at the electronegativity values. Here on the right, I have a table of electronegativity values. The higher the value, the more electronegative the atom is. As you can see, all these elements have a value. That means they all try to pull electrons towards themselves. They are competing with the other atom in the bond. For example, let's look at a C-H bond. We see that carbon has an electronegativity value of 2.5 and we see that hydrogen has an electronegativity value of 2.1-- a value of 2.5 is greater than 2.1, therefore the electrons are pulled towards the carbon atom in a carbon-hydrogen bond. There is an electronegativity difference. In this case there is a difference of 0.4 units. Let's do this same analysis for a carbon-carbon bond. Carbon has an electronegativity value of 2.5, carbon has an electronegativity value of 2.5, therefore there is zero difference in electronegativity values. Do the same thing for a carbon-nitrogen bond. Carbon is 2.5 and nitrogen is 3.0, therefore our difference is 0.5, And because nitrogen has the higher value, the electrons move towards the nitrogen. Now look at hydrogen and oxygen, hydrogen is 2.1 as we know, oxygen is 3.5, therefore you have a difference of 1.4, and because oxygen is higher in electronegativity value the electrons move towards the oxygen. In other words, these bonds are polar. If there is a difference in the electronegativity value, as we can see, the electrons prefer to spend more time around one of the atoms in the bond, and the atom they prefer to spend more time on, is the more electronegative atom. And we show this via these partial charges, these delta pluses and delta minuses, which hopefully you recall. If electrons spend more time around one of the atoms in a bond, that atom is overall more negatively charged. So on this slide, we have three polar bonds and one nonpolar bond. But now we get to a caveat. If I have a very small difference in electronegativity, that bond is polar but it's not that polar and, in fact, it's probably pretty similar to a nonpolar bond. So what's that cut-off? At what point, at what difference in electronegativity do we say 'Okay, this bond is now polar enough to be considered polar.' That difference is usually listed as 0.4-- so if you look at our electronegativity difference values, this is a difference of zero, therefore a carbon-carbon bond is nonpolar. If you look at a carbon-hydrogen bond, that difference is 0.4-- that is not above the threshold I just told you, of 0.4-- therefore, while a C-H bond is slightly polar, it is not polar enough for us to consider it polar. So a C-H bond is also nonpolar. In contrast, if you look at the C-N and O-H bonds down below, we have a difference of 0.5-- that is above 0.4, therefore a C-N bond is polar. If we look at the hydrogen-oxygen bond, that is a difference of 1.4-- therefore, that bond is also polar. In this course, it will be important for you to be able to determine what bonds in a molecule are polar. Does that mean you need to memorize this table? And do these calculations in order to identify what bonds are considered polar, and what bonds are considered nonpolar? The answer is no, and you might have already figured out how to make that distinction without doing any of these calculations. You see on this slide how a carbon-carbon and a carbon-hydrogen bond are considered nonpolar. But whenever you connect a carbon to a heteroatom, or a hydrogen to a heteroatom, those bonds are polar, and that is the distinction you need to be able to make.
That brings us to the end of the webcast, to recap electronegativity is a measure of how strongly an atom pulls electrons towards itself. Large differences in electronegativity lead to polar bonds. In organic molecules what types of bonds fall into this category? As you have just seen, carbon carbon and carbon hydrogen don't have a very large difference in electronegativity, therefore they are considered to be nonpolar. This is not to say that in a carbon hydrogen bond there is no difference in electronegativity, clearly there is a difference. But it is not large enough for us to consider a carbon hydrogen to be polar. In contrast carbon heteroatom bonds are usally polar. Carbon oxygen, carbon nitrogen, carbon halogen all have large differences in electronegativity. Similarly hydorgen heteroatom bonds are polar. Hydrogen oxygen, hydrogen nitrogen, hydrogen halogen bonds tend to have a large difference in electronegativity.
compound characterization intro to spec lets say I handed you this white powder and asked you to tell me what it was how would you go about doing that? the process of identifying an unknown is called characterizing it when we characterize a compound we learn about its properties for example what you might do is melt this unknown powder and see if that melting point matches the melting point of any known compounds however as you might imagine their are many compounds in the world which have the same melting point so that on its own is not enough to figure out what it is another tool you could use is what we call spectroscopy spectroscopy is useful because it analyzes compounds on the molecular level there is no way for us to directly see what atoms make up a molecule and how those atoms are connected what we can do however is indirectly observe the molecule and how we do this is by seeing how the molecule interacts with various forms of energy what do i mean by indirectly observe? think about this analogy imagine you are in a hallway and the hallway has a corner and around that corner is an object of some kind you cannot see the object directly because the wall is in the way however if there is a mirror at the corner of the hallway you can use that mirror to indirectly view the object its a similar idea here we cannot view the molecule but we can view the energy that the molecule is interacting with a basic schematic of a spectroscopy experiment is shown here you have some kind of energy source. usually it is some form of light. we then take whatever energy we have selected and we shoot that energy at a sample of the compound we are trying to characterize. such as the white powder on the previous slide the energy interacts with the sample in some way and then some energy is emitted that emitted energy is analyzed via a detector of some kind the detector then translates that information from the energy to give us data in some form usually in what we call a spectrum this spectrum organizes the information in a visual way that we can interpret we then take that data that spectrum and we analyze it and we interpret it to come to a conclusion hopefully the identity of the molecule you will spend a significant amount of time in the early portion of this course interpreting various types of spectra it is likely that you have not seen anything like these spectra before but that is no reason to be worried, while these spectra may appear abstract to start with all spectra observe certain rules and you can use those rules to interpret them you should treat observing spectra very much like diagnosing a medical or engineering problem in many cases these types of problems are not directly observable but you can use multiple pieces of info to identify the problem anyway for example lets say you are a doctor and a patient comes to you with some symptoms a cough a fever something along those lines you cannot look at the patient and see the bacteria or the virus causing the illness the symptoms are an indirect way of observing the illness however the symptoms on their own are usually not enough to identify the illness you might run some blood tests and those blood tests come back and give you more information that is complementary to the symptoms that you already knew about. you then take the symptoms and the information you obtained from the blood tests and you can come up with a diagnosis in other words that was a logic puzzle. you took the information available and you came to a conclusion spectroscopy is the same way you do not memorize spectra instead you will be exercising your critical thinking skills in this course you will be given several different types of spectra and you will be asked to pull out information and then use that information make a conclusion of some kind usually identifying an unknown molecule .
Lets say we are trying to figure out what that white powder at the beginning of the webcast was. What are some questions we might ask to try and identify it? You might ask, what atoms make up this compound? Are there carbon atoms in there? Are there oxygen atoms in there? If there are oxygen atoms, how many oxygen atoms are there? In order to figure out what the molecule is, we have to know what our building blocks are. What do we have to put together? Once we know what building blocks we have, how are those building blocks connected? In other words, what type of functional groups are present? If we have oxygen atoms, are those oxygen atoms in alcohols, are they in ethers, are they in carbonyls, things like that. Once we know what functional groups are present, how are those functional groups connected? How do we put the pieces together to come up with the final molecular structure? Each spectroscopic method you learn about in this course will help answer one or more of these questions. The spectroscopic methods you will use in this course will be mass spectroscopy, infrared spectroscopy, and nuclear magnetic resonance spectroscopy. For now, all you need to be aware of is what spectroscopy is and why we use it. That brings us to the end of this webcast. To recap this webcast, we cannot directly observe molecular structures. What we can do however is use spectroscopy to indirectly view molecules. Spectroscopy allows us to characterize these molecules and learn something about their structure. By the ends of the first few classes of Chem 233, you'll be able to take all of this information from different types of spectroscopy and determine the structure of an unknown molecule.
Compound Characterization: Mass Spectroscopy. At the end of the introduction to spectroscopy webcast which you viewed last week, we discussed what kinds of information we need in order to identify an unknown compound such as the mysterious white powder in that webcast. To identify an unknown compound, we need to know what atoms make up that compound, what building blocks are available to us and it would be helpful to us to know any functional groups common in combination to the atoms that are present in that molecule. Once we have that information, we can then begin trying to see of we can figure out how all those pieces are connected in order to identify the structure of our unknown compound. In order to gain that information and to answer these questions, we use spectroscopy. Today, we are going to see how mass spectroscopy allows us to answer this first question: What atoms make up our mysterious compound? Using modern techniques, mass spectroscopy allows us to determine the molecular weight of our mysterious compound. On the right side of the screen here we have a general schematic of a mass spectroscopy instrument. How a mass spectroscopy experiment works is that you take your analyte to the compound your are analyzing and you convert it into ions here in the ion source. You take your sample, you inject it into the instrument and the instrument converts it into ions. These ions are then sent into an area containing magnets. These magnets then filter these ions. How do magnets separate ions? Magnets generate a magnetic field. These ions are not magnetic. So what is happening here? Remember from physics that when you have a magnetic field, you also have an electric field. Using these magnets, we can create a magnetic field which creates an electric field which allows us to filter out the ions we want. This filtering process separates ions based on their mass to charge ratio which on this screen is designated by m/q where m is the ion mass and q is ion charge. There are a few other letters which can be used to signify the ion charge. In this presentation, you might see e used to represent ion charge. You also might see the letter z used to represent the ion charge. These three letters: q, e, and z all mean the same thing. The instrument can then tells us what mass to charge ratios are present using a detector. We then look what kinds of ions remain in our sample. You do not need to memorize this schematic. You do not need to know all the pieces of the mass spectrometer. You simply need to know the basic components. You have an ion source that makes ions. These ions are then sent to an area containing magnets. These magnets then sort, separate, filter out the different kinds of ions and they do so by using the mass to charge ratio. If our detector detects a particular mass to charge ratio, it lets us know via the spectra output. There are two general methods to turn our sample into ions. The first way is to use what is called the hard ionization. Electron ionization is an example of a hard ionization process. Hard ionization deliberately fragments our molecule using force. In the case of an electron ionization process, we take electrons and we shoot them at our molecule. These electrons hit our molecule and break it into many pieces. Based on what fragments our detector sees, we can then learn what pieces are present in our molecule and try to put it together.
On the cover of you laboratory notebook, there is a mass spectroscopy section which lists several common fragments and their associated masses...................for this course we will not focus very much on hard ionization techniques.....do not memorize that table of fragments......know what hard ionization is, know the basics of how it works, and know what kind of information it gives us... the second type of ionization is soft ionization....an example of soft ionization would be electrospray ionization..............soft ionization takes our molecule and it turns it into an ion....but it doesn't fragment the molecule in the process............this type of information is useful because it allows us to find the molecular formula of the molecule... because our molecule is kept intact in one piece..we can discover its molecular formula........on this slide, we see this structure of acetylsalicylic acid better known as aspirin.....aspirin has a molecular weight of a 180 g/mol.......however as is... aspirin is not detectable on a mass spectrometer.....remember, mass spectroscopy requires your compound your analyte to be converted into an ion.......how electrospray ionization accomplishes this is it takes the molecule......and it detaches an ion to it......there are many ions that are available but the two most common ions are the hydrogen ion shown here as H+.....and the sodium ion.......shown here as Na+.......before we continue for some terminology.....you may here me refer to dehydrogen ion as a proton... this is an organic chemistry par-lands... we call a hydrogen ion a proton because if you take a hydrogen atom which contains one proton and one electron......and you remove that one electron to make it into an ion... all you're left with this a proton..you will hear me use this terminology again when we begin discussing nuclear magnetic resonance spectroscopy......recall that our mass spectrometer detects a mass to charge ratio not simply mass....fortunately for us... electrospray ionization tends to make ions that contain only one charge.....for this course, If i give you a mass to charge ratio... you can safely assume that the charge is one... as a result, if we were to take these combinations... of aspirin and these ions and combine them....we would expect to see a mass to charge ratio of 181 and 203 in our final mass spectrum....let us say we analyze aspirin using electrospray ionization..what would the spectrum look like....we would see so that it looks like this....this is a mass spectrum, on the x-axis we have the mass to charge ratio......and on the y-axis we have something that is called intensity... all intensity measures is the number of ions corresponding to that mass to charge ratio......for your purposes all you care about is whether a peak appears at a particular mass to charge ratio or not..............in this mass spectrum we see a mass to charge ratio of 181..you can see how that matches our expected mass to charge ratio....this peak this signal corresponds to the mass of our compound plus the mass of the hydrogen ion......similarly on the right.....we have a peak a signal.....of 203.....which corresponds to what we would expect... for the mass of our compound plus the mass of sodium....we call these peaks the largest peaks.......molecular ion peaks... it's because it corresponds to the mass of the intact non-fragment in the molecule..........how is this useful to us?.....let us say that we took our unknown compound and we analyze it using electrospray ionization and what we saw were these two peaks what would they tell us......what these peaks would tell us is that we have a compound that had some mass using the mass of the compound we are going to use a computer to establish the molecular formula of that compound......for example, in this case if we knew our compound had a molecular weight of 180 g/mol, the computer would tell us that meant our molecular formula was C9H8O4........it would not tell us how those atoms were connected but this is a great place to begin... somethings to keep in mind..........be on the look out for M+H and M+sodium....in mass spectroscopy experiment you might see one you might see the other you might see both of them be aware of that if asked to interpret mass spectra.........
Let us look a little more closely at these mass spectrum.....clearly there is on major peak... one peak larger than the rest however you might have also noticed....these smaller peaks.....to the right....what do these smaller peaks correspond to?......those smaller peaks are a result of isotopes....if you look at the periodic table of elements....you will be carbon has an atomic weight of 12.011...that atomic weight is an average of all the isotopes of carbon.....if you take a sample of carbon almost 99% of that carbon will be carbon 12....about 1% of that carbon will be carbon 13 and a minuscule amount of that carbon will be carbon 14...........how does this affect mass spectrum?......recall, that mass spectroscopy separates compounds based on their mass to charge ratio........imagine a situation where we have a molecule of aspirin that contains no carbon 13....i have a molecular weight of 180 g/mol....now let us say I have a molecule of aspirin that contains one atom of carbon 13.........as a result, the molecule of aspirin with one atom of carbon 13 will have a mass of 181 g/mol... where we might call M+1....how would these combinations of different isotopes affect our mass spectrum......for a molecule of aspirin that contains no carbon 13 we have a mass of 180 g/mol.....we add the mass of a proton to that we see 181 g/mol.....and that is the largest signal in our mass spectrum......if instead we have a molecule aspirin that contains one atom of carbon 13......we have a mass of 181.....plus the mass of a proton.........to give us 182....which we see in the mass spectrum don't we?....notice how the signal for 182 is much smaller than the signal for 181.......that is because....carbon 13 is much less abundant than carbon 12.....if you look real closely you can see another even smaller signal at 183....that would correspond to an aspirin molecule that contain two carbon 13 atoms.........the take home message here is that the presence of isotopes..will give us different masses... for the same molecule........these three signals you see here... all belong to aspirin.......it's just that some of those molecules of aspirin have different isotopes of carbon... of course carbon is not the element that exist in different isotopes........there are two other elements for understanding these isotopic patterns is very useful....the first of these elements is chlorine........here i have a molecule that contains a chlorine atom......using the atomic weight of chlorine i see in the periodic table I calculate a molecular weight for this molecule of 156.57.........do i see that mass on the mass spectrometer?...to make this discussion easier....the mass spectra you see on this slide will not include any ions......remember that in reality you would see a mass plus the mass of an ion of some kind. a proton or a sodium but discussion of this slide on isotopic patterns you will use the mass of these molecules without the additional ions.......what i see is a signal corresponding to a mass of 156.....an a signal corresponding to a mass of 158...why is that?.....chlorine has two main isotopes....chlorine... can come......the mass of 35.....and it could come with a mass of 37.....................if you take a sample of chlorine..roughly 75% of that chlorine will be chlorine 35..and roughly 25% of that chlorine will be chlorine 37.......and you might be able to see how this distribution is reflected in the size of these signals...........you have two main isotopes of chlorine.......therefore, we should see two main signals... one for each isotope of chlorine... and they should exist in a roughly 3 to 1 ratio........because the isotopes exist in a roughly 3 to 1 ratio.....therefore, if you're looking at mass spectrum you see two main peaks there are 2 amus apart... why 2 amus?...because that's the difference in amus between the two isotopes of chlorine.......that are roughly at a 3 to 1 ratio....you have a chlorine somewhere in your molecule..very useful to know.........similarly... I take that same molecule and now replace the chlorine with a bromine i see another isotopic pattern........in bromine my two main isotopes.....................
A Bromine-79 and Bromine-81 which exists in a roughly 50/50 ratio. And we see that in the mass spectrum for this compound we have two main signals that are two amu's apart. Again, that is because that is because there is a 2 amu difference between the isotopes of bromine, and the signals are roughly the same size. If you are analyzing a mass spectrum that contains two signals two amu's apart that are roughly the same size, you have a bromine somewhere in your molecule; another very useful pattern to know. That is the end of this webcast. To recap what we have discussed I expect you to have a basic understanding of mass spectroscopy theory. Know that mass spectroscopy takes your sample and converts it into ions. Those ions are then separated via their mass to charge ratio and depending on the type of ionization we use, we get different information. Electrospray ionization turns our sample into ions by attaching ions to our molecule, the most common of these ions being proton and sodium although others are possible. Electroscpray ionization allows us to figure out what the molecular formula of our unknown compound is. Finally Chlorine and Bromine have very characteristic isotope patterns in a mass spectrum. If you see those isotope patterns, you should recognize what kind of atom is present in your molecule. Before we finish, a few reminders for the second lecture. You have another series of webcasts to watch for the second lecture, these webcasts will be on infrared spectroscopy. Once you have watched all the assigned webcasts for lecture 2, you may choose to complete the optional pre-lecture survey located on the compass2g course website. The responses to this survey will help me determine what to focus on during lecture period. If you decide to come to the optional period, be sure to remember to bring clicker and worksheet. And finally, remember to complete the online pre-lab quiz for your first experiment before the due date. If you do not complete the pre-lab quiz you will not be allowed to perform your first experiment.
Compound characterization: Infrared Spectroscopy Background. In this webcast, we will discuss the theory behind infrared spectroscopy. At the end of the introduction to spectroscopy webcast, we discuss how we needed certain pieces of information in order to identify an unknown compound. This webcast will discuss infrared spectroscopy, which will help us identify what functional groups are present in our molecules. Infrared spectroscopy, what you might guess from its name, uses infrared energy. In an infrared of IR spectroscopy experiment, you have your IR source, and the IR source radiates your samples with a beam of IR light. That IR light is then absorbed by the covalent bonds present in your molecule. The instrument then detects how much of that original energy did not get absorbed. It then plots that data as an expression of CM^-1. This unit is often called wave numbers; although you may have also hear it referred to as reciprocal centimeters or inverse centimeters. The IR spectrum that the instrument produces usually presents the output as percent transmittance. In other words, it shows the data as a measure of how much energy was transmitted through the sample or how much energy was not absorbed. Occasionally, you may see spectra that use percent absorbance instead. What does an IR spectrum look like? Here is the IR spectrum of asiprin (formal name of aspirin stated after). Here on the X-Axis, we have wave number. Here on the Y-Axis, we have percent transmittance. What we see here are number of peaks in this spectrum. What do these peaks tell us? We see here that at the top of the Y-Axis is one hundred percent. What that means is that if this line is close to the top, very little of that light was absorbed. That tells us that there are no bonds in our molecule that absorb the light at this wave number. In contrast, if we look at these peaks on the right, we see that the molecule absorbs a great deal of IR energy at these wave numbers. Every single one of these peaks you see corresponds to some kind of bond in our molecule absorbing that light. You will see how this is useful to use as we proceed through this webcast. To begin, let us have a short discussion on covalent bonds. You can treat covalent bonds as a classical vibrating string. If your bond has a dipole moment- in other words if you bond is polar- and that dipole moment changes as your bond stretches and contracts like a spring, it is what we call IR active. It will produce a peak in the spectrum. Where that peak appears in the spectrum depends on what wave number of light it absorbs. What wave number light it absorbs primarily depends on two things: the mass of the atoms in the bonds and the strength of the bonds. Now, let us talk a little bit more about what I mean when I say a change in dipole moment. Here, I have a carbonyl. I have a carbon double bonded to an oxygen, and you know that this bond is polar. In other words, it has a dipole moment, which we represent using the Greek letter 'nu'. Imagine taking that bond and stretching it like a spring. What happens is this dipole moment gets larger as you stretch the partial positive and partial negative charges away from each other, you get a larger dipole moment. In contrast, if we contract or compress our bond like a spring, we move those partial charges closer together; therefore resulting in a smaller dipole moment. As our bond stretches and contracts, we have a change in dipole moment. If we have a large change in dipole moment, a large delta view, where delta represents change, you would have a strong IR single. That means that we would see a large peak, corresponding to this bond in the IR spectrum. [Gibberish] that every polar bond can be seen in an IR spectrum. That is not quiet true. Here, I have carbon dioxide. Carbon dioxide has a carbon oxygen double bond to the right, and a carbon oxygen double bond to the left. These bonds are polar. Carbon is delta positive, where as the oxygens are delta negative. Now, recall that being IR active means that we see a change in dipole moment. If I take carbon dioxide, and I stretch the left oxygen the same way that I stretch the right oxygen. In other words, do I see a change in dipole moment. No! These dipole moments would cancel each other out. Therefore, because we would see little or in this case no change in dipole moment, we would not see an IR signal. This type of stretch is what we call IR inactive.
Does that mean Carbon Dioxide does not appear in an IR spectrum? It turns out we do see carbon dioxide in an IR spectrum and heres why. On the slide, you see what we call modes of vibration. These are the various ways bonds in a molecule can vibrate. As we saw on the previous slide, if we take carbon dioxide and we stretch it symmetrically like you can see here, you would see no change in dipole involvement. However, if we take that same molecule but asymmetrically stretch the bonds, we would see a change in dipole involvement. And therefore, we would see carbon dioxide in an IR spectrum. The consequence of having different kinds of vibration, is that one bond can show up in many different places in an IR spectrum. Fortunately for us, we can still interpret large portions of an IR spectrum with these. Do not memorize these six modes of vibration ,simply know that there are many different kinds and that each kind of vibration can give it's own signal in an IR spectrum. To review what we have discussed so far, we know that we can treat covalent bonds in a molecule as if they were springs. In an IR Spectroscopy experiment, our compound is exposed to infrared light. The bonds in our molecule absorb some of that light and begin vibrating. These vibrations then give us the signals we see in an IR spectrum. Now we are going to discuss what determines where those signals appear. Let us treat our covalent bonds as springs. I have an atom on the left and an atom on the right and a bond between them, which acts like a spring. Recall Hooke's Law from physics that says the force needed to move the spring depends on two things. It depends on 'k', the force constant, in other words how stiff the spring is. And 'X', how far you are moving the spring... what's the displacement. If we take this simple equation and we substitute in some variables relevant to atoms and we do some rearrangements, we get this new equation... it looks scary but its actually not that bad. What this equation tells us is that this variable called 'nu bar', also known as the wave number of length the bond will absorb, depends on two things. It depends on kf, again our force constant... it's how strong our bond is. The stronger the bond the more stiff the bond. As you can see, as kf gets larger, the wave number must also get larger. Second, our wave number depends on the mass of the atoms. As you can see, as our masses get larger, the denominator of this fraction gets bigger. As the denominator of this fraction gets larger, the right side has to get smaller. Hopefully that makes sense to you mathematically, heavier atoms result in a lower wave number. In summary, this equation tells us that the wave number of light that is absorbed by a bond depends on the strength of the bond and on the mass of the atoms in that bond. It turns out the type of light these bonds absorb is infrared light. By shining infrared light onto a molecule you can see what wave number of light are absorbed by the bonds in that molecule. Here are some examples. On the left I have a series of bonds and on the right I have the wave number values of the light that is absorbed by each particular bond. Lets compare these first two. C-H and C-D. D stands for deuterium. Deuterium is a hydrogen atom that contains one proton and one neutron in the nucleus. That means that it is heavier than a normal hydrogen atom. How does the wave number of light that these bonds absorb compare to each other? As we can see, the carbon deuterium bond absorbs at a lower wave number than the carbon hydrogen bond. That matches what we solve for the equation here. We know that heavier atoms result in a lower wave number. Now let's compare these last three. Carbon-carbon single bond, carbon-carbon double bond, and carbon-carbon triple bond. We see that these bonds also do not have the same wave number absorption value. Why is that? Let us look at bond strengths. Look at the carbon-carbon bond strengths, we see that as we go from a single bond to a double bond to a triple bond, it takes more energy to break that bond. In other words, our bond becomes stronger. Based on the equation we discussed on the previous slide, stronger bonds should absorb at higher wave numbers. And we see that as true. A carbon-carbon triple bond absorbs at a higher wave number than a carbon-carbon double bond, which absorbs at a higher wave number than a carbon-carbon single bond.
The payoff here is that because infrared spectroscopy allows us to see what kinds of covalent bonds are present within a molecule, it allows us to determine what kinds of functional groups are present in the molecule. For example, if you look at this table, if my infrared spectrum has an absorbance at 2200 wave numbers, that means I know I have a C-C triple bond in my molecule. I have an alkyne. We will talk more about common absorbances and how we can use them in structure determination in the next webcast. But for now, we have reached the end of this webcast. To recap, infrared spectroscopy allows us to identify functional groups present in a compound. The reason we can use infrared spectroscopy to do this is because each type of covalent bond in a molecule absorbs a particular wave number of light, and we can see that wave number by what is absorbed in an infrared spectrum. The presence or absence of an absorbance in an infrared spectrum can confirm or disprove the presence of a functional group. Of course there are exceptions, and we will discuss them in the next webcast, but for now, if an infrared spectrum contains an absorbance for a particular bond, that means the molecule has that type of bond. If an infrared spectrum does not contain an absorbance for a particular type of bond, that means the molecule does not contain that type of bond.
Compound characterization IR spectroscopy characteristic stretches. This is the slide we used to end the previous webcast on the background to IR spectroscopy. In that webcast we discussed how we can IR spectroscopy to identify functional groups within a molecule because certain bonds absorb certain wave numbers of light. You can see a small subset of that here in this yellow box. Of course, organic molecules can contain many other types of bonds other than ones listed in this box. In this webcast we will talk about common bonds that you will find in organic molecules, and the typical absorbances you will find them at. This slide contains an image and a number of tables. If you own a CHEM 233 lab notebook you can find this image and these tables on the cover of your lab book. If you do not own a CHEM 233 notebook you can find a copy of these tables on the compass2g course website. What do we have here? Up top we have what is being called a generic IR spectrum. By generic all it means is that it is showing all of the common types of absorbances that you can find in an IR spectrum. Up to this point you have heard me refer to each of these peaks as absorbances or signals. Another way to refer to these is using the word 'stretches'. Remember these peaks result from bonds stretching as a result of absorbing certain wavenumbers of light. How does this image correlate to the tables down below? This image is divided into a number of different regions based on letter. A B C D and so on. Each letter corresponds to a particular type of stretch. for example, the letter A responds to OH and NH stretches. This is the first thing that you should get from this slide. Different bonds can have absorbances that appear in the same region. They can overlap. As we can see, OH bonds and NH bonds overlap quite a bit. If that's true, how can you say whether a stretch in this area belongs to an OH bond or an NH bond? Well, to do that you are going to need different information. We'll talk about that information in future webcasts. The second thing that you should get from this slide is that stretches don't appear at a particular wavelength. They appear in a range. If you're looking at the OH stretch, it doesn't just appear at just, say, 3400 wavenumbers. It's anywhere between 3200 and 3600 wavenumbers. similarly, if we look at the F region, which corresponds to carbonyl stretches, we see that they can appear anywhere between 1650 wavenumbers and 1785 wavenumbers depending on the type of carbonyl. Does the fact that a stretch can appear at different wavenumbers tell us something about the type of functional group? It actually can, and we'll talk about that in relation to carbonyls later in this webcast. Now, this slide contains a ton of information. Do I expect you to memorize every single bond on this table. No, what I expect you to memorize is the general ranges for the most important of these stretches. Let's talk about those stretches here. On this slide I have here an empty IR spectrum. What we're going to do is fill it in piece by piece with the most common stretches you might see in an IR spectrum. The first piece we're going to look at is from 1500 to lower wavenumbers. This particular region is called the fingerprint region. The fingerprint region tends to be very crowded. Many different types of absorbances appear in this region. This region is often very difficult to interpret correctly. As a result, whenever you are interpreting an IR spectrum I strongly recommend that you do not attempt to interpret the fingerprint region. The reason we call this the fingerprint region is because it is characteristic of a particular compound. Because it is so complex it acts as a fingerprint for a particular compound and we can use to identify it. The next region to look at is approximately 1650 wavenumbers. In this region we see carbon carbon double bonds. Now, note that this is approximate. Carbon carbon double bonds can appear above 1650 they can appear below 1650 but they will always appear in this area. The next region to be on the lookout for is at approximately 1700 wavenumbers.This region we see carbonyls. Again, carbonyl stretches may be above 1700, they might be blow 1700, but they should be somewhere in the area. The next region to look at is at around 2200 wavenumbers.
Here we will find carbon-carbon triple bonds. But there is a caveat here, if you look at the table on your lab notebook cover or on the course website you will notice that for the carbon carbon triple bond it says that the signal for the carbon-carbon triple bond might be weak if the carbon-carbon triple bond is too symmetrical. Why is that? Remember a bond is IR active if there is a change in dipole moment as it stretches and contract. If a carbon-carbon triple bond is too symmetrical there isn't a large difference in dipole moment, which means that even if it stretches and contracts there isn't going to be much of a change and so it won't appear or if it does appear it won't be very large. As a result c-c triple bonds might not appear in a IR spectrum even if there in the molecule. How will you know whether it will appear or not? You won't. And so you will have to use other spectroscopic methods to corroborate your conclusion. This is one of those exceptions I mention at the end of the last webcast and you have to be careful with it. The next region to look at, is at 3,000 wave numbers. Here we find C-H bonds. The type of C-H bonds however is important. If the carbon in a C-H bond is sp3 hybridized, then it appears below 3000. Typically between 2900 wave numbers and 3000 wave numbers. Although stretches can go below 2900 wave numbers. However if it is sp2 hybridized then it appears just above 3000 say from 3000 wave numbers- 3100 wave numbers. And that's incredibly useful, whether a C-H stretch is above or below 3000 tells us what type of carbon we have in that bond. Similarly, if we have a sp hybridized carbon that's even further above 3000 usually at around 3300 although again it can be a little bit above or a little bit below. This is an example of how the same type of bond can appear in different parts of the IR spectrum based on what comprises the bond. The sixth and final region is not really a particular wave number its more a block from 4000 to can be as low as 3000 or even lower. Is where we find OH bonds and NH bonds the reason that these type of bonds can appear in such a wide area is because their shape is different than the shape of most other stretches. The shape of an OH or an NH stretch tends to be quite broad in contrasts the shape of most other bonds, say a carbonyl, tends to be quite narrow like I'm drawing here on the right, and thats another important thing to know about an IR spectrum. The shape of a stretch can tell you what type of stretch it is. Most stretches will be quite sharp and distinct. You can immediately identify an OH or a NH stretch because they will look different they will tend to be much broader than most other stretches. While I do not expect you to memorize the table I showed you on the last slide, I do expect you to memorize these six regions. Now let's take this knowledge and put it to use by interpreting an IR spectrum here is an IR spectrum for Aspirin again. let's look at this step-by-step, remember that the fingerprint region is 1500 wave numbers and lower. Which means we're not going to interpret any of this. And frankly that comes as an relief to me, because look at all of these stretches. Look at how difficult it will be to try and interpret this, so we ignore all of that. Now let us look at the next region, let's look at roughly 1650, do I see a stretch there? Indeed I do. Therefore there is a C-C double bond in the molecule is that true? In fact there is I have several C-C double bonds. These C-C double bonds give me this stretch. Ok so that's the C-C double bond region. Now let's look at the C-O double bond region, do I see anything there? That's at roughly 1700 and indeed I do, I see 2 peaks in that region that means I have a carbonyl somewhere in my molecule and I do in fact I have 2.
You might be wondering 'why do these two carbonyls show up at different locations?' We'll talk about why that is on the next slide. Now let's look at the next region. At 2200, I would see stretches that correspond to carbon carbon triple bonds. Do I see any stretches in this area? No. No I don't, therefore I probably don't have any carbon carbon triple bonds. Now remember the caveat that I stated: just because I don't see a stretch here does not mean there isn't a carbon carbon triple bond. But it's a very good indication that I don't have a carbon carbon triple bond. Ok, now let's look at the next region. Let's look at roughly 3000. What do I see here? I see a bunch of stretches below 3000. That means I have sp3 hybridized carbons attached to hydrogens. Is that true? Yeah, cause I have those here on the methyl group. Ok, do I have anything above 3000? Well, that's kind of hard to say. I do have this region right here. There is a stretch of some kind here, but what does that stretch correspond to? It's actually difficult to say, and that's because in this region we actually have stretches overlapping with each other. This very broad stretch corresponds to the -OH located here. Unfortunately, that stretch is overlapping with what we should see for these sp2 hybridized carbons attached to the hydrogens. The stretches belonging to these bonds are present, unfortunately they are being covered up by the stretch for the -OH. This is an important lesson to learn for IR spectroscopy. Stretches corresponding to different bonds can overlap with each other. Hopefully interpreting this IR spectrum is now no longer as intimidating as it once was. You now know that everything here on the right side of the spectrum is not interpreted, which makes our work much easier. And you saw how each of these other clearly defined stretches corresponded to bonds present in aspirin. You also learned that the stretches for different kinds of bonds can overlap with each other and how it is important to be aware of that possibility. Let us discuss carbonyls a little bit. One of the most common mistakes that you may make when interpreting infrared spectroscopy involves carbonyl stretches. On this slide, you see the IR spectroscopy data tables corresponding to carbonyls that you can find on your organic chemistry lab notebook cover. You see how each type of carbonyl: carbonyl attached to a ring, an ester, an aldehyde, a ketone, an acid, an amide, and what's called a conjugated carbonyl are given their particular ranges. The mistake you may make is believing that these values are exact values. From this table, you may believe that ketones appear at 1715, whereas carboxylic acids will always appear at 1710. This is not true. The potential danger of this table is you believing that there are such thing as a ketone stretch, or an ester stretch, or an aldehyde stretch. The carbonyl stretch tells you that there is a carbonyl in your molecule. It does not tell you what kind of carbonyl you have. Fortunately you can narrow the options. If you look at this table, you see that there is a dividing line at 1700. These types of carbonyls above this line will always be above 1700. If you have an amide, or a conjugated carbonyl, that stretch will appear below 1700. If you do not know what conjugated means yet, when I say conjugated carbonyl, I mean a carbonyl connected to a carbon carbon double bond. Why do amides and conjugated carbonyls appear below 1700? This is because of resonance. Let me draw an amide here. R stands for some alkyl group. I can take this amide and draw a resonance structure where I take the lone pair on the nitrogen and move it this way to make this resonance structure.
Why does this matter? Remember that the wave number of a stretch depends on the strength of the bond. You know that the stronger the bond, the higher the wavenumber it appears at. Remember from general chemistry that what a bond is actually like can be treated as a sort of average between all of its resonance structures. Let us look here particularly at the carbon-oxygen bond. And the resonance structure on the left, I have a double bond between the carbon and the oxygen. Double bond is a strong bond. In the resonance structure on teh right, I have a carbon-oxygen single bond which is weaker than the carbon-oxygen double bond. You may recognize at the resonance structure on the right is not a particularly good one because it has charges. As a result, when averaging these resonance structures, this resonance structure on the right does not count for very much. However, it counts enough that the carbon-oxygen double bond in an amide is weaker than the carbon-oxygen double bond of most other carbonyls. It's the same argument if you have a conjugated carbonyl. Take a conjugated carbonyl of some kind and I do the same process. I can draw a similar resonance structure that has a carbon oxygen single bond. As a result, after averaging these structures the carbonyl in a conjugated carbonyl molecule is weaker than most other carbonyls. As a result, it shows up at a lower wavenumber. Before finishing up this slide, some of you may be wondering, okay if that is true, why is it that esters don't do the same thing? Those oxygens in esters have lone pairs why can't they move in the same way? This is because oxygen is much better at holding onto its lone pairs. As a result, the lone pairs on oxygen do not move in the same way. Therefore, the carbonyl in an ester is weakened because of resonance. Using this information we can now explain why we saw two carbonyl stretches in the IR spectrum for aspirin. Here at roughly 1700, two carbonyl stretches. WE have one at approximately 1750, the one on the left, and one below 1700, the one on the right. What this tells me is that the one below 1700 belongs to either an amide or it is a conjugated carbonyl. We see in our molecule amide or it is conjugated carbonyl. And we see in our molecule, we have a conjugated carbonyl. We have this carboxylic acid carbonyl directly connected to a carbon-carbon double bond. In contrast, we have this ester carbonyl which is not conjugated. Therefore, it should appear above 1700, and indeed it does. And around 1750. This is a fantastic example of how you can use the location of a carbonyl stretch and try to identify what kind of carbonyl it is. One final thing before we finish this webcast. Do you remember that carbonyls and carbon-carbon double bonds can overlap in this region? How can you tell the difference? As you can see, the carbonyl stretches tend to be stronger and more broad than the carbon-carbon double bond stretches. That won't always be the case, but if you have to make a decision, you could use size and shape to help you make that decision. That brings us to the end of this webcast, To recap, while you have access to the wavenumber values to many bonds via those tables at the beginning of this webcast, do not memorize all of them. Instead, memorize the six primary regions that we discussed. The first is the fingerprint region that is below 1500 wavenumbers. This region is difficult to interpret, and I recommend you that you avoid trying to use it in your infrared spectrum analysis. There is a carbon-carbon double bond region at approximately1650 wave numbers, there is the carbonyl region at approximately 1700 wave numbers.
We know now that the type of carbonyl matters a great deal. The stretch for most carbonyls will appear above 1700. Some carbonyls, carbonyls that are a part of amides or carbonyls that are conjugated will appear below 1700 because of resonance. that resonance weakens the C-O double bond causing them to absorb light at lower wavelengths. There is the C-C triple bond region at approximately 2200 wavenumbers. Now, remember the C-C triple bond stretch may not appear or may be very weak if the bond is too symmetrical so always be careful when working in this region. C-H bonds appear around 3000 wavenumbers and you know the type of C-H bond determines where it appears. C-H bonds that are sp3 hybridized are below 3000, C-H bonds that are sp2 hybridized are above 3000. And finally, O-H bonds and N-H bonds tend to appear at around 3500 wavenumbers. They also tend to be shaped differently than most other stretches. In the next webcast you will see examples of all of these stretches. There you will see how shape can be used to identify stretches and you will see examples of how the same type of bond, say, carbonyls or C-H bonds, can appear at different locations depending on the type of carbonyl or C-H bond.
compound characterization. infrared spectroscopy example spectra. in this webcast i'll be showing you a number of IR spectra. the purpose of this webcast is to demonstrate how even small changes in the structure of the compound can have large consequences in the associated infrared spectra. you will see how stretches that we discussed in the previous webcast actually look like in a real infrared spectra. here we have two molecules, hexane and 1-hexene. Hexane contains many sp3 hybridized carbons connected to hydrogens and as we can see how below 3,000 we see stretches that correspond to the sp3 hybridized carbons attached to hydrogens. when we compare hexane to 1-hexene we still have many sp3 hybridized carbons attached to hydrogens and we still see stretches below 3,000 that correspond to that. we also have however sp2 hybridized carbons attached to hydrogens. those should appear above 3,000 and in fact we do see stretches above 3,000 that correspond to those sp2 hybridized carbons attached to hydrogens. you continue on and compare 1-hexene to 1-hexyne which has an alkyne, we see that we have an sp carbon attached to a hydrogen. that should show about roughly 3,300 wave number and indeed we see that in the IR spectrum. We see this stretch which corresponds to this sp hybridized carbon attached to a hydrogen. now lets compare the spectrum for 1-hexyne to the spectrum for 2-hexyne. both have alkynes but they are different in a key way, notice how 1-hexyne has an sp hybridized carbon attached to a hydrogen which is why we see this stretch at 3,300 wave number area. 2-hexyne does not have that bond. the carbons in 2-hexyne are both bonded to carbons. there is no sp hybridized carbon attached to a hydrogen. that is why this signal here is not present in 2-hexyne. you look at roughly 2,200 we see a stretch here, that is the carbon carbon triple bond stretch. you see that same stretch down below. notice however that the stretch for 2-hexyne is much weaker than the stretch for 1-hexyne. its because the alkyne in 2-hexyne is more symmetric has a much smaller change in dipole moment than 1-hexyne. therefore we have a correspondingly smaller signal in the IR spectra. those are adding non-carbon functional groups. on top we have hexane once again and down below we have hexanol. hexanol has an alcohol has an O-H bond. notice how this has a very obvious consequence, the IR spectra for 1-hexanol has a very strong a very broad stretch in the 3,400 wavenumber area. if we change the alcohol to an amine, in this case a primary amine, we see a stretch in the same area but it's much smaller compared to the alcohol stretch and it also has a different shape. we see that there are two peaks to this stretch. this is how you can distinguish an O-H from an N-H using IR spectroscopy even though they appear in the same place. An O-H is very large, very broad whereas an N-H tends to be much smaller. A primary amine tends to have two peaks, secondary amines tend to have only one peak. Now let's compare our hexanol to hexanal. We've gone from an alcohol, an O-H to a carbonyl. As you can see the O-H stretch has disappeared in hexanal because there's no O-H present. However, we now have a new stretch at 1,700 wave numbers this new stretch corresponds to the carbonyl. as you can see it is quite strong which is characteristic of carbonyl stretches. compare hexanal to hexanone, we go from an aldehyde to a ketone. lets look at these carbonyl stretches, these are incredibly similar. there is no way you will be able to distinguish the aldehyde from the ketone based on the carbonyl stretch they are too similar this is why i emphasized in the previous webcasts how you cannot use the location of a carbonyl stretch to determine what type of carbonyl is present. you can, however, use a different stretch which i did not talk about earlier because it sometimes shows up and sometimes doesn't but it can be useful. if you look at the structure for hexanal, we have a unique c-h stretch, this hydrogen attached to the carbonyl carbon that bond is special. that shows up in a particular location in a particular shape which we can see here. this is often called the fermi doublet. again it doesn't always show up and even if it does, it might be covered up by other stretches. don't rely on this appearing however if it does appear, this fermi doublet is characteristic of an aldehyde. see how we see those stretches here but not in the ketone.
Now let's compare the aldehyde to an ester. we again see two stretches in the carbonyl region that are very similar. you would not be able to tell which of these was the aldehyde or which of these was the ester based solely on the carbonyl stretch. now let's compare the ester to the acid, as you can see the acid has two bonds that contain oxygen a carbonyl and the O-H as you can see both the ester and the acid have a carbonyl stretch because they both contain carbonyls. however, only the carboxylic acid contains an O-H which is why only the IR spectrum corresponding to the acid contains this broad O-H stretch. This is the end of the example IR spectra for this webcast. These were good examples to use to show you how the presence of absence of a functional group in a molecule can greatly effect what you see in an IR spectrum. The ability to determine which stretches are or are not present will be crucial to your success in interpreting IR spectra.
SORRY, THIS VIDEO DOES NOT SUPPORT CAPTION YET.
We name nuclei aligning in the same direction as the magnetic field as alpha spins, whereas we name nuclei aligning in the opposite direction as the magnetic field as beta spins. The reason that we see more alpha spins than beta spins has to do with energy. On the right, we see a graph where as we go from left to right along the x-axis, the strength of our magnetic field, measured in a unit called Tesla, increases. On the y-axis, we have energy where you go from the bottom to the top of the graph, we increase in energy. These black lines you see correspond to the energy of alpha spins and beta spins, where the beta spin is the top line and the alpha spin is the bottom line. You can see that the moment we apply a magnetic field, the alpha spins and the beta spins no longer have the same energy. Beta spins increase in energy whereas alpha spins decrease in energy. The reason that most nuclei are alpha spins is because alpha spin nuclei are lower in energy. One more piece of information before we continue. Notice how the distance between the alpha spin energy and the beta spin energy increases as the strength of the magnetic field increases from left to right. This increasing difference in energy becomes very important when we talk about the quality of our NMR spectrum, which you will discuss late in this webcast. Now let us discuss how an NMR experiment actually works. At this point, we have taken our sample of nuclei and placed them into a magnetic field where they have aligned themselves in the same direction or in the opposite direction of the magnetic field. Remember that alpha spin nuclei are lower in energy than beta spin nuclei. What happens next is we treat these nuclei with radio wave energy. Which I am representing here as B1. The nuclei then absorb the energy and now all nuclei become beta spin. Our nuclei have absorbed the energy given by the radio waves in B1 causing them to what we call spin flip. To think about this graphically, let's look down below. If I have an alpha spin nuclei and it absorbs energy, it goes from the alpha spin to a beta spin. This is the first half of an NMR experiment. You have a sample of nuclei in a magnetic field. You then expose those nuclei to radio waves, causing the nuclei to flip their spins. The second half on an NMR experiment is simply waiting for your spin flipped nuclei to relax back to their original alpha spins. These spin flipped nuclei are now higher in energy but they don't want to be higher in energy so what they do is they relax, they release that excess energy to return to the alpha spin state. This energy they release is detected by the instrument and used to make the spectrum that we get as a result of an NMR experiment. It is the energy that is released that we measure. The amount of energy released depends on the magnetic field strength of the instrument. Recall the graph from the previous slide that showed how the difference between the beta and alpha spin energy grew larger as the instrument used a higher magnetic field. A consequence of that energy difference is that when the nuclei relax from the beta to the alpha spin state, they release more energy. Which gives us better quality data. The data we receive comes in this format. This is what is called a free induction decay for FID for short. An FID is shown as a time domain. What does that mean? This graph here shows how the signal we measure in an NMR experiment changes over time. Data in this form is very difficult to interpret. Fortunately, what we can do is use what is called a fourier transform. A fourier transform is a mathematical operation that turns one complex function into another. In this case, we are taking a graph that measures over time into a graph that measures over frequency. This frequency domain is the spectrum we see at the end of an NMR experiment. You can see how weve gone from a series of blobs on the left to a series of clear defined signals here on the right. Now that we understand how NMR works, what can it do for us? As you might imagine from the definition of an organic molecule, which we know are molecules made primarily of carbon and hydrogen atoms, organic compounds tend to contain many hydrogen atoms. Since hydrogen atoms are NMR active, we can observe how they interact with energy in an NMR spectrometer, allowing us to learn something about those hydrogen atoms. We will begin talking about what we can learn using NMR spectroscopy in the next webcast.
Before we end this webcast, a note on NMR solvent. In an NMR experiment you usually take your compound and dissolve it into a solvent of some kind. A common solvent is Chloroform (CHCI3), because many compounds are soluble in chloroform, however you might notice a problem here chloroform contains one proton, that means chloroform will appear in the NMR spectrum. We do not want that because all we want to see in our NMR spectrum are signal that belong to the compound that we are examining. What can we do to get around this? What we can do it use deuterated solvents, in this example deuterated chloroform. Remember that deuterium is a hydrogen atom that contains both a proton and a neutron in the nucleus. How does going from a hydrogen atom which contains only one proton in the nucleus to another hydrogen atom that contains both a proton and neutron in the nucleus help us? Because the spin number of one deuterium is different that the spin number of one half for hydrogen. A deuterium atom will not interfere with a proton and NMR experiment. Therefore, by using deuterated solvents we can perform an NMR experiment without the solvent contaminated our NMR spectrum. Thats the end of this webcast, to recap proton NMR functions by placing molecules into a magnetic field and then irradiating those molecules with radio waves. Nuclei with particular spins for this course are the hydrogen nuclei and the carbon 13 nuclei align themselves mostly with the applied magnetic field. However, upon absorbing energy from the radio waves that are being irradiating with, those nuclei flip spins to align against the applied magnetic field.Then the nuclei are allowed to relax, releasing energy that can analyzed to give us information about the molecule.
Compound characterization: proton nuclear magnetic resonance interpretation part 1 examples. In this webcast we will go through a few examples to reinforce what you have learned concerning interpreting NMR spectra in the previous webcast. Consider this molecule on the left. Tell me how many signals you expect to see, and what are the multiplicities of those signals. Pause the video, take some time, and decide. Because this is a warm up, I included some helpful labels for you. The protons labeled Ha, are equivalent, and the protons labeled Hb are also equivalent. I should also remember that the proton that is part of the alcohol would also give its own signal. Well because it is labile, I may or may not see it. What about multiplicities? For the Ha protons, I would expect to see a triplet, which I will shorten to just T, because there are only two neighbors to the Ha protons. For the Hb protons, I would expect to see a quartet, which I will shorten to just q. Because the Hb protons have three neighbors. Remember, labile protons do not cause any splitting. Let's look at the actual NMR spectra and see how we did. Look at that! I see three signals: one, two, three. One of which is a triplet, like I expected, and one of which is a quartet, like I expected. Excellent. Do the chemical shifts make sense? Should the quartet be further downfield than the triplet? Remember the quartet belongs to the Hb protons. The Hb protons are very close to this electron withdrawing alcohol, therefore the Hb protons should be more shielded than the farther away Ha protons. Therefore the Hb protons should be more downfield and that matches what we see. Similar exercise here. Looking at this chemical structure, how many signals do you expect, what is your predicted multiplicity for each signal, and now try and predict the chemical shift for each set as well. Pause the video, take some time, and then let's see how you did. Welcome back! I expect to see three signals, the methyl on the left should produce its own signal, the methylene in the middle should produce its own signal, and the methyl on the left should produce its own signal. What about multiplicities? The purple protons have no adjacent hydrogens, therefore they should show up as a singlet, which I shall abbreviate using the letter S. The methylene protons have three neighbors, therefore they should show up as a quartet, and the blue protons have two neighbors, therefore they should show up as a triplet. What about chemical shifts? What do we predict for those? The purple protons are adjacent to a carbonyl. That carbonyl is electron withdrawing, but it is not very electron withdrawing. I predict those protons will appear at roughly 2.5 ppm. That's downfield but now very downfield. Similarly, the red protons, being adjacent to the same carbonyl, should be in roughly that same area. In contrast, the blue protons are pretty far away from that carbonyl, therefore they should still be pretty shielded. I predict they will appear at roughly 1.0 ppm. Your values may not match mine exactly, that's okay. So long as your values are in the same vicinity, you're thinking about this the right way. Now let's see how our predictions match reality. The purple protons should appear as a singlet at roughly 2.5 ppm. Is there such a signal in that area? Yes, there is. I have a singlet at roughly 2.1 ppm. My prediction was pretty close. My red protons should be a quartet at roughly 2.5 ppm. How did we do there? Pretty good, actually, there's a quartet at almost exactly 2.5 ppm. What about the blue protons? I should see a triplet at 1.0 ppm. Excellent! I see a triplet at just above 1.0 ppm. My predictions were pretty accurate. Why were my chemical shift predictions so accurate? This is because different types of protons appear in characteristic locations. Protons not near electron withdrawing groups tend to be at roughly 1.0 ppm. Sometimes a little more, sometimes a little less, but somewhere in that area. Protons near electron withdrawing groups such as carbonyls will appear downfield of that. Because carbonyls are weak electron withdrawing groups, they should be at roughly 2.5. Again, sometimes a little more, sometimes a little less, but somewhere in that area. The first two exercises asked you to take a structure and predict what the spectrum would look like. In most cases, however, we don't know what the compound looks like. Instead, we try to use the spectrum to tell us what the compound looks like. To do this, we have to look at a proton NMR spectrum such as this one, and be able to pull out all of the useful information. We usually organize that information using tables. In this course, when labeling signals in a spectrum, we are going to use letters. Where we start with A with the signal farthest downfield, and then go down the alphabet as we go to the right. Like so. What i would like you to do .
is pull out all the important information in this NMR spectra. that means i want you to tell me the integration of each signal, the chemical shift of each signal which i shall designate using the greek letter delta, and the multiplicity of each signal. spend some time and fill out this table and then come back and check your work. okay, let's see how you did. to find the integration of A, i look at this number below the signal. it says a value of 2 therefore A's integration is 2. i continue down the line filling in the values. if i don't have an integer i simply round the nearest whole number and there you go. i filled in the first column of my table. now let's look at chemical shifts. when it comes to recording chemical shifts it doesn't have to be exact. for example, for signal A i'm not going to record 3.413. there's no way i can get that exact. I'm just going to simply write 'okay it looks to me about 3.4 parts per million'. for B, it looks to me about 2.1. C is about, i might say 1.75 for that. again, it's not an exact value, but it's a best estimate just based on what i see. and then signal D is about 0.9. there you go, that's another column of very useful information recorded in our data table. now multiplicity. A has 2 peaks therefore that's a doublet, which i shall designate with lowercase d. B is a singlet, C has 7 peaks therefore that's a septet which i shall shorten to just 'sept', and then D is another doublet. excellent, that's the entire table of information that you can pull out of an NMR spectra based on what we've discussed so far. one more exercise before we go, however. using the multiplicity, tell me the number of adjacent protons. pause the video. tell me how many protons are next door to each of these signals. let's see how you did. A is a doublet. remember the n+1 rule, where n is the number of adjacent protons. for A, n+1 has to equal 2. therefore, n equals 1. there was 1 adjacent proton to signal A. to at B, that's a singlet so that's zero. if you look at C, that's a septet. it's got to be 6. 7 peaks, 7 minus 1 is 6. and D is another doublet. therefore that 2 has only adjacent proton. there we go. we now know how many equivalent sets of hydrogens there are. 1, 2, 3, 4. we now know how many protons belong in each set based on the integration. we have a rough idea of what kinds of protons these are based on the chemical shift. signal A is further downfield, therefore it must be near a strong electron withdrawing group. in contrast, signal D is very far upfield. therefore it must not be near any electron withdrawing group. we also know something about the neighborhood of all these signals. we know that the protons in signal A have only one neighbor. but the protons in signal C have 6 neighbors. this NMR spectrum is a partial NMR spectra. it is only showing some of the proton signals for this molecule. as a result we cannot identify this particular molecule. however, if we did have a full spectrum and you had a full table of information, all you would need to begin figuring out what the compound is would be the molecular formula. that brings us to the end of this webcast. to recap, the most important thing you can do when interpreting NMR spectra is to organize your data. this process begins by working through a spectrum one aspect at a time. label your signals in the NMR spectra and then identify their chemical shift, their integration, and their multiplicity. with that information in hand and organized, it will be easier to see how the all the different pieces fit together.
compound characterization proton nuclear resonance spectroscopy spectra interpretation part 1 in this webcast we will discuss how to interpret proton NMR spectra, what information can we gain from it, and what can we use that information for previous webcasts ended with this slide most organic compounds contain many hydrogen atoms as you can see from the structure of aspirin here on this slide we have hydrogen atoms on the aromatic ring we have hydrogen atoms on the methyl group over here and we have a hydrogen atom here as part of the carboxylic acid as you might imagine just from looking at the molecule there are many different types of hydrogen atoms how might that affect an NMR experiment the chemical structure you see here is of 1-propanol the NMR spectrum you see below it is the proton NMR spectrum for 1-propanol by the end of this webcast you will be able to see how the spectrum corresponds to the chemical structure what a proton NMR spectrum allows us to learn about a molecule are the number of unique sets of hydrogens in the molecule we will learn this via the number of signals in the proton NMR spectrum we will learn about the number of hydrogens in each unique set and we will learn this via the integration of each signal now number 1 and number 2 both sound similar here is the difference number 1 the number of unique sets of hydrogens tells us the number of different types of hydrogen atoms present in the molecule number 2 tells us the number of hydrogen atoms of each particular type proton NMR will tell us the number of hydrogens adjacent to each set in other words, proton NMR will tell us how many neighbors each set of hydrogen atoms has and it will do so via peak splitting, also known as multiplicity proton NMR will also tell us about the presence of nearby functional groups via something called chemical shift finally it will tell us something about connectivity where these hydrogen atoms are with respect to each other in the chemical structure this information is to us via something called J-couplings for this webcast, we will focus on only these first 4 points before we begin, we should discuss labile protons on the previous slide you saw how proton NMR can give us information about a molecule via things like the number of signals, the integration of the signals, the multiplicity, splitting of the signals, and their chemical shifts each of the aspects of the NMR spectrum follows certain rules those rules are what allows us to interpret an NMR spectrum labile protons are special labile protons tend to not follow the rules that you will learn in this webcast it is important to be able to identify labile protons and understand how they may or may not affect a proton NMR spectrum labile protons tend to be acidic protons examples of acidic protons are protons in alcohol and protons in amines these labile protons do not necessarily follow the same rules all other protons follow because of the process called exchange if you look at the structure of 1-propanol here on the bottom left we see a number of protons attached to carbon and we also see a proton attached to this oxygen protons attached to carbon by large stay in one place, they don't move in contrast this acidic proton proton, circled in red, this labile proton does move when we talk about exchange we mean these labile protons exchange between molecules you can imagine this proton being used to protonate, or being transferred to another alcohol this exchange process, this fact that labile protons tend to move around between molecules has a number of consequences unlike most other protons signals in an NMR spectrum labile protons often give broad peaks that do not integrate properly, they often have variable chemical shifts, and they do not always show coupling to adjacent sets of hydrogens we haven't talked about these topics yet but you will understand what these phrases mean as we go through integration and chemical shifts and coupling let's say we have an NMR spectrum and we suspect that we have a labile proton in our molecule is there a way that we can use this exchange process to figure out what signals belong to labile protons the answer is yes what we can do is we can add D2O to our NMR sample why would this help us remember that D stands for deuterium deuterium is simply a hydrogen atom that contains 1 neutron therefore deuterium will exchange with the labile protons in a molecule remember from the previous webcast that deuterium does not appear in a proton NMR spectrum as a result as this labile proton, circled in red, is exchanged for deuterium the signal in the NMR spectrum that belongs to this proton gets smaller and smaller and smaller until it disappears once it has been completely replaced with deuterium the addition of deuterium isn't the only reason a labile proton might disappear chloroform which is the most common NMR solvent is slightly acidic the practical consequence of this is that labile protons may not appear in an NMR spectrum, even without the use of D2O Here's a demonstration of a D2O experiment up top I have the NMR spectrum for this amine and the bottom I have the same spectrum for the same amine but I've added D2O are these 2 spectra different in the top spectra I see this signal here but in the bottom spectra I don't why is that It's because this signal belongs to the protons in the amine as theses protons are swapped out for deuterium this signal disappeared .
this is how you identify labile protons in your proton NMR spectra. in this webcast we will use the NMR spectrum of 1-propanol to demonstrate various ideas. as you go through each aspect of a proton NMR spectrum, the number of signals in that spectrum, the integration of those signals, the peak splitting of those signals, and the chemical shift of those signals, we will use 1-propanol as our example. now we will begin discussing application of NMR spectroscopy by first discussing equivalent hydrogens. when we talk about equivalent hydrogens, we are talking about hydrogens in the same chemical environment. one to way to describe chemical environment is by connectivity. in other words, what atoms are connected to these hydrogens and symmetry. equivalent hydrogens give rise to 1 signal in an NMR spectrum. for example, if i have 4 hydrogens that are chemically equivalent, i would see only one signal for those 4 hydrogens. for some examples let us begin by examining this structure here on the left. in this structure i have drawn in all of the hydrogens. i have also already told you how many sets are present in this one molecule. it turns out that all of these hydrogen atoms are chemically equivalent. let's talk about why that is. let us look at these 3 hydrogens on the left first. we see that these 3 hydrogens are all attached to the same carbon. the reason that these 3 hydrogens are chemically equivalent to each other is because if i take this carbon atom and i rotate it, i can rotate this hydrogen atom to be in this spot and this hydrogen atom into this spot. because i can freely rotate these hydrogen atoms to switch positions, they are chemically equivalent. this leads us to our first general rule for determining whether protons are chemically equivalent. hydrogens on the same carbon that can rotate, and can rotate is an important caveat which we will discuss shortly, are equivalent. so, these 3 protons on the left are chemically equivalent to each other. these protons on the right are chemically equivalent to each other. now let us discuss why the protons on different carbons are also equivalent to each other. this has to do with symmetry. draw a line straight down the middle of this molecule. you will see that the left side is a mirror image of the right side. because this molecule is symmetric, i can swap the positions of these protons simply by flipping the molecule. therefore these protons are chemically equivalent to these protons due to symmetry, which leads us to our second general rule. if a molecule is symmetrical or if a part of a molecule is symmetrical, mirror image sets of protons will be equivalent. let's show some more examples. in this new molecule i have 2 sets of protons. let's talk about why that is. i have these protons on the left which are attached to the same carbon so these are identical to each other. i have these protons on the right which are attached to the same carbon. therefore these are identical to each other as well. why are these protons on the right chemically equivalent to these protons on the left. this has to do with symmetry. i can flip or rotate this molecule and get the same structure back. therefore these green protons are chemically equivalent to each other. in contrast these red protons in the middle, while they are chemically equivalent to each other because they are attached to the same carbon, these red protons are not chemically equivalent to the green protons. let's go on to another example. in this structure, i have 3 sets of protons. the blue, the green, and the red. hopefully you can see why the green protons are different than the other 2 colors. these red protons on the right are part of a methyl group. these blue protons on the left also belong to a methyl group. yet they are different colors. why is this methyl group different from this methyl group? the reason for this is there is no symmetry in this molecule. this methyl group is attached to the carbonyl. this methyl group is attached to this methylene. therefore the red protons are not the same as the blue protons. use the same logic in rings. look at this molecule on the bottom left. i have 4 sets of equivalent protons. purple, blue, green, and red. by this point you should recognize that the red protons are different from all other protons and that the purple proton is different from all other protons. now let's look at the blue and green protons. these green protons are on opposite sides of the molecule, same with the blue protons. why are the green protons chemically equivalent to each other? this is because of symmetry. if i draw a line right through the middle of this molecule i see that i can rotate this molecule and flip it so that the green protons swap and the blue protons swap. one final, more tricky example. here i have an alkene. this alkene has 4 sets of equivalent protons.
I have these red protons that are part of the methyl group, and I have these purple, green, and blue attached to the alkene. Previously, I stated that if hydrogens are on the same carbon, they are equivalent. Yet, these green and blue protons are labeled as different. Why is that? It has to do with a stimulation that I said for that rule. That if they are on the same carbon and the carbon can rotate to swap the proton positions, then they are equivalent. This carbon carbon double bond cannot rotate; therefore, this green proton cannot switch positions with this blue proton. Therefore, they are not chemically equivalent. Okay. Let's give you some practice now. Here is one propanol. Pause the video, take a few minutes, and tell me how many sets of chemically equivalent protons are there in one propanol. Welcome back! Let's see how you did. I see the protons here as part of the methyl group being chemically equivalent. I see the protons on this methylene as being chemically equivalent. I see the protons on the next door methylene to be chemically equivalent. Finally, I see this proton as part of the alcohol, as it's own set. We finished our discussion on identifying equivalent sets of protons. Now we are going to talk about integration of the signals that result from those individual sets. Recall that each signal on a proton NMR spectrum results from one set of equivalent protons. What integration, or in other words the area underneath each of these signals, tells us the number of chemically equivalent protons that belong to that set. For example, let us look on the left side of the NMR spectrum here. I have this signal, which corresponds to one set of equivalent protons. This number underneath that signal is the integration. What this tells me is that there are two protons that belong to this particular set. If we go next door, I see an integration of 0.98. That is a fraction. Is that a problem? No. These values that we see below are calculated by the computer and are calculated using the data provided by the experiment. Lower quality data will give us less accurate integrations. When we see non-integer integration, like we see here, you usually round to the nearest whole number. So, in this case, 0.98 rounds to 1.0. So, this signal here, contains only one proton in that particular set. You go to the next signal. This signal we would round to two. So, there are two protons that are part of this set. And this final signal, with an integration value of three indicates that there are three protons in this set. Now there is one stipulation here. All of these integration values are relative. Remember, a computer calculates these integration values. What the computer does not know is exactly how many protons are present in each signal. All it can give us is the ration between all of these signals. For example, these signals can instead be four, two, four, and six, or six, three, six, and nine. The computer would not be able to distinguish that. For this course, you can assume that the integration signals that you see are accurate as is; unless, the equation says otherwise. Now, let us how the NMR spectrum for one propanol matches with what we have learned about and what we should see. When we were discussing sets of equivalent protons, we figured out that we should see four signals for one propanol because we have four sets of equivalent protons. We have this set here, this set here, this set here, and, finally, this set here. Do we see four signals in our NMR spectrum? Yes, we do! One, two, three, and four! Each of these signals corresponds to one set in our molecule. Can we begin assigning which signals belong to which set using integration? Well, let's think about it. Let us look at the signal farthest right. This has an integration of three. Do any of our sets of protons contain three protons?
The answer is yes. The purple protons contain three protons. Therefore this signal corresponds to this set of protons here. What about this signal here? that integrates for one. What set does that belong to? It has to belong to the orange set because the orange set is the only set that contains only one proton. Okay, that's not so bad, we've begun seeing how the NMR spectrum lines up with the molecule structure. What about these last two signals? unfortunately we can't identify these just yet. Both of these signals have an integration of two. The remaining sets of protons both contain two protons. We're going to need more information before assigning each of these signals to a particular set. A tool that can help us do that is what is called chemical shift. The x axis of an NRM spectrum is measured in chemical shift, usually represented by the greek letter delta with the units being ppm. PPM stands for parts per million. Why use such a strange unit? The reason we use ppm instead of other units such as hertz is because NMR spectrometers come in various strengths. It would be very inconvenient to have to use a different unit for every different strength of spectrometer. By using ppm, we allow all NMR spectra to use the same units regardless of the strength of the spectrometer. To calculate ppm, we take the energy of the signal we measured from the NMR experiment, which is measured using frequency, the unit for which is hertz. Then we divide it by the strength of the spectrometer, which is measured in mega hertz. Look at these units. Hertz over mega hertz. One over a million. That's where the parts per million unit comes from. Some terminology before we continue. When interpreting NMR spectra, we often have to compare signals to each other. When we do so, we don't use the terms left or right. Instead we use the terms upfield and downfield. For example if I am looking at this signal here, and comparing it to this signal to its right, this signal is downfield of the signal at lower ppm value. In contrast, this signal is upfield of the signal at a higher ppm value. Which you can see here. Farthest upfield we have hydrogen atoms attached to carbons which are not near electron withdrawing groups. We will define what electron withdrawing groups are in a few slides. For now, just know the term and know that electron withdrawing groups tend to be functional groups that contain heteroatoms such as oxygen and nitrogen. If we begin to move downfield, we find hydrogen atoms that are near heteroatoms such as oxygen or nitrogen. Not all electron withdrawing groups are equivalent. Carbonyls for example are electron withdrawing, but they are not strongly electron withdrawing. As a result, hydrogen atoms near a carbonyl, notice how I'm saying near not a attached to, you will see in a little bit how hydrogen atoms attached to an aldehyde or attached to a carboxylic acid are very far downfield, but for normal hydrogen atoms that are near a carbonyl, those tend to be around 2 to 2.5 ppm because a carbonyl is not a strong electron withdrawing group. In contrast, hydrogen atoms near say an alcohol or an amine tend to be farther downfield from 3 to 4 ppm. We continue moving downfield, we find hydrogen atoms attached to alkenes, hydrogen atoms attached to aromatic rings, of which a phenyl ring is a common example. And finally, farthest downfield we have hydrogen atoms are a part of an aldehyde or part of a carboxylic acid. You may have noticed that these number ranges do not exactly match the numbers you see in the spectra data tables on the cover of your laboratory manual, which you can also find on the compass 2g course website. The values in those tables have been distilled to this simple image, which has divided the proton NMR spectrum into whole numbers and half numbers for your convenience. You are expected to memorize these regions. An important note before we continue, these regions are not hard barriers. It is possible for an alkene proton to appear above 6.5 ppm. It depends on what exactly is around that proton. That being said, these values for regions you see here are good rules of thumb for most spectroscopy problems. Just remember that overlap between regions is possible. Now that we have discussed at what chemical shift different types of protons appear at in a proton NMR spectrum, we are going to discuss why these different types of protons appear in these specific chemical shift. What makes a hydrogen atom not near an electron withdrawing group so different from a hydrogen atom that is near an electron withdrawing group?
This has to do with the concept called shielding. A nucleus with more electron density is what we call shielded. And shielded signals appear upfield. What do we mean by shielded? We'll talk about what shielded means on the next slide. In contrast. A nucleus with less electron density is deshielded, and will therefore appear down-field. Lets look at 1-propanol here on the left. Lets consider this proton here in blue. Is this proton shielded or deshielded? Remember if you are shielded you have more electron density. How much electron density does this proton have? Notice that it is quite close to this oxygen. Oxygen is electronegative. That means oxygen will pull electron density towards it. It is what we call an electron withdrawing group. That means this proton is losing electron density. This proton is deshielded. Lets go next door to this proton. Is this shielded or deshielded? The oxygen is pulling electron density from this proton in the middle. However, because this proton is farther away it is not losing as much electron density. As a result, it is more shielded than the first proton. But still it is slightly deshielded. This is all about comparisons here. Let's look at this final proton on the left. Is this shielded or deshielded? This proton is very far away from this electronegative oxygen. Therefore, if this proton is losing electron density, it is losing only a very small amount of it. Therefore, this proton on the left is the most shielded of all of these. Because this proton on the left is most shielded, it will appear furthest upfield. Because this proton on the right is the most deshielded, it will appear the furthest downfield. What about this proton that is part of the alcohol? It's directly attached to that oxygen. Doesn't that mean it should appear farthest downfield of all of these? This proton is attached to an oxygen. Therefore it is a labile proton. And labile protons tend to not follow all the rules that other protons do. This labile proton can appear in a large range on the NMR spectrum. And it's very difficult to predict where it will appear exactly. In the NMR spectrum for 1-propanol, you've seen that signals have appeared at particular values on the x-axis. Where do those values come from? They result from a comparison to a standard. Remember how we standardized NMR spectra by using ppm as our unit for chemical shift. To decide whether a signals appears at 3 ppm or 9 ppm or 1 ppm, we make another comparison. Tetramethylsilane, or TMS for short, is a universal NMR standard. The hydrogen atoms in TMS are very shielded. As a result, most protons signals in an NMR spectrum will appear down-field of TMS. So what we do to make NMR spectroscopy analysis easier is make the signals in TMS equal to zero and compare everything to that. If you see an NMR signal at 1 ppm, that means that signal is 1 ppm down-field of TMS. What causes this shielding effect? Why does the presence of electron density affect the chemical shift of our signals? In this diagram, I have a nuclei here as shown by this arrow and the electron density around this nuclei is represented by this blue sphere. Remember that electrons are charged, and that these electrons are spinning. Because electrons are charged and spinning, they generate a magnetic field. It turns out, the magnetic field generated by the spinning electrons shown here by the green arrow, is pointed in the opposite direction of the magnetic field we apply in an NMR experiment. Because the magnetic field applied by the electrons is in the opposite direction of the applied magnetic field, it cancels out some of the applied magnetic field. And makes the applied magnetic field weaker. This means that the nuclei feels less of the magnetic field. It is shielded from the applied magnetic field. Therefore, it appears upfield in an NMR spectrum. In contrast, if I had little electron density, I would have a smaller electron magnetic field, which would cancel out less of the applied magnetic field. That means nuclei will be less shielded and would appear down-field. This explains why hydrogen atoms near electron withdrawing groups are further down-field than hydrogens not near electron withdrawing groups. However, if you recall the general chemical shift tables from a while back, you know that alkenes and aromatic protons are even further downfield. Yet those don't have any electron withdrawing groups. This has to do with an idea called anisotropy. We will not discuss anisotropy in this course. Simply know that it exists and explains why hydrogen atoms are part of alkenes and aromatic rings appear farther down-field than hydrogen atoms near electron withdrawing groups. How can we use chemical shift to our advantage? Previously, we had assigned several of our sets of protons, we know that the purple protons belong to this signal on the right.
Let's look at the blue protons. The blue protons are closer to the Oxygen than the red protons are. That means the blue protons should be less shielded than the red protons. If the blue protons are less shielded they should appear further downfield. Which of these two unassigned signals is further downfield? The one on the left. Therefore this signal should correspond to the blue protons. In contrast, the red protons are farther away from this oxygen. That means the red protons are more shielded therefore they should appear further upfield. Which means, this signal further upfield belongs to the red protons, and we already know what signal the purple protons belong to we could use the same logic here. The purple protons are farthest away from the oxygen therefore they are the most shielded and should appear farthest upfield, and they do. If you go back and look at the table of general ranges that I expected you to memorize you'll see how these signals fit into those general ranges. One final topic before we finish this webcast. Spin-Spin Coupling. As you may have noticed signals in spectra often appear as multiple peaks. This signal on the left has 6-peaks. 1, 2, 3, 4, 5 6...and the signal on the right has three peaks. The number of peaks that belong to each signal indicates a number of neighboring or adjacent hydrogen's. The number of peaks present is called the 'multiplicity' of the signal. If you see 1-peak in a signal that is called a 'singlet'. If you see 2-peaks that is called a 'doublet'. When I ask for the multiplicity of a signal this is what I am asking for, how many peaks are present. What's the multiplicity of this signal? It has 1, 2, 3-peaks, therefore this would be called a 'triplet'. What about the signal on the left? There are 6-peaks therefore that would be called a 'sextet'. Before continuing one quick note on 'multiplet'. In this course your NMR Spectra should be what an Organic Chemist would call 'clean'. They will be easy to interpret. I would not expect to see many complex NMR signals that you would have to call multiplets because there are no clear pattern's. Where does this splitting come from? Why do signals appear as multiple peaks? It is because the magnetic field of a proton is affected by the magnetic fields of it's neighbors. For example, consider this molecule where we have proton A and proton B. If we consider proton A it has a magnetic field which points up, or points down. Proton B has a magnetic field which can also point up or point down. this means it can be aligned with A in other words pointing in the same direction or it can be aligned against A pointing in the opposite direction. Depending on which it is proton A is either more shielded or more deshielded. Think back to what we talked about when discussing the shielding effects of electron's. the magnetic field of spinning electron's cancelled out some of the magnetic field we apply because of the magnetic field of the electrons was opposite the applied magnetic field. it is the same thing here. If Hb points in the same direction it creates more shielding. If Hb points in the opposite direction it creates deshielding. Of course, this works both ways. If Hb effects or what we call 'splits' Ha then Ha also has to effect or 'split' Hb. What's the consequence of this? If Ha is all on it's own we would expect to see a signal with one peak. However, once we consider Hb we instead get two peaks. One of these peaks results from Hb increasing the shielding of Ha and one of these peaks results from Hb deshielding Ha. This is why we would see a doublet here. How close does a proton have to be to split another proton? Typically, although there are exceptions only vicinal protons, in other words, protons that are on adjacent carbons will split each other. Here Ha and Hb are vicinal. They are on adjacent carbons therefore they split each other. As you might expect, Labile protons tend to not follow this rule. Usually Labile protons do not cause splitting and are not split themselves, even if they are vicinal to other protons.
Now that we understand where splitting comes from how do we know how many peaks a signal should appear as? To make this prediction, you use the n+1 rule. If hydrogen A has some number of neighboring equivalent hydrogens, which we are gonna designate it by n, the number of peaks in A's signal is n+1. For example, if there are no neighbors then I would see only one peak in my signal, a singlet. If I had one neighbor, like I saw on the previous slide, I should see two peaks, a doublet, where 1+1 is 2. You can use this equation in reverse as well. If I have a quartet, four peaks, I know that the protons in that signal must have three neighbors. Let's see if that n+1 rule matches what we see in the spectrum for 1-propanol. Let's look at the purple protons first. How many neighbors do the purple protons have? Well, let's look at the vicinal carbon, the next door carbon. How many protons are attached to this carbon? One... two. The n+1 rule says there should be 2+1 peaks, three total. Does this signal correspond to the purple proton show up as a triplet? Yes it does. Now let's look at the red protons. How many neighbors does the red protons have? Well we have to look to all vicinal carbons. Is the vicinal carbon to the left and the vicinal carbon to the right. So you have to count all of the protons on those carbons. We have one, two, three, four, five. So the n+1 rule... says I should see 5+1, six peaks, a sextet. Does the signal correspond to the red proton show up as a sextet? Yes it does. Now lets look at the blue protons. I have a vicinal carbon to the left, which has two protons. What about this proton to the right? Does that split our blue protons as well? No... because this is a labile proton. Labile protons do not cause splitting. That means the blue protons have only two neighbors, which means I should see... a triplet. Do they show up as a triplet? Yes they do. One final note, notice how the labile proton shows up only as a singlet because it is not split by any adjacent protons. To recap what we have discussed in this webcast. Proton NMR spectroscopy allow us to learn a great deal about the structure of a molecule. The numbers of signal we see tells us the number of different protons present in a molecule. The integration of each signal tells us the number of protons that contribute to that signal. The chemical shift to that signal gives us information about what kind of protons are present? And finally, splitting provides the information about the number of adjacent protons.
Compound Characterization: Proton Nuclear Magnetic Resonance Spectroscopy Spectra Interpretation Part II. In the previous webcast, we discussed how you can pull a great deal of information out of a proton NMR spectrum. Examples include chemical shift, integration, and multiplicity. In this webcast we will discuss the final piece of information you can pull out of a proton NMR spectrum: Coupling constants, also known as J couplets. A coupling constant, or a J constant or a J value, is the distance between peaks in an NMR signal. This distance must be measured in Hz. It is a quantitative measurement of the magnetic influence of neighboring hydrogens. For example, if a neighboring hydrogen has a large amount of magnetic influence, then you should expect a correspondingly large coupling constant. This J value is independent of the strength of the spectrometer. This is why it is measured in Hz. In the same way that splitting is reciprocal, the J value for the splitting must also be reciprocol. If Ha splitting Hb has some coupling constant, Hb splitting Ha must have the same coupling constant. Let us look at these proton NMR signals at the bottom of the slide. Here we see that in these particular signals, we have these numbers, these values, above each of these peaks in the signals. These values correspond to the exact ppm value of each peak. To calculate the J value, based on this definition up here, the distance between the peaks, you might think that this will be as simple as taking value one and subtracting value two. However, there is a caveat here. What you need to remember is that this value must be measured in Hz, where these values are all in parts per million. How do we convert parts per million into Hz? We'll discuss this on the next slide. Before continuing, one note: for this course, when we talk about coupling constants, we are talking specifically about what are called simple first order coupling constants. Simple first order coupling produces proton NMR signals of the kind that you have been shown. There are situations where peak splitting does not produce these types of clean signals. For this course you do not have to worry about these more complex types of signals. Now, a demonstration on how to calculate simple J values. Here in the upper left we have the molecular structure for diethyl ether. These proton NMR signals you see correspond to the protons in diethyl ether. In the interest of getting more practice, you may wish to spend some more time figuring out which signals correspond to what protons in the structure after the end of this webcast. If I want to calculate the J values for these signals, I have to be able to convert these ppm values to Hz values. How do we do that? The first thing we have to know is what is the strength of our spectrometer. In this example, these signals were taken in a spectrometer with the strength of 500 MHz. Now, remember that ppm is calculated by taking the chemical shift of the peak in Hz and dividing it by the strength of the spectrometer, which is measured in MHz, or to give us ppm as our chemical shift. If I want to take the chemical shift of a peak in ppm and convert it back into Hz, all I need to do is take my chemical shift in ppm and multiply it by the frequency of the spectrometer instrument. Knowing this information, let's calculate the J value for this triplet on the left. It is important to know that the J value for a signal is independent of which two peaks you decide to use to calculate it. For example, in this triplet, I could take this distance between peaks from the left-most peak to the middle peak, or I could take the distance from the middle peak to the right peak. Either distance will give me the same J value. Let's say I decide to use this distance on the right. What I could do is take this value, plug it into this equation, and calculate the shift in Hz, take the second value do the same thing, and then subtract the two values. That is a perfectly valid way to calculate the J value. What I prefer to do is instead of converting each of these signals into Hz individually, if you subtract them and then convert them into Hz. Let me show you that process now. That is the chemical shift of my middle peak in ppm. Now I shall subtract the chemical shift of the right peak in ppm.
And that gives me the difference in chemical shift in ppm. Now I wish to convert this into Hertz, I simply multiply this by the strength of the spectrometer, which gives me a value of 5.81 Hz. When talking about J-values, you always round to the tenths place. This means that the J-value the coupling constant for this triplet is 5.8 Hz. Let's do the same thing for this quartet on the right. I shall again pick the two right most peaks. Remember, it doesn't matter which two peaks I select. Either distance between adjacent peaks should give us the same J-value. Do the same calculation. That's my difference in chemical shift in ppm. Now, let's convert it into Hertz by multiplying by the strength of the spectrometer to give me a coupling constant of 5.8 Hz. Again, round it to the tenth place. Notice how these values are identical. This is because coupling constants are reciprocal. If these two signals result from protons splitting each other, they must have the same coupling constant. In this case, that should make sense because these protons on the methylene and these protons on the methyl must be splitting each other they must possess the same J-value. Now, let's say you selected a different distance. For example, if you look at this triplet on the left, what if instead we selected the left most peak and the middle peak. What J-value will we calculate there? What I told you is that we should obtain the same J-value. But, if you use these numbers on the screen you would instead see a J-value equal to 6.0 Hz. Why is that? These chemical shift values are given to us by computer. How accurately the computer is able to measure the middle of each of these peaks determines how accurate our calculated J-values are. So what happens if the J-value you calculate is different than the J-value I calculate because I selected a different distance? Your answer will still be acceptable. So long as your answer is within the threshold, say plus or minus 0.2 Hz, your answer is fine. Those values are about the same and any difference is a result of the numbers given to you by the computer. Now for some practice. Go ahead and calculate the coupling constant for this signal here. Remember that these values in blue up top are measured in ppm. Pause the video and calculate the J-value the coupling constant for this sextet. Welcome back. Let's see how you did. For this signal, I'm selecting the middle two peaks. This is not a requirement, you can select any two peaks that are adjacent to each other. I just happened to be selecting the middle two. Do some calculations and get the difference in ppm. And then multiply by the strength of the spectrometer which this time is 600 MHz. Make sure you pay attention to the values the problem gives you to get a value of 7.9 Hz. Now your value might be slightly different. Your different might be a little bit more or it might be a little bit less. So long as you selected two peaks that were adjacent to each other and used the values given to you by the problem your answer is acceptable. What makes this useful as a tool to us? Remember J-values are reciprocal. That means that if you have two signals that have the same J-value, you know that the protons belonging to those signals must be adjacent to each other. You learned about connectivity this way. Before finishing this webcast, we have to talk about something that was glossed over in the previous one. In the previous webcast, we discussed why two protons that are next door to each other split each other. When trying to predict how many peaks each A should possess, we learned about the n+ 1 rule. Where if we have a hydrogen that has n number of neighboring equivalent hydrogens the number of peaks is n+ 1. There was a word in this that I didn't discuss last webcast. That word is equivalent. In most cases for aliphatic protons, the equivalent portion of this definition is not relevant. Unfortunately, not all protons are simply aliphatic protons.
consider a situation where we have two protons, Hb and Hc, splitting proton a. now consider what would happen if Hb and Hc are different types of protons. what should we see for the signal for Ha? if Hb and Hc did not interfere with Ha, we would expect to see a singlet, one signal. of course, we know that's not true. we know that Hb and Hc will affect Ha somehow. on the previous slide, we were reminded of how when Hb interacts with Ha we should we a doublet. now, what happens when we include Hc in this scenario? we know that, like Hb, Hc can either be aligned with the magnetic field of Ha or opposed to the magnetic field of Ha. Therefore, we should see splitting similar to what Hb preformed. well, we already have two peaks so, what should that splitting look like? you would see something that looks like this. where each of these peaks resulting from Ha splitting with Hb are now split by Hc producing a pair of doublets or what we call a doublet of doublets. an example that would cause this type of situation can be seen here in the middle. if you look at this green proton, you can call that Ha. if this green proton is Ha, it is being split by this blue proton and this purple proton, which are not the same. Therefore, this green proton would show up as a doublet of doublets. If you look at 1-propanol, our example from the proton nmr webcast part one, we saw that we had different sets of equivalent hydrogens. yet, for these red protons here, we didn't see a complicated splitting pattern that resulted multiple j-values. why is that? this is because for most aliphatic protons, even if they are non equivalent such as the purple and the blue protons, the coupling constants are close enough that we don't see this type of splitting. therefore, the n+1 rule still works for simple aliphatic protons. how can you, the student, figure out whether to use the n+1 rule or to be on the lookout for multiple j-values? i will inform you if multiple j-values are present. for this course, you simply need to be aware that nonequivalent protons can give different coupling constants resulting in more complex splitting patterns. our last topic for this webcast will be on how we can use these j-values, these coupling constants, to tell us something about the structure of the molecule. we already know that if signals have identical j-values, they have to be splitting each other. you can also use the numerical value of there coupling constants to tell us the orientation of some protons. if you look here in this blue box, we have two protons in various orientations. these orientations are shown via newman projections. in a newman projection, we are looking straight down a bond. this intersection here represents the front carbon we are looking down and the circle represents the second carbon of the bond we are looking down. the angle between these various bonds is called the dihedral angle. if you look at these two protons, our dihedral angle is 180 degrees. if you look at the middle structure where we have simply rotated this proton to a new position, our new dihedral angle is 60 degrees. if i rotate this proton again, it is now at 0 degrees. the dihedral angle between protons is important because the dihedral angle determines the strength of the coupling. if you look at the table below, we see a number of protons at different orientations and the resulting coupling constants between those two protons. the greatest value of these coupling constants is if we know something about the structure of the molecule already. if you look at the bottom of this table, we have proton a and proton b on the same carbon of an alkene, on different carbons of the alkene but on opposite sides of the double bond, what we call trans, or on different carbons of the alkene but on the same side of the double bond, what we call cis. you see how each orientation has a different coupling constant value range. if we know we have two protons that are part of the same alkene, we can know whether they are on the same carbon, they are trans or they are cis simply by looking at which range their coupling constant falls into. do not memorize these values. if they are needed they will be provided to you but do know how to use them. to recap this webcast, the coupling constant or the j-value of a signal is a measurement of the strength of the interaction between two nuclei. this value is calculated using the distance between peaks in a proton nmr signal and the strength of the instrument used to generate those signals. j-values are reciprocal. two protons splitting each other must have the same j-value. it is possible for signals to have more than one j-value. this occurs when a proton is being split by two significantly different types of protons. and finally, the dihedral angle between protons on adjacent carbons determines the strength of a coupling value and you can use those values to try and identify the relative positions and orientations of the two protons.
Previously we discussed what proton NMR is, and what it does for us in terms of determining the structure of molecules. This slide summarizes the information NMR can provide us. When discussing proton NMR we use the proton NMR for 1-propanol which can be seen here to demonstrate these ideas. Carbon 13 NMR provides some of the same information to us but for carbons instead. Carbon 13 NMR tells us the number of unique sets of carbons in the molecule via the number of singles in the spectrum, very similar to proton NMR, and finally it gives us some information about what kinds of carbons are in the molecule and the presence of functional groups via chemical shift. On this slide we see the Carbon 13 spectrum of 1-propanol. As you can see this is similar to a proton NMR spectrum where we have distinct signals, and these signals are present at different chemical shifts. You may also have noticed some differences, for example, there is no splitting in these signals. We are now going to discuss how proton and Carbon 13 NMR are similar and how are they different. Like a proton, Carbon 13 has a nuclei spin of 1/2, as a result we can see Carbon 13 nuclei in an NMR spectrum. unlike protons where most protons are H1 the NMR active nuclei of Carbon 13 is not the most abundant isotope. In fact, less than 1 percent of all carbon is Carbon 13. the consequence of having little Carbon 13 is we get weaker signals during an experiment. As a result, Carbon 13 experiments often require more time to get data of quality similar to a proton NMR. Fortunately for us Carbon 13 resonates, or absorbs energy at a different frequency than protons do. This means that a proton NMR tells us only about protons and carbon NMR tells us only about carbons. Like in proton NMR the number of signals in a Carbon 13 NMR tells us how many sets of equivalent carbons are present. However, because Carbon 13 is not very abundant the integration of a Carbon 13 signal is unreliable, it can be done, but it is often not done. Like in proton NMR where the presence of functional groups effect the chemical shifts of nearby protons, in Carbon 13 NMR the presence of nearby functional groups will effect the chemical shift of carbon signals. One caveat to remember however, in a proton NMR your general ppm range for chemical shift is from 0-14 in a carbon NMR your chemical shift range is much higher 0-220. Finally Carbon 13 experiments are designed to decouple Carbon 13 nuclei from proton nuclei. Because both of these nuclei have the same spin quantum number they could split each other. A Carbon 13 experiment is designed to decouple the two nuclei, or in other words prevent them from splitting them from splitting each other. The practical consequence of this is that in a Carbon 13 NMR you do not see any multiplicity, which means you see no coupling constants. This explains why we don't see coupling between protons and carbons. What about coupling between Carbon 13 atoms and other Carbon 13 atoms? Answer is that we would except the abundance of Carbon 13 is quite low. the odds of two Carbon 13 atoms being next to each other in a molecule is quite low, as a result we do not see Carbon 13 atoms splitting adjacent Carbon 13 atoms. The take home message here is that in a Carbon 13 NMR the only pieces of information you are concerned about pulling out of it is the number of sets of equivalent carbons and the chemical shift of the singles in your NMR spectrum. The number of sets of NMR carbons are determined the same way that is was done in proton NMR. If you can take a bond a rotate it to swap carbons to get the same molecule back those carbons are equivalent. Similarly, if you take a molecule and you can flip it and get the same structure back because of molecular symmetry those carbons are also equivalent. Each signal corresponds to a set of equivalent carbons. The chemical shift of carbon signals follows similar trends that you saw in proton NMR. Let's show that now.
Chemical shift ranges you can find in the same location. I don't expect you to memorize this entire table. Instead I expect you to memorize a set of important ranges, which you can see here. At the top I have included the general chemical shift ranges for proton NMR that we discussed in the proton NMR webcast. On the bottom we have the chemical shift ranges for Carbon 13 NMR that I expect you to memorize. You will notice that in contrast to the proton NMR ranges there are only three regions for a Carbon 13 NMR. Roughly from 0-90 ppm we have the aliphatic region where carbon is not near an electron withdrawing group (EWG) and carbons near electron withdrawing groups are located. From 90-170 ppm we have alkene carbons and aromatic carbons, and then beyond 170 ppm we have carbonyls. YYou will notice that the trend for Carbon 13 NMR is exactly the same as the trend for proton NMR, the key difference is the ppm value of the chemical shifts. Why are there fewer ranges in a carbon 13 NMR? This is because there is significantly more overlap in Carbon 13 NMR than there is in the proton NMR. In Carbon 13 NMR it is generally true that carbons near electron withdrawing groups will be farther downfield than carbons not near electron withdrawing groups. Similarly, in Carbon 13 NMR it is often true that carbon atoms in an aromatic ring will be farther downfield than carbon atoms in an alkene. However, these will not always be true. There is much more overlap in a Carbon 13 spectrum, so you have to be more careful using chemical shifting using Carbon 13 NMR than you would interpreting a proton NMR. Using this new knowledge lets go ahead and assign the carbons in the structure of 1-propanol to the signals we see in this carbon 13 spectrum for 1-propanol. Look at the carbon furthest from the right circled in purple, now you see that that carbon is very close to this electron withdrawing alcohol. That means that this carbon should be very deshielded, therefore should be further downfield. That means this purple carbon should belong to this signal here. To further drive home the point that there is no splitting in a carbon spectrum I have zoomed in on this signal here. Even when zoomed in we see only one peak. There is no splitting in a Carbon 13 NMR spectrum. Now lets look at this next door carbon. That's close to the alcohol but not that close, therefore it should be some what downfield not very downfield. That carbon should belong to this signal here. Look at this last carbon circled in blue, that is the furthest away from the alcohol therefore it should be the most shielded, and therefore should appear furthest upfield, it belongs to that carbon. As you can see, analysis of carbon NMR is much simpler than proton NMR. There is no integration, and there is no splitting. All that is left is chemical shift analysis and the number of signal's analysis, and fortunately the trends for chemical shift in a Carbon 13 NMR spectrum are the same as the trends in chemical shift for a proton NMR spectrum. The values will be different, but the trends are the same where the most shielded is upfield and the least shielded is downfield. To recap this webcast, Carbon 13 NMR spectroscopy allows us to learn about the structure of a molecule, in this case we are learning about the carbon atoms. The number of signals in a Carbon 13 NMR spectrum tells us the number of equivalent sets of carbons and the chemical shift of those signals gives us information about what kinds of carbons are in the molecule and the presence of functional groups. The trends for chemical shift in a Carbon 13 NMR are the same as the trends in chemical shift for a proton NMR, more shielded more upfield, less shielded more downfield. However, there is much more overlap in the potential chemical shift ranges for particular carbons. For example, the range for alkene carbons and the range for aromatic carbons possess significant overlap, therefore it is harder to identify what types of carbons are present based on the chemical shift, although you could still narrow the possibilities. Now we are going to work through some example Carbon 13 NMR spectrum problems. Up until this point the NMR spectra you have seen have been what an Organic Chemist would call clean. That means the signals you saw corresponded only to the molecule you were analyzing. In reality NMR spectra are not always so clean. Common signals you might see in a NMR spectrum that don't belong to your molecule, are signals corresponding to the NMR solvent. For example, in proton NMR you will often see a signal corresponding to Chloroform at 7.2 ppm and/or a signal corresponding to TMS at 0.0 ppm. Some of you may be thinking 'How can we see a Chloroform peak if we are using deuterated chloroform (CDCL3)?' Unfortunately in a bottle of deuterated chloroform not every molecule of chloroform is successfully deuterated, so there's always a little bit of CHCL3 as in impurity, which we see in the NMR spectrum. In Carbon 13 NMR the most common signal you see that doesn't belong to your molecule again belongs to chloroform, this time the carbon in chloroform, that usually appears at about 77 ppm and does so as a triplet. You'll see some examples of this in these example problems. Here we have a molecule of cyclopentanol, pause the video and predict how many signals in the Carbon 13 NMR we should see, and the chemical shifts of those signals.
Welcome back, lets see how you did. The first thing to recognize about this molecule is: it is symmetric. Right down the middle. How we identify identical sets of carbons is the same way to identify identical sets of protons. These two carbons up top are equivalent because I can simply flip this molecule and swap those carbon positions and get the same structure. Similarly, the carbons in the bottom are equivalent because if I again flip the molecule, i swap those positions and get the same molecule back. However, I'm not done. There is another carbon in this molecule. The carbon that is part of the carbonyl. In proton NMR, we often didn't look at carbonyls because they usually didn't have protons attached to them. In a carbon NMR however, we cannot forget carbonyls because those carbonyls have carbons in them. Now lets predict our chemical shifts. Carbonyls can appear over a wide ppm range. but I do know that they appear very far downfield. I shall predict somewhere in the range of 200ppm. In reality it may be a little bit more, it may be a little bit less, but it will be somewhere that far downfield. Now lets look at the carbons adjacent to that carbonyl. The carbonyl is electron withdrawing, but it's not that electron withdrawing. Therefore, I would predict somewhere around 40ppm. And finally, the blue protons being very far away from the carbonyl should be pretty far upfield. Therefore, I predict somewhere around 20ppm. If your number predictions don't match my number predictions, that's okay because remember all these values are approximate ranges. So long as you're in the ballpark, you're thinking about this the right way. Now let us see how good our predictions were. I predicted the carbonyl to be around 200ppm and I see the signal there corresponding to the carbonyl at what appears to be about 220ppm. so not that close, but in the right area. If we now look at the red carbons, I predicted somewhere at around 40ppm I see a signal at 38ppms, so that one actually not to bad. That's pretty close. And for the blue carbons, I predicted 20ppm. in reality, it's at about 20ppm. Again, not bad. And there we go, identifying the types of carbons present in the structure and their proximity to any nearby electron withdrawing groups, we were able to predict with some accuracy, the chemical shifts those carbons would appear at in the carbon 13 NMR spectrum. We also saw how identifying equivalent sets of carbons is the same as identifying equivalent sets of protons. One note before we go, if you look down here at around 77ppm, we see 3 peaks. This signal corresponds to the NMR solvent, chloroform. Don't mistake this signal for belonging to your compound if you see it. One more exercise before we finish. Like before, predict how many signals we should see in the carbon 13 NMR spectrum and their chemical shifts. Pause the video, take a few minutes to make your predictions, and then come back. Welcome back, let's see how you did. Like before, I'm going to be on the look out for symmetry. and here I do see some symmetry. I see these carbons all attached to the same carbon, therefore they should be equivalent. Theses aren't the only carbons present, however, we also have this carbon in the middle. When talking about proton NMR, we didn't care about that carbon because it didn't have any protons attached to it. But in carbon 13 NMR, it is present, it will appear in the NMR spectrum so we have to remember that it is there. Now lets predict some chemical shifts. That red carbon is very close to that alcohol, therefore it should be pretty deshielded. I predict somewhere in the region of 70ppm. Purple carbons are a little further away, I predict them to be slightly deshielded lets say about 30ppm. Again, if your predictions values don't match mine exactly, that's okay. So long as you're in the same range. Lets see how good our predictions were. For the purple carbons, I should see a signal at roughly 30ppm. And I do see a signal at roughly that ppm range. Excellent. How about the red carbon? I expected it at roughly 70ppm, I see a signal at roughly 70ppm. Another very good prediction. The take home message here is that the chemical shift trends you learned in proton NMR apply to the chemical shifts in carbon 13 NMR. There more shielded you are, the more upfield you are. The more deshielded you are, the more downfield...
Before we begin solving our first full spectroscopy problem we need one more tool in our toolbox. The degrees of unsaturation of a compound is a very quick piece of information to learn about a molecule but also very important. In order to fill octets, a molecule must possess a certain ratios of carbons, hydrogens, and heteroatoms. Different ratios of these atoms will result from the presence or absence of pi bonds and/or rings. The degrees of unsaturation of a molecule will tell us how many pi bonds or rings are present in a molecule. To calculate your degrees of unsaturation, you take the number of carbons in your molecules and multiply that by 2, then add 2 to that value and then you subtract the number of hydrogens in your molecule, add the number of nitrogen atoms in your molecule and then subtract the number of halogens in your molecule, where x here stands for halogen. You then take all of that and divide that by 2. A simple mathematical process but an important one. Do not memorize the equation. If you need it, it will be provided to you. Every degree of unsaturation corresponds to a multiple bond, a pi bond or a ring. Remember that a double bond is 1 pi bond. Therefore a double bond would correspond to one degree of unsaturation. A triple bond contains 2 pi bonds therefore it will contribute two degrees of unsaturation. Now that we know what the degrees of unsaturation of a molecule is, let's get some practice calculating it. On this slide is provided for you the molecular formula for some molecule. Pause the video and take a few minutes to calculate the degrees of unsaturation for this molecule. Welcome back, let's see how you did. We know that the degrees of unsaturation for a molecule calculated by taking the number carbon atoms in your molecule, multiplying it by 2, adding to it the value of 2, subtracting the number of hydrogen atoms in the molecule, adding a number of hydrogen atoms in the molecule, and then subtracting the number of halogens atoms, where halogens are fluorine, chlorine, bromine, and iodine. And taking all of that and dividing it by 2. We plug in the values from our molecular formula. We have 2 times the number 4 which is the number of carbons plus 2, minus the number of hydrogen atoms which is 6, plus the number of nitrogen atoms which is 1, minus the number of halogen atoms which is in this case is also 1 because we have one chlorine atom in our molecule. Take this and divide it by 2. We do some arithmetic and we find that this reduces down to 4 over 2 which is equal to the value of 2. So this molecule whatever it is has two degrees of unsaturation. What does that mean? That means we either...2 pi bonds or 2 rings or...1 pi bond and 1 ring. How do we know which scenario is the correct one? From just the degrees of unsaturation we don't. We have to use other spectroscopic information to help guide us there. But as a starting point this was an incredibly easy value to calculate and it gave us a great deal of information. If we were trying to solve the structure of this unknown molecule, our final structure has to fit one of these three possibilities. 2 pi bonds or 2 rings or 1 pi bond plus 1 ring. It cannot be anything else. That bring us to the end of the webcast. To recap, the degrees of unsaturation for a molecule tells you the number of pi-bonds and/or rings located in that molecule. To calculate the degrees of unsaturation for a molecule, you have to know the molecule formula. Either I have to give it to you or I give you a way to figure it out.
Solving spectroscopy problems. This webcast will hopefully give you some insight info how to take different types of spectra and use that spectra to determine the structure of an unknown compound. you start by first organizing your data. this means making use of tables. you'll be dealing with different types of spectra that give you different types of information and being able to organize the data in a way that makes sense will be crucial to success. Once you have the data organized and you begin interpreting it you must remember that each piece of your data must be consistant with all the other data at your disposal. for example, if you see a carbonyl stretch in your infrared spectrum, you must also see carbonyl signal in your carbon thirteen spectrum. remember solving spectroscopy problems is very much diagnosing a medical condition. you are taking the spare pieces of information and must come to a conclusion that is consistant will all those pieces of information. fortunately, some of the data you collect will be redundant. what this means is often there is no one correct way to solve a spectroscopy problem. it is entirely possible you could come to the same conclusion as the person next to you using a different logical route where both routes are equally valid. in a typical spectroscopy problem, you will be provided the molecular formula for the unknown molecule, in this case c5h10o, and a series of spectra. in this case, i have an ir spectra in the upper left, a 13C spectra in the upper right, and a proton nmr spectra at the bottom. this particular problem does not include a mass spectrum but you can imagine also being given mass spectra to interpret as well. this one slide contains a huge amount of information. so how do you begin trying to interpret these spectra and come up with an unknown structure? well you don't look at all of it all at once. to start with, lets look at the molecular formula and the infrared spectrum. the molecular formula allows us to calculate the degrees of unsaturation for the compound. lets remember that degrees of unsaturation is equal to two times the number of carbons plus two minus the number of hydrogens plus the number of nitrogen atoms minus the number of halogen atoms all over two. if we plug in out values, we see that we have two times five plus two minus ten all over two because we have no nitrogen atoms and we have no halogen atoms. do some arithmetic, we see that we have two over two or one degree of unsaturation. that means that we have one pi bond or one ring. now let us begin interpreting the ir spectrum. let us go through the regions in the ir spectrum as you were taught in the ir spectroscopy webcast. first, we know that anything in the fingerprint region is not to be interpreted so you can ignore everything on the right side there. now we start going to higher wave numbers. as we go from right to left, the first region we would encounter would be the carbon carbon double bond region, around 1650 wave numbers. do we see any stretches around 1650? no we don't so we do not have any carbon-carbon double bonds. the next region is for carbonyls at around 1700 wave numbers. do we see a stretch at around 1700 wave numbers? indeed we do. we have a carbonyl stretch at around 1700 wave numbers. lets start by making a table where the left side is the type of bond and the right side is the wave number. lets begin organizing our information. the next region would be at roughly 2200 which is where we would find any carbon-carbon triple bonds. do i see any carbon-carbon triple bond stretches? no i don't so we probably don't have a carbon-carbon triple bond. now lets look at 3000 wave numbers. at 3000 we would see c-h stretches. do we see any stretches here? yes we do. if i draw a line from 3000 we see that all of my c-h stretches are below 3000. therefore all of my c-h bonds in this molecule have carbons that are sp3 hybridized.
because I see nothing above 3000, I have no sp2 hybridized C-H bonds or sp hybridized C-H. Thats's pretty useful information to know. Finally, let's look in the 3500 area, do we see any major stretches here? Some of you are maybe thinking, ya, we see this here, and because this lump is so small, that's probably an N-H bond. Here is where you need to be careful. In this particular spectrum, this blob doesn't actually correspond to anything in our molecule, that blob corresponds to residual water in our sample. How would you, as a student know that? You would know that by the shape and the size. Remember, alcohols tend to be very broad and very tall, clearly not an O-H. It is very small, which is consistent with what you have seen for N-H's. However, the shape of this blob is not consistent with the N-H's you have seen. The N-H stretches you have seen have been either relatively short but broad 2 peak signals, or moderately strong, single peak signals. That's how I know this does not belong to my molecule and is likely just residual water. And there we go, you finished our analysis of the infrared spectrum. I note that I have a carbonyl somewhere in my molecule and all of my C-H bonds are sp3 hybridized carbon C-H bonds. Doesn't sound like much, but that gives us actually a great deal. For example, remember how we had only one degree of unsaturation, and that degrees of unsaturation correspond to either pi bonds or rings? We now know that this one degree of unsaturation corresponds to the carbonyl in our molecule. We know we have a carbonyl because we have a stretch that tells us we do. Carbonyls contain a pi bond, therefore the carbonyl is the source of our one degree of unsaturation. We now know that there are no rings in our molecule because we have no degrees of unsaturation left, and we have no other pi bonds in the molecule. We have done a very quick analysis here but we have learned a great deal from this very short analysis. Okay, so far we have calculated our degrees of unsaturation, which is a value of one and recorded that in our tables. In the IR spectrum, we have filled a table containing the major stretches in the IR spectrum. Now let's move on to interpreting the carbon 13 NMR. Before we start, let us note that we have three peaks here at roughly 77 ppm. Remember, that corresponds to chloroform, the NMR solvent, so it is not part of our molecule. Now let's start our interpretation. First, we're going to label these carbon signals. In this course, for consistency, we're going to label carbon signals using numbers, from left to right. So this signal on the left, is 1, and we go from left to right, we simply label those 2, 3, 4. Let's go ahead and start making a table. 1, 2, 3, 4. And now let's record the chemical shift of each of these signals. Look at carbon 1, that's between 210 and 220, it's probably about 213, doesn't have to be exact. Let's remember the units for this column are ppm. Let's look at carbon 2, and it looks to be, OHH, 42 ppm. Carbon 3 appears to be 27 ppm. And carbon 4, let's say 18 ppm. And that's it. That is the entire analysis of our carbon 13 spectrum. What has this analysis told us? Remember that a carbon 13 NMR tells us 2 things: tells us the number of equivalents of carbons, and it gives us some information about the types of carbons present and/or the presence of functional groups. Let's look at the number of signals we have. 1,2,3,4. Now let;s compare that number to the number of carbons in our molecular formula.
Five. I have 5 carbons in my molecular formula but only four signals in the carbon NMR. How is that possible. It's possible because of symmetry. Remember, a signal corresponds to a set of equivalent carbon atoms. That means one of these signals, 1,2,3, or 4, must contain two carbon atoms. Which one is it? In a proton NMR we would know via integration. Unfortunately, carbon 14 NMR does not integrate well. Now ets look at these chemical shifts, I have a signal at 213 ppm. I know that carbonyl carbons show up in that range That means I have a carbonyl somewhere in my molecule. And that's good because this is consistent with our conclusions from the IR spectrum analysis. We had a carbonyl stretch in the IR spectrum, we have a carbon 13 signal in the carbon 13 NMR, our data is consistent. What about these other chemical shifts. 42, 27, 18. Those are pretty far upfeild so that means we probably don't have any strong electron withdrawing groups in the molecule. That being said, signals 2 and 3 are slightly deshieleded. Do we know of any electron withdrawing groups that could be desheilding 2 and 3. Sure we do! The carbonyl. This tells me that carbons 2 and 3 are probably close to the carbonyl, maybe even directly attached to it. I don't know that for certain, but given the information we currently possess that's not a bad guess. Okay so we finished analyzing the carbon 13 spectrum. we now take this information, put it into our table if we've not already done so. Then we begin analyzing the proton NMR spectrum. Analyzing the proton NMR spectrum is likely to be the most time consuming portion of any spectroscopy problem.. This is because yo can pull out more information form a proton NMR spectrum then you can from the other types of spectra given to you. Let us begin by labeling our proton NMR signals. In this course for consistency we are going to label proton signals using letter, starting with A from left to right. Now that that's done, lets begin building our table. What pieces of information can we get out of a NMR spectrum. Like with the carbon, you can pull out chemical shift, Unlike the carbon, we can pull out integration and multiplicity and coupling constants, j-values. Lets go ahead and begin filling in these values by first looking at the chemical shifts of our signals. Lets look at signal A. It turns out I have a zoomed in picture of signal A and I can see that the middle of the signal is at about 2.55 ppm. If we look at signal B next that looks to be at about 2.05. Look at signal C, the middle looks to be at about -mm- 1.16 ppm. Great. Chemical shift is done, now lets move onto integration. Look at these values down below. Signal A has an integration of 1, signal B has an integration that rounds to 3 because 3 is the closes integer. And signal C has an integration of 6 because 6 is the closest integer, Okay, we're done there as well, now lets move onto multiplicity. How many peaks does signal A have? 1, 2, 3, 4, 5, 6,7. That makes signal a a septet. Which is sept. for short. Look at signal B, I see only one peak therefore that's a singlet. S for short. And finally for signal C, we have 2 peaks therefore that's a doublet. D for short. Now lets looks at out J-values. Lets look at signal B, signal B has no splitting. Therefore signal B has no coupling constant, no J-value. A and C however so have splitting therefore they must have a coupling constant, a J-value. Lets look at signal A first, looking at the zoomed area for signal A, I'm going to pick the 2 leftmost peaks. You don't have to, you can pick any two adjacent peaks, but I'm going to pick the two left most peaks. I don't have to, you can pick any two adjacent peaks, but I'm going to pick these left two I'm not gong to show the arithmetic here, but if I take the difference in chemical shift between these two peaks and multiply it by the spectrometer, 500Mhz, the value I get is 6.4 Hz. If I do this same arithmetic for the doublet on the right, I get 6.4 Hz. Isn't that interesting? And there we go, we have pulled out all of the information we can from this proton NMR spectrum. We see that we have 3 sets of equivalent protons, .
And we've listed the chemical shifts of the signals, integration of those signals, the multiplicity of those signals, and the coupling constants of those signals. We're not going to do a full analysis here but what are some good things we can see from this data? From the chemical shifts of our protons, we see that all of our protons are relatively upfield. That means there are no strong electron withdrawing groups in our molecule. This is consistent with our carbon NMR ID. If we look at the integrations we see that we have integrations of 1, 3, and 6. We know that carbons cannot have more than 4 bonds, how can we have an integration of six? To get an integration of 6, you must have protons on different carbons that are chemically equivalent. Another indication of symmetry. We'll talk more about multiplicity on the next slide, but before we leave we should look at the coupling constants. Signal a and c have the same coupling constant, therefore they must be splitting each other. Therefore they must be adjacent to each other. We have now finished interpreting our proton NMR spectrum. We have taken the information from the spectrum and organized it into a table. Now lets see if we can take all the information we possess and turn it into a molecular structure. This slide contains all the data tables that we have created so far in this spectroscopy analysis. We have our molec formula and the associated degrees of unsaturation and the infrared stretches that we identified in the infrared spectrum, we have the chemical shifts of the carbon signals from the carbon 13 NMR spectrum, we have the data from the proton NMR spectrum that we did right now. How we can can take these disparate pieces of information and put them into a molecular structure. I'm going to show you one way to parse this data. There are likely dif ways you can analyze this data and come to the same conclusion. Don't think that you have to solve these types of problems the same way I am about to. I am simply giving a demonstration of how I solve these types of problems. First I know that I have a carbonyl. I know that this carbonyl takes care of our one degree of unsaturation. I also know that this carbonyl contains our only electronegative atom. Therefore this carbonyl is the only EWG in the molecule. Because the carbonyl is the only EWG in this molecule, the signals that are downfield in the proton and carbon spectra must be attached to this carbonyl. If we look specifically at the protons we see that signals A and B both have relatively downfield chemical shifts. That means that they are most likely adjacent to this carbonyl. Okay if we want to connect A and B to the carbonyl we have to know what A and B correspond to. Are the methines, methylenes, methyls? How can we figure out what they are? lets look at the other information we possess. We see that sig B is a singlet with an integration of 3. The integration of 3 tells me that B is probably methyl. The fact that it is a singlet tells me that this methyl is not adjacent to any other protons. This is a good indication that the methyl is probably directly connected to the carbonyl. Does all our data support this? We have a signal that is probably a methyl because it has an integration of 3. It is a singlet therefore it is not adjacent to any protons, and it is relatively downfield meaning it is probably next to our EWG carbonyl and that all matches our proposed partial structure. Lets look at signal A. Signal A has an integration of 1 and is a septet. An integration of 1 tells me that it is probably a methine which means it is connected to three things. Because the chemical shift is so far downfield it is probably connected to the carbonyl.
Doesn't tell us what else the methine is connected to. What are our options? The protons that are connected to signal c are the only ones left. Let's look at what types of protons those are. We see that we have an integration of 6. The multiplicity of that signal was a doublet. The integration of 6 tells me that this is probably two methyl groups because 2 times 3 would be 6. This could be three methelenes. However, if we look at our partial structure we've used three carbons out of the five available. That means there are only two carbons left. Therefore, this has to be two methyl groups and not three methelenes. If I attach those methyl groups to the methine, does all off my data make sense? Signal c is an integration of 6 that appears as a doublet. Would these protons that I've labeled in green be chemically equivalent? Yes they would, and would integrate to 6. Would they appear as a doublet? Yes they would, these protons are adjacent to only one proton, therefore they would appear as a doublet. Does the coupling constant make sense? C has a coupling constant of 6.4 therefore the coupling constant for this methine which is signal a should also be 6.4, and it is. A and C must be adjacent to each other because they have the same J value. And indeed they are adjacent to each other in this proposed structure. Does the chemical shift for c make sense? With a chemical shift of about 1 that means it's far away from any electron withdrawing groups, and indeed these methyls are far away from our electron withdrawing carbonyl. So the data for signal c matched our proposed structure. Let's go back a make sure it also matched our data for a and b. In our proposed structure signal b belongs to this methyl all on its own, and we've already shown how all of this data matches its proposed location. Let's look at signal a. For signal a, we've already talked about how the chemical shift matches, and the integration matched, and the coupling constant matches. What about the multiplicity? Signal a our methine is adjacent to 6 protons, therefor it should appear as a septet. Does it? Yes it does. This proposed structure is consistent with all of our proton NMR data. It was only one degree of unsaturation therefore it matches our degree of saturation value. The functional groups in our proposed structure match the information we got from the infrared spectrum. We have a carbonyl and all of our CH bonds contain sp3 hybridized carbons. What about the carbon NMR data. We have one carbonyl carbon that't present in our proposed structure. That's great. And we have three other carbon signal, bringing us to four carbon signals total. Does this proposed structure give us four carbon signals? Yes, this methyl would produce its own signal. This carbonyl would produce its own signal, the methine would produce its own signal, and these two methyls at the end because they're chemically equivalent would also produce their own signal. That is four carbon signal that we should see and four carbon signals in the carbon 13 NMR. Therefore I am confident that this molecular structure is our unknown structure. Hopefully this demonstration of how to solve a spectroscopy problem was helpful. In this demonstration I showed how to use each of these separate pieces of data to come up with a proposed chemical structure. I showed how each data was useful to determine something in particular about the chemical structure and how various pieces of data corroborated each other for example the carbonyl stretch in the in infrared spectrum was corroborated by the carbonyl signal in the carbon 13 NMR spectrum. Hopefully solving spectroscopy problems is now less intimidating. Don't be afraid of spectroscopy problems. Just ensure that you organize your data effectively. You saw how by taking all of this information and putting it them into tables, I was able to see patterns and connections within data sets and between data sets. How to effectively use this information will come with practice and with experience, but it always starts with proper organization of the data from the spectra. I would not be surprised if during this webcast if some of you saw certain connections before I spoke about them. There is no one way to work through a spectroscopy problem. In my case, I started with the degrees of unsaturation, went to the infrared spectrum and then briefly talked about the carbon NMR before moving on to the proton NMR data. Instead, you could have started from the proton NMR and then worked your way through these other types of data. So long as your final conclusion is supported by all of your data, you are doing well.
Thin Layer Chromatography- background. In this webcast we will discuss the first laboratory technique you will learn for this course. To begin we will start with what chromatography is, and then later delve more into what is Thin Layer Chromatography in terms of how it works. Chromatography is a technique that separates mixtures based on intermolecular interactions. In a chromatography experiment, compounds move between a stationary phase, and an immobile phase. The stationary phase, is as the name suggests, a fixed, nonmoving, usually a solid but it does not have to be material that is attached to some inert unreactive surface. The mobile phase again as the name suggests, is a moving phase. Which is a fluid, liquid or a gas that flows through the nonmoving stationary phase. often times this mobile phase is called the eluant when referring to a specific substance/composition. Now let's talk about how these intermolecular interactions are relevant in a chromatography experiment. Why do these intermolecular interactions allow us to separate mixtures? In a chromatography experiment, the molecules in your starting mixture are in contact with both the stationary and mobile phases simultaneously. Some of the molecules in your mixture may have strong interactions with the stationary phase. While some molecules in the mixture may have weak interactions in the stationary phase. This results in partitioning. The molecules that weakly interact with the stationary will not stick to the stationary phase very much. As a result they will spend a great deal of time in the mobile phase, and they will move quickly through the apparatus. In contrast, molecules that have a strong interaction with the stationary phase will stick well to the stationary phase, and will not spend much time in the mobile phase. Therefore they will move slowly through the apparatus. Here is a visual demonstration of a typical chromatography experiment. This green box represents our stationary phase. This is the non-moving phase which our compounds, which in this case are the red diamonds, and our yellow triangles, are placed onto and are interacting with. The blue circles represent our mobile phase. Remember that the mobile phase flows over or through our stationary phase. Shown here by the blue circles moving upward. In a chromatography experiment, some compounds may strongly interact with the stationary phase, and some may weakly interact with the stationary phase. Let us see whether our compound 1, the red diamond, or compound 2, the yellow triangles, interact with the stationary has with different strengths. Here we are again moving the mobile phase across the stationary phase and we can see that compound 1 has moved up the stationary phase. What this tells me is that compound 1 does not interact strongly with the stationary phase. Therefore it enters the mobile phase and moves across the stationary phase. Now this does not mean that compound 1 does not interact with the stationary phase at all. As you can see, compound 1 has returned the stationary phase. In contrast, compound 2 has not moved. This means compound 2 has strong interactions with the stationary phase. This does not compound 2 never moves. Let's do another cycle of our mobile phase. AS you can see both compound and compound 2 have moved across the stationary phase. However, they have moved at different rates. They have partitioned themselves. Compound 1 has weak interactions with the stationary phase, therefore it moves quickly across the stationary phase. Compound 2 has strong interactions with the stationary phase, therefore it moves slowly across the stationary phase, and this is how a chromatography experiment functions. Compounds in a mixture are separated based on the strength of the interaction they possess with the stationary phase. Now let's take those ideas and apply them to a particular type of chromatography. In this case we were discussing thin layer chromatography. Thin layer chromatography, like any other chromatography technique, has a stationary phase and a mobile phase. In thin layer chromatography, the stationary phase is a thin layer of adsorbent material fixed onto an inert surface. Remember that adsorbent means that substances will adhere to the surface of the material.
Here on the left, we see an example of a thin layer chromatography plate or TLC plate for short. The stationary phase on a TLC plate is this white substance you see coating this flat surface. You will talk more about the station in face in a TLC experiment the mobile phase is a solvent or mixture of solvents that is pulled across the stationary phase using capillary action. Here at the bottom of this jar is a small amount of organic solvent or a small amount of a mixture of organic solvents. When the bottom of this TLC plate is placed into the solvent, the solvent is slowly drawn up the plate via capillary action. The result of the mobile phase the eluent being drawn up the TLC plate with capillary action is as that eluent moves up the plate it carries analytes with it. These analytes are separated due to differences in attraction for the stationary phase. The stronger the attraction, the stronger the interactions with the stationary phase the less distance the analytes move. In contrast the weaker the attraction the analytes have of the stationary phase the weaker the interactions the farther they move up the plate. Let us look again at the this example TLC plate. Before the TLC experiment was performed, the bottom of the TLC plate here, was placed a spot of black ink. If we started with black ink, how do we have all these different colors? Black ink is actually a mixture of several different organic compounds. These compounds happened to be colored. By performing this TLC experiment, we have separated the colors in that black ink as you can see here. The colors at the bottom of the TLC plate here on the left had strong interactions with the stationary phase and so moved less far. In contrast, the colors at the top of the TLC plate, the yellows, the oranges, and the reds, had weak interactions with the stationary phase and thus moved farther up the TLC plate. There are 3 important components to any TLC experiment. The first is the type of stationary phase. The second is the type of mobile phase. And the third is the type of compound you're analyzing. To try and aid you in understanding TLC. This webcast will discuss components separately, and it may help you when thinking through TLC problems to think about components as separate entities, and then see how they connect. We shall begin this discussion of the components of a TLC experiment by talking about the stationary phase. Remember that in a TLC experiment, the stationary phase, is a nonmoving, thin layer of adsorbant material placed on some inert backing. There are two general types of stationary phases you can use in a TLC experiment. The first and most common type is what is called a normal phase. In a normal phase TLC, the stationary phase TLC is a polar substance. The most common examples being silica gel, or alumina. as you can see here the image on the right, silica gel is a network of SiOSi bonds. Each of these asterisks represents the networks of SiOSi bonds in the silica gel stationary phase. The reason the silica gel is polar is because at the surface of the silica gel, we have these silicon OH bonds, and you know that OH is a very polar bond. The second type of general stationary phase is what is called, reverse phase. In a reverse phase TLC, the stationary phase is a nonpolar material. The most common example of this is silica gel that has been what we call 'capped' with hydrocarbon chains. As you can see here on the right we have transformed our SiOH bonds into SiO-alkyl chain bonds. You know that CC and CH bonds are nonpolar. By capping OH bonds with these long alkyl chains, we create a very nonpolar surface coating. So, we have two types of stationary phases that we can use in a TLC experiment. A polar normal phase, and a nonpolar reverse phase. The type of phase you use matters a great deal. And analyte affinity for the stationary phase. Or in other words, how strongly the analyte sticks to the stationary phase depends on the polarity of the stationary phase and the functional groups in the analyte compound. Here is a general listing of common functional groups you can find on organic molecules. Here on the right we start with standard hydrocarbons and alkyl halides. And as we go to the left, we start seeing heteroatoms, and you might notice a trend. As we go from right to left, we go from having molecules that only possess vanderwaals interactions to molecules that possess dipole-dipole interactions, to molecules that can hydrogen bond.
Do not memorize the exact order that is drawn here. Instead remember that trend. Molecules that possess primarily van der Waals forces are the least polar. Molecules that possess dipole dipole interactions of the words molecules of polar bonds are moderately polar and ball skills that can hydrogen bond are the most polar. When we have a polar stationary phase hold or compounds interact with it more strongly.They have a higher affinity for; they stick better. In contrast you might imagine that if we have a nonpolar stationary phase the opposite is true. If we are using a non-polar reverse phase then non polar compounds should have the strongest interactions with the stationary phase. The takehome message here is that polar compounds stick better to polar stationary phases. Non polar compounds stick better to non-polar stationary phases. The stronger the affinity of a compound for the stationary phase, the stronger a compound sticks to the stationary phase, the less distance it will travel in a TLC experiment. now let's discuss the mobile phase. When deciding on what elements or another words what solvent or solvent mixture to use in a TLC experiment you have to consider a few things. If we are using a normal phase TLC plates we must ensure that our chosen solvent or solvent mixture readily dissolves our compound. Remember in a chromatography experiment the purpose of the mobile phase is to move or transport hour and a light across the stationary phase. If our analyte cannot enter the mobile phase because it is insoluble in the mobile phase then the analyte can never move and therefore the experiment cannot work. The solvent we choose cannot be too polar. The reason for this is that if we choose a solvent that is too polar, all of our compounds will move too quickly and therefore will not separate. We will discuss how polarity affect how fast compounds move on the next slide. The solvent must also not be too nonpolar. If the solvent is too non-polar that are compounds will not move at all. Remember these facts are true for a normal phase TLC plate. If we are using a reverse-phase TLC plate, the type of eluant that causes compounds to move too quickly and the type of eluant that causes compounds to move too slowly is reversed. Generally the eluant we choose for a TLC experiment is determined by trial and error. It is difficult to accurately predict what eluant is best to use in a TLC experiment. Here we have a listing of common organic solvent used in TLC experiments. These solvents are ordered based on their polarity creating what we call an eluotropic series. Eluo coming from the word eluant. As you go from the bottom of this list to the top of this list, we get more polar. Like with the polarity of compounds you saw a few slides back do not memorize this list. Instead memorize the trend. Here at the bottom, we have common hydrocarbons and other compounds that contain only van der Waals interactions, then we have compounds that contain hetero atoms that are polar therefore they contain dipole dipole interactions, and finally the most polar solvents ourselves that can hydrogen bond. This trend is exactly the same as what you saw previously. In a normal phase TLC plates, one that is polar, increasing the polarity of the eluant result in what we call an increase in eluant strength. In other words in a normal phase TLC plate, increasing the strength of the eluant result in all compounds moving faster.
The reverse is true as well If we lower the strength of the eluent if we make the eluent less polar all compounds move more slowly In a reverse phase TLC experiment where we have a nonpolar stationary phase the opposite is true with a nonpolar stationary phase the less polar you make the solvent the faster the compounds move to summarize the more similar the eluent is to the polarity of the stationary phase the faster the compounds move in the experiment polar eluents result in fast moving compounds using a normal phase TLC plate. nonpolar eluents result in faster movement of compounds using a reverse phase TLC plate. the polarity of the eluent directly determines what we call the retention or how far the compounds move on the stationary phase That is the end of the background of a TLC experiment but before we continue we need to be able to answer this seemingly simple question you run a normal phase TLC plate you then repeat the experiment but this time, you use a more polar solvent system what kinds of compounds move further up the TLC plate? let's break this question into components there is the stationary phase to consider and there is the mobile phase to consider you know the normal phase TLC plate is a polar stationary phase that means polar compounds will stick well and move a small distance whereas nonpolar compounds will not stick well and will move a greater distance now let's talk about the mobile phase by increasing the polarity of the solvent, we will increase the strength of the eluent because we are using a polar stationary phase and we know that increasing the strength of the eluent means that all of our compounds move faster. therefore, the answer to this question is that because we are increasing the polarity of the solvent system, we are increasing the strength of the eluent all compounds should move farther across the TLC plate. The polarity of the compounds themselves is entirely irrelevant. the polarity of the stationary phases is what determines the order in which compounds move or what we call elute up a TLC plate. The mobile phase is what determines exactly how far these compounds will elute the mobile phase will never change the order in which compounds move up a TLC plate. That brings us to the end of this webcast. To recap Thin layer chromatography is a method for the analysis of compounds or mixtures of compounds. The stationary phase of a TLC plate determines which compounds adhere more strongly to the stationary phase. the more similar the compounds in the mixture of the analytes are to the stationary phase, the smaller the distance they travel If you have a polar stationary phase, polar compounds adhere more strongly and therefore a smaller distance If you have a nonpolar reverse phase stationary phase, the nonpolar compounds adhere more strongly and travel a smaller distance The mobile phase used in a TLC analysis determines how far compounds travel. The more similar the mobile phase is to the stationary phase, the farther everything travels If I have a polar stationary phase, the more polar I make the mobile phase I make the eluent the farther all of my compounds travel up the TLC plate. If I have a nonpolar stationary phase the less polar I make the mobile phase, I make the eluent that farther everything travels.
Thin Layer Chromatography. Performing an Analysis. In this webcast, we will discuss how a TLC analysis is performed. We will talk about how to set up and then use a TLC plate. How to view or visualize that TLC plate, and then how to analyze or interpret that TLC plate. First, you have to prepare you TLC plate. Step one it to acquire your TLC plate. And then draw a line a short distance away from the bottom of the plate, somewhere around 1 cm. You don't have to actually measure 1 cm, just eyeball it. It is important to draw this line in pencil. Pen ink contains many different organic compounds. Those organic compounds will contaminate your TLC experiment. Every time you draw on a TLC plate, you must use pencil. Now that we have drawn this horizontal line across the TLC plate, you will add hash marks perpendicular to that line. The number of hash marks you draw will depends on the number of samples you intend to place on your TLC plate. Sometimes, one of these hashes will be designated a reference hash. Each of these hashes corresponds to what organic chemists would call a lane. The compounds will move from the bottom of this TLC plate to the top in a straight line. So each hash mark corresponds to a particular lane on the TLC plate. The purpose of a reference lane is to provide something to compare to, once the experiment is complete. Once you have made you hash marks and labeled you hash marks, you will then spot a solution if your compound. For this experiment the solutions will be made for you. You will take a small glass capillary and draw a small amount of the solution into the glass capillary. You will then spot a small amount of the solution onto each hash mark. It is important to try to keep the spots small. Spots that are too large will not elute properly. After you spot your sample your TLC will look wet. You will then wait until the spots have completely dried and all the solvent has evaporated. You can accelerate this processes by carefully drying your TLC plate using an air stream. Now that your TLC plate is prepared, the time has come to do what we call developing the plate. Its time to perform our TLC experiment. First, you will take a container, in your case you will take your beaker, and you will add a small amount of your eluent to your beaker. Do not measure half a centimeter simply eyeball it. Once your solvent it in your beaker, you will then add your TLC plate to your beaker using a pair of tweezers. You will then cover your beaker using aluminum foil. In your case your also instructed to add a filter paper to your beaker prior to placing you TLC plate into the beaker. The purpose of the filter paper is to evaporate some of the solvent. What this does is it saturates the atmosphere in the beaker with evaporated solvent. his will slow down the evaporation of the eluent as it travels up the TLC plate, allowing for faster development. When placing your TLC plate into the eluent, do ensure that your horizontal line is above the solvent. If your horizontal line is submerged in the solvent you analytes will simply dissolve and will not travel up the plate.Now that your TLC plate is in the solvent, capillary action will draw the eluent up your TLC plate. you will simply wait until the eluent is about 1 cm from the top f the plate. This may take a few minutes. You can accelerate this processes by using filter paper as instructed in the lab manual, as well as ensuring that you have completely covered the top of your beaker. The end of the development processes should look something like this where you eluent is about one centimeter from the top of your TLC plate. This line of solvent is what we call the solvent front. The solvent front is the maximum distance the solvent has traveled from the bottom of the plate to the top of the plate. Once your solvent front has traveled an appropriate distance, you will then remove your plate from the beaker using tweezers. You must then immediately mark the solvent front with your pencil. Once you remove the TLC plate from the beaker your solvent will begin evaporating immediately. Do not wait to long to mark the solvent front otherwise the solvent will completely evaporate and you will have no idea where to make your mark. After marking the solvent front, simply wait for your TLC plate to dry.. You can accelerate this process by carefully drying your TLC plate with an air stream.
After developing your TLC plate and allowing it to dry, your TLC plate will likely look something very similar to this, the same as when it started. Don't be fooled, just because you cannot see any compounds, it does not mean that no compounds are here. After the TLC plate has dried, the first thing you will do is circle any visible spots on the TLC plate with pencil. However, most organic compounds are not colored, therefore they will be invisible to the naked eye on a TLC plate. If most compounds are invisible to your eye, how can you see them? This is where a process called visualization comes in handy. Visualization is the term for techniques that we use in order to visualize or see the compounds on our TLC plate. The first type of visualization you will use is ultraviolet light. You will take your TLC plate and place it under an ultraviolet lamp, which will be located in the labs. After placing the TLC plate under the UV light, your TLC plate will glow green, with the excpetion of these dark spots. These dark spots you see correspond to different compounds. Each spot is one compound. Now that you can see these spots, you will mark them following the instructions in your lab manual. The reason that we can use UV light in this way is because TLC plates are often dubbed with an indicator, such as zinc sulfide. These indicators flouresce green under the type of ultra violet light that you will be using. Compounds on the TLC plate will block this flourescene from occuring and will therefore appear dark. You will also be visualizing your TLC plate using iodine. How this technique works is that you will take your TLC plate and you will place it into a jar that contains iodine. The iodine in the chamber will sublime and stick to the surface of the TLC plate, turning it a brown color. As the TLC plate turns color, you will notice the appearance of several dark spots. Once you are confident that all spots have been visualized, usually waiting long enough for the entire plate to turn brown is enough, you will then remove the plate and mark the spots according to the instructions in your lab manual. Don't wait too long however. Remember iodine sublimes, the moment you remove your TLC plate from the iodine chamber, the iodine on your TLC plate will begin to sublime into the atmosphere and dissapear. Remember to quickly mark your spots before all of your iodine dissapears. Why are we using two visualizing methods? On the previous slide, I showed you this TLC plate, which was visualized using iodine. You may have noticed that this TLC plate showed different spots then the TLC plate visualized using ultraviolet light. That wasn't by accident. Not all compounds can be visualized using all methods. If you look at the plate visualized using ultraviolet light, we see these bottom spots, that are not present on the TLC plate visualized using iodine. At the top of the iodine plate, we see these two spots that are not present on the TLC plate visualized using ultraviolet light. This is why it is important to have different mehtods of visualization. In the TLC experiment, you may find some compounds that can be visualized using one method, and not be the other. Ok, so we have developed the TLC plate, we have visualized it, and we have labled the various spots on our TLC plate. What do we actually record in our notebook? You usually record a few things. One is a sketch of the TLC plate and the second is a calculation of what is called a rentention factor. A rentention factor is a measure of the distance a compound travels across a TLC plate. The calculation is actually quite simple. To calculate the retention factor, or Rf, you take the distance your analyte traveled and divide it by the distance the eluent traveled. In other words, it is the distance a spot traveled over the distance the solvent front traveled. Let us look at this TLC plate for an example. I want to measure the retention factor of the purple spot. To calculate that I have to find the distance the purple spot traveled, which in this case is 3.5 centimeters. To find this value, I measure the distance from where the spot started, where I placed it, to where the spot ended, up here, and I measure at the middle of the spot. I then take this value and divide it by the distance the solvent front traveled, which is the distance from the horizontal line to the mark I made to indicate the solvent front. I plug these vales into this equation, 3.5 over 6, to get a value of 0.58. Notice that the retention factor is unitless, this is because the retention factor is simply a ratio of distances. That being said, when performing your calculation, do not forget to include your units.
Recording this data is important. Because the retention factor of a compound is characteristic of that compound. What do I mean by characteristic? What that means is if I repeat this TLC experiment again, and again, and again, the retention factor for the purple spot will always be 0.58. However, there are important criteria to meet first. The retention factor for a compound is constant only in the exact chromatographic conditions. This means that if i change the stationary phase, I change the retention factor. If i change the mobile phase, I change the retention factor. This is why it is important to always record the exact TLC conditions you use. Now, some quick tips to help you perform the TLC experiment. First, make sure you are always wearing your gloves and do not touch the silica gel with your bare hands. If you touch a TLC plate with your bare hands, the oils on your hand will contaminate your experiment. When drawing your lines, don't push down too hard. The silica gel layer on the TLC plate is, as the name of the technique suggests, a very thin layer, and is easy to break through. Draw lightly and carefully on a TLC plate to not damage it. When spotting your solutions, try to spot small spots of roughly equal size. Using small spots helps ensure that you have high quality TLC plates. Keep a careful eye on the TLC plate as you are developing it. Do not allow the solvent front to reach the top of the TLC plate. This is what we call overdeveloping. Overdeveloping a TLC plate means that your retention factors are no longer reliable. When visualizing your TLC plate using ultraviolet light, do be careful to not expose your eyes or your skin to the UV light. The iodine in the iodine chambers is corrosive and toxic. So, please use it carefully and only in the fume hood. And finally, this is your first wet experiment. That means this will be the first time you will have to dispose of various chemicals and used equipment. Make sure you dispose of waste in the appropriate containers. That brings us to the end of this webcast. To recap, visualization is the process used to allow compounds on a TLC plate to be seen. Different methods of visualization will work for different compounds. As discussed in this webcast, you will be using two methods of visualization in the experiment. One using ultraviolet light and one using iodine. The retention factor of a compound is a measure of the distance a compound travels compared to the distance the solvent front travels. This value is characteristic of a particular compound. This comes with a caveat, however. It is characteristic only if all aspects of a particular TLC experiment are a constant. For example, if you change the stationary phase, you change the retention factor. If you change the mobile phase, you change the retention factor.
Thin Layer Chromatography- Applications. In the previous webcasts, we discussed how TLC works and how to perform a TLC analysis. In this webcast, we will discuss what we can learn using TLC in the laboratory. One use of TLC is to do a preliminary determination of the purity of a compound. To do this kind of analysis, you will compare your sample of compound of unknown purity to a sample of the same compound that you know was pure. There are two possible results. Here on this TLC plate I have two lanes. One labeled K and one labeled U. The lane labeled K is where I spotted my known pure sample of compound. The lane labeled U is where I spotted my compound of unknown purity. On this TLC plate, we can see that we have two spots in our unknown lane. Remember, each spot on a TLC plate corresponds to a different compound. Therefore, our sample of unknown purity is impure because it contains more than one compound. If our TLC instead looked like this, where we have only one spot in the unknown lane, and that one spot is at the same retention factor as the spot in the known purity lane, we can say that our sample of unknown purity is probably pure. Why am I saying probably? It is possible, albeit unlikely, to have an impurity with the same retention factor as the compound. In other words, it is possible that there are multiple spots overlapping together. Such a situation is unlikely, but it must always be considered. The next use of a TLC plate is a preliminary identification of an unknown compound. This analysis is very similar to the analysis we just used on the previous slide. You will do a comparison. You will spot a pure known compound and compare it the spot of a pure unknown compound. One potential result is this TLC plate. Where again, K stands for our known compound and U stands for our unknown compound. Here, our unknown compound has a different retention factor than our known compound. Therefore, our unknown compound cannot be our known compound. We could also have a situation such as this. Where our unknown compound has the same retention factor as our known compound. This is very good evidence that our unknown compound is the same as our known compound. However, it is possible that our unknown compound is a different compound. It just happens to have the same retention factor as the known compound. This is unlikely, but it must always be considered. The final general use of TLC is following reaction progress. When a chemist performs an organic chemical reaction, how do they know when the reaction is done? We can use TLC to what we call 'monitor or watch' a reaction as it proceeds. What we do is over time we take the reaction solution and spot in on a TLC plate, which in this case designated by R-x-n for our reaction lane. And, we compare our reaction lane to our starting material. This TLC plate corresponds to a TLC plate that was taken before the reaction began. As we can see, our reaction mixture contains only starting material. If we wait some amount of time, we might see a TLC plate that looks like this. We now see two spots in our reaction mixture. One spot corresponds to the starting material. But we also have the second new spot. This new spot probably belongs to the product we are making in this chemical reaction. If we wait even longer, we might see a TLC plate that looks like this. Our reaction mixture now contains only one spot again. But now, that one spot does not correspond to the starting material. This means that all of our starting material is gone and has been converted to product. That brings us to the end of this webcast. To recap, TLC can be used to perform a preliminary purity analysis of a compound. Each spot on a TLC plate corresponds to a compound. If a single sample has more than one spot, that means that sample is impure. Remember, an analysis of a sample that shows only one spot does not mean that that compound is pure, definitively, but it is a good indication. TLC can be used to preliminarily identify an unknown compound. The retention factor for a compound is characteristic. Therefore, if the retention factor for an unknown compound matches the retention factor for a known compound that is a good indication that the compounds are one in the same. Again, this is not definitive. It is possible that two compounds can be different but have the same retention factor. Finally, TLC can be used to monitor the progress of a reaction. If TLC analysis are performed over the course of a reaction, you may be able to see starting materials disappear and products appear on a TLC plate. When all starting material is gone, you know that all of the starting material has been consumed and the reaction is complete.
Determining the absolute configuration of an alcohol. This experiment will be a little different than the types of activity that you've performed so far in this course. Instead of learning a new technique such as spectroscopy or thin layer chromatography. You will now be applying techniques that you already know to answer some questions. In this experiment, you'll answer two questions in regards to an unknown molecule that you will be given. By the end of this experiment, you will determine the structure of the unknown molecular via proton NMR spectroscopy. You will also determine the absolute configuration of that unknown protein. You will do so by using what is called the CEC method which applies TLC. We will talk about TLC shortly. To start today's webcast let us talk a little bit more of chirality. If you're concurrently taking chem 232 you have recently covered this topic. For a brief review, chirality has to do with the three dimensional structure of a molecule. Here on the slide we have two molecules that are identical. Except for the three dimensional orientation of some of this component. As you can see, as drawn these structures are mirrored images of each other. If you try to take the structure of the right and overlap with the one of the left, you will find that you can not be successful. These mirror images are what we called non superimposable. This means that the stereochemical relationship of these two molecules are enantiomers. Enantiomers are non superimposable mirrored images. So we have a pair of enantiomers here. Why do we care? We care because the chirality or more specifically the stereochemistry of a molecule can have tremendous impact on the biological applications of that molecule. For example, this molecule on the left is the S enantiomer of what we call naproxen. You might know naproxen better by its stray name aleve. Aleve is an analgesics which is use as anti-pain, anti-fever, and anti- inflammation pharmaceutical. Now compare those biological properties to the molecule on the right. R- Naproxen is a liver toxin. You can see how knowing which enantiomer we have is important. For this experiment you should review chem 232 notes on a few topics. You should know what stereo centers are and how to identify them and rules to assign whether stereo center is R or S and how to determine if a molecule is chiral if it contains stereo centers. Remember a molecule can have stereo centers but not be chiral. Meso molecules are an example of this. Give them the importance of distinguishing one enantiomer to another just like how easy is it to distinguish one molecule from another. Unfortunately, enantiomers have the same physical properties. For example two enantiomers of a single molecule will give us the proton NMR spectroscopic data. They will have the same retention factor on TLC. They will also melt at the same temperature, boil at the same temperature, and have the same solubility. They do however rotate plane polarized lights in different directions. Unfortunately that does not help which enantiomer of a molecule we have. The direction in compound rotate plane polarized light does not tell us which enantiomer it is. It only tells us we have a chiral molecule. Fortunately, there are techniques that allow us to identify the absolute configuration of a molecule. X-ray crystallography is a very common technique used by chemist. In your biology course as you may have seen crystal structures of various proteins. Those crystal structures were generated using x-ray crystallography. The Mosher Method is a technique organic chemists often use to establish absolute configuration of molecules that contain alcohols. Vibrational circular dichroism is a more recent technique that utilizes computational method to try to predict the absolute configuration of a molecule. All of these techniques require a specialty equipment and require time and training. The technique that you'll be using is called Competing enantioselective conversion (CEC). The CEC method as you will see is quite simple to execute and analyze. To discuss the CEC method, we will break the CEC method into its constituan parts.We will talk about the competing portion, entioselective protein, and conversion portion separately. To start, we will shall discuss the competing aspects of this method.
In this experiment, you will be taking an alcohol shown here on the left and turning it into an ester show here on the right this figure here is what is called a reaction scheme this may be the first time you have seen something like this a reaction scheme is how organic chemists communicate what is being used in a chemical reaction on the left side of a reaction scheme we have our starting materials these are the chemicals the reagents we are going to use in our chemical reaction we have this arrow moving from left to right that designates that our starting materials on the left are being converted into what we call products on the right everything on the right side of this arrow is a product located above and below the arrows are where organic chemists often place what are called the reaction conditions. the reaction conditions can include things such as other reagents being used in the chemical reaction in this case, we are including a type of molecule called an anhydride in this case, buteric anhydride and down below an organic base in this case, a triethylamine other information you might find above and below an arrow in a reaction scheme includes things like the reaction temperature the reaction time and the reaction solvent let us interpret this reaction scheme here before we continue what this reaction scheme tells us that we are taking an alcohol and using this anhydride and this base we are converting our alcohol into this ester This type of reaction is called an esterification if you are concurrently CHEM232, you will not have covered this material yet that's okay for now we simply need to be able to read a reaction scheme where the starting materials are on the left products are on the right and above and below the arrows are the reaction conditions and be able to identify the type of molecules being used we have an alcohol being turned into an ester using an anhydride and a base this type of reaction often proceeds very quickly however, under the particular conditions you will be using this reaction is very slow to accelerate or speed up this reaction you will be using a catalyst shown here in blue This particular catalyst is called Homobenzotetramisole or HBTM for short do not worry about memorizing the full name just recognize this molecule as being called HBTM now that we know what kind of reaction you will be performing in this experiment let us discuss how you will be using it in this experiment, you will be performing this esterification reaction twice you will perform two separate reactions each reaction does the same thing both reactions take an alcohol and using an anhydride and a base convert that alcohol into an ester this reaction, is accelerated through the use of a catalyst HBTM if you look closely, you might see that there is a slight difference between these two reactions if you look at the HBTM catalyst the reaction on top uses one enantiomer of HBTM and the reaction on the bottom uses the other enantiomer of HBTM this is a subtle but very important difference to recap this slide the competing portion of a CEC experiment comes from you performing two identical experiments except one experiment uses one enantiomer of HBTM while the other experiment uses the other enantiomer of HBTM before continuing let us discuss how HBTM accelerates this reaction .
Here on this slide I have each?? and I am exposing it to the anhydride used in this reaction. What's happening here? When?? is placed in the presence of an anhydride, it reacts with that anhydride to make what is called a reactive intermediate which we see here on the right. The anhydride on its own is not reactive enough to react with the alcohol. What we have done is take two low energy reagents and combined them to make one high reactive intermediate, which will react very quickly with alcohols. We have finished discussing the competing portion of a CEC experiment. now let us discuss the enantioselective portion. Here on the screen in blue is the structure of hbtm(?), our catalyst. However, you know that this structure is not complete. You recognize that there is a stereo center here, at this carbon connecting the nitrogen and the phenyl group. This means this molecule is chiral and comes as two enantiomers, shown here in black. One of these is the R enantiomer of hbtm and one of these is the S enantiomer of hbtm. I'm not going to tell you which one is which. I expect you to be able to assign which enantiomer of hbtm is R and which one is S. Ok, so hbtm is chiral. Why do we care? We care because while enantiomers have the same physical properties, they may and often do, have different chemical properties. In this experiment you will take each enantiomer of hbtm and react it with one enantiomer of alcohol. In this case, let us assume that your unknown alcohol possesses this stereochemistry. Here on this slide we have a chiral alcohol that will react with a chiral catalyst. Will this chiral alcohol react the same way with each chiral catalyst? The answer is no. We will see what we call enantioselectivity. The chiral alcohol will be selective for one enantiomer of catalyst over the other. Let's talk about why that is. On this slide I am showing a pair of gloves. At the top I have a left handed glove, and at the bottom I have a right handed glove. Think of these gloves as the hbtm catalyst. Where the left handed glove is one enantiomer of the catalyst, and the right handed glove is the other enantiomer of the catalyst. Now, let us take these gloves and try to fit a hand in them. In this case, my left hand. You could think of my left hand as the one enantiomer of alcohol on the previous slide. We're going to take one enantiomer of my hand, and try to place it into each enantiomer of this glove. Or in the actual reaction, we're going to take one enantiomer of alcohol and react it with each enantiomer of catalyst. There are two potential outcomes. The first outcome, taking my left hand and putting it into my left handed glove, results in my left hand fitting in my left handed glove quite well. In the other situation, taking my left hand and trying to fit it into my right handed glove does not work out so well. I can get it in there, but it doesn't really fit right. This top situation is a matched case. The enantiomer of my hand matches the enantiomer of the glove. The bottom is what we might call a mismatched case, where the enantiomer of my hand does not match the enantiomer of my glove. We can take this same analogy and apply it to our two chemical reactions. Here we are showing our activated intermediate already formed. Consider this top activated intermediate as one enantiomer of glove, and this bottom activated intermediate as the other enantiomer of glove. Each activated intermediate will react with the same chiral alcohol. Now remember, we don't know which enantiomer this alcohol is, that's what you're trying to figure out. But you do know you have only one enantiomer. This alcohol is the same as my hand on the previous slide. What will happen here is the alcohol will react with the activated intermediates to form the product ester. Both reacts form the same product to regenerate the catalyst, and a triethylamine salt that was used to de-protonate or remove this proton that was on the alcohol. One of these cases will be what we call a matched case. The other case will be a mismatched case. What determines whether the top reaction is the matched case or the bottom reaction is the matched case?
The source of the entantioselectivity of this reaction has two components. The first has to do with the stereochemistry of the catalyst. Here on this slide, I am showing two visual representations of our alcohol reacting with our activated intermediate. On the left, I have a two dimensional drawing of this reaction. And on the right I have a three dimensional drawing generated using a program Spartan. In both images, my alcohol is at the top and the activated intermediate is at the bottom. In this drawing in the left, I have drawn this phenyl ring here pointing down in a red color. If you look at the three dimensional structure here on the right you see that this phenyl ring points straight down. The consequence of this is that the phenyl ring effectively blocks the bottom half of our activated intermediate. If our alcohol wants to react with the activated intermediate, it has to come from the top side because the bottom side is blocked by this very large, very bulky phenyl group. That is the first component of this reaction's enantioselectivity. The second component of this reaction's enantioselectivity has to do with the aromatic system on the catalyst. If you look to the drawing on the left and look at the blue colored portions of the activated intermediate, we see an aromatic system. This aromatic system participates in what is called pi stacking with the aromatic system on the alcohol. In your biology courses, you may have heard of pi stacking in relation to DNA. What is happening here is that the aromatic portions of the molecules are lining up to stack on top of each other. You can think of the catalysts as a kind of landing pad for the aromatic ring on the alcohol. What these two components do is, in the matched case of the enantiomer of alcohol and enantiomer of catalyst, the alcohol is perfectly positioned to react with the carbonyl. In a mismatched case, using the other enantiomer of our activated intermediate, this OH would not be perfectly positioned and would take more time to move and rotate in order to react with the carbonyl in our activated intermediate. I want to make a distinction here. The phenyl ring on the stereocenter is not involved in the pi stacking with the alcohol. The phenyl ring on the stereocenter is entirely a steric interaction. It's big so it blocks one side of the activated intermediate. It is not involved in the pi stacking that orients the alcohol for its attack on the activated intermediate. That finishes our discussion on the enantioselective portion of this method. Now let us discuss the final conversion portion. Okay, so we have two reactions. Each reaction takes the same alcohol to make the same product. The only difference between these two reactions is the enantiomer of catalyst used. One of these reactions will be a matched case where the enantiomer of the alcohol is matched with the enantiomer of the catalyst, whereas in the other reaction, the enantiomer of the alcohol will be mismatched with the enantiomer of the catalyst. To explain why this is useful to us, we have to go back to general chemistry for a bit and talk about kinetics. Recall that kinetics deals with the rate, the speed of the reaction, and that the rate of a reaction depends on k which is a constant which varies from reaction and the concentration of the reagents. For this particular reaction, the rate law is k (our constant) times the concentration of the alcohol times the concentration of the catalyst times the concentration of the anhydride. If these reactions are identical, shouldn't they have the same concentration of alcohol and catalyst and anhydride? The answer is yes, both of these reactions are using the same concentrations of these reagents. Therefore, shouldn't these reactions proceed at the same rate? The answer is actually no, and this is because of enantioselectivity. The matched case will be faster. Here, in our competing reaction, one reaction will be faster than the other because the faster reaction will be the matched pair of alcohol and catalyst. And it turns out, if we know which reaction is faster, we can identify the absolute configuration of our alcohol.
If the reaction using R-HBTM is faster, then the alcohol when drawn like this has the OH coming out towards us. Which here is the S configuration. If the S enantiomer of catalyst is faster, then the alcohol is the R confiuration. Okay, so we're going to have a mast reaction and a mis masht reaction. The masht reaction will be faster if we know which reaction is faster, we know what enantiomer of alcohol we have. How will we determine which reaction is faster? To do this, we will look at conversion. Conversion is a measure of how far our reaction has proceed. How much product has been made. Have we made 25% of our product or have we made 75% of our product. In this experiment, both of your reactions will run for the same amount of time. One hour. This means that the faster reaction will produce more product. Let's talk briefly about the procedure. To recap you have two reactions, both reactions use the same unknown alcohol. Mechanically this experiment is quite simple. You will take pre made solutions and add them in the correct volumes in the correct order. The correct order is very important. Once you have added all of your solutions in the right order, you will then have to wait one hour. In that one hour waiting time, you will take proton NMR spectroscopic data given to you, and determine the structure of your unknown compound. Your alcohol will be one of these three options. Shown here on this slide. You will then in your notebook, justify which structure is your unknown compound. Now remember er, enantiomers give the same spectroscopic information; therefore, you will not be able to determine which enantiomer you have using the NMR data. That is why you are performing the CEC method. In this experiment, you will determine which reaction made more product using TLC, which we will discuss on the next slide. Using this data, you will then establish the absolute configuration of your unknown alcohol and justify your conclusion in your notebook. Here is an example CEC analysis TLC plate. We have two lanes, A and B. Each lane is one reaction. We see that in lane A we have two spots and in lane B we have the same two spots. However, the spots in lane A have different intensities than the spots in lane B. How are you going to interpret this TLC? Remember, in your reaction you are taking an alcohol and converting it into an ester. One of these spots is the alcohol and one of these spots is the ester. You will need to determine which spot is the alcohol and which spot is the ester using what you already know about TLC. Once you have identified which spot is the ester, you will then look and see which lane has the more intense ester spot. The intensity of a spot is directly proportional to the amount of that compound present. More intense spots, darker spots, mean more material. You will look at your two lanes and see which lane has the darker ester spot. Alternatively you could also look at which lane has the lighter alcohol spot, because remember the alcohol is being used to make the ester. The faster reaction will use up more alcohol. The alcohol spot should be lighter as a result. You will notice that this plate is green. In order to visualize the spot, you will be using a new method of TLC visualization. You will be staining your plate using a stain called Phosphomolybdic acid or PMA for short. Simply follow the instructions on your procedure. The post lab quiz for this experiment will be a little different than the post lab quizzes that you have seen so far. Thus far in the course, you have learned new techniques and the post lab quizzes tested your understanding of those techniques. This experiment is teaching you about a new technique, the CEC method, but it is also applying old techniques.
For this post-lab quiz, you should expect some fundamental questions on stereochemistry, be able to answer questions involving the stereochemistry concepts I specified at the very beginning of this webcast. You should expect some fundamental questions on the CEC Method. You should understand the competing aspect of the CEC Method, the enantioselective aspect of the CEC Method, and the conversion aspect of the CEC Method. You should also expect critical thinking questions. What do I mean by critical thinking questions? This experiment is about taking techniques you know and applying them to answer a question. What if I changed something about the experiment? Would you be able to predict what would happen as a result? That's what I mean by critical thinking questions: taking what you know and being able to predict what would happen if something was changed, or being able to decide on what to do if you wanted to cause a particular change to occur. Finally, expect spectroscopy questions as well. This experiment isn't about spectroscopy but it does utilize spectroscopy and given the importance of spectroscopy you should expect some questions testing your knowledge of it. That brings us to the end of this webcast. To recap, the CEC Method allows us to determine the absolute configuration of an unknown alcohol. It does so by comparing the rates of two reactions between the alcohol and a pair of catalyst enantiomers in the presence of butyric anhydride. Which of these two reactions is faster is established by using TLC. After knowing which reaction is faster, we use a predictive mnemonic to establish the absolute configuration of our unknown alcohol.
Melting points background. In this webcast, we will discuss what melting points are, what can affect them, and how to determine the melting or freezing point of a mixture using a phase diagram. For a quick review of general chemistry, physical properties can be identified by observing a sample. By physically watching a sample the identity of the sample does not change and as a result the physical properties do not change, making them characteristic of that compound. Examples of physical properties include: the solubility of a compound in some solvent, the boiling point of that compound, the color of that compound, and the melting point of that compound. For example, pure gold is always yellow. The color is characteristic of gold. Melting point is the temperature at which there is a phase change of solid to liquid. An example of this would be ice turning into liquid water. Here on the right we have a phase diagram. Remember that a phase diagram shows how the phases of, in this case, a pure compound changes as the temperature changes. Here on the x-axis we have the amount of heat added to our sample, for as we go to left to right, we add more heat. On the y-axis, we have the temperature of our sample, for as we go from the bottom to the top we have an increase in temperature. We start here at the bottom left with the solid at some temperature. As we add heat to it, the temperature of that solid increases. This continues until we reach the melting point. At the melting point, we continue to add heat but the temperature does not change. This is because all the energy from the heat is being used to convert the solid into a liquid until all of our sample has melted and turned into a liquid at which point the heat can then be used to continue increasing the temperature of our sample. At the melting point, at this plateau area of the phase diagram, both liquid and solid exist in equilibrium. By adding enough heat to a sample we can drive the equilibrium to complete liquid or by removing enough heat we can drop the equilibrium to complete solid. For a pure compound, the melting point is actually a melting range. The compound will melt over a narrow temperature range of about 1-2 degrees celsius. If we have an impure compound that contains soluble impurities-- notice how soluble is in red there we'll come back to that in a moment-- the melting point will be much lower and have a wider temperature range. This effect of soluble impurities of a melting point of a sample is called a melting point depression. As a result, melting points are an indicator of purity, where more impurities result in a larger melting point depression. If you know the melting point of a compound and your sample of that compound does not match that melting point that means your sample must be impure. The farther away your sample's melting point is from what the melting point should be the more impure the sample is. Why do impurities cause this melting point depression? This has to do with the crystal lattice of the solid. Here on this slide we see a number of turquoise circles arranged in a regular repeating pattern. Each of these circles represents one molecule. It takes energy to break this lattice up and convert these molecules from the solid phase to the liquid phase. Let's add an impurity to our crystal lattice and see what that does. Here on the right I have the same crystal lattice but I've added this yellow circle which represents this impurity. Because this impurity is a different molecule than the rest of the solid it disrupts the crystal lattice, it causes all of the other molecules to not fit together as well as they should. As a result the crystal lattice is weaker and it takes less energy to break it apart. The solid melts at a lower temperature. To show the effect that an impurity has on a melting point of a compound, we can use what is called a phase diagram. This slide is showing what is called a two component phase diagram where our mixture contains only two compounds here labeled A and B. Along the y-axis we have the temperature of the sample. Where as you go from the bottom to the top we increase in temperature. Along the x-axis, we have the mole fraction of our mixture, in this case specified as the mole fraction of compound B. The mole fraction is simply a ratio of the number of moles of a particular compound in this case B and the total moles of compounds in the mixture. For example if in my mixture I have one mole of B and one mole of A, the mole fraction of this mixture is one mole of B over two total moles of compound to give me a mole fraction of 0.5. Mole fraction is essentially another way of writing percent. If I have a mixture that is 0.7 mole fraction of mole B, that means my mixture is 70% B. The reason we use mole fraction as a percentage is that mole fraction is used in several mathematic equations.
Let's analyze this phase diagram. First what are the melting points of pure acetic acid and pure water. If you look on the left where we have a mole fraction of water of 0, in other words pure acetic acid, we see that the liquidus line intercepts the y-axis at about 17 degrees Celsius. Where as on the other side where we have a mole fraction of water of 1, pure water, you have a melting point of about 0 degrees Celsius. And if we could zoom in even further, we could get some exact values for these melting points. Okay, so our eyeball guess were pretty close to the actual values. Now let us see if we can identify a eutectic mixture of water and acetic acid. We know that a eutectic mixture creates a eutectic point, and a eutectic point is the place on the diagram that has the lowest melting point. We see here on the diagram that the lowest melting point is right here. And the mole fraction of water at that point is about 0.7. Therefore, a mixture that is 70% water and 30% acetic acid is a eutectic mixture. Now let us use a phase diagram to show what happens if we take a sample of acetic acid and water and begin to freeze it. In this example, we have a mixture that is a mole fraction of 0.9 H2O and it starts at 20 degrees Celsius. What happens as we cool? First, let's find the mole fraction on the x-axis. Here we go, 0.9 of water and now let's find the relevant temperature: 20 degrees Celsius. So we start here on the phase diagram. Let's start cooling it. Let's lower the temperature, lower the temperature. Eventually, we reach the liquidus line. At the liquidus line, we begin to freeze the mixture but not the entire mixture begins to freeze. At this point, only water begins to freeze. So as we take this mixture and begin freezing it, the solid we make is pure water. What's the consequence of this on the mole fraction of the liquid mixture left behind? Well, if we are taking water, and only water, from the liquid mixture and turning it into a solid, then the mole fraction of water remaining in the liquid must decrease. In other words, we move towards the left on this phase diagram. As we freeze more and more water, the liquid contains less and less water so our mole fraction of water has to decrease, and this continues until we reach the eutectic point. At the eutectic point, we have a eutectic mixture. What's special about a eutectic mixture is that the solid that forms when a eutectic mixture freezes is the same composition as the liquid it started with. So, at this point we have only solid water and a eutectic mixture in the liquid. If we continue cooling, the liquid continues to freeze, only now, because we are eutectic mixture, both water and acetic acid begin freezing turning into a solid. The solid that forms as a result of freezing a eutectic mixture is a eutectic mixture. So, in this case, if our liquid is 70% water, then the solid that forms as a result of freezing the mixture is also 70% water. We continue cooling, we continue cooling, until all of the liquid is frozen then our new solid composition has to be the same as what we started with. Hopefully that makes sense. If we take a sample that is 90% water and we freeze all of it, the solid also has to be 90% water. If we continue cooling, the temperature simply continues to fall. Let's walk through that one more time. You started with a mixture at a particular mole fraction at a particular temperature. We began to cool it down until we hit the liquidus line. When we hit the liquidus line, the water and only the water began to freeze. As a result, the mole fraction of water in the liquid left behind decreases and continues to decrease until we reach a eutectic mixture. Once the liquid left behind is a eutectic mixture, both water and acetic acid begin to freeze simultaneously, and they freeze in a eutectic ratio.
This continues until the entire sample is frozen at which point the temperature simply falls as we continue cooling the sample. This was an example of freezing. You can imagine a sample of melting which is identical expect going in the opposite direction. For example, we can start down here in the completely solid region, begin heating, and once we hit the solidus line we begin to melt. The mixture melts until we have only solid water at which point the pure remaining solid water melts, the mole fraction of the liquid phase increases in water until everything has melted and then we simply heat the completely liquid mixture. That brings us to the end of this webcast. To recap, the melting point of a compound is characteristic of that compound. No matter how many times you melt a sample of pure water it will always melt at 0 degrees Celsius. Impurities can affect the melting point of the compound. Soluble impurities lower the melting point a compound by disrupting the crystal lattice. Remember this is only for soluble impurities. Insoluble impurities do not affect the melting point a compound. Phase diagrams show what phase a mixture of compounds is in based on the mole ratio the compounds in the mixture and the mixture's temperature. In a phase diagram the curves, for example the liquidis line and lines, for example the solidus line, between regions in a phase diagram show the beginning of transition between phases. These curves and lines are where you start to freeze and/or start to melt depending on which direction you're going.
Melting Point: Performing an Analysis In this webcast, we will discuss how to perform how to perform a melting point analysis and what we can learn from performing a melting point analysis. The first thing you will do is acquire a melting point capillary tube. This tube is a small glass rod where one end the bottom is sealed and the other end, the top, is open. You will take this capillary tube and press the open end into a small amount of your solid sample. This sample uses a watch glass because the glass is a hard surface, although you could also do this in a weighing boat or other soft surfaces. By tapping your capillary tube into the solid, you will push some of your solid into the capillary tube. You will then flip the capillary tube the right side up and tap the bottom of the tube on to a hard surface, such as your bench top, to cause your solid to move to the bottom of the tube. The amount of material in a capillary tube should actually be quite small. You're looking for a height of about 1 to 2 millimeters. If you pack too little into your capillary tube, you might miss it melting. If you pack too much into the capillary tube, you will get inconsistent heating and therefore, a bad melting point. Once you have your sample ready, you will then take your capillary tube and place it into the Mel-Temp here. The Mel-Temp you will use may look different than this one, but they all work the same way. You can view your sample via this magnifying lens here. You control the rate of heating using this knob down at the bottom and you read the temperature inside the Mel-Temp via this read out here. A note about this knob. These numbers you see do not correspond to particular temperatures. In the Mel-Temp area, there are small cars that show how particular power settings correspond to particular rates of heating and particular max temperatures. You can use those cars as a reference to determine how high to set your power setting. Okay, so you've prepped your sample, it's in the Mel-Temp, and you've begun heating your sample. What should you expect to see? Here on the left, we have a sample that is just beginning to melt. We see a very little amount of liquid begin to form. When you see this happen, record the temperature in which this is occurring. This is the start of your melting range. Over time, as you continue to heat, the solid will eventually turn completely into a liquid. The moment it turns completely to a liquid, record that temperature. That is the end of your melting range. For accurate melting points, you must heat carefully. If you heat too quickly, you, one, might miss your sample melting all together, or two, record values that are incorrect. You should be looking at an increase in temperature of about 1 to 2 degrees Celsius a minute. Some tips before you get into the lab. The melting point will always be reported as a range. Remember, the beginning of the range is when you first begin to see liquid and the end of the range is when your sample is completely liquid. Do not melt your sample too quickly. You're looking for, ideally, a one to two degree Celsius per minute change. Allow your Mel-Temp to cool between melting point analyses. You do not want to put your sample in when the Mel-Temp is already above the melting point temperature of your sample. Be aware and watch your sample to avoid having to repeat your melting point analysis. Watching a solid melt is admittedly not the most exciting thing, but you still must watch it to ensure you record accurate data. Depending on how the Mel-Temp is set up, it might be possible to fit more than one capillary tube in a single Mel-Temp. Ask your TA for advice. Finally, make sure your sample is dry. Any solvent that is still clinging to your solid sample will act as an impurity and lower the melting point of your sample. Now we are going to discuss the uses of performing a melting point analysis. A melting point analysis allows us to learn two thing about a sample. It allows us to probe the purity of a known solid substance. It also allows us to determine the identity of an unknown solid assuming I have corroborating evidence from other sources. How can the melting point analysis allow us to learn something about the purity of a sample? Remember the presence of impurities will lower the melting point of a compound. On this slide, I have three samples of benzoic acid and I have listed their melting points below the images. Pause the video and take a minute to think about which of these is the most pure and which of these is the least pure.
Welcome back! I know that the presence of an impurity will lower the melting point of a sample. That means that the sample with the highest melting point should be the most pure. As we can see, the sample in the middle has the highest melting point of the three possibilities. Therefore, this middle sample must be the most pure. What about least pure? well, we also know that the more impure a sample is the lower its melting point and the wider its melting point range. Look at the sample on the right, we see that the melting point is the lowest of the three possibilities and the melting point range, which here is 4 degrees celcius, is wider than the other two. Therefore sample three must be the least pure of these possibilities. How can we use melting points to establish the identity of a compound? To do this, we will use a particular technique. On this slide we get three samples, A, B, and C. One of these vials contains m-nitrophenylacetic acid. The other two vials contain benzoic acid. M-nitrophenylacetic acid and benzoic acid have the same melting point, 120 to 122 degrees celcius. This is important. These are different compounds that possess the same melting point. Therefore we can't melt them individually to figure out which vial contains the m-nitrophenylacetic acid. What we can do, however, is perform a mixed melting point analysis. We know that impurities will lower the melting point of a compound. How can we use this? Well, let's say we mix vial A with vial B. If they are the same compound, then there should be no change in melting point. If they are different compounds, we should see a depression in melting point. Look at these results on the right. Mixing A with B gives a melting point of 120 to 122 degrees celcius. Mixing B with C gives us a melting point of 112 to 118 degrees celcius. Hmmmmm! This mixed melting point is lower than the mixed melting point for A and B. Interesting. Let's look at A and C. Mixing these two compounds result in the melting point of 110 to 117 degrees celcius. What this tells me is that A and B are the same compound because we don't see a depression in the melting point. In contrast, B and C are different compounds because we have a lower melting point. A and C are different compounds for the same reason. Therefore, vial C must be m-nitrophenylacetic acid. These compounds all have the same melting point, but we still see a melting point depression for mixing B with C and mxing A with C, because the two mixed samples were not the same compound. That brings us to the end of this webcast. To recap, melting point analysis samples should be the appropriate height, 1 to 2 millimeters, and heated carefully. A melting point analysis can be used to establish the purity of a compound. Pure compounds have a narrow melting point range. Melting points can also be used to identify a compound via what is called a mixed melting point experiment. If you take an unknown compound and mix it with a known compound and you do not see a melting point depression, that means the two samples must be identical.
Recrystallization Background In this webcast, you will discuss what recrystallization is and how we utilize the solubility of a compound to perform a recrystallization. What is recrystallization? Recrystallization is a purification technique for solids, that is based on controlled solid to solution to solid phase transitions. In other words, you take a solid, you dissolve it in some solvent, and then after being dissolved, the compound returns to being solid hopefully in a more pure form This technique is capable of purifying compounds that contain one or more impurities The physical property that is exploited in this process is solubility If you have made rock candy before, you have actually performed a recrystallization. When making rock candy such as here in the bottom left, you take sugar and you add it to boiling water. Once you've added enough sugar, you allow the water to cool and you place some string or a stick into the water and the sugar crystalizing out onto the solid support. Of course, we wouldn't be talking about recrystallization if making rock candy was all it was good for. Most of the solid pharmaceuticals on the market today, such as you see here in the bottom right, are purified using recrystallization. Even pharmaceuticals as common as aspirin are purified using recrystallization. The solubility of any compound depends on three things. It depends on the solute- the compound you are dissolving, it depends on the solvent- what you are using to dissolve the solute, and the temperature of the solvent. To connect those few variables, a given solute has a specific solubility in a given amount of solvent and a given temperature. Thats a lot of variables to consider when talking about something as simple as trying to dissolve something. Here on the right, we have a graph that shows the solubility of various compounds at various temperatures. The x axis is temperature where as we go from left to right, the temperature increases. The y axis is the solubility of a compound in 100grams of water. As you go from the bottom to the top, more of our compound in grams dissolves in the same amount of water.Each line here corresponds to a particular compound. Let us look at 20 degrees celsius. We see that about 200g of sugar will dissolve in 100g of water. At that same temperature, we see that amount 80g of ammonium sulfate will dissolve in the same amount of water. You can see how at the same temperature and the same amount of water, different compounds have different solubilities. A solute, when being dissolved, will dissolve until the solubility limit is reached. At this point we call the solution saturated. If we go back to our table here on the right, remember that at 20 degrees celsius, our solubility is 200g of sugar per 100g of water. That means if you go home and weigh 100g of water into a cup, you can dissolve 200g of sugar in there. If you keep trying to add more and more sugar, the sugar will not dissolve and will simply remain a solid at the bottom of your cup. One note before continuing, if you look at the y axis, this is the solubility in a specific amount of water, 100g. If we change the amount of water we use, we change the solubility. Using more water means we can dissolve more solute. Using less water means we can dissolve less solute. This dissolving process is an equilibrium, where our solute in solution is constantly changing back into a solid and then returning back into a solution. Whether our solute favors being in solution or favors being a solid depends on the temperature. For solids, generally, as the temperature of the solvent increases, our solubility also increases. As the temperature of our solvent decreases, the solubility of our solute also decreases. We can see that on the graph here on the right. We look at sugar again; as we go from left to right, the solubility of sugar increases dramatically.
if we take a saturated solution, in other words, a solution that can hold no more solute and we cool it, it becomes supersatured. in other words, there is not enough room in the solvent to hold all the solute. As a result, the solute must exit the solution. When solute exits the solution, it forms a solid, it forms crystals. This crystal lattice is highly ordered, as you can see here on the right. This regular ordered arrangement is very thermodynamically stable, because our solute molecules (presented here by the yellow triangles) fit together very well. This is the reason recrystallization is able to purify compounds. The stability the compound gains by forming a crystal only occurs because the solute molecules really want to stick together to form these structured crystals. If these blue impurities up top try to attach themselves to the crystals, you can see how because they are different shapes they would not fit into the lattice nearly as well as the remaining yellow triangles. Therefore these impurities remain in solution. Leaving us with pure solid crystal. This is exactly how making rock candy works. If you imagine these yellow triangles as sugar molecules, when making rock candy you boil water and you add sugar until the water is saturated at the boiling temperature. You then allow that water to cool forming a supersaturated solution and so the sugar crystallize out. One note before we continue. Recrystallization is not the same as precipitation. You may have heard of precipitation in general chemistry. Precipitation is when a solid is formed as a result of a chemical reaction. A recrystallization is not a chemical reaction. In a recrystallization you can take one compound you dissolve it and then you get the same compound as a solid. No chemical reaction has occurred. okay. so in a recrystallization we know that you have a supersaturated solution and then you allow it to cool this cooling lowers the solubility of the solute causing the solute to form crystals. How quickly can you let that solvent cool? It turns out that cooling slowly is much better. Here's why. Here on the left we have a number of turquoise squares. These squares are our solute. Here in the bottom left we are beginning to form a crystal, but we still have some of these squares in solution. We also have this red circle. This red circle represents an impurity. Lets see what happens as we wait and watch our solute continue to grow this crystal. We see that one of our squares has left the solution and attached itself to the crystal surface. Oh no! Our impurity has now attached itself to the crystal surface. Have we failed now that this impurity is attached to the crystal surface. No. Because remember crystallization is an equilibrium. This impurity has attached itself to the surface, but because it's a different shape different molecule it doesn't fit very well so it returns to the solution. What if it tries again? What if it attaches itself to another place on the crystal. It's still a different molecule still doesn't fit well into the lattice. Therefore it will once again drift away allowing our remaining solute molecules to attach themselves to the crystal surface and thus finish growing the crystal. Slow cooling allows this equilibrium process to occur forming large pure crystals. Let's say we cool quickly what would happen there? We have the same diagram on the right and now we're going to have our impurity attach itself to the crystal surface. This time however we're going to cool quickly. So before this impurity has time to return to the solution our solute molecules trap it into the crystal lattice. This is why slow cooling in a recrystallization is much better than quickly cooling. Quickly cooling a solution will result in the trapping of impurities into the crystal lattice which defeats the entire purpose of performing a recrystallization. Another consequence is we form small crystals. Small crystals are harder to isolate and are more likely to be impure. That brings us to the end of this webcast, to recap recrystallization is a method to purify solid compounds. Recrystallization works by manipulating the solubility of these solute compounds in a solvent. The solubility of solids in a solvent usually increases with temperature. By creating supersaturated solutions we can cause crystals to form. If done properly these crystals should be a pure solid compound. A recrystallization functions by dissolving the solid in a hot solvent to ensure that everything possible dissolves and then slowly cool in order to form our supersaturated solution to allow for pure crystal formation. As our desired compound crystallizes out the impurities we are trying to remove remain behind in solution.
Recrystallization- perform a new technique In this webcast, we will discuss the thought process behind performing a recrystallization. Depending on what kinds of impurities are present in your compound, you will utilize different techniques. Mechanically,a recrystallization is quite simple. You take your impure solid and you dissolve it in an appropriate hot solvent using as little volume of the solvent as possible. We'll talk about what an appropriate solvent is shortly. Once you have dissolved your impure solid in as little hot solvent as possible, you then allow that solution to slowly cool. As the solution slowly cools, the solubility of your solid will decrease and if you have performed the technique properly, result in crystals of your compound to begin to form. These crystals should be pure because the impurities should be left behind in solution. Now, this assumes that your impurities are soluble in this solution. In the event that you have insoluble impurities, you have to perform what is called a hot filtration. We will talk about soluble impurities and insoluble impurities shortly. But first, lets talk about solvent choice. On the previous slide, i said you had to use an appropriate solvent. There are a few criteria a solvent must meet in order to be useful in a recrystallization. First, the solvent cannot react with the compound, it must be what we call inert. Remember, in a recrystallization, no chemical reaction should occur. Second, your solvent should dissolve all of your compound when it is hot. It also must dissolve as little of your compound as possible when it is cold. Let us look at this graph on the right. If you look at the line for sugar, we see that, as our temperature increases, as our solvent in this case water gets hot, we dissolve a great amount of sugar. When we allow the water to cool back to roughly room temperature, we see that the solubility has decreased dramatically, meaning that most of our sugar should return to the solid phase. Therefore, water could be used to recrystallize sugar. In contrast, if we look at sodium chloride, this bottom line, we see that the solubility does not change very much as our temperature increases. therefore, water would be a poor solvent to try and recrystallize sodium chloride from. Finally, as a practical concern, our solvents should be volatile. In other words, easy to evaporate, easy to remove. The easier it is to dry your crystals, the better the recrystallization. Earlier, I mentioned insoluble impurities and soluble impurities. Insoluble impurities are impurities that do not dissolve in the solvent, even when the solvent is hot. As a result, these must be filtered out. We'll talk about how to do this shortly. Here on the right, we see a testable containing a solution of some kind and in the solution is suspended some solid. Because the solid will not dissolve in the solvent, this is an insoluble impurity. A soluble impurity is an impurity that dissolves in the hot solvent and is still dissolved when the solvent is cold. Here on the right, we see a testable containing a solution that clearly has no solid in it. In other words, everything in here is dissolved, is soluble. Finally, you can have partially soluble impurities. These partially soluble impurities are a sort of middle ground between soluble and insoluble. Because of this, they are often difficult to remove. For this course, you should concern yourself with primarily insoluble impurities and soluble impurities. Lets say we have a sample of a solid that contains both an insoluble impurity and a soluble impurity. What do we do in order to purify our solid? The first thing we do is remove the insoluble impurity through a hot filtration.
When removing an insoluble impurity, you attempt to dissolve all of your sample in hot solvent. What will happen is, your desired compound will dissolve, as well as any soluble impurities. The insoluble impurity however, because it is insoluble, will not dissolve and will remain a solid. You will then perform a hot filtration. In this lab experiment, you will use gravity filtration to remove the insoluble impurity. In the image on the right, we see an example of a hot filtration. We have an erlenmeyer flask containing a hot solution with an insoluble impurity and we are carefully pouring the hot solution through some filter paper. The solvent will pass through the filtered paper and will be collected in some collection vessel while the insoluble impurity will remain behind, caught by the filter paper. When performing a hot filtration, you do have to take care. The moment you take your flask off of your hot plate, your solution will begin to cool. If it cools too much, your desired compound will begin to form crystals, and those crystals will be caught in the filter paper. A hot filtration must be performed rapidly but also carefully. The glass will be hot and the solution will be hot. To slow the rate of cooling that will occur as your solution passes through the filter paper, you can pre-warm the filter paper and the funnel using pure hot solvent. Okay, so we have now successfully removed our insoluble impurity. Excellent. But we still have this soluble impurity to take care of, how do we do that? Now, we perform a recrystallization. When performing a recrystallization, you have an impure solid that you will dissolve in an appropriate, and we discussed what appropriate means previously, hot solvent- using as little volume as possible. Of course, as little volume as possible is not particularly specific. When you begin a recrystallization, how much volume of solvent do you use? A good rule of thumb is to add enough solvent to cover your impure sample. You then boil that solvent and try to dissolve your sample inside of it by swirling the container. If swirling the container and boiling the solvent is not enough to dissolve all of your sample, thats when you begin adding small amounts of more solvent. You continue this process until your entire sample dissolves after swirling and boiling solvent. As you can see here in this image in the bottom left, we have a solution of an impure solid, which has been dissolved in boiling solvent. You then allow your solution to slowly cool and as the solubility decreases, crystals will begin to form. Taking this solution to the left and allowing it to cool forms these crystals you see on the right. The yellow impurity that was present remains in solution while the solid crystals that formed are now pure. In this experiment, to collect the crystals you will form, you will use what is called a vacuum filtration. Lets say you were performing a recrystallization, you've done everything properly, but crystals just won't form. Why might this happen? Ideally, when you make a super saturated solution, the solute should immediately leave the solution and form crystals. Occasionally, something called metastability is reached, where the solute refuses to return to the solid phase and form crystals. To try and encourage crystal formation, or what we call induce crystallization, you can take a few actions. The first is to cool in ice. Once you put your solution in ice, you should then be patient. Your solution will not cool instantaneously. If you have waited an appropriate amount of time- five or ten min- You can then try to induce crystallization by scratching the inside of your flask with a spatula. By scratching the glass on the inside, you make a rough area. The rough area provides a place for crystals to begin growing. If you have taken all of these actions and crystals still won't grow, then it is likely that you have used too much solvent. If you have used too much solvent, all of your compound may be soluble in the cold solvent. To try and fix this, you should concentrate your solution. To do this, you should evaporate some of your solvent. To prevent this situation from happening when dissolving your impure solid in hot solvent, make sure your using small volumes of hot solvent to begin with, with thorough swirling.
To recap how to perform a recrystallization here is a flow chart first thing you ask yourself is when given a sample is your compound pure if it is pure, then you are done there is no need to perform a recrystallization of course, we are not going to give you a pure compound so, let say if your compound isn't pure what do you do? you dissolve your sample in hot solvent you then look at your solution are insoluble impurities present? do you see solids still? if yes, you perform a hot filtration to remove those insoluble impurities you then take the solution that pass through and allow it to cool and form crystals if there weren't any insoluble impurities, then there is no need to perform a hot filtration you go straight to allowing your solution to cool to form crystals then you look at your solution and ask yourself okay, are crystals being formed? if not, then you have to induce crystallization either by cooling the solution, being patient, or scratching the inside of the flask if you used too much solvent, you may have to concentrate your solution by boiling off some solvent once crystals begin to form, you then collect your crystals via filtration in this case, you will be using vacuum filtration if crystals formed without any induction then you simply filter to collect them and then you will determine the purity if your compound is pure, then you are done if you compound is still impure, then you go through this process again and repeat until your compound is pure that brings us to the end of this webcast to recap the solvent used in the recrystallization is crucial to success your solvent must dissolve the entirety of your sample when hot and as little as possible when cold the type of impurity or impurities present within your sample determines what procedures to perform an insoluble impurity is removed through the use of a hot filtration a soluble impurity is removed through a traditional recrystallization to ensure sufficient crystal formation, you should use as little solvent as possible to dissolve the entirety of your compound when it is hot and then carefully chill your solution as much as possible in order to minimize the solubility of your compound in the solvent .
That tells whether the impurity 2 is a soluble impurity. so, how are you going to separate impurities 1 and 2 from A? well we know impurity 1 is an insoluble impurity. therefore, we can remove that from that from a hot filtration. if we take our sample, dissolve as much as we can in hot solvent, impurity 1 will remain a solid. and we can remove that through a hot filtration. if we take the solution that passes through the filter paper, which contains compound A and impurity 2, we know that impurity 2 is a soluble therefore we should be able to remove that through a recrystallization. Lets go ahead and say that we have removed impurity 1 through our hot filtration. we now have compound A and impurity 2 still in solution. we preform a recrystallization and we successfully purify coumpound A. how much of A did we lose in this process if we used 100mL of solvent? Well we know that solubility of Compound A, we know that at the cold temperature 25 degrees Celsius, 1.0 grams of A will dissolve in 100 milliliters of water. We are using 100 milliliters of water. Therefore, 1.0 grams of A is still dissolved in solution after the recrystallization. Let me say this again: we know the solubility of A via the solubility table and we know the volume of solvent used from the question, telling us the amount of A left in solution. Okay, so that's not so bad, we're not leaving that much behind. But let's say I don't want to leave 1 gram behind, I want to minimize the amount of material that I cannot retrieve in this recrystallization. How can we do this? In other words, how can we maximize our recovery? Well remember, there are two things we can do: we can try to cool our solution using an ice bath. Lets say we don't have access to ice or anything else that can chill our solution, what else can we do? we can also change the amount of solvent we use. Just how much solvent do we need to ensure that all of impurity 2 stays in solution at the cold temperature? to answer that question, we again look at the solubility table. we know that we have 1.0 grams of Impurity 2 in our sample. From the solubility table, we know that 1.5 grams of impurity 2 dissolves in 100 milliliters of water. That means to dissolve 1 gram of impurity 2 we need 67 milliliters of H2O. To say this again, we know that we have 1 gram of impurity 2. I want to use just enough solvent to keep impurity 2 dissolved at the cold temperature. By minimizing the amount of solvent used, we lower the amount of compound A we leave behind. We know the amount of impurity 2 in our sample and the solubility of impurity 2 in water, our solvent, we calculated the volume of water needed to dissolve all of our impurity at the cold temperature. How much of compound A is left behind using this volume of water? Well, we're using 67 milliliters of water, we know the solubility of A from the solubility table, do some quick math, we leave behind 0.67 grams of Compound A. This is significantly less than the 1 gram of Compound A using 100 milliliters of water. By using less solvent, we still remove all of Impurity 2 while minimizing the amount of Compound A we leave behind. That brings us to the end of this webcast. To recap, recrystallization effectiveness is determined by the purity of the isolated compound and how little compound was lost in the solvent through the use of percent recovery. You will assess the purity of a compound via a melting point analysis in this experiment. we will talk about melting points more in the melting point webcasts. Percent recovery is a measure of how much compound was recovered from the initial impure sample. You can increase your percent recovery using colder temperatures when chilling your solvent and/or using a lower volume of solvent.
Bromination of an alkene. In the previous experiment, you learned out how to use recrystallization to purify a solid compound and how to perform a melting point analysis to characterize that compound. In this experiment, you will perform a reaction, the bromination of an alkene, and then you will use the techniques of recrystallization and melting point analysis to purify and then learn something about the resultant product of that reaction. A reaction mechanism is a step-by-step diagram of how bonds are formed and broken during a chemical reaction. These mechanisms show how electrons move. Not how atoms move. If you are concurrently taking CHEM 232, you will have been recently introduced to reaction mechanisms in the context of substitution reactions. You will not yet have covered bromination of alkenes. That's okay, in fact, that's actually ideal. This experiment will show one way to identify the mechanism of reaction when we don't know what the mechanism is yet. The understanding of a reaction mechanism is important. By understanding the mechanism, we can make changes to the reaction conditions in order to do things such as optimize the yield of the reaction and increase the purity of the product of the reaction. Mechanism determination is a non-trivial problem. It is often quite difficult to see what the starting material turns into as it goes from starting material to product. Tools that are available to organic chemists when determining the mechanism of an reaction include using spectroscopy to view intermediates. During a reaction, intermediates tend to not last very long. But oftentimes we can use things such as infrared spectroscopy or NMR spectroscopy to view those intermediates before they disappear. We can use kinetics to see how changing the concentrations of various reagents affects the rate of the reaction. As you saw with the absolute configuration determination experiment, the concentration of base had no effect on the rate of the reaction. What that tells us is that the base is not present in the rate-determining step. The base not being used in the rate-determining step tells us something about the mechanism. Another tool we can use is an analysis of product distribution. If we have two potential mechanisms, and mechanism one provides one product and mechanism two provides a different product, if we can identify which product is actually made, we can identify the mechanism that is what we call 'operative' in the reaction. And it is this type of analysis that you will be performing in this experiment. You will perform a bromination reaction on an alkene. There are several potential mechanisms for this reaction. By figuring out what the product of the reaction is, you will then be able to determine the mechanism of the reaction. If you're concurrently taking CHEM 232, you will not yet have discussed the bromination of an alkene. As a result, we will discuss only in the fundamental aspects of this reaction. In a bromination reaction, you have an alkene (such as this one here in the bottom left). This alkene reacts with bromine to attach a bromine atom to each carbon that had been part of the alkene. Notice how the double bonds in the phenyl ring are still present. Remember what i said at the very beginning of this course. Alkenes and phenyl rings undergo different chemical reactions. The solvent in this reaction is acetic acid. The presence of acid helps accelerate this process. Molecular bromine, B R two, is quite toxic and quite dangerous to handle. As a result, we will not be using molecular bromine itself. Instead, we will be using pyridinium tribromide, which you can see here in the upper left. Pyridinium tribromide is a salt that is quite stable and much less dangerous than molecular bromine. When you take pyridinium tribromide and you dissolve it in a solvent (such as acetic acid), pyridinium tribromide, in an equilibrium, forms pyridinium bromide and molecular bromine. Now the key here is this is an equilibrium process. The equilibrium greatly favors the left side of this equation. This means that we have only a small amount of molecular bromine present at any given time. If we only have a small amount of molecular bromine present, will this reaction be slow? Well no. Because remember Le'Chatlier's principle. If you take this molecular bromine, and use it in the bromination reaction, the equilibrium up here has to shift to the right in order to make more bromine. To recap this slide, molecular bromine is quite dangerous. Instead of using molecular bromine, you will use pyridinium tribromide, a salt. When dissolved in solvent, this salt produces pyridinium bromide and molecular bromine in small quantities. However, enough molecular bromine is present to allow the bromination in this alkene to occur. As the bromine is consumed, this equilibrium shifts to the right to make more molecular bromine. The particular alkene you will use is what is called tranexamic acid. There's nothing special about this particular alkene, it is just an easy to use reagent.
The question in this experiment is by what mechanism does this bromination reaction occur? There are 3 potential mechanisms that we can propose for this reaction. The first, is the mechanism that proceeds through what we call anti-addition. Anti means that the bromine atoms attach themselves on opposite sides of the double bond. If you have trouble visualizing this, don't worry we'll see an example of this on the next slide. The second potential mechanism is one that proceeds through what we can a syn addition. Syn means that the two bromine atoms are added from the same side of the double bond. And then finally, the reaction could proceed through a mechanism that produces a mixture of both anti and syn additions. You are going to figure out which of these mechanisms is the correct one. And you will do this through analyzing the products of the reaction. Here on the slide we see the product of this reaction, the dibrominated compound. What we haven't drawn, however, is the stereochemistry on this molecule. You know, that each carbon atom, the bromines are attached to is a stereo center. And it turns out that each proposed mechanism produces different stereochemistry. Let's see that now. Possibility 1 was anti-addition. And if you recall, anti means coming from opposite sides of the double bond. Here we have the bromide atoms where the bromide atom on the left came from the top of the double bond and the bromide atom on the right came from the bottom of the double bond. Because this is not an enantioselective reaction, if mechanism 1, possibility 1 is the correct one we would expect to see this compound plus its enantiomer formed in the chemical reaction. Possibility 2, the syn addition, would produce this product. Where both of these bromide atoms came from the top of the double bond. And as of possibility one, because this is not an enantioselective reaction, we will make this compound and the enantiomer of this compound if mechanism 2 is the correct mechanism. And finally with possibility 3, if the mechanism is a mixture of syn and anti addition products we will see a mixture of all of these compounds. To recap this slide, each potential mechanism produces a different product mixture. If we can identify which product mixture is actually made as a result of the reaction, we can identify the mechanism of the reaction. The procedure for the experiment is operationally quite simple. You will take your alkene, your trans-cinnamic acid and you will dissolve it in glacial acetic acid. At room temperature this is a slow process, so you will use some gentle heating to make it dissolve faster. Once all of the trans-cinnamic acid is dissolved, you will then add your pyridinium tribromide to your reaction mixture and then boil the solution for 15 minutes. Note: this is not heating for 15 minutes. You start the 15 minutes once it begins boiling. Not once you begin heating. After the 15 minutes have passed you will allow your reaction mixture to cool and your product will precipitate out as the mixture cools. You will collect your product via a vacuum filtration. You will take another technique, recrystallization, and purify your product. And finally, once your product is purified you will analyze the product via a melting point analysis. Through that analysis you will identify which product you have. You can do this because each potential product has a different melting point. The anti-addition product, possibility 1, has a melting point of 202-204 degrees celsius. Some of you may be thinking, but I have a mixture of this compound and its enantiomer. Shouldn't I see a melting point depression? The answer is no. Enantiomers of a compound do not act as impurities. Therefore, even though I have a mixture of enantiomers I will still see a narrow, non-depressed melting point. Possibility 2, the syn addition, has a much lower melting point. 93.5-95 degrees celsius. Remember, the reason that possibility 1 and possibility 2 have different melting points is because they are diesteriomers. Diesteriomers do have different melting points because they are different compounds. Knowing that, what would you expect the melting point for possibility 3 to be? Where we have a mixture of syn addition and anti-addition. You should think about what melting points would be reasonable for this situation. This is the first experiment where you will perform a chemical reaction and then isolate the product of that chemical reaction. When making a new compound, it is important to assess how efficient, how effective that reaction was. The percent yield of a reaction is a measure of how much product we actually made compared to how much product we should have made based on the amount of starting materials we used in the reaction. In short, it is our actual yield, what we physically have in our possession at the end of the reaction over our theoretical yield, what we should have made based on the amount of starting materials we used. Remember to calculate the percent yield of a reaction, you have to identify the limiting reagent. The limiting reagent is the starting material that gets used up first. It limits the amount of product you can make. When finding your limiting reagent for this experiment, assume that all pyridinium tribromide turns into molecular bromine, Br2.
Acid-Base Extraction- Background In this webcast, we will discuss what an acid-base extraction is and how it works. An extraction is a purification technique that separates solids and/or liquids via partitioning between two phases based on solute solubility. If you've ever made coffee or tea, you have performed an extraction. In coffee beans and tea leaves are numerous goodies, such as caffeine. In the case of coffee, you add hot water to ground coffee beans. You now have two phases, the solid coffee beans and the liquid water. The caffeine and other desirable compounds in the ground coffee beans move from the solid coffee beans into the liquid water. They partition themselves and in doing so, separate themselves from everything else. In organic chemistry, we typically use what are called liquid-liquid extractions. A liquid-liquid extraction is an extraction that uses two immiscible solvents. We will talk about what immiscible means on the next slide. Usually, one of these solvents is aqueous, or made of water, and the other solvent is organic. The word immiscible here is quite important. Miscible and immiscible describe the ability of two liquids to mix with each other. Miscible liquids are liquids that will mix with each other in all ratios. An example of two miscible liquids is water and ethanol. Here on the slide, you see a bottle of vodka, which contains water and ethanol. This mixture appears to be homogeneous, we don't see any separations or barriers within this bottle. In contrast, an immiscible mixture is when you have two liquids that will not mix, will separate. Sometimes it depends on what ratio of liquids you are using. An example of this is would be this balsamic vinaigrette. In balsamic vinaigrette you have water and you have oil. If you take a bottle of balsamic vinaigrette and leave it sitting on a table for awhile you'll see the two liquids separate and form layers. Here is a visual demonstration of an extraction that will show why using immiscilbe solvents is required. Here I have two compounds, yellow triangles and red squares, and lets put those compounds into this container. I'm now going to add some kind of solvent, lets say an organic solvent of some kind. This solvent will dissolve my compounds. What I'll l add next is an aqueous layer, a layer made of water, and what will happen as a result of this is some of my compounds will prefer the aqueous layer over my organic layer. And as a result, they will move to the aqueous layer, In this case, my red squares favor the aqueous layer. The only reason this works is because these two liquids don't mix. If the two liquids mixed, you'd have a single layer and there would be no way to separate the compounds. One note before I continue: you will notice that not all of my red squares have entered the aqueous layer. That is because compounds will always have some solubility in some solvents. What determines which layer a compound favors is the compound's polarity in comparison to the polarity of the solvents. The general golden rule for an extraction is 'like dissolves like'. We know that water is a polar solvent. Based on the golden rule that we just discussed, that means polar compounds will prefer to dissolve in water. The reason for this as you can see here in this diagram polar compounds have partial charges. We know that in water all of our oxygens are delta negative and all of our hydrogens are delta positive. By dissolving polar compounds, such as ions, we can arrange the charges in a favorable manner that is energetically stable. As you can see here on the left, the positive ion is surrounded by partially negative oxygens whereas the ion on the right, which is negative, is surrounded by partially positive hydrogen atoms. In contrast, organic solvents which range from nonpolar to moderately polar tend to dissolve neutral non-charged compounds up to moderately polar compounds. Most organic compounds fall in this category of neutral to moderately polar.
Acid/Base Extraction- Calculations. Up to this point, we have discussed acid/base extraction in qualitative terms. For example, we know that if we have an acidic compound in a mixture, we should use a basic aqueous solution to convert it into a salt and extract it. What we will discuss in this webcast is the quantitative aspects of an acid/base extraction. When you have a mixture and you're extracting a compound just how much of that compound is transferred into the new layer? Previously, I mentioned the partition coefficient 'K'. I described it to you as a measure of how at equilibrium a compound will prefer one layer over another. Let's say when separating a mixture, I want to get as much of a particular compound out as possible. How much solvent should I use when doing so? To answer that question, I can use K. Remember that K is the ratio of the amount of compound in the organic layer over the amount of compound in the aqueous layer. Where the amount of compound is measured in grams of compound over volume of solvent. If we take this and substitute it into K, we get this expression down below. Which with some rearrangement, produces this final expression here on the right side. Do not memorize this equation, if you need it, it will be provided for you. What this equation allows us to do is if I know K, and three of these variables, I can solve for the fourth one. Let's have an example of that. Let's say I want to perform what is called a single extraction. I know that the partition coefficient for compound A between ether and water is 8.5. What I want to know is how much of A would be extracted, in other words, how much will be present in the organic layer from a solution that contains 10 grams of A in 100 milliliters of water if I use 100 milliliters of my organic solvent. Let's look at this equation that we just discussed. I know K, cause that's given to me by the question. I know the volume of aqueous solution because that's given to me by the question. And I know the volume of organic solvent because that is also given to me by the question. And what I want is the amount in the organic layer. But I can't solve for that yet because I don't know the amount in the aqueous layer. Ok, so I'm missing information, can I find that information somewhere? Yes I can, cause I also know that the total amount of compound has to equal the amount in the organic layer plus the amounts in the aqueous layer. So if I do some rearrangement, the amount in the aqueous layer is the total amount of compound minus the amounts in the organic layer. It turns out, that I know the total amount of compound A, cause that's given to you in the question. So if I take this equation and plug it in, for N aq, I get this expression down below. I know K, I know N total, I know V aq, I know V org, and so, I can solve for N org. If I do some algebra and isolate N org, all I need to do is plug in the various values to give me a value of 8.95 grams in the organic layer. Pretty simple. Key points in this example. One, is recognizing what each of these variables mean. Two, is recognizing that I can replace N aq with N total .
minus n org allowing me to use all the information in this question to solve for n org. Now let us consider the amount that we extracted 8.95 grams is almost 95 percent of the material. But let's say almost 90 percent isn't good enough what could I do to extract more material. One thing you could do is increase the amount of organic solvent you use hopefully it makes sense that by using more organic solvent we would extract more material. But that becomes quite inefficient is there a better way to increase the amount of material I extract. The answer is yes what we can do is use multiple extractions. In this example I'm using 25 milliliters of my organic solvent ether but I'm using 25 milliliters 4 times. This is the same total volume as I used in the previous example only now I'm using it portion wise. In this case I will use this equation where the amount in the aqueous layer is equal to the total amount of compound multiplied by combination of the volumes of solvents and the differentiation coefficient raised to this letter R. Where r is the number of extractions of equivalent volume and this is important this equation is only valid if the portions of solvents you use is all the same volume. Ok lets look at what i have, I still know n total from the question I know vq still again given to me by the question. I know K given to me by the question and I know the volume of the organic layer also given to me by the question. And finally I know r which is 4 again given to me by the question. So all i do is plug in the appropriate values. Get a value of 0.105 grams but we're not done. What is the question asking of us. What it wants to know is the mass of a that would be extracted. It wants to know the mass of a in the organic layer. What did we just solve for? We just solved for neq what we want is norg. But we know that norg is equal to the total amount of compound minus the amount in the aqueous layer. So we take 10 grams of compound minus 0.105 grams which we just solved for we get a value 9.895 grams. Notice how this value is much higher than what we just solved for on the previous example. Previously we extracted just under 90 percent of compound a here we extract almost 99 percent of compound a what makes this so impressive is that we used the same volume of organic solvent. All we changes is how we used the volume in the first example we used it all at once in this example we used it portion wise. The take home message is that multiple extractions always extract more compound than a singe extraction of the same volume. One more thing before I continue. I've shown you 2 examples using 2 different equations I can ask you to solve for any variable in those equations. Be able to use to solve for any variable I ask for. This includes solving for r. To solve for r you'll need to use some basic logarithmic rules. make sure you review those rules because you will be asked to solve for r at some point. That brings us to the end of this webcast to recap the partition coefficient of a compound is a measure of which solvent of a pair of solvents used in an extraction of a compound prefers. When trying to extract a compound from a mixture, multiple extractions of equivalent volume are more efficient than a single extraction of the same total volume. You have seen several mathematical equations in this webcast do not memorize those equations you will be provided them if you need them but do be able to solve for any variable within those equations.
Acid/Base Extraction- Case Study. In the previous webcast, we discussed the fundamentals of an acid/base extraction. In this webcast, we will discuss the thought process of using those fundamentals to decide what aqueous solutions to add when you are given a mixture of compounds that you are trying to separate. Consider a mixture that contains these three compounds. On the left, we have a molecule that contains an amine, on the right we have a molecule that contains a carboxylic acid, and in the middle we have a molecule that contains neither of those functional groups. Our goal is to separate these three compounds via acid/base extraction. How do we do this? The first thing we do is we dissolve these three compounds in some kind of organic solvent. This example uses methyline chloride, although we can use any organic solvent that will dissolve all three of these compounds. Now that we've done that, we will add an aqueous solution of some kind. The question is what kind of aqueous solution are we going to add? The answer to that question depends on which compound you want to react with first. This table shows us what extracting agent to use, what aqueous solution to use, to remove a particular type of compound, the substance we are extracting from a mixture. This top section contains acids: strong carboxylic acids, weak carboxylic acids, and phenols. If we want to convert these acids into salts, we have to add a base. By taking an acid and reacting it with a base, we convert it into a salt. Now, in principle, any base will react with any acid, but that's not entirely true. Here at the top, we have a strong carboxylic acid. That means we can use a weak base such as sodium bicarbonate to react with it. Down below, we have a phenol. A phenol is a relatively weak acid. A weak base like sodium carbonate is not strong enough to react with this weak acid to any significant extent. As a result we need to use a stronger base such as sodium hydroxide in order to convert our phenol into a salt. This fact can be incredibly useful. Let's say I have a mixture of a strong carboxylic acid and a phenol. You might think, well they're both acids, there's no way I can separate them using acid/base extraction, but that's not true. If I have a mixture of a strong carboxylic acid and a phenol, by adding a weak base such as sodium bicarbonate aqueous solution, only the carboxylic acid will be converted into a salt, leaving the phenol behind. Let's say we had a base such as an amine. How can we separate amines from a mixture? Well, if amines are basic, we should add an acid. A common acid to use is hydrochloric acid, although many other acids are also useful. By taking an amine and reacting it with an acid, we convert it into a salt. Okay, so I know that if I want to remove an acid, I should add a basic aqueous solution. If I want to extract a base, I should add an acidic aqueous solution. Let's say I want to remove the base first. I don't have to, but in this example let's say I'm removing my base first. I know that to do so I need to add an acidic aqueous solution. If I add an acidic aqueous solution, what should happen to this mixture? Well, the carboxylic acid, being an acid, will not react with the acid I'm adding, so that will remain the same. The central compound, which contains no acidic and no basic functional groups, will all similarly not react and will remain the same. However this amine, being a basic functional group, will react with the acid.
to protonate the amine producing this salt. this salt is very polar as a result our compound moves from the organic layer to the more polar aqueous layer. so what happens next well we have two layers we separate the organic and the aqueous layers. we then put this aqueous layer aside and consider what we have left in the organic layer. what i could to separate these two compounds. i know that i have a carboxylic acid in this mixture so what happens if i add a new second aqueous solution that is basic. like before, this compound on the left will not react with anything and so will remain as is in the organic layer. In contrast, the carboxylic acid will react with the base it will be deprotonated in order to form this salt. this salt is very polar so our carboxylic acid moves from the organic layer to the aqueous layer. and like before, we no separate the organic and the aqueous layers. now, let us recap exactly where everything is at this moment. We have one aqueous layer that is acidic this layer contains our amine salt we have a second aqueous layer that is basic this layer contains our carboxylic acid salt. The third layer, that is our organic layer that contain our neutral organic compound. Okay, so we have successfully separated all of these compounds. now let us discuss how to get them back. How to remove them from their solutions. The organic layer is the easiest layer to deal with. This compound is the only compound currently in the organic layer. organic solvents are easy to remove. you might think ok we jsut evaporate the solvent and we recover this compound but its not quite that simple. many organic solvents can mix with trace amounts of water. these trace amounts of water will contaminate your isolytic compound so you have to remove that water before we evaporate the solvent. You can do that by adding what is called a drying agent. a drying agent is a solid that will absorb trace amounts of water. examples of drying agents will include magnesium sulfate and sodium sulfate. You will add small amounts of drying agent until the solid becomes flocculent or loosely clumped. When you have added enough drying agent such that the added solid no longer clumps you know your solvent is dry. You will then remove your drying agent through a simple gravity filtration. And then finally the solvent will be removed and you will collect your compound by evaporating the solvent using a machine called a rotor evaporator. You will not be using a roto evaporator your TA will. Recovering the original amine and the original carboxylic acid requires a different process. Currently in our aqueous solutions we have the salts of those compounds. If we were to simply evaporate the water, what we would get is the salts. But I don't want these salts I want the original compounds. What can I do to allow that to happen. What we will do is neutralize the solutions. To the acidic aqueous layer, you will add some base. This base will deprotonate the salt. In contrast in the basic aqueous layer you will ad some acid. This will protonate the salt. The end result of this neutralization is the original compounds. But you may have noticed something. These compounds are not particularly polar therefore they are not soluble in water. so what happens when we convert these salts back to the organic compounds that are insoluble in water.. They will precipitate out and form a solid which you will then collect via filtration. to recap this extraction demonstration we have successfully separated three compounds using their affinity for organic and aqueous solutions as we change their polarity. We separated the amine by adding an acidic aqueous layer that converted it into a salt thus extracting it into the aqueous layer. Then to collect it, we precipitated it out by neutralizing the aqueous solution. The carboxylic acid was separated in a similar manner except for the carboxylic acid we added a basic aqueous solution. This converted our carboxylic acid into a salt extracting it into the aqueous solution and then we collected it by neutralizing the aqueous solution causing it to precipitate out. This neutral non fictionalized carbon here on the right, never reacted with any acid or any base, as a result its polarity remained unchanged throughout this entire process so it remained in the organic layer and then it was collected by evaporating the organic layer.
You'll perform a similar extraction process in the lab how will you confirm that you successfully separated your mixture. First you will collect all of the precipitated products with vacuum filtration you will then dry your products thoroughly and then you will take melting points you will compare your melting points to the known melting points of the pure compounds. Remember that we dry thoroughly because any residual solvent will lower the melting point of your sample. Some practical notes on performing the extraction. On the right is what we call a separatory funnel. This is what you will use in the lab, the separatory funnel has several components. You have this glass body in which your liquids will be contained, you will have this cap up top and you will have this stopcock here at the bottom. The stopcock is a valve that regulates liquid flow through the vessel. When addin your liquids to the separatory funnel, make sure the stopcock is closed. In principle for an extraction you only need two layers to be in contact with each other however this is a very slow process. TO increase the rate at which compounds move between layers, you will vigorously shake the separatory funnel. When doing this make sure you have a firm grip on the cap. If the cap comes off you will spill liquid all over yourself and your hood. In this shaking process you will create gas. This gas will create pressure inside he vessel. Eventually, enough pressure will be built up to cause this cap to pop off potentially spilling your liquid. To prevent this from occurring you must frequently vent your separatory funnel. To do this you will hold the separatory funnel upside down with a firm grip on the cap, then you will open the stopcock to release any built up pressure. When it come time to separate these layers what you will do is you will remove this cap, open the stopcock and allow the liquid to flow through until the entire bottom layer is removed. Removing the cap is important. If you don't remove the cap, there is no air to replace the liquid flowing out and as a result not flow will occur. You will be dealing with clear, colorless solutions. Every layer will be colorless. Make sure that your layers are clearly labeled and nothing is thrown away until you have obtained all three compounds. This is to prevent you from accidentally throwing away a layer that you still need. When neutralizing your aqueous layers, use pH paper to ensure that you have completely neutralized the layers. And finally, occasionally, you may create what is called an emulsion when shaking an organic solvent in an aqueous solution. Sodium hydroxide and methylene chloride are a common pair that causes emulsions to form. An emulsion is what you see here. Its when two layers refuse to separate from each other completely. To break up this emulsion swirl or gently rock the separatory funnel. This brings us to the end of this webcast. To recap, compounds in the mixture can be separated through the careful additions of aqueous solutions if the compounds in that mixture poses certain functional groups. In particular, for an acid base extraction, we need our compounds to poses acidic or basic functional groups that can chemically react with the acids or bases we were using in aqueous solutions. Different strengths of acidic or basic aqueous solutions can be used to separate compounds containing the same type of functional groups in certain situations. For example, a strongly acidic compound of a mixture can be separated from a weakly acidic compound in that same mixture by using an appropriate basic aqueous solution. This basic aqueous solution must be strong enough to deprotonate the strongly acidic compound in a mixture but not strong enough to deprotonate the weakly acidic compound in the mixture. At the end of an extraction, you want to recover the original compounds. Any salts created during an extraction should be converted to their neutral forms through neutralizing the aqueous solutions that they are in.
Distillations- Background and Simple Distillations. In this webcast we will discuss what solutions are and how they work. We will discuss the [gibberish] substitution experiment a simple distillation. Distillation is a method for the purification of liquids and the reason is exclusively for liquids is because it separates compounds base on their boiling points. In a distillation, compounds undergo a series of phase changes. In the most basic of distillations, your liquid will be converted into a gas, and then will returned to being a liquid. Hopefully more pure than when it started. In this particular experiments you will be performing what we call a simple distillation. Simple distillations are are quick to perform. However, they are only appropriate for mixtures that contains compounds of large differences in boiling points that larges at least 40 degrees Celsius. During distillation, you will be recording the boiling point of the liquid as they distill. In the same way that a melting point is characteristic of a compound the boiling point is also characteristic of a compound. You can use the boiling point of your compound as it distills, you try and identify it. The distillation apparatus you will set up in this experiment is the most complex apparatus you will have to use in this course so far. This image shows a completely set-up distillation apparatus with one exception: remember to include the metal hose clamps to secure the connections between your hoses and the condenser, which are not shown here. In distillation you will place your liquid into this round bottom flask, often called a distillation flask or the distillation port. The liquid in this round bottom will be heated using this hot plate and the aluminum block until it begins to boil. When it boils it will be converted into a vapor and travel up the apparatus, until it reaches this intersection. At this intersection we had this metal rod. This metal rod belongs to a thermometer. Your vapor will touch this thermometer, which will light to record the temperature of the vapor, which is the same as the boiling point of the liquid. Your vapor once at this intersection will then travel down to the condenser, hitting the cool walls and condensing back into a liquid, which you will collect here at the end. Before beginning your distillation,you must have your TA check your apparatus. An improperly set-up apparatus can become a pressure vessel, which can explode. There will be points associated with your TA checking your apparatus in this experiment. Additionally, you will be using heat and as always remember the hot glass looks just like cold glass. Do not touch any part of your apparatus until you know that it is safe to touch. Thus far we've talked about the practical aspect of a distillation. Noe let us discuss how a distillation actually allows you to separate liquids. Let's start with the basics. If a distillation separates liquids based on their boiling points, we should talk about what boiling points are. The boiling point of a liquid is the temperature at which the vapor pressure of the liquid equals the external pressure. Consider a jar that I have poured some water into and then sealed the jar with a cap. The water in that jar will begin to evaporate and form a vapor in the space above the liquid. The pressure of that vapor is the vapor pressure. This graph shows the boiling point of a liquid as the vapor pressure of that liquid changes. On the x axis we have temperature in degree Celsius. On the y axis we have vapor pressure. Consider a situation where we are at atmosphere pressure, 760 torr. When our liquid boils the vapor pressure must also equals 760 torr. If we want to know at what temperature it boils we simply look at 760 torr, we move it to the right until we encounter this line, and then look to the x axis to find the boiling point, in this case looking to be about 62 degree Celsius. Now let us lower the atmosphere pressure by using, say, a vacuum. If we lower the atmospheric pressure to 380 torr, that means our vapor pressure now has to equal only 380 torr in order to begin boiling. The new boiling point would be if we go over to the right until we encounter this line, and then look down to the x axis, about 47 degree Celsius. the take on measures for this slide is that the higher the pressure the atmosphere, the higher the vapor pressure it needs to be. The higher the vapor pressure it needs to be, the higher the boiling point will be because we need more energy to reach that vapor pressure. This diagram here corresponds to a pure liquid. What if we start adding impurities?
If we add a non-volatile impurity, we get a decrease in vapor pressure. That means we need a higher temperature in order to get that liquid to boil. There are many components on this slide, let's talk about them one-by-one. A non-volatile impurity is an impurity that has no vapor pressure. In this diagram, sugar dissolved in water would be a non-volatile impurity. Why would adding a non-volatile impurity decrease the vapor pressure? One way to rationalize this is to consider the adding of the impurity as diluting the liquid. You may find it useful to review your notes on general chemistry if you are struggling with that idea. If we lower the vapor pressure, why would that increase the boiling point? Well remember, a liquid boils when the vapor pressure equals the atmospheric pressure. This red line is the vapor pressure of water as temperature increases. If atmospheric pressure is 760 torr, we have to heat water to 100 degrees celsius for it to boil. If we add a non-volatile impurity, our vapor pressure decreases. This blue line here shows the vapor pressure of water with our non-volatile impurity. At any given temperature, our vapor pressure is lower than the red line. As a result, the liquid has farther to go to reach 760 torr. We need a higher temperature to reach the same vapor pressure. Now, let's that instead of using a non-volatile impurity, we use a volatile impurity. For this experiment, let us assume that Raoult's Law holds. Raoult's Law states that the vapor pressure of an ideal solution is dependent on the vapor pressure of each chemical component and the mole fraction of those components present in the solution. What do I mean by ideal solution? An ideal solution is a solution in which the interaction between like molecules are the same as those between unlike molecules. Consider a solution that is a mixture of A and B. If this is an ideal solution, the A-A interactions are the same as the B-B interactions which are the same as the A-B interactions. Fortunately for us, many organic solutions approximate the behavior of an ideal solution. Now that we know what an ideal solution is, let us talk more about Raoult's Law. Let us consider an ideal, binary mixture of A and B. What Raoult's Law is saying is that the pressure of component A is equal to the vapor pressure of A if it was pure, times its mole fraction. Similarly, the vapor pressure of B in the mixture is equal to its pure vapor pressure times its mole fraction. The total vapor pressure should equal the vapor pressure of A added to the vapor pressure of B. Remember Dalton's Law of Partial Pressures from general chemistry? That's what this is. What these relationships state is that the vapor pressure of a component depends on how much of it there is. The higher the mole fraction of a component, the more its vapor pressure contributes to the total vapor pressure. The total vapor pressure is equal to the sum of the vapor pressures of the individual components. If we take this mixture of A and B, we can take these relationships and develop a phase diagram. In this phase diagram, we are plotting the temperature in degrees Celsius versus the mole fraction of one of our components, in this case component A. Our mole fraction, our old friend from the two-component phase diagrams from the melting point experiment. All the things we discussed about mole fraction back then still apply here. Make sure you read the x-axis carefully and read any questions carefully for what I'm asking for. In this phase diagram, we have two lines. We have a liquid line down below and we have a vapor line. The liquid line corresponds to the liquid mixture of A and B. The vapor line corresponds to the vapor we are making by boiling A and B.
Make sure you use the correct line for the questions that I will be asking you. To begin interpreting this phase diagram, lets start with a simple question. What is the boiling point of a mixture that is 80% A? To start, lets locate 80% A on the x-axis. Our x-axis is in Mol fraction of A. Therefore, a mixture that is 80% A will have a Mol fraction of 0.8 for A, which is right here. To find the boiling point of this mixture, I go up until I hit the liquid line. Once I've hit the liquid line, and then go all the way over to the y-axis to find the boiling point. Here looking to be about 102 degrees Celsius. Not too difficult. Now lets go deeper into interpreting this phase diagram. When distilling an ideal mixture, the vapor is richer in the lower boiling component. Now note that when I say richer, it doesn't necessarily mean a majority. When I say richer, I mean compared to the liquid. If our mixture contains 30% B and it is the lower boiling point component, the vapor that is formed from boiling our mixture might be 35% B or 40% B. It depends on the phase diagram. In this particular phase diagram, component B is the lower boiling point component. How do I know that? Lets look at the phase diagram. We see here on the x-axis that we are talking about the Mol fraction of A. When I have pure A, a Mol fraction of 1, I have a boiling point of about 110 degrees Celsius. In contrast, when I have a Mol fraction of A of 0, in other words pure B, I have a boiling point of about 78 degrees Celsius. That means that for this particular mixture the vapor I formed from boiling the mixture should be enriched in B. Lets say, I am starting with a mixture of this 80% A. And, 20% B. Like we had on the previous slide. That means I'm starting here on the right. What is in composition of the vapor being formed? Like before, we are going to go up until we hit the liquid line. To answer this question, we are not going to go to the y-axis. To answer this question, we are going to go until we hit the vapor line. And finally, once we've hit the vapor line, we return to the x-axis. And this here tells us the composition of the vapor. Looking to be approximately 58% A and 42% B. Lets talk through that again. I have some starting mixture 80% A 20% B, which is here on the x-axis. I go up until I hit the liquid line, and then I go to the left until I hit the vapor line. By returning to the x-axis, I find the composition of the vapor. Notice how my vapor is enriched in B. I've gone from 20% B in the liquid to 42% B in the vapor. Now lets say I take my vapor and condense it and turn it back into a liquid. What's the composition of that liquid? Well hopefully you find it easy to see that the composition of our collected liquid after the distillation has to be the same as the composition of the vapor. Because we are turning the vapor into the liquid we collect. So, at the end of the day, what do we have? We have a collected liquid that is enriched in B, but we are nowhere near having pure A or pure B. How useful is this technique, really? Well remember this technique is only used if there is a significant difference in boiling point at least 40 degrees, which we do not have in this mixture. For liquids with large differences in boiling point, a simple distillation works quite well, but for liquids with a small difference in boiling point, you have to use more advance distillation techniques. You will learn one of this fractional distillation in the next experiment. That brings us to the end of this webcast. To recap, distillation is a method to purify mixtures of liquid compounds. Separation occurs due to a difference in boiling points. The vapor produced from a distillation of a liquid mixture is always enriched in the lower boiling point component. Assuming your mixture is an ideal mixture. A mixture boils when the mixture vapor pressure equals the external pressure. For an ideal solution containing volatile impurities, the vapor pressure is dependent on two things: the pure vapor pressure of each component in the mixture, and the mole fraction of each component in the mixture.
Unimolecular Nucleophilic Substitution and Experiment Notes. In this webcast we will discuss the background of the unimolecular nucleophilic substitution or, Sn1 for short, reaction that you will perform. In this experiment, you will be performing a unimolecular nucleophilic substitution (or Sn1 for short) reaction. As you learned in CHEM 232, there are several different types of substitution reactions. And how they are different is their mechanism. To begin this webcast, we will have a review on substitution mechanisms. A bimolecular nucleophilic substitution (or Sn2 for short) reaction is a one-step concerted transition state that results in inversion of stereochemistry. Let us break this description into smaller pieces. Bimolecular means that in the rate-determining step, we have two species that are reacting with each other. In this particular example, we have this alkyl halide and this chloride ion. They react in a single step through what we call a concerted transition state. In this transition state we see that the chlorine atom, carbon atom bond is beginning to be formed at the same time that the carbon atom, bromine atom bond is being broken. This is what we mean by concerted. Everything is happening at once. The consequence of this mechanism is that our nucleophile, in this case our chloride ion, can attack this carbon from only one direction. From the opposite side of the bromine atom. This results in inversion of stereochemistry. Where in this example our bromine atom was pointing towards us, therefore our chlorine atom must be pointing away from us in the product because it had to attack from the opposite side of the bromine. Not all substitution reactions will proceed through this mechanism. If you would like an Sn2 reaction to occur, there are ways that you can bias the conditions to favor and Sn2 mechanism. Primary leaving groups tend to be excellent candidates for and Sn2 mechanism. Followed by secondary leaving groups and then finally by tertiary leaving groups. Where tertiary leaving groups for all intents and purposes do not undergo an Sn2 mechanism. This is easy to rationalize. If our nucleophile has to come from the backside of our leaving group, then the less stuff around the leaving group, the easier the reaction is. A tertiary leaving group has a lot of stuff around it, therefore it is very difficult for a nucleophile to attack it. In contrast, a primary leaving group is pretty open and so is easy to attack. Strong nucleophiles tend to favor an Sn2 mechanism. The reason for this is strong nucleophiles tend to react quickly. Why would reacting quickly help to favor an Sn2 mechanism? To help answer that, let's first discuss the Sn1 mechanism. An Sn1 mechanism is a unimolecular two-step mechanism that proceeds through a carbonyl cation intermediate. Consider this tertiary alcohol. We are going to add a little bit of acid. What this does is this turns this hydroxide, which is a terrible leaving group, into a good leaving group. And we'll talk more about this on the next slide. After being turned into a good leaving group, in this case water, we get spontaneous breakage of this carbon-oxygen bond, producing water and this carbocation intermediate. We have a carbon here, which has only three bonds. Therefore it is positively charged and we have this wide open empty orbital that is a fantastic electrophile for a nucleophile to attack. In this case, the bromide ion that formed after HBr was used to protonate the alcohol. Our bromide ion attacks the carbocation to form our final product. Let's talk about how this is a unimolecular mechanism but it's two steps. This might sound like a discrepancy, but these two adjectives describe different aspects of this mechanism. The unimolecular portion refers to the rate-determining step. Remember that in a mechanism, the rate-determining step is the slowest step. In an Sn1 mechanism, the ionization step, this first step to form the carbocation is the slow step. In this step, the only species present is this alcohol. Therefore, this is a unimolecular rate-determining step. This is in contrast to the Sn2 mechanism where the rate-determining step is the only step: the attack of the chloride onto our alkyl bromide. Where we have two species, therefore, this is a bimolecular rate-determining step. If we return to the Sn1 mechanism, this is a two-step mechanism, this is a two-step mechanism because it takes two steps to go to product. The first step is the ionization and the second step is the attack of the nucleophile onto the carbocation to form our final product.
Arostarton electrons are the lone pairs for bonds, and they end on either atoms or bonds. In this experiment, you'll be adding t-amyl alcohol, also known as 2-methyl 2-butanol, to your separatory funnel, and with it you'll be adding a concentrated hydrochloric acid aqueous solution. You will then shake these two things together to, what we call, affect the reaction, or in other words cause the reaction to occur. One note before we continue, t-amyl alcohol is a liquid. The concentrated hydrochloric acid solution is a solution. In your physical properties table you do need to record the number of moles being used for each component here. Remember that for a solution you have to use the concentration to find the moles, whereas for the liquid if you are measuring a volume you have to use the density and then the molecular weight. You will the=n identify which layer is which, one layer will be your aqueous solution,and one layer will be your product. Think back to the extraction experiment, how can you identify which layer is your aqueous layer and which layer is your organic layer if you don't know which one is which. Speaking of your extraction experiment, you will then use the skills you learned in that experiment to purify your product. You will perform what we call a wash. A wash is simply a type of extraction, specifically a wash is usually trying to remove impurities from the organic layer. The first wash you will perform is with aqueous NaCl solution, what we call brine. The purpose of using a brine solution is to remove any bulk water located in your organic layer. Remember organic layer always pick up at least a little bit of water. What a brine solution does is in the same way that biological cells can have water leave or enter them as a result of salt concentration inside or outside the cell, a brine solution is saturated in salt, and as a result, any water in the organic layer will leave the organic layer in order to dilute the salt in the aqueous layer. Once you have removed any bulk water present, you will then add in an aqueous solution of sodium bicarbonate in order to remove any remaining acid. Remember, sodium bicarbonate is a base. Once you have performed these two washes, these two extractions, you will take the organic layer and completely dry it using drying agents, like you did in the extraction experiment. And finally you will purify your product via a distillation. At the end of the reaction it is likely that you will have a mixture of at least your product and unreacted starting alcohol. You will use distillation to separate them. A quick note on extraction before we continue: sodium bicarbonate being a base will react with HCl. In the process you will make CO2, which is a gas. It is very important that you are patient and add your sodium bicarbonate solution carefully, otherwise you may make a little volcano in your hood, producing a mes that you will have to clean up, like you see here on your right. When shaking your separatory funnel, you will be making CO2 which will build up pressure in your separatory funnel. As a result make sure you vent often to prevent dangerous build-up of pressure. Along those lines, when venting or even when just shaking, do not point the separatory funnel at anyone so that any gas released does not impact your fellow students. That brings us to the the end of this webcast. To recap, the mechanism of a substitution reaction depends on the type of the leaving group, the strength of the nucleophile, and the solvent. The stereochemical outcome of a substitution reaction is dependent on the mechanism. For the conserted Sn2 reaction, you get inversion of sterochemistry, whereas in the step-wise Sn1 mechanism, you go through a flag carbocation, resulting in a mixture of stereochemical products.
Distillations-Fractional Distillation and Non-Ideal Solutions. In this webcast we will discuss a new type of distillation, a fractional distillation. Fractional distillation will apply the same principal we used for a simple distillation just in a slightly different context. We will also discuss in this webcast the distillation of non-ideal solutions. This here is a fractional distillation set up. The set up is very similar to the simple distillation you assembled in the previous experiment. We have a round bottom flask which is where the reaction occurs, you have this condenser which cools the vapor into a liquid which allows you to collect it here at the end. In fact, the set up is identical to the simple distillation set up except for the addition of this fractionating column. This fractionating column is a glass tube which has been packed with steel wool. We'll talk about why steel wool is used in a little bit. Like with the simple distillation do not attach your round bottom to the column with a keck clamp, otherwise it may melt. Remember to use your metal hose clips to connect your hoses to your condenser. Something that is not shown here but you should do is insulate your fractionating column and your round bottom flask here. Over the course of this experiment the vapor that is boiling off here will travel up this column in order to be collected in the condenser. However, as your vapor travels up it will cool down. If it cools down too much it will condense in the column and then drip back down into the round bottom flask. To keep the vapor from cooling too quickly, you will coat the column and round bottom flask in aluminum foil. Like with the simple distillation experiment, there will be points associated with your TA checking your apparatus before you begin distilling. So this is a fractional distillation set up, what exactly does this fractionating column do for us? A fractional distillation is essentially a series of simple distillations. Consider this phase diagram which is identical to what you saw for simple distillations. In the webcast for that experiment, we showed how you can take a mixture that is 0.8 mole fraction of A and perform a simple distillation to collect a liquid that is more enriched in B. However we also discussed how this liquid is not particularly pure in either A or B. What you could imagine doing is taking that collective liquid and performing another simple distillation. Collecting that liquid, performing another distillation, and repeating that process until you received pure liquid, in this case, pure B. You might also imagine that performing six, seven, eight, or even more distillations in a row would be quite time consuming. But a fractional distillation allows us to do is essentially perform multiple simple distillation simultaneously, and we do this using that distillation column, also known as a fractionating distillation we saw on the previous slide. That distillation column is rated based on the number of what we call theoretical plates on that column. A theoretical plate corresponds to the effect of one simple distillation. What happens in the distillation column is the vapor you produce in the distillation will condense inside the column. It will then re-evaporate, travel further up the column and then condense again until it finally reaches the top of the column,. Essentially a plate is one cycle in this process. The purpose of the steel wool is to provide surface area for the vapor to condense. So in that distillation column, our vapor evaporates, condenses on that steel wool, evaporates again, condenses again, and continues until at the end we have a pure liquid. This may seem like ancient technology, and it is, but it is also incredibly useful because it is incredibly scalable. The gasoline you out in your car is produced from a fractional distillation. Here on the left we have an oil refinery, and these large metal tubes are very large fractionating columns, where raw petroleum is placed in the bottom of these columns and is allowed to fractionally distill up to the top. The inside of these towers is very similar to what we call a bubble-cap column, which we have here on the right, where our liquid mixture is here at the bottom, and we boil it until it begins to produce vapor. The vapor travels up the column, and condenses onto each of these plates. We recently used the term 'theoretical plates' is because we have physical plates for the vapor to condense on. So the vapor is formed, condenses, evaporates, condenses, and continues all the way up until it is collected up at the top.
Here is a visual demonstration of how the number of theoretical plates within any fractionating column affects the composition of the liquid collected during distillation. Here we have two different fractionating columns. We have the same amount of compound in the mixtures in the bottom of each column, but what is not the same is the number of plates inside of each column, The column on the left has 3 plates, the column on the right has 6 plates. Lets start distilling this mixture on the left. We are going to boil our liquid to make some vapor, then the vapor will condense on the first plate. It will heat up again, make vapor again, condense on the second plate, and then once more to condense on the final third plate. As you can see our final liquid mixture is enriched in the yellow circles, but its not pure, What if we used more plates? If we repeated this process using the column on the right we shall evaporate, and condense, evaporate and condense and continue that process until eventually at the top of our column we have pure yellow circles. More plates in a distillation column means you have what we call an efficient distillation. To put this in technical terms, the column on the right is more efficient that the column on the left. The column on the right has enough plates to give us pure product. The column on the left does not. And just to tie this back to that phase diagram I was showing you before, remember that each cycle corresponds to a plate. Now in your distillation column you will not have physical plates, you will instead have steel wool. This is why we use theoretical plates. Theoretical plates are a measure of the amount of surface area present within your column upon which your repeated condensation and evaporation cycles can occur. More theoretical plates means more simple distillation which therefor leads to more pure distillant, as you saw on the previous slide. The efficiency of a distillation column is measured in terms of height equivalent theoretical plates, or HETPs for short. We use HETPs because it makes measuring easier. We assume all plates are of equal heights. What this means is that having a smaller HETP corresponds to a higher efficiency column. Hopefully that makes sense, By having a smaller height, we can pack in more plates across the same distance, And remember an efficient column is a column with enough plates to give us a pure product. now there is a trade-off here. More theoretical plates gives us better separation, but it comes at the cost at time. The more plates we have, the more condensation and evaporation cycles we go through, and each of the cycles takes some amount of time. Lets take what we know and apply it to these two situations,. I have two fractionating columns here. I have on the left a vigreux column, where we have glass indentations providing surface area for vapor to condense on. On the right, you have the column you'll be using in this experiment packed with steel wool; Column on the left has an HETP of 10cm, while the column on the right has a HETP of 1.5 cm. Now lets consider this first question, what column would we use if we wanted to separate a mixture of pentane and octane, where there is greater than sixty degrees C difference in boiling points. So did you pick the more efficient column on the right, or the less efficient column on the left? I would choose the less efficient column on the left. This is a pretty large difference in boiling points. Therefor it should be pretty easy to separate them. That means that using a less efficient column is better because it'll give us pure compound without costing us much time. In contrast, lets consider the second question. Which column would we use to separate a mixture of methanol and water? This is a much smaller difference in boiling point, 35 degrees Celsius. Well, that's pretty close so I would probably bite the bullet and use the more efficient column on the right. It will take more time, but it is also guaranteed to give me pure compound. That brings us to the end of our discussion on fractional distillation. Now we will discuss the distillation of non-ideal solutions, We will define what a non-ideal solution is, and then we will see how the phase diagram for a non-ideal solution differs from the phase diagram of an ideal solution. Fear not, the same principles you learned to interpret ideal solution phase diagrams will be the same principals you will use to interpret non-ideal solution phase diagrams. Up until this point we have been discussing what we call ideal solutions. ideal solutions follow Raoult's Law, and give us phase diagrams that look like this, which you are hopefully comfortable with. Unfortunately, not all solutions are ideal solutions. Non-ideal solutions create what we call deviations from Raoult's Law.
These deviations result from different interactions between various components. Consider this situation interaction between like molecules for example A interacting with A and B interacting with B are stronger than unlike molecules, A interacting with B. The consequence of this is the vapor pressure of the mixture is higher than the ideal solution. To put it another way, A does not like mixing with B. So this mixture is easy to evaporate. You have a high vapor pressure. Because we have a higher vapor pressure than is ideal, we have what is called a positive deviation. The positive refers to the higher vapor pressure. The consequence of having a positive deviation is what we call a minimum boiling point azeotrope. Now consider this new phase diagram. The X axis is still some mole fraction of a compound and y axis is still temperature. Now in this phase diagram which deviates from Raoult's law we have two region. A region in the left and right that meets at this point here. This point is called azeotrope. It is the minimum boiling point azeotrope because it is the lowest boiling point on this diagram. An azeotrope is a mixture of two or more liquids whose composition cannot be changed via distillation. In this case we have a minimum boiling point azeotrope. What this means is that after distillation we collect an azeotrope and one pure compound. Let's talk why that is. Consider a situation where we are starting at a mixture that is 0.2 mole fraction of ethanol. Now while this phase diagram may look different from the other diagrams that you have seen, how you interpret it is exactly the same. Let's say you want to perform a simple distillation. In this case we go up to a liquid line then go over to the vapor line, the same way we have always done. Once we get to the vapor line, we go back down to the x-axis to collect our distilets, which is now is roughly 0.7 mole of ethanol. Ok that is not so bad. Again this is exactly what we have done in previous phase diagram for ideal solutions. Ok now let's say instead of doing a simple distillation I wanted to perform a fractional distillation. That means that I will keep going until eventually I can't go any further. and that occurs are the azeotrope. Notice how if I take the azeotrope and boil it, there's not where to move. I am at the lowest boiling point on this phase diagram. That means that I can no longer purify this mixture. The take home message from the first part is that for a positive deviation phase diagram, which produces a minimum boiling point azeotrope. The liquid you collect is an azeotrope. What about the liquid that you leave behind. Remember in distillation you don't boil the entire mixture. If you did then you will collect the same mixture back. If the vapor is becoming more enriched in ethanol, what about the composition of the liquid. That means the liquid must be less enrich in ethanol until eventually all the ethanol distills off leaving us with pure water. So while the vapor we form becomes more and more enrich in ethanol, the liquid we leave behind becomes more and more enrich in water until eventually we get pure water. What if we started on the other side of the azeotrope? If we distilled something over here, the vapor would become more enrich in water until eventually you reach the azeotrope again. But the liquid must be enrich in ethanol because the water is being boiled away to form the azeotrope. Now if we have a positive deviation from the Raoult's law you can imagine. Now we also have a negative deviation from Raoult's law. In this case interaction between unlike molecules are stronger than the interaction between like molecules. In this case mixture A holds onto B stronger than A hold on to A or B hold on to B. A mixture wants to stay a mixture and doesn't want to boil away. That means that our vapor pressure is lower than that of what it would be if it was an ideal solution. Notice how the negative adjective refers to the vapor pressure. For this type of solution forms a phase diagram that looks like this. The boiling point of the azeotrope is higher than the boiling point of pure A or B. How do we read this type of diagram? Well you read it the same way that you've read anything else. This phase diagram is for a mixture of formic acid and water. Let's say we start at 0.4 mole fraction of formic acid and we begin to of a fractional distillation.
Elimination reactions, the baeyer test, and experiment notes. In this webcast, we will discuss the chemical reaction aspects of the intermolecular elimination experiment. In the previous experiment, you performed a unimolecular nucleophilic substitution reaction. You know from chem 232 that substitution and elimination reactions are often in competition with each other. Let us begin this webcast by discussing that topic. From chem 232, you know that whenever you have the conditions for an elimination reaction, you also have the conditions for a substitution reaction. Where if we have, a substrate such as this, or a leaving group that's in blue in the presence of a nucleophile, we can have a substation reaction where our leaving group is substituted with a nucleophile. This top pathway leading to this product or our nucleophile can instead act as a base, deprotinate this red hydrogen here leading to this bottom pathway and the formation of an alkene product. This is an unfortunate reality. If we want a substitution we always have to worry about elimination and if we want elimination we always have to worry about substitution. Fortunately, there are things that we can do to bias one pathway, one reaction over another. For example, substation reactions can be encouraged using strong nucleophiles that are also weak bases. Examples include the chloride ion and the bromide ion. If you want an elimination reaction to occur, we can encourage that using weak nucleophiles that are strong bases. The tert-butoxide ion is an example of this type of base. If we use a strong nucleophile that is also a strong base, we can and will make a mixture of substitution and elimination products. The amounts of each depending on the type of leaving group present, whether it is primary secondary or tertiary. Why do particular reaction conditions result in particular reaction pathways being preferred? To answer that question, let's limit our analysis to only SN1 and E1 reactions. Let us assume that we have reaction conditions where we know we are going to go through a carbo cation like we see on this slide. We have a substrate over here in the presence of a nucleophile. This substrate is going to form a carbo-cation which can then go on to either the substitution product, the top pathway, or the elimination product via the bottom pathway. What determines which pathway is preferred is the transition state leading to those products. To discuss that, let us draw a reaction coordinate diagram. Remember that a reaction coordinate diagram is essentially a graph showing the progress of a reaction. Our reaction starts with our substrate and our nucleophile at some energy. We then form this carbo-cation which we know is a high energy intermediate. So we go from our starting energy to our carbo-cation. Now we have a choice. We can form either the substitution product or the elimination product. Let's go ahead and draw those pathways here. The substation product will be shown by this blue curve and the elimination product will be shown by this red curve. Some product at the bottom for substation and some product at the bottom here for elimination. You know that in order to go from one part of the reaction coordinate diagram to another, we have to pass through this transition state here at the top of the curve. And that means we need enough energy to go from our starting position here, in this case our carbo-cation, to get over this hump. With that knowledge you can see that it takes less energy to go over this red curve, leading to the elimination product, then it does to go over this blue curve leading to the substitution product. Because it takes less energy to go over the red hump the elimination reaction is faster, therefore the elimination product would be the major product based on this reaction coordinate diagram. Notice how the elimination product is higher in energy then the substitution product. The elimination product is less stable than the substitution product. That is completely irrelevant when determining which product is the major product. One note before we continue, this assumes that these reactions are irreversible, meaning that once we make product we can never go back to starting material. Because substitution reactions and elimination reactions are generally irreversible, it is the transition state energies that determine which product is the major product. By choosing different reaction conditions, we altar the height of these transition state energies to make sure that our desired product is the major product. Now let us apply that knowledge to predicting the products of an elimination reaction. In chem 232 you were taught Zaitsev's rule. Zaitsev's Rule states that the more substituted a double bond is the more stable it is. Furthermore, in an elimination reaction, the most stable possible alkene should be the major product.
Let's show an example. Let's take this alkyl bromide and perform an elimination reaction. If we do that, we will get a mixture of products. On the left, we have this terminal alkene, in the middle, we have this disubstituted trans alkene, and on the right we have this disubstituted cys alkene. The terminal alkene is formed from a base deprotonating one of these hydrogen atoms at the end of the molecule. In this case, we are showing an E2 mechanism where the carbon carbon double bond is formed simultaneously as the leaving group is kicked out. The cys and the trans double bond are formed in a similar manner just using hydrogen atoms on the other side of the leaving group shown here in red. According to Zaitsev's rule, the more substituted a double bond is, the more stable it is. Therefore, either the trans or the cys double bond should be the most stable, because they are disubstituted whereas the terminal alkene is only monosubstituted. You know from chem 232 that the trans alkene is more stable than the cys alkene because there are fewer steric interactions between the substituents. Being on opposite sides of the double bond is less crowded than being on the same side of the double bond. Therefore, the trans alkene should be the major product, it should be the one that's produced the most and the terminal alkene should be the minor product, the product that is produced the least, with the cys alkene somewhere in the middle. But on the previous slide, I told you that the stability of the product has no bearing on what the major product should be. Why is it that in organic chemistry we teach you this rule? This is because there is no way for you to look at a compound and say 'yeah, the transition state that leads to this compound will be lower in energy.' Fortunately for us, in most cases for an elimination reaction, the most stable product happens to result from the transition state that is lowest in energy. This is also why using bulky bases can change the product distribution. You know that using tertbutoxide, a bulky base, you will make primary the terminal alkene, even though it is less stable, This is because by using the bulky base, you alter the transition state energies to make the transition state leading to the terminal alkene product, lower in energy than the transition state leading to the other products. Now that we have talked about transition states, let's talk about the E1 mechanism. In this experiment, you will be taking cyclohexanol, shown here on the left, and treating it with phosphoric acid which is a strong acid. Like in the SN1 experiment, you will be protonating this alcohol to turn it into a good leaving group. Similar to what was stated in the mechanism discussion in the SN1 webcast, this protonation step is not part of the E1 mechanism proper. This protonation step is to get the molecule ready to undergo the E1 mechanism but is not part of the E1 mechanism itself. Once you have made this good leaving group, you will then allow it time and energy through the use of heat to form a carbocation, which will then be deprotonated using a base of some kind to form the alkene product. Before we move on, to be clear the E1 mechanism is a 2 step mechanism that consists of the formation of a carbocation as show here at the bottom and the subsequent deprotonation of a hydrogen atom adjacent to the carbocation as show here on the right. Remember, the initial protonation step is not part of the E1 mechanism. The protonation step prepares the molecule to undergo the E1 mechanism which consists of the leaving group leaving to form the carbocation and the subsequent deprotonation to form the new alkene. A simple mechanism and very similar to the SN1 mechanism in the previous experiment. Both reactions go through a carbocation. The reason that we go through an elimination reaction here instead of a substitution reaction is because we do not have a good nucleophile. In the substitution experiment, you produced a chloride ion which is a fantastic nucleophile. In this experiment, you are forming this dihydrogen phosphate ion which is a terrible nucleophile. Because it is a terrible nucleophile, any substitution reaction is slow which gives enough time for something, either the dihydrogen phosphate ion or the solvent or some other base to come along and deprotonate the hydrogen to form the alkene product. One final note about this mechanism before we continue.As you may have noticed, this reaction is catalytic in acid. We start with an acid and then we regenerate that acid over the course of the reaction. Keep this in mind for when you fill out your table of chemicals in your pre-lab notebook. The phosphoric acid will not be the limiting reagent even though it is the reagent that will appear to provide the least amount of product. It is because the acid is not consumed over the course of the reaction. Because the acid gets regenerated, it cannot be the limiting reagent. When you are filling out your table of chemicals, do not set the equivalent of acid to one, even though it may be the reagent with the fewest number of moles. Instead, you should set the number of the equivalent of the alcohol to one, and then set all of your ratios based off of that. This may mean that you have fewer than one equivalent of acid; that's okay because it is catalytic.
The reaction component of this experiment is pretty simple. You will take some cyclohexanol and you will add it to a round bottom flask. You will then add some phosphoric acid to that flask to start the reaction. While the reaction is running, you will simultaneously be fractionally distilling the cyclohexene as it is formed. After you have collected the cyclohexene, you will then dry it using potassium carbonate. To separate your product from the potassium carbonate, you will then perform a simple distillation and then if necessary, dry your product again, and then finally perform something called the Baeyer test to confirm that your collected liquid is in fact your product. The purpose of the Baeyer test is to determine if there is unsaturation, or in other words, alkenes in your final product. How the Baeyer test works is you will take a sample of your compound, hopefully containing an alkene of some kind. You will then add a solution of potassium permanganate, which is purple in color. If an alkene is present, it will react with the potassium permanganate to form a diol. This will have two consequences. First, the solution will go from purple to colorless as the potassium permanganate is used up, the purple color goes away. The second consequence is the formation of solid manganese dioxide, which is a brown solid. What you will do is you will take this potassium permangate solution and add it to a solution of your product and your starting material. If you see a brown solid after testing the solution of your product, you have a positive test for unsaturation, or in other words, you have an alkene in your product. Now sometimes you may not see any brown precipitate form. This is why we add potassium permanganate to both the product and a solution of starting material. What this allows us to do is to compare the number of drops it takes for the solutions to remain purple. If your starting material takes one drop to remain purple, but your product takes ten drops to remain purple, even if you don't see any brown solid, that tells me that your product contains alkene. It took more drops to remain purple, that means there was alkene in there to consume the potassium permanganate you were adding. That brings us to the end of this webcast. To recap, if multiple reaction pathways are possible, and they are irreversible, then the pathway with the lowest energy transition state leads to the major product. The energy of the products themselves is irrelevant. Whichever product is easier to make requires less energy to make will be the major product, even if that product is not the most stable of the possible products. The Baeyer test confirms the presence of alkenes by reacting potassium permanganate with any alkenes present in the molecule. If there are alkenes present in the molecule, then this reaction will produce a brown precipitate and/or a difference in the number of drops needed to maintain the purple color change that results from adding potassium permanganate. If it takes more drops of potassium permangate to keep the solution of your product purple than it does to keep a solution of your starting material purple, then your product likely contains alkenes.
Aldol condensation using unknown aldehydes and ketones. If you are concurrently taking Chem 232 you have not covered the aldol reaction. As a result, this webcast will introduce you to the aldol reaction by discussing what it is and how it works. The aldol reaction is a valuable carbon carbon bond forming reaction. As you know from Chem 232 making carbon carbon bonds is incredibly important in organic synthesis. When an aldol reaction creates a new carbon carbon bond, is connects an sp3 hybridized alpha carbon of a carbonyl, which is on our nucleophile, with a carbonyl carbon on an aldehyde or a ketone that is on our electrophile. An aldol reaction can proceed through two mechanisms. either an acidic mechanism or a basic mechanism. as the name suggests, the mechanism you go through depends on whether you use acid or whether you use base. In this experiment, you'll be using a base and so we will the basic mechanism shortly. An aldol reaction becomes an aldol condensation which is what you'll be performing in this experiment when water or a water equivalent is generated as a byproduct. On the previous slide I told you that the nucleophile in an aldol reaction must contain an sp3 hybridized alpha carbon. Before we discuss why this is necessary, let us look at some structures and first define what an alpha carbon is and then get some practice in identifying what alpha carbons fit this criteria. here are four carbonyl structures. let us look at the structure in the upper left. an alpha carbon is simply a carbon atom that is directly attached to a carbonyl. so this carbon here is an alpha carbon and so is this carbon here on the other side. and if you go through the remaining structures,you can quickly label these as alpha carbons because these are all directly attached to carbonyls. notice how the structure in the upper right has only one alpha carbon. the right side of the carbonyl, being an aldehyde, contains only a hydrogen atom. now let us identify which of these carbons are sp3 hybridized. remember than an sp3 hybridized carbon is one that contains four sigma bonds. if we look at the structure in the upper left, this alpha carbon on the left side of the carbonyl here is not sp3 hybridized. in contrast, if we look at the carbon on the right, we see that there are these implicit hydrogens remember. and so this carbon is in fact sp3 hybridized. and so yes this carbon can be used in an aldol reaction. you don't know how yet, but you will once we talk about the mechanism later in this webcast. if we continue on with these structures, and label them with red Xs for alpha carbons that are not sp3 hybridized, and green check marks if they are, we see that some molecules like the one in the upper left and bottom left have two alpha carbons but only one of those alpha carbons is sp3 hybridized. we see in the upper right that we have a molecule that contains no sp3 hybridized alpha carbons. we see a molecule in the bottom right that has two sp3 hybridized alpha carbons. what does this tell us? well this tells us that this aldehyde here in the upper right cannot be used as a nucleophile in an aldol reaction. it had no sp3 hybridized alpha carbons. these structures on the left, the upper left and the bottom left have one sp3 hybridized alpha carbon therefore these can be used as a nucleophile in an aldol reaction. similarly, see this structure in the bottom right we have two sp3 hybridized alpha carbons therefore this structure as well can be used as a nucleophile in an aldol reaction. okay so we can identify alpha carbons and we can identify alpha carbons that are sp3 hybridized. what makes these particular carbons so important? what makes alpha carbons so important is their proximity to the carbonyl. unlike most other CH bonds, the CH bond of an alpha carbon is particularly acidic. if we add a base of some kind, that base can deprotonate that proton, leading to what we call a carbanion. now in the past when you've added the base to an organic molecule you have never seen this type of reactivity. why is this CH bond different from all of the other CH bonds you have seen in organic chemistry? what makes this bond different is the carbanion we form can be stabilized via resonance like so.
Now there's no longer an electrophile for this enalate to attack. So what is this enalate going to do? What this enalate is going to do is collapse as normal, but instead of attacking an electrophile, it will push this alcohol as a leaving group. So we have hydroxide, a water equivalent, leaving as a byproduct. And we have formed a brand new alkene in our product. And there I go. That is the condensation portion of an aldo-condensation mechanism. Taking our aldo product, we once again deprotinate the alpha carbon to create our enalate, and this enalate collapses to push off our leaving group, the hydroxide, to form an alkene. Now lets talk about this mechanism a little bit. First, many of you may be thinking that hydroxide is a terrible leaving group. How can hydroxide leave without being protinated to form water? There are two primary components to this. The first, we are in basic conditions. There's base around. There is no way to protinate this hydroxide to turn it into a good leaving group. Two, this final product we make on the right, this alkene is what we call conjugated. Remember the conjugated means that we have double bonds adjacent to each other. So we have this c, c double bond and c, o double bond next to each other. Conjugation is a thermodynamically stable arrangement. While it costs a great deal of energy to force this alcohol to leave as a hydroxide ion, we gain all of that back and more by forming this conjugated product. So what we call the driving force, what allows this reaction to happen even though it looks unfavorable is getting lower in energy. It is the thermodynamic stability of this final conjugated product. You may be wondering why is it necessary to go through the enalate to go through the alcohol? Why can't we simply deprotinate that hydrogen atom and eliminate the alcohol in an E2 mechanism. The reason why the E2 mechanism is not applicable is because this direct concerted process has a very high energy barrier. Whereas forming the enalate has a much lower energy barrier. And you know that the lower the energy barrier, which is the energy of the transition state, the faster that process is. So forming the enalate is a much faster process than doing the direct elimination. And that is why we go through the enalate when we eliminate the alcohol to form our product. This particular mechanism that you see here for the elimination of the alcohol is what we call an E1 CB mechanism. We call this an E1 CB mechanism because it is an elimination, where the rate determining step is unimolecular, as you can see here we have only one species present in the elimination. And it goes through the conjugate base of the starting material. Where this enalate is the conjugate base of this ketone acid here. Take home message from this slide. The elimination of the alcohol to form the alkene condensation product proceeds through an E1 CB mechanism. Where a base deprotinates our alpha carbon once again to form again to form our enalate, and our enalate forces off the alcohol as hydroxide ion to make our product. The alcohol is a terrible leaving group. The reason this reaction is able to proceed is one, we are under basic conditions so we cannot protinate the alcohol to make a better leaving group and two, the product we make is thermodynamically very stable. So the energy we pay to eliminate the alcohol is compensated for by the energy we get back from forming our conjugated product. Now that we understand how an aldol-condensation works lets talk about what you will be performing in the lab itself. In the lab itself you will perform what we call a double aldol condensation using an unknown aldehyde and an unknown ketone. Remember earlier in this webcast when we identified how many sp3 hybridized alpha carbons are present in four example carbonyl structures. On that slide we saw how that structure had 2 alpha carbons that fit that criteria. Therefore each alpha carbon can perform an aldol reaction and that is what will happen in this experiment. You will be given one of these four ketones. All four of which have 2 sp3 hybridized alpha carbons. And so each alpha carbon will undergo an aldol reaction. For your electrophiles you will be given one of three possible aldehydes shown here down below.
You'll be given one ketone and one aldehyde, but you will not be told which unknown is your ketone and which unknown is your aldehyde. The first thing you will need to do is using provided infrared spectra, you will identify which of your unknowns is the aldehyde and which of your unknowns is the ketone, which you will then have to justify in your lab notebook. So think about the structures I just showed you. How are the aldehydes different from the ketones? What stretches could you use to differentiate one from the other? Once you have made your identifications and checked with your TA, you will then add the correct volumes of each reagent to an Erlenmeyer flask. You will then start the reaction through the addition of a solution of sodium hydroxide in ethanol. For some unknown combinations, a precipitate will form near immediately. For other combinations, you may need to heat the reaction gently for the reaction to occur. Why would we need to add heat? Remember how in the condensation portion of the reaction, eliminating the alcohol is not a particularly easy process because the alcohol is a terrible leaving group. By adding heat, we provide enough energy for that process to occur. And finally once your product has been made, you will collect it via a filtration. Once you have your product in hand, you will then perform a melting point analysis of your product and compare that melting point to the melting points of the possible products. In the lab handout, you will find a table of the melting points of the possible products. Within that table, you will select 2 or 3 products which are close to the melting point of your product. Make sure your product is dry before performing your analysis or your melting point will be incorrect. To narrow down the identity of your product from your selected choices, you will then perform an NMR analysis. YOu will be provided proton NMR and Carbon 13 NMR to interpret. By matching the NMR data to the structure of one of your choices, you can confirm the identity of your product. Be aware that you will likely see signals in your proton NMR spectrum that possess multiple J values, particularly in the alkene region. Once you have identified your product, you can then backtrack and identify your starting aldehyde and ketone. Ensure that you justify your conclusion for the identity of your unknowns in your lab notebook. To recap this webcast, the aldol reaction is a powerful method to form carbon carbon bonds. The condensation variant of an aldol reaction produces water or water equivalent as a byproduct. The aldol reaction can be effected using an acid or a base. In this experiment, you will be using a base. The base variant proceeds through an enolate intermediate that acts as your nucleophile. The enolate can only be formed from a compound that contains an sp3 hybridized carbon adjacent to a carbonyl. As the enolate is formed from deprotonating one of these alpha carbons, there has to be a hydrogen atom attached to the alpha carbon and finally the electrophile in an aldol reaction must be a carbonyl containing compound, usually an aldehyde or a ketone.